import { Ops } from './const';
export declare const HOST = "https://api.swan.io/sandbox-partner/graphql";
export declare const HEADERS: {};
export declare const apiSubscription: (options: chainOptions) => (query: string) => {
    ws: WebSocket;
    on: (e: (args: any) => void) => void;
    off: (e: (args: any) => void) => void;
    error: (e: (args: any) => void) => void;
    open: (e: () => void) => void;
};
export declare const apiFetch: (options: [input: RequestInfo | URL, init?: RequestInit | undefined]) => (query: string, variables?: Record<string, unknown>) => Promise<Record<string, any> | undefined>;
export declare const InternalsBuildQuery: ({ ops, props, returns, options, scalars, }: {
    props: AllTypesPropsType;
    returns: ReturnTypesType;
    ops: Operations;
    options?: OperationOptions;
    scalars?: ScalarDefinition;
}) => (k: string, o: InputValueType | VType, p?: string, root?: boolean, vars?: Array<{
    name: string;
    graphQLType: string;
}>) => string;
export declare const Thunder: (fn: FetchFunction) => <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR>) => <Z extends ValueTypes[R]>(o: (Z & ValueTypes[R]) | ValueTypes[R], ops?: OperationOptions & {
    variables?: Record<string, unknown>;
}) => Promise<InputType<GraphQLTypes[R], Z, SCLR>>;
export declare const Chain: (...options: chainOptions) => <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR>) => <Z extends ValueTypes[R]>(o: (Z & ValueTypes[R]) | ValueTypes[R], ops?: OperationOptions & {
    variables?: Record<string, unknown>;
}) => Promise<InputType<GraphQLTypes[R], Z, SCLR>>;
export declare const SubscriptionThunder: (fn: SubscriptionFunction) => <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR>) => <Z extends ValueTypes[R]>(o: (Z & ValueTypes[R]) | ValueTypes[R], ops?: OperationOptions & {
    variables?: ExtractVariables<Z>;
}) => SubscriptionToGraphQL<Z, GraphQLTypes[R], SCLR>;
export declare const Subscription: (...options: chainOptions) => <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR>) => <Z extends ValueTypes[R]>(o: (Z & ValueTypes[R]) | ValueTypes[R], ops?: OperationOptions & {
    variables?: ExtractVariables<Z>;
}) => SubscriptionToGraphQL<Z, GraphQLTypes[R], SCLR>;
export declare const Zeus: <Z extends ValueTypes[R], O extends "query" | "mutation", R extends keyof ValueTypes = GenericOperation<O>>(operation: O, o: (Z & ValueTypes[R]) | ValueTypes[R], ops?: {
    operationOptions?: OperationOptions;
    scalars?: ScalarDefinition;
}) => string;
export declare const ZeusSelect: <T>() => SelectionFunction<T>;
export declare const Selector: <T extends keyof ValueTypes>(key: T) => SelectionFunction<ValueTypes[T]>;
export declare const TypeFromSelector: <T extends keyof ValueTypes>(key: T) => SelectionFunction<ValueTypes[T]>;
export declare const Gql: <O extends "query" | "mutation", SCLR extends ScalarDefinition, R extends keyof ValueTypes = GenericOperation<O>>(operation: O, graphqlOptions?: ThunderGraphQLOptions<SCLR>) => <Z extends ValueTypes[R]>(o: (Z & ValueTypes[R]) | ValueTypes[R], ops?: OperationOptions & {
    variables?: Record<string, unknown>;
}) => Promise<InputType<GraphQLTypes[R], Z, SCLR>>;
export declare const ZeusScalars: SelectionFunction<ScalarCoders>;
export declare const decodeScalarsInResponse: <O extends Operations>({ response, scalars, returns, ops, initialZeusQuery, initialOp, }: {
    ops: O;
    response: any;
    returns: ReturnTypesType;
    scalars?: Record<string, ScalarResolver | undefined>;
    initialOp: keyof O;
    initialZeusQuery: InputValueType | VType;
}) => any;
export declare const traverseResponse: ({ resolvers, scalarPaths, }: {
    scalarPaths: {
        [x: string]: `scalar.${string}`;
    };
    resolvers: {
        [x: string]: ScalarResolver | undefined;
    };
}) => (k: string, o: InputValueType | VType, p?: string[]) => unknown;
export type AllTypesPropsType = {
    [x: string]: undefined | `scalar.${string}` | 'enum' | {
        [x: string]: undefined | string | {
            [x: string]: string | undefined;
        };
    };
};
export type ReturnTypesType = {
    [x: string]: {
        [x: string]: string | undefined;
    } | `scalar.${string}` | undefined;
};
export type InputValueType = {
    [x: string]: undefined | boolean | string | number | [any, undefined | boolean | InputValueType] | InputValueType;
};
export type VType = undefined | boolean | string | number | [any, undefined | boolean | InputValueType] | InputValueType;
export type PlainType = boolean | number | string | null | undefined;
export type ZeusArgsType = PlainType | {
    [x: string]: ZeusArgsType;
} | Array<ZeusArgsType>;
export type Operations = Record<string, string>;
export type VariableDefinition = {
    [x: string]: unknown;
};
export declare const SEPARATOR = "|";
export type fetchOptions = Parameters<typeof fetch>;
type websocketOptions = typeof WebSocket extends new (...args: infer R) => WebSocket ? R : never;
export type chainOptions = [fetchOptions[0], fetchOptions[1] & {
    websocket?: websocketOptions;
}] | [fetchOptions[0]];
export type FetchFunction = (query: string, variables?: Record<string, unknown>) => Promise<any>;
export type SubscriptionFunction = (query: string) => any;
type NotUndefined<T> = T extends undefined ? never : T;
export type ResolverType<F> = NotUndefined<F extends [infer ARGS, any] ? ARGS : undefined>;
export type OperationOptions = {
    operationName?: string;
};
export type ScalarCoder = Record<string, (s: unknown) => string>;
export interface GraphQLResponse {
    data?: Record<string, any>;
    errors?: Array<{
        message: string;
    }>;
}
export declare class GraphQLError extends Error {
    response: GraphQLResponse;
    constructor(response: GraphQLResponse);
    toString(): string;
}
export type GenericOperation<O> = O extends keyof typeof Ops ? typeof Ops[O] : never;
export type ThunderGraphQLOptions<SCLR extends ScalarDefinition> = {
    scalars?: SCLR | ScalarCoders;
};
export declare const PrepareScalarPaths: ({ ops, returns, }: {
    returns: ReturnTypesType;
    ops: Operations;
}) => (k: string, originalKey: string, o: InputValueType | VType, p?: string[], pOriginals?: string[], root?: boolean) => {
    [x: string]: `scalar.${string}`;
} | undefined;
export declare const purifyGraphQLKey: (k: string) => string;
export declare const ResolveFromPath: (props: AllTypesPropsType, returns: ReturnTypesType, ops: Operations) => (path: string) => 'enum' | 'not' | `scalar.${string}`;
export declare const InternalArgsBuilt: ({ props, ops, returns, scalars, vars, }: {
    props: AllTypesPropsType;
    returns: ReturnTypesType;
    ops: Operations;
    scalars?: ScalarDefinition;
    vars: Array<{
        name: string;
        graphQLType: string;
    }>;
}) => (a: ZeusArgsType, p?: string, root?: boolean) => string;
export declare const resolverFor: <X, T extends keyof ResolverInputTypes, Z extends keyof ResolverInputTypes[T]>(type: T, field: Z, fn: (args: Required<ResolverInputTypes[T]>[Z] extends [infer Input, any] ? Input : any, source: any) => Z extends keyof ModelTypes[T] ? ModelTypes[T][Z] | Promise<ModelTypes[T][Z]> | X : never) => (args?: any, source?: any) => Z extends keyof ModelTypes[T] ? X | ModelTypes[T][Z] | Promise<ModelTypes[T][Z]> : never;
export type UnwrapPromise<T> = T extends Promise<infer R> ? R : T;
export type ZeusState<T extends (...args: any[]) => Promise<any>> = NonNullable<UnwrapPromise<ReturnType<T>>>;
export type ZeusHook<T extends (...args: any[]) => Record<string, (...args: any[]) => Promise<any>>, N extends keyof ReturnType<T>> = ZeusState<ReturnType<T>[N]>;
export type WithTypeNameValue<T> = T & {
    __typename?: boolean;
    __directives?: string;
};
export type AliasType<T> = WithTypeNameValue<T> & {
    __alias?: Record<string, WithTypeNameValue<T>>;
};
type DeepAnify<T> = {
    [P in keyof T]?: any;
};
type IsPayLoad<T> = T extends [any, infer PayLoad] ? PayLoad : T;
export type ScalarDefinition = Record<string, ScalarResolver>;
type IsScalar<S, SCLR extends ScalarDefinition> = S extends 'scalar' & {
    name: infer T;
} ? T extends keyof SCLR ? SCLR[T]['decode'] extends (s: unknown) => unknown ? ReturnType<SCLR[T]['decode']> : unknown : unknown : S;
type IsArray<T, U, SCLR extends ScalarDefinition> = T extends Array<infer R> ? InputType<R, U, SCLR>[] : InputType<T, U, SCLR>;
type FlattenArray<T> = T extends Array<infer R> ? R : T;
type BaseZeusResolver = boolean | 1 | string | Variable<any, string>;
type IsInterfaced<SRC extends DeepAnify<DST>, DST, SCLR extends ScalarDefinition> = FlattenArray<SRC> extends ZEUS_INTERFACES | ZEUS_UNIONS ? {
    [P in keyof SRC]: SRC[P] extends '__union' & infer R ? P extends keyof DST ? IsArray<R, '__typename' extends keyof DST ? DST[P] & {
        __typename: true;
    } : DST[P], SCLR> : IsArray<R, '__typename' extends keyof DST ? {
        __typename: true;
    } : Record<string, never>, SCLR> : never;
}[keyof SRC] & {
    [P in keyof Omit<Pick<SRC, {
        [P in keyof DST]: SRC[P] extends '__union' & infer R ? never : P;
    }[keyof DST]>, '__typename'>]: IsPayLoad<DST[P]> extends BaseZeusResolver ? IsScalar<SRC[P], SCLR> : IsArray<SRC[P], DST[P], SCLR>;
} : {
    [P in keyof Pick<SRC, keyof DST>]: IsPayLoad<DST[P]> extends BaseZeusResolver ? IsScalar<SRC[P], SCLR> : IsArray<SRC[P], DST[P], SCLR>;
};
export type MapType<SRC, DST, SCLR extends ScalarDefinition> = SRC extends DeepAnify<DST> ? IsInterfaced<SRC, DST, SCLR> : never;
export type InputType<SRC, DST, SCLR extends ScalarDefinition = {}> = IsPayLoad<DST> extends {
    __alias: infer R;
} ? {
    [P in keyof R]: MapType<SRC, R[P], SCLR>[keyof MapType<SRC, R[P], SCLR>];
} & MapType<SRC, Omit<IsPayLoad<DST>, '__alias'>, SCLR> : MapType<SRC, IsPayLoad<DST>, SCLR>;
export type SubscriptionToGraphQL<Z, T, SCLR extends ScalarDefinition> = {
    ws: WebSocket;
    on: (fn: (args: InputType<T, Z, SCLR>) => void) => void;
    off: (fn: (e: {
        data?: InputType<T, Z, SCLR>;
        code?: number;
        reason?: string;
        message?: string;
    }) => void) => void;
    error: (fn: (e: {
        data?: InputType<T, Z, SCLR>;
        errors?: string[];
    }) => void) => void;
    open: () => void;
};
export type FromSelector<SELECTOR, NAME extends keyof GraphQLTypes, SCLR extends ScalarDefinition = {}> = InputType<GraphQLTypes[NAME], SELECTOR, SCLR>;
export type ScalarResolver = {
    encode?: (s: unknown) => string;
    decode?: (s: unknown) => unknown;
};
export type SelectionFunction<V> = <T>(t: T | V) => T;
type BuiltInVariableTypes = {
    ['String']: string;
    ['Int']: number;
    ['Float']: number;
    ['ID']: unknown;
    ['Boolean']: boolean;
};
type AllVariableTypes = keyof BuiltInVariableTypes | keyof ZEUS_VARIABLES;
type VariableRequired<T extends string> = `${T}!` | T | `[${T}]` | `[${T}]!` | `[${T}!]` | `[${T}!]!`;
type VR<T extends string> = VariableRequired<VariableRequired<T>>;
export type GraphQLVariableType = VR<AllVariableTypes>;
type ExtractVariableTypeString<T extends string> = T extends VR<infer R1> ? R1 extends VR<infer R2> ? R2 extends VR<infer R3> ? R3 extends VR<infer R4> ? R4 extends VR<infer R5> ? R5 : R4 : R3 : R2 : R1 : T;
type DecomposeType<T, Type> = T extends `[${infer R}]` ? Array<DecomposeType<R, Type>> | undefined : T extends `${infer R}!` ? NonNullable<DecomposeType<R, Type>> : Type | undefined;
type ExtractTypeFromGraphQLType<T extends string> = T extends keyof ZEUS_VARIABLES ? ZEUS_VARIABLES[T] : T extends keyof BuiltInVariableTypes ? BuiltInVariableTypes[T] : any;
export type GetVariableType<T extends string> = DecomposeType<T, ExtractTypeFromGraphQLType<ExtractVariableTypeString<T>>>;
type UndefinedKeys<T> = {
    [K in keyof T]-?: T[K] extends NonNullable<T[K]> ? never : K;
}[keyof T];
type WithNullableKeys<T> = Pick<T, UndefinedKeys<T>>;
type WithNonNullableKeys<T> = Omit<T, UndefinedKeys<T>>;
type OptionalKeys<T> = {
    [P in keyof T]?: T[P];
};
export type WithOptionalNullables<T> = OptionalKeys<WithNullableKeys<T>> & WithNonNullableKeys<T>;
export type Variable<T extends GraphQLVariableType, Name extends string> = {
    ' __zeus_name': Name;
    ' __zeus_type': T;
};
export type ExtractVariablesDeep<Query> = Query extends Variable<infer VType, infer VName> ? {
    [key in VName]: GetVariableType<VType>;
} : Query extends string | number | boolean | Array<string | number | boolean> ? {} : UnionToIntersection<{
    [K in keyof Query]: WithOptionalNullables<ExtractVariablesDeep<Query[K]>>;
}[keyof Query]>;
export type ExtractVariables<Query> = Query extends Variable<infer VType, infer VName> ? {
    [key in VName]: GetVariableType<VType>;
} : Query extends [infer Inputs, infer Outputs] ? ExtractVariablesDeep<Inputs> & ExtractVariables<Outputs> : Query extends string | number | boolean | Array<string | number | boolean> ? {} : UnionToIntersection<{
    [K in keyof Query]: WithOptionalNullables<ExtractVariables<Query[K]>>;
}[keyof Query]>;
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export declare const START_VAR_NAME = "$ZEUS_VAR";
export declare const GRAPHQL_TYPE_SEPARATOR = "__$GRAPHQL__";
export declare const $: <Type extends GraphQLVariableType, Name extends string>(name: Name, graphqlType: Type) => Variable<Type, Name>;
type ZEUS_INTERFACES = GraphQLTypes['AccountHolderInfo'] | GraphQLTypes['AccountHolderStatusInfo'] | GraphQLTypes['AccountMembershipStatusInfo'] | GraphQLTypes['AccountStatusInfo'] | GraphQLTypes['AccountVerification'] | GraphQLTypes['AccountVerificationStatusInfo'] | GraphQLTypes['CapitalDepositDocumentStatusInfo'] | GraphQLTypes['CardStatusInfo'] | GraphQLTypes['CompleteDigitalCardStatusInfo'] | GraphQLTypes['Connection'] | GraphQLTypes['DigitalCard'] | GraphQLTypes['DocumentFile'] | GraphQLTypes['Edge'] | GraphQLTypes['FeeCreditor'] | GraphQLTypes['FeeDebtor'] | GraphQLTypes['Field'] | GraphQLTypes['FundingLimitSettingsChangeRequestStatusInfo'] | GraphQLTypes['FundingLimitSettingsStatusInfo'] | GraphQLTypes['FundingSource'] | GraphQLTypes['FundingSourceStatusInfo'] | GraphQLTypes['IndividualUltimateBeneficialOwnerInfo'] | GraphQLTypes['InternalCreditTransferCreditor'] | GraphQLTypes['InternalCreditTransferDebtor'] | GraphQLTypes['InternalDirectDebitMandate'] | GraphQLTypes['LegalDocumentStatusInfo'] | GraphQLTypes['MerchantPaymentLinkStatusInfo'] | GraphQLTypes['MerchantPaymentMethod'] | GraphQLTypes['MerchantPaymentMethodStatusInfo'] | GraphQLTypes['MerchantProfileStatusInfo'] | GraphQLTypes['OnboardingAccountHolderInfo'] | GraphQLTypes['OnboardingStatusInfo'] | GraphQLTypes['PartnershipStatusInfo'] | GraphQLTypes['PaymentDirectDebitMandate'] | GraphQLTypes['PaymentMandate'] | GraphQLTypes['PaymentMandateCreditor'] | GraphQLTypes['PaymentMandateDebtor'] | GraphQLTypes['PaymentMandateStatusInfo'] | GraphQLTypes['PaymentStatusInfo'] | GraphQLTypes['PendingDigitalCardStatusInfo'] | GraphQLTypes['PhysicalCardStatusInfo'] | GraphQLTypes['Reason'] | GraphQLTypes['ReceivedDirectDebitMandate'] | GraphQLTypes['ReceivedDirectDebitMandateStatusInfo'] | GraphQLTypes['Rejection'] | GraphQLTypes['SEPACreditTransferCreditor'] | GraphQLTypes['SEPACreditTransferDebtor'] | GraphQLTypes['SEPADirectDebitCreditor'] | GraphQLTypes['SEPADirectDebitDebtor'] | GraphQLTypes['SEPADirectDebitMandate'] | GraphQLTypes['StandingOrderStatusInfo'] | GraphQLTypes['StatementInfo'] | GraphQLTypes['SupportingDocumentCollectionStatusInfo'] | GraphQLTypes['SupportingDocumentStatusInfo'] | GraphQLTypes['Transaction'] | GraphQLTypes['TransactionStatusInfo'] | GraphQLTypes['TrustedBeneficiary'] | GraphQLTypes['TrustedBeneficiaryStatusInfo'] | GraphQLTypes['UltimateBeneficialOwnerInfo'] | GraphQLTypes['WebhookSubscriptionStatusInfo'];
export type ScalarCoders = {
    AccountNumber?: ScalarResolver;
    AmountValue?: ScalarResolver;
    AuditId?: ScalarResolver;
    AuthorizationId?: ScalarResolver;
    BIC?: ScalarResolver;
    CardToken?: ScalarResolver;
    CCA2?: ScalarResolver;
    CCA3?: ScalarResolver;
    Currency?: ScalarResolver;
    Date?: ScalarResolver;
    DateTime?: ScalarResolver;
    EmailAddress?: ScalarResolver;
    HexColorCode?: ScalarResolver;
    IBAN?: ScalarResolver;
    PhoneNumber?: ScalarResolver;
    PIN?: ScalarResolver;
    SepaCreditorIdentifier?: ScalarResolver;
    SepaReference?: ScalarResolver;
    TokenRequestorId?: ScalarResolver;
    Upload?: ScalarResolver;
    URL?: ScalarResolver;
    WalletToken?: ScalarResolver;
};
type ZEUS_UNIONS = GraphQLTypes['ActivatePhysicalCardPayload'] | GraphQLTypes['AddAccountMembershipPayload'] | GraphQLTypes['AddAccountMembershipsPayload'] | GraphQLTypes['AddCardPayload'] | GraphQLTypes['AddCardsPayload'] | GraphQLTypes['AddCardsWithGroupDeliveryPayload'] | GraphQLTypes['AddDigitalCardPayload'] | GraphQLTypes['AddDirectDebitFundingSourcePayload'] | GraphQLTypes['AddExternalAccountBalancePayload'] | GraphQLTypes['AddExternalAccountPayload'] | GraphQLTypes['AddFundingLimitSettingsChangeRequestPayload'] | GraphQLTypes['AddInternalDirectDebitPaymentMandatePayload'] | GraphQLTypes['AddMerchantProfilePayload'] | GraphQLTypes['AddOrUpdateExternalAccountBalancePayload'] | GraphQLTypes['AddReceivedInternalDirectDebitB2bMandatePayload'] | GraphQLTypes['AddReceivedSepaDirectDebitB2bMandatePayload'] | GraphQLTypes['AddSepaDirectDebitPaymentMandatePayload'] | GraphQLTypes['AddSingleUseVirtualCardPayload'] | GraphQLTypes['AddSingleUseVirtualCardsPayload'] | GraphQLTypes['AddVirtualIbanEntryPayload'] | GraphQLTypes['AllowSddPayload'] | GraphQLTypes['AllowSddVirtualIbanEntryPayload'] | GraphQLTypes['BeneficiaryVerificationResult'] | GraphQLTypes['BindAccountMembershipPayload'] | GraphQLTypes['CancelCardPayload'] | GraphQLTypes['CancelConsentPayload'] | GraphQLTypes['CancelDigitalCardPayload'] | GraphQLTypes['CancelFundingSourcePayload'] | GraphQLTypes['CancelPhysicalCardPayload'] | GraphQLTypes['CancelStandingOrderPayload'] | GraphQLTypes['CancelTransactionPayload'] | GraphQLTypes['CancelVirtualIbanEntryPayload'] | GraphQLTypes['CloseAccountPayload'] | GraphQLTypes['CloseAccountStatusReason'] | GraphQLTypes['ConfirmPhysicalCardRenewalPayload'] | GraphQLTypes['CreateCapitalDepositCasePayload'] | GraphQLTypes['CreateMerchantPaymentLinkPayload'] | GraphQLTypes['CreateMultiConsentPayload'] | GraphQLTypes['DeleteSupportingDocumentPayload'] | GraphQLTypes['DenySddPayload'] | GraphQLTypes['DenySddVirtualIbanEntryPayload'] | GraphQLTypes['DisableAccountMembershipPayload'] | GraphQLTypes['EnableReceivedDirectDebitMandatePayload'] | GraphQLTypes['FinalizeOnboardingPayload'] | GraphQLTypes['GenerateCapitalDepositDocumentUploadUrlPayload'] | GraphQLTypes['GenerateSupportingDocumentUploadUrlPayload'] | GraphQLTypes['GrantConsentWithServerSignaturePayload'] | GraphQLTypes['IbanValidationResult'] | GraphQLTypes['IdentificationDocument'] | GraphQLTypes['IdentificationLevelStatusInfo'] | GraphQLTypes['InitiateCheckMerchantPaymentPayload'] | GraphQLTypes['InitiateCreditTransfersPayload'] | GraphQLTypes['InitiateFundingRequestPayload'] | GraphQLTypes['InitiateInternationalCreditTransferResponsePayload'] | GraphQLTypes['InitiateMerchantPaymentCollectionPayload'] | GraphQLTypes['InternationalCreditTransferCreditor'] | GraphQLTypes['InternationalCreditTransferDebtor'] | GraphQLTypes['OnboardCompanyAccountHolderPayload'] | GraphQLTypes['OnboardIndividualAccountHolderPayload'] | GraphQLTypes['PrintPhysicalCardPayload'] | GraphQLTypes['RefundPayload'] | GraphQLTypes['ReplayWebhookEventPayload'] | GraphQLTypes['RequestMerchantPaymentMethodsPayload'] | GraphQLTypes['RequestMerchantProfileUpdatePayload'] | GraphQLTypes['RequestSupportingDocumentCollectionReviewPayload'] | GraphQLTypes['ResumeAccountMembershipPayload'] | GraphQLTypes['ResumePhysicalCardPayload'] | GraphQLTypes['ScheduleStandingOrderPayload'] | GraphQLTypes['ShareholderInfo'] | GraphQLTypes['SuspendAccountMembershipPayload'] | GraphQLTypes['SuspendAccountStatusReason'] | GraphQLTypes['SuspendPhysicalCardPayload'] | GraphQLTypes['SuspendReceivedDirectDebitMandatePayload'] | GraphQLTypes['UpdateAccountHolderPayload'] | GraphQLTypes['UpdateAccountMembershipPayload'] | GraphQLTypes['UpdateAccountPayload'] | GraphQLTypes['UpdateCardPayload'] | GraphQLTypes['UpdateCompanyOnboardingPayload'] | GraphQLTypes['UpdateIndividualOnboardingPayload'] | GraphQLTypes['UpdateReceivedSepaDirectDebitB2bMandatePayload'] | GraphQLTypes['UpdateSupportingDocumentPayload'] | GraphQLTypes['UpdateUserConsentSettingsPayload'] | GraphQLTypes['ViewCardNumbersPayload'] | GraphQLTypes['ViewPhysicalCardNumbersPayload'] | GraphQLTypes['ViewPhysicalCardPinPayload'] | GraphQLTypes['WebhookSubscriptionPayload'] | GraphQLTypes['WebhookUnsubscribePayload'];
export type ValueTypes = {
    /** Whether you call it a wallet, monetary account, payment account or bank account, the notion of account is fundamental at Swan. All payment flows necessarily go through an account. */
    ['Account']: AliasType<{
        /** Unique identifier of an account */
        id?: boolean | `@${string}`;
        /** Unique account number */
        number?: boolean | `@${string}`;
        /** Account name */
        name?: boolean | `@${string}`;
        /** Account holder */
        holder?: ValueTypes['AccountHolder'];
        /** Cash account type */
        cashAccountType?: boolean | `@${string}`;
        /** Country of the account */
        country?: boolean | `@${string}`;
        /** Payment level */
        paymentLevel?: boolean | `@${string}`;
        /** Bank Identifier Code
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        BIC?: boolean | `@${string}`;
        /** International Bank Account Number
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        IBAN?: boolean | `@${string}`;
        /** Currency */
        currency?: boolean | `@${string}`;
        /** `true` if the main IBAN refuses all Sepa Direct Debit received */
        blockSDD?: boolean | `@${string}`;
        /** Status of the account */
        statusInfo?: ValueTypes['AccountStatusInfo'];
        /** Partnership status */
        partnershipStatusInfo?: ValueTypes['PartnershipStatusInfo'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        virtualIbanEntries?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>;
            },
            ValueTypes['VirtualIBANEntryConnection']
        ];
        memberships?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['MembershipsFilterInput'] | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['AccountMembershipOrderByInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['AccountMembershipConnection']
        ];
        /** `true`if a consent is required to fetch new transactions */
        requiredConsentToFetchNewTransactions?: boolean | `@${string}`;
        /** Language used for account statements */
        language?: boolean | `@${string}`;
        /** Legal representative account membership */
        legalRepresentativeMembership?: ValueTypes['AccountMembership'];
        /** Type of the account : EMoney if account holder has not finished the KYC requirements, PaymentService otherwise */
        paymentAccountType?: boolean | `@${string}`;
        /** Date of the account going from eMoney to PaymentService */
        upgradedAt?: boolean | `@${string}`;
        /** Link to the account's bank details */
        bankDetails?: boolean | `@${string}`;
        legalDocuments?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['LegalDocumentsFilterInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['LegalDocumentConnection']
        ];
        /** A list of balances regarding an account. */
        balances?: ValueTypes['AccountBalances'];
        statements?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['StatementFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['StatementConnection']
        ];
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['TransactionsOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['TransactionsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TransactionConnection']
        ];
        invoices?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>;
            },
            ValueTypes['InvoiceConnection']
        ];
        receivedDirectDebitMandates?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value updatedAt desc) */
                orderBy?: ValueTypes['AccountReceivedDirectDebitOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['AccountReceivedDirectDebitMandateFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['ReceivedDirectDebitMandateConnection']
        ];
        merchantProfiles?: [
            {
                /** number of elements in the list (default value 50) */
                first: number | Variable<any, string>; /** When the list of elements needs to start after a element */
                after?: string | undefined | null | Variable<any, string>; /** When the list of elements needs to be ordered */
                orderBy?: ValueTypes['MerchantProfileOrderByInput'] | undefined | null | Variable<any, string>; /** When the list of elements needs to be filtered */
                filters?: ValueTypes['MerchantProfileFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['MerchantProfileConnection']
        ];
        standingOrders?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an offset to start at */
                offset?: number | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['AccountStandingOrderOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['AccountStandingOrderFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['StandingOrderConnection']
        ];
        fundingSources?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an offset to start at */
                offset?: number | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['FundingSourceOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['FundingSourceFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['FundingSourceConnection']
        ];
        trustedBeneficiaries?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                offset?: number | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value label asc) */
                orderBy?: ValueTypes['TrustedBeneficiaryOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['TrustedBeneficiaryFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TrustedBeneficiaryConnection']
        ];
        __typename?: boolean | `@${string}`;
    }>;
    /** A list of balances regarding an account. */
    ['AccountBalances']: AliasType<{
        /** Balance composed of booked, pending transactions and rolling reserve used known at the time of calculation. */
        available?: ValueTypes['Amount'];
        /** Balance just composed of pending transactions. */
        pending?: ValueTypes['Amount'];
        /** Balance just composed of booked transactions. */
        booked?: ValueTypes['Amount'];
        /** Balance just composed of rolling reserve used in booked transactions. */
        reserved?: ValueTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Closed status information */
    ['AccountClosedStatus']: AliasType<{
        /** Account status (always Closed for type AccountClosedStatus) */
        status?: boolean | `@${string}`;
        /** Reason why the account is suspended
    @Deprecated */
        reason?: boolean | `@${string}`;
        /** Reason why the account is currently closed */
        reasonInfo?: ValueTypes['CloseAccountStatusReason'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Closing status information */
    ['AccountClosingStatus']: AliasType<{
        /** Account status (always Closing for type AccountClosingStatus) */
        status?: boolean | `@${string}`;
        /** Reason why the account is suspended
    @Deprecated */
        reason?: boolean | `@${string}`;
        /** Reason why the account is currently in closing */
        reasonInfo?: ValueTypes['CloseAccountStatusReason'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['AccountConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** AccountEdge list */
        edges?: ValueTypes['AccountEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Refers to the country of the account. It will determine the country code of the local IBAN of the account.
  
  Available Account Country: CCA3 */
    ['AccountCountry']: AccountCountry;
    /** Implements the Relay Edge interface */
    ['AccountEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The account */
        node?: ValueTypes['Account'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountFilterInput']: {
        /** Account Status we want to filter on */
        status?: Array<ValueTypes['AccountStatus']> | undefined | null | Variable<any, string>;
        /** Account Payment Levels we want to filter on */
        paymentLevels?: Array<ValueTypes['PaymentLevel']> | undefined | null | Variable<any, string>;
        /** Searches name, account number, and IBAN */
        search?: string | undefined | null | Variable<any, string>;
    };
    ['AccountFundingLimitsReachedReason']: AccountFundingLimitsReachedReason;
    /** The account holder is the person who owns the money stored in the account. The account holder can be one of your customers, whether it is a natural person or a legal person, or quite simply you. */
    ['AccountHolder']: AliasType<{
        /** Unique identifier of the account holder. */
        id?: boolean | `@${string}`;
        /** Verification status.
         *Banking regulations require financial institutions such as Swan to know and verify their customers in order to comply with their anti-money laundering and terrorist financing obligations. In banking jargon, we talk about KYC (Know Your Customers) procedure* */
        verificationStatus?: boolean | `@${string}`;
        /** Account holder type information. */
        info?: ValueTypes['AccountHolderInfo'];
        /** Account holder status information. */
        statusInfo?: ValueTypes['AccountHolderStatusInfo'];
        /** Residency address. */
        residencyAddress?: ValueTypes['AddressInfo'];
        /** Created date. */
        createdDate?: boolean | `@${string}`;
        /** Updated date. */
        updatedDate?: boolean | `@${string}`;
        accounts?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['AccountOrderByInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['AccountConnection']
        ];
        supportingDocumentCollections?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>;
            },
            ValueTypes['SupportingDocumentCollectionConnection']
        ];
        fundingLimitSettingsChangeRequests?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>;
            },
            ValueTypes['FundingLimitSettingsChangeRequestConnection']
        ];
        /** Account holder onboarding */
        onboarding?: ValueTypes['Onboarding'];
        externalAccounts?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>;
            },
            ValueTypes['ExternalAccountConnection']
        ];
        paymentMandates?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value updatedAt desc) */
                orderBy?: ValueTypes['PaymentMandateOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['PaymentMandateFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['PaymentMandateConnection']
        ];
        /** Funding limit settings */
        fundingLimitSettings?: ValueTypes['FundingLimitSettings'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Holder Canceled Status Information */
    ['AccountHolderCanceledStatusInfo']: AliasType<{
        /** Status of the account holder. */
        status?: boolean | `@${string}`;
        /** Reason why the account holder is suspended. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountHolderCompanyInfo']: AliasType<{
        /** Account holder type (always Company for type AccountHolderCompanyInfo) */
        type?: boolean | `@${string}`;
        /** Name of the company. */
        name?: boolean | `@${string}`;
        /** Registration number of the company (SIRET, ...). */
        registrationNumber?: boolean | `@${string}`;
        /** Registration date of the company. */
        companyRegistrationDate?: boolean | `@${string}`;
        /** Legal form of the company (SAS, SCI, SASU, ...). */
        companyType?: boolean | `@${string}`;
        /** Business activity. */
        businessActivity?: boolean | `@${string}`;
        /** Business activity description.
    This must be 1024 characters long maximum. */
        businessActivityDescription?: boolean | `@${string}`;
        /** Estimated monthly payment volume (euro). */
        monthlyPaymentVolume?: boolean | `@${string}`;
        /** The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
    
    The ultimate beneficiary is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: ValueTypes['IndividualUltimateBeneficialOwner'];
        /** Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT */
        vatNumber?: boolean | `@${string}`;
        /** Tax Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ValueTypes['AddressInformation'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)). */
    ['AccountHolderConnection']: AliasType<{
        /** Total number of element in the list. */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page. */
        pageInfo?: ValueTypes['PageInfo'];
        /** AccountHolderEdge list. */
        edges?: ValueTypes['AccountHolderEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface. */
    ['AccountHolderEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism. */
        cursor?: boolean | `@${string}`;
        /** The account holder. */
        node?: ValueTypes['AccountHolder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Holder Enabled Status Information */
    ['AccountHolderEnabledStatusInfo']: AliasType<{
        /** Status of the account holder. */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountHolderFilterInput']: {
        status?: Array<ValueTypes['AccountHolderStatus']> | undefined | null | Variable<any, string>;
        types?: Array<ValueTypes['AccountHolderType']> | undefined | null | Variable<any, string>;
        verificationStatus?: Array<ValueTypes['VerificationStatus']> | undefined | null | Variable<any, string>;
        /** Searches company name, first name, last name */
        search?: string | undefined | null | Variable<any, string>;
        firstName?: string | undefined | null | Variable<any, string>;
        lastName?: string | undefined | null | Variable<any, string>;
        birthDate?: string | undefined | null | Variable<any, string>;
        registrationNumber?: string | undefined | null | Variable<any, string>;
    };
    /** Individual account holder. */
    ['AccountHolderIndividualInfo']: AliasType<{
        /** Account holder type (always Individual for type AccountHolderIndividualInfo). */
        type?: boolean | `@${string}`;
        /** Account Holder's first name and last name. */
        name?: boolean | `@${string}`;
        /** Employment status of the account holder (regulatory questions). */
        employmentStatus?: boolean | `@${string}`;
        /** Monthly income of the account holder (regulatory questions). */
        monthlyIncome?: boolean | `@${string}`;
        /** User of the individual account holder. */
        user?: ValueTypes['User'];
        /** Tax Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account holder types. */
    ['AccountHolderInfo']: AliasType<{
        /** Account holder type */
        type?: boolean | `@${string}`;
        /** Account holder name */
        name?: boolean | `@${string}`;
        ['...on AccountHolderCompanyInfo']?: Omit<ValueTypes['AccountHolderCompanyInfo'], keyof ValueTypes['AccountHolderInfo']>;
        ['...on AccountHolderIndividualInfo']?: Omit<ValueTypes['AccountHolderIndividualInfo'], keyof ValueTypes['AccountHolderInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Account Holder was not found */
    ['AccountHolderNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing account holders */
    ['AccountHolderOrderByFieldInput']: AccountHolderOrderByFieldInput;
    /** Order that can be applied when listing account holders */
    ['AccountHolderOrderByInput']: {
        field?: ValueTypes['AccountHolderOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Account holder status. */
    ['AccountHolderStatus']: AccountHolderStatus;
    /** Account Holder Status Information */
    ['AccountHolderStatusInfo']: AliasType<{
        /** Status of the account holder. */
        status?: boolean | `@${string}`;
        ['...on AccountHolderCanceledStatusInfo']?: Omit<ValueTypes['AccountHolderCanceledStatusInfo'], keyof ValueTypes['AccountHolderStatusInfo']>;
        ['...on AccountHolderEnabledStatusInfo']?: Omit<ValueTypes['AccountHolderEnabledStatusInfo'], keyof ValueTypes['AccountHolderStatusInfo']>;
        ['...on AccountHolderSuspendedStatusInfo']?: Omit<ValueTypes['AccountHolderSuspendedStatusInfo'], keyof ValueTypes['AccountHolderStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Holder Suspended Status Information */
    ['AccountHolderSuspendedStatusInfo']: AliasType<{
        /** Status of the account holder. */
        status?: boolean | `@${string}`;
        /** Reason why the account holder is suspended. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account holder type */
    ['AccountHolderType']: AccountHolderType;
    /** Rejection returned if the account holder type is individual.
  An individual account holder can't create a b2b received direct debit mandate. */
    ['AccountHolderTypeIndividualRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Language: ISO 639-1 language code */
    ['AccountLanguage']: AccountLanguage;
    /** An account membership represents the rights of a user for a given account.
  
  *Each account is administered by an account membership having the capacity of legal representative. He has the possibility of delegating rights on this account to other users.* */
    ['AccountMembership']: AliasType<{
        /** Unique identifier of an account membership */
        id?: boolean | `@${string}`;
        /** email */
        email?: boolean | `@${string}`;
        /** user of this account membership */
        user?: ValueTypes['User'];
        /** `true` if this account membership having the capacity of the legal representative of the account holder. */
        legalRepresentative?: boolean | `@${string}`;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount?: boolean | `@${string}`;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries?: boolean | `@${string}`;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments?: boolean | `@${string}`;
        /** `true` if this account membership can invite, update, suspend or resume memberships */
        canManageAccountMembership?: boolean | `@${string}`;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | `@${string}`;
        /** status of the account membership */
        statusInfo?: ValueTypes['AccountMembershipStatusInfo'];
        /** account of the account membership */
        account?: ValueTypes['Account'];
        /** Periodic Spending limit list */
        spendingLimits?: ValueTypes['SpendingLimit'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** version of the account membership started from '1' and incremented at every updates */
        version?: boolean | `@${string}`;
        /** Residency address of the member */
        residencyAddress?: ValueTypes['AddressInfo'];
        /** Tax Identification Number of the member */
        taxIdentificationNumber?: boolean | `@${string}`;
        /** List of accepted identification level */
        acceptedIdentificationLevels?: boolean | `@${string}`;
        /** Recommended identification level */
        recommendedIdentificationLevel?: boolean | `@${string}`;
        /** Indicate if the identity bound to the account membership has required identification level */
        hasRequiredIdentificationLevel?: boolean | `@${string}`;
        /** Disabled date */
        disabledAt?: boolean | `@${string}`;
        cards?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['CardOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['CardFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['CardConnection']
        ];
        /** Periodic Spending */
        spending?: ValueTypes['Spending'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when a user is binded with the error to the account membership */
    ['AccountMembershipBindingUserErrorStatusInfo']: AliasType<{
        /** AccountMembership status (always BindingUserError for type AccountMembershipBindingUserErrorStatusInfo) */
        status?: boolean | `@${string}`;
        /** `true` if the first name of the user binded doesn't match with the invitation */
        firstNameMatchError?: boolean | `@${string}`;
        /** `true` if Swan hasn't verified the user's identity */
        idVerifiedMatchError?: boolean | `@${string}`;
        /** `true` if the last name of the user binded doesn't match with the invitation */
        lastNameMatchError?: boolean | `@${string}`;
        /** `true` if the phone number of the user binded doesn't match with the invitation */
        phoneNumberMatchError?: boolean | `@${string}`;
        /** `true` if the birth date of the user binded doesn't match with the invitation */
        birthDateMatchError?: boolean | `@${string}`;
        /** restricted to a user */
        restrictedTo?: ValueTypes['RestrictedTo'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountMembershipCannotBeDisabledRejection']: AliasType<{
        accountMembershipId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountMembershipCannotBeUpdatedRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['AccountMembershipConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** AccountMembershipEdge list */
        edges?: ValueTypes['AccountMembershipEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when the user has to consent to invite a new account membership */
    ['AccountMembershipConsentPendingStatusInfo']: AliasType<{
        /** AccountMembership status (always ConsentPending for type AccountMembershipConsentPendingStatusInfo) */
        status?: boolean | `@${string}`;
        /** The consent required to invite this account membership */
        consent?: ValueTypes['Consent'];
        /** restricted to a user */
        restrictedTo?: ValueTypes['RestrictedTo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when the account membership is disabled */
    ['AccountMembershipDisabledStatusInfo']: AliasType<{
        /** AccountMembership status (always Disabled for type AccountMembershipDisabledStatusInfo) */
        status?: boolean | `@${string}`;
        /** reason why the account membership is disabled */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['AccountMembershipEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The account membership */
        node?: ValueTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when the account membership is enabled */
    ['AccountMembershipEnabledStatusInfo']: AliasType<{
        /** AccountMembership status (always Enabled for type AccountMembershipEnabledStatusInfo) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** when a new account membership is invited and there is no user binded yet */
    ['AccountMembershipInvitationSentStatusInfo']: AliasType<{
        /** AccountMembership status (always InvitationSent for type AccountMembershipInvitationSentStatusInfo) */
        status?: boolean | `@${string}`;
        /** restricted to a user */
        restrictedTo?: ValueTypes['RestrictedTo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Account Membership is not allowed to use an operation. */
    ['AccountMembershipNotAllowedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountMembershipNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if invitation has not been sent to user yet */
    ['AccountMembershipNotReadyToBeBoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing account memberships */
    ['AccountMembershipOrderByFieldInput']: AccountMembershipOrderByFieldInput;
    /** Order that can be applied when listing account memberships */
    ['AccountMembershipOrderByInput']: {
        field?: ValueTypes['AccountMembershipOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Filters that can be applied when listing accounts (Only applied in user context) */
    ['AccountMembershipsFilterInput']: {
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null | Variable<any, string>;
        /** Can the user initiate payments on this account */
        canInitiatePayments?: boolean | undefined | null | Variable<any, string>;
        /** Can the user manage account membership */
        canManageAccountMembership?: boolean | undefined | null | Variable<any, string>;
        /** Can the user manage beneficiaries */
        canManageBeneficiaries?: boolean | undefined | null | Variable<any, string>;
        /** Can the user view account */
        canViewAccount?: boolean | undefined | null | Variable<any, string>;
        /** Account memberships status/statuses we're looking for */
        status?: Array<ValueTypes['AccountMembershipStatus']> | undefined | null | Variable<any, string>;
        /** Filtered by email */
        email?: string | undefined | null | Variable<any, string>;
        /** Filtered by first name */
        firstName?: string | undefined | null | Variable<any, string>;
        /** Filtered by last name */
        lastName?: string | undefined | null | Variable<any, string>;
        /** Searches email, first name, last name, and id */
        search?: string | undefined | null | Variable<any, string>;
    };
    /** List of account memberships permission */
    ['AccountMembershipsPermission']: AccountMembershipsPermission;
    /** AccountMembership enabled */
    ['AccountMembershipStatus']: AccountMembershipStatus;
    /** here are the different account membership status: */
    ['AccountMembershipStatusInfo']: AliasType<{
        /** AccountMembership status */
        status?: boolean | `@${string}`;
        ['...on AccountMembershipBindingUserErrorStatusInfo']?: Omit<ValueTypes['AccountMembershipBindingUserErrorStatusInfo'], keyof ValueTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipConsentPendingStatusInfo']?: Omit<ValueTypes['AccountMembershipConsentPendingStatusInfo'], keyof ValueTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipDisabledStatusInfo']?: Omit<ValueTypes['AccountMembershipDisabledStatusInfo'], keyof ValueTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipEnabledStatusInfo']?: Omit<ValueTypes['AccountMembershipEnabledStatusInfo'], keyof ValueTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipInvitationSentStatusInfo']?: Omit<ValueTypes['AccountMembershipInvitationSentStatusInfo'], keyof ValueTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipSuspendedStatusInfo']?: Omit<ValueTypes['AccountMembershipSuspendedStatusInfo'], keyof ValueTypes['AccountMembershipStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** when the account membership is suspended */
    ['AccountMembershipSuspendedStatusInfo']: AliasType<{
        /** AccountMembership status (always Suspended for type AccountMembershipSuspendedStatusInfo) */
        status?: boolean | `@${string}`;
        /** reason why the account membership is suspended */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Thrown when an related account is not eligible to the feature */
    ['AccountNotEligibleRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the account was not found or if the user does not have the rights to know that the card exists */
    ['AccountNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Swan account number */
    ['AccountNumber']: unknown;
    /** Account Opened status information */
    ['AccountOpenedStatus']: AliasType<{
        /** Account status (always Opened for type AccountOpenedStatus) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fields that can be used when ordering accounts */
    ['AccountOrderByFieldInput']: AccountOrderByFieldInput;
    /** Order that can be applied when listing accounts */
    ['AccountOrderByInput']: {
        field?: ValueTypes['AccountOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Filter that can be passed to get the received direct debit mandate in a specific data range */
    ['AccountReceivedDirectDebitMandateFiltersInput']: {
        /** To filter on status values */
        status?: Array<ValueTypes['ReceivedDirectDebitMandateStatus']> | undefined | null | Variable<any, string>;
        /** To filter on scheme values */
        scheme?: Array<ValueTypes['ReceivedDirectDebitMandateScheme']> | undefined | null | Variable<any, string>;
    };
    /** Field we can use when ordering that can be applied when listing receives direct debit mandate results */
    ['AccountReceivedDirectDebitOrderByFieldInput']: AccountReceivedDirectDebitOrderByFieldInput;
    /** Order that can be applied when listing receives direct debit mandate results */
    ['AccountReceivedDirectDebitOrderByInput']: {
        field?: ValueTypes['AccountReceivedDirectDebitOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Filters that can be applied when listing Standing orders */
    ['AccountStandingOrderFiltersInput']: {
        status?: Array<ValueTypes['StandingOrderStatus']> | undefined | null | Variable<any, string>;
    };
    /** Field we can use when ordering that can be applied when listing standing order results */
    ['AccountStandingOrderOrderByFieldInput']: AccountStandingOrderOrderByFieldInput;
    /** Order that can be applied when listing standing order results */
    ['AccountStandingOrderOrderByInput']: {
        field?: ValueTypes['AccountStandingOrderOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    ['AccountStatus']: AccountStatus;
    ['AccountStatusInfo']: AliasType<{
        /** Account status */
        status?: boolean | `@${string}`;
        ['...on AccountClosedStatus']?: Omit<ValueTypes['AccountClosedStatus'], keyof ValueTypes['AccountStatusInfo']>;
        ['...on AccountClosingStatus']?: Omit<ValueTypes['AccountClosingStatus'], keyof ValueTypes['AccountStatusInfo']>;
        ['...on AccountOpenedStatus']?: Omit<ValueTypes['AccountOpenedStatus'], keyof ValueTypes['AccountStatusInfo']>;
        ['...on AccountSuspendedStatus']?: Omit<ValueTypes['AccountSuspendedStatus'], keyof ValueTypes['AccountStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Suspended status information */
    ['AccountSuspendedStatus']: AliasType<{
        /** Account status (always Suspended for type AccountSuspendedStatus) */
        status?: boolean | `@${string}`;
        /** Reason why the account is suspended
    @Deprecated */
        reason?: boolean | `@${string}`;
        /** Reason why the account is currently suspend */
        reasonInfo?: ValueTypes['SuspendAccountStatusReason'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Verification */
    ['AccountVerification']: AliasType<{
        /** Creation date of the account verification */
        createdAt?: boolean | `@${string}`;
        /** Unique identifier of the Account Verification */
        id?: boolean | `@${string}`;
        /** Account Verification Status Information */
        statusInfo?: ValueTypes['AccountVerificationStatusInfo'];
        /** Last update date of the account verification */
        updatedAt?: boolean | `@${string}`;
        ['...on DirectDebitAccountVerification']?: Omit<ValueTypes['DirectDebitAccountVerification'], keyof ValueTypes['AccountVerification']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the external account has already been rejected.
  
  In such a case, contact Swan directly to resolve the situation for this specific account holder. */
    ['AccountVerificationAlreadyRejectedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Verification Status */
    ['AccountVerificationStatus']: AccountVerificationStatus;
    /** Account Verification Status Information */
    ['AccountVerificationStatusInfo']: AliasType<{
        /** Account verification status */
        status?: boolean | `@${string}`;
        ['...on PendingReviewStatusInfo']?: Omit<ValueTypes['PendingReviewStatusInfo'], keyof ValueTypes['AccountVerificationStatusInfo']>;
        ['...on PendingVerificationStatusInfo']?: Omit<ValueTypes['PendingVerificationStatusInfo'], keyof ValueTypes['AccountVerificationStatusInfo']>;
        ['...on RejectedVerificationStatusInfo']?: Omit<ValueTypes['RejectedVerificationStatusInfo'], keyof ValueTypes['AccountVerificationStatusInfo']>;
        ['...on VerifiedStatusInfo']?: Omit<ValueTypes['VerifiedStatusInfo'], keyof ValueTypes['AccountVerificationStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Account Verification is not in the expected status */
    ['AccountVerificationWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ActionNotAllowedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ActivatePhysicalCardInput']: {
        /** Unique identifier present on physical card */
        identifier: string | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    ['ActivatePhysicalCardPayload']: AliasType<{
        ['...on ActivatePhysicalCardSuccessPayload']: ValueTypes['ActivatePhysicalCardSuccessPayload'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on PhysicalCardNotFoundRejection']: ValueTypes['PhysicalCardNotFoundRejection'];
        ['...on PhysicalCardWrongStatusRejection']: ValueTypes['PhysicalCardWrongStatusRejection'];
        ['...on CannotActivatePhysicalCardRejection']: ValueTypes['CannotActivatePhysicalCardRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on UserNotCardHolderRejection']: ValueTypes['UserNotCardHolderRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ActivatePhysicalCardSuccessPayload']: AliasType<{
        /** The consent required to activate this physical card */
        consent?: ValueTypes['Consent'];
        /** The physicalCard to activate */
        physicalCard?: ValueTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ActiveMerchantPaymentLinkStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** The date when the payment link expires.
    By default the payment link expires 120 days after it was created. */
        expiresAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new account membership */
    ['AddAccountMembershipInput']: {
        /** Unique identifier of a given account */
        accountId: string | Variable<any, string>;
        /** Email address */
        email: string | Variable<any, string>;
        /** Restricted to a user if necessary */
        restrictedTo: ValueTypes['RestrictedToInput'] | Variable<any, string>;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean | Variable<any, string>;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean | Variable<any, string>;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean | Variable<any, string>;
        /** `true` if this account membership can invite, update, suspend or resume account membership */
        canManageAccountMembership: boolean | Variable<any, string>;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** Residency address of the member to be added */
        residencyAddress?: ValueTypes['ResidencyAddressInput'] | undefined | null | Variable<any, string>;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined | null | Variable<any, string>;
    };
    ['AddAccountMembershipPayload']: AliasType<{
        ['...on AddAccountMembershipSuccessPayload']: ValueTypes['AddAccountMembershipSuccessPayload'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InvalidPhoneNumberRejection']: ValueTypes['InvalidPhoneNumberRejection'];
        ['...on PermissionCannotBeGrantedRejection']: ValueTypes['PermissionCannotBeGrantedRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new account membership */
    ['AddAccountMembershipsInput']: {
        /** Unique identifier of a given account */
        accountId: string | Variable<any, string>;
        /** Memberships to add to the account */
        memberships: Array<ValueTypes['MembershipInfoInput']> | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    ['AddAccountMembershipsPayload']: AliasType<{
        ['...on AddAccountMembershipsSuccessPayload']: ValueTypes['AddAccountMembershipsSuccessPayload'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InvalidPhoneNumberRejection']: ValueTypes['InvalidPhoneNumberRejection'];
        ['...on PermissionCannotBeGrantedRejection']: ValueTypes['PermissionCannotBeGrantedRejection'];
        ['...on TooManyItemsRejection']: ValueTypes['TooManyItemsRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddAccountMembershipsSuccessPayload']: AliasType<{
        accountMemberships?: ValueTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddAccountMembershipSuccessPayload']: AliasType<{
        accountMembership?: ValueTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new card */
    ['AddCardInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string | Variable<any, string>;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean | Variable<any, string>;
        /** `true` if this card allows payments outside of the country */
        international: boolean | Variable<any, string>;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean | Variable<any, string>;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** Card name */
        name?: string | undefined | null | Variable<any, string>;
        /** `true` to show the card confidential information in the same request */
        viewCardNumber?: boolean | undefined | null | Variable<any, string>;
        /** The id of the card product to use to create the new card. */
        cardProductId?: string | undefined | null | Variable<any, string>;
        /** Spending limit */
        spendingLimit?: ValueTypes['SpendingLimitInput'] | undefined | null | Variable<any, string>;
    };
    ['AddCardPayload']: AliasType<{
        ['...on AddCardSuccessPayload']: ValueTypes['AddCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on CardProductDisabledRejection']: ValueTypes['CardProductDisabledRejection'];
        ['...on CardProductSuspendedRejection']: ValueTypes['CardProductSuspendedRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: ValueTypes['EnabledCardDesignNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on MissingMandatoryFieldRejection']: ValueTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a new cards */
    ['AddCardsInput']: {
        /** The configuration of all the cards you want to add */
        cards: Array<ValueTypes['CardConfigInput']> | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined | null | Variable<any, string>;
    };
    ['AddCardsPayload']: AliasType<{
        ['...on AddCardsSuccessPayload']: ValueTypes['AddCardsSuccessPayload'];
        ['...on AddingCardsToDifferentAccountsRejection']: ValueTypes['AddingCardsToDifferentAccountsRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on TooManyItemsRejection']: ValueTypes['TooManyItemsRejection'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardProductSuspendedRejection']: ValueTypes['CardProductSuspendedRejection'];
        ['...on CardProductNotApplicableToPhysicalCardsRejection']: ValueTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        ['...on CardProductDisabledRejection']: ValueTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: ValueTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: ValueTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddCardsSuccessPayload']: AliasType<{
        /** The newly created cards */
        cards?: ValueTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddCardSuccessPayload']: AliasType<{
        /** The new card added */
        card?: ValueTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a new cards */
    ['AddCardsWithGroupDeliveryInput']: {
        /** Address to deliver the printed physical cards */
        groupDeliveryAddress: ValueTypes['CompleteAddressWithContactInput'] | Variable<any, string>;
        /** The configuration of all the cards you want to add */
        cards: Array<ValueTypes['CardConfigWithGroupDeliveryInput']> | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined | null | Variable<any, string>;
    };
    ['AddCardsWithGroupDeliveryPayload']: AliasType<{
        ['...on AddCardsWithGroupDeliverySuccessPayload']: ValueTypes['AddCardsWithGroupDeliverySuccessPayload'];
        ['...on AddingCardsToDifferentAccountsRejection']: ValueTypes['AddingCardsToDifferentAccountsRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on TooManyItemsRejection']: ValueTypes['TooManyItemsRejection'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardProductSuspendedRejection']: ValueTypes['CardProductSuspendedRejection'];
        ['...on CardProductNotApplicableToPhysicalCardsRejection']: ValueTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        ['...on CardProductDisabledRejection']: ValueTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: ValueTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: ValueTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddCardsWithGroupDeliverySuccessPayload']: AliasType<{
        /** The newly created cards */
        cards?: ValueTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new digital card */
    ['AddDigitalCardInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
        /** Provider for which to generate a digitalCard */
        walletProvider: ValueTypes['WalletProviderType'] | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    /** Payload returned on mutation completion */
    ['AddDigitalCardPayload']: AliasType<{
        ['...on AddDigitalCardSuccessPayload']: ValueTypes['AddDigitalCardSuccessPayload'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on CardCanNotBeDigitalizedRejection']: ValueTypes['CardCanNotBeDigitalizedRejection'];
        ['...on ApplePayNotAllowedForProjectRejection']: ValueTypes['ApplePayNotAllowedForProjectRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on UserNotCardHolderRejection']: ValueTypes['UserNotCardHolderRejection'];
        ['...on CardProductDisabledRejection']: ValueTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: ValueTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: ValueTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddDigitalCardSuccessPayload']: AliasType<{
        /** Digital Card used for ApplePay or GooglePay
    
    The consent can be found in the digital card status information. */
        digitalCard?: ValueTypes['PendingDigitalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a Direct Debit Funding Source */
    ['AddDirectDebitFundingSourceInput']: {
        /** Scheme of the underlying payment mandate */
        scheme: ValueTypes['SEPADirectDebitScheme'] | Variable<any, string>;
        /** Id of the account on which to create a funding source.
    Money will be funded to this account when an `initiateFundingRequest` is done using this funding source */
        accountId: string | Variable<any, string>;
        /** IBAN to use in the direct debit transaction that will be triggered when funding the account.
    Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source */
        iban: ValueTypes['IBAN'] | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** Name to give to this funding source */
        name?: string | undefined | null | Variable<any, string>;
    };
    /** Add Direct Debit Funding Source Payload */
    ['AddDirectDebitFundingSourcePayload']: AliasType<{
        ['...on AddDirectDebitFundingSourceSuccessPayload']: ValueTypes['AddDirectDebitFundingSourceSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: ValueTypes['NotFoundRejection'];
        ['...on AccountVerificationAlreadyRejectedRejection']: ValueTypes['AccountVerificationAlreadyRejectedRejection'];
        ['...on IBANNotReachableRejection']: ValueTypes['IBANNotReachableRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Add Direct Debit Funding Source Success Payload */
    ['AddDirectDebitFundingSourceSuccessPayload']: AliasType<{
        /** The created funding source */
        fundingSource?: ValueTypes['FundingSource'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddExternalAccountBalanceInput']: {
        /** Unique identifier of a given external account */
        externalAccountId: string | Variable<any, string>;
        /** Amount of the balance */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Type of the balance */
        type: ValueTypes['ExternalAccountBalanceType'] | Variable<any, string>;
        /** Last changed Date */
        lastChangedAt: ValueTypes['DateTime'] | Variable<any, string>;
    };
    ['AddExternalAccountBalancePayload']: AliasType<{
        ['...on AddExternalAccountBalanceSuccessPayload']: ValueTypes['AddExternalAccountBalanceSuccessPayload'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        ['...on ExternalAccountBalanceAlreadyExistsRejection']: ValueTypes['ExternalAccountBalanceAlreadyExistsRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddExternalAccountBalanceSuccessPayload']: AliasType<{
        /** The added external balance */
        externalAccountBalance?: ValueTypes['ExternalAccountBalance'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddExternalAccountInput']: {
        /** Unique identifier of a given account holder */
        accountHolderId: string | Variable<any, string>;
        /** External account identifier */
        externalId: string | Variable<any, string>;
        /** Name of the account */
        name?: string | undefined | null | Variable<any, string>;
        /** Type of account */
        cashAccountType: ValueTypes['CashAccountType'] | Variable<any, string>;
        /** Bank Identifier Code */
        BIC: ValueTypes['BIC'] | Variable<any, string>;
        /** International Bank Account Number */
        IBAN: ValueTypes['IBAN'] | Variable<any, string>;
        /** Currency */
        currency: ValueTypes['Currency'] | Variable<any, string>;
        /** Account Holder name */
        holderName: string | Variable<any, string>;
        /** Country */
        country: ValueTypes['CCA3'] | Variable<any, string>;
        /** Original Created date */
        originalCreatedAt: ValueTypes['DateTime'] | Variable<any, string>;
        /** Usage information of the account */
        usage: ValueTypes['ExternalAccountUsage'] | Variable<any, string>;
        /** Source of the account information */
        source: string | Variable<any, string>;
        /** Balances */
        balances?: Array<ValueTypes['ExternalAccountBalanceInput']> | undefined | null | Variable<any, string>;
    };
    ['AddExternalAccountPayload']: AliasType<{
        ['...on AddExternalAccountSuccessPayload']: ValueTypes['AddExternalAccountSuccessPayload'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        ['...on IbanValidationRejection']: ValueTypes['IbanValidationRejection'];
        ['...on ExternalAccountAlreadyExistsRejection']: ValueTypes['ExternalAccountAlreadyExistsRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddExternalAccountSuccessPayload']: AliasType<{
        /** The added external account */
        externalAccount?: ValueTypes['ExternalAccount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new request for funding limit settings change */
    ['AddFundingLimitSettingsChangeRequestInput']: {
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit: ValueTypes['FundingLimitAmountInput'] | Variable<any, string>;
        /** Requested amount settings for the funding limit */
        fundingLimit: ValueTypes['FundingLimitAmountInput'] | Variable<any, string>;
        /** Unique identifier of a given account holder */
        accountHolderId: string | Variable<any, string>;
    };
    /** Payload returned on mutation completion */
    ['AddFundingLimitSettingsChangeRequestPayload']: AliasType<{
        ['...on AddFundingLimitSettingsChangeRequestSuccessPayload']: ValueTypes['AddFundingLimitSettingsChangeRequestSuccessPayload'];
        ['...on FundingLimitSettingsChangeRequestBadAmountRejection']: ValueTypes['FundingLimitSettingsChangeRequestBadAmountRejection'];
        ['...on AccountHolderNotFoundRejection']: ValueTypes['AccountHolderNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Add Funding Limit Settings Change Request Success Payload */
    ['AddFundingLimitSettingsChangeRequestSuccessPayload']: AliasType<{
        /** The new request for funding limit settings change */
        fundingLimitSettingsChangeRequest?: ValueTypes['FundingLimitSettingsChangeRequest'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the attempting to add cards to different accounts. */
    ['AddingCardsToDifferentAccountsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add an Internal Direct Debit Payment Mandate */
    ['AddInternalDirectDebitPaymentMandateInput']: {
        /** The ID of the concerned merchant payment method */
        paymentMethodId: string | Variable<any, string>;
        /** Determines whether the payment mandate is a one-off or recurrent */
        sequence?: ValueTypes['InternalDirectDebitSequence'] | undefined | null | Variable<any, string>;
        /** Reference of the payment mandate */
        reference?: string | undefined | null | Variable<any, string>;
        /** Language that will be used to produce the mandate PDF document */
        language?: ValueTypes['MandateLanguage'] | undefined | null | Variable<any, string>;
        /** ID of the Swan account of the debtor */
        debtorAccountId: string | Variable<any, string>;
        /** Signature date of the Internal Direct Debit mandate */
        signatureDate?: ValueTypes['Date'] | undefined | null | Variable<any, string>;
        /** Custom name of the Internal Direct Debit mandate */
        name?: string | undefined | null | Variable<any, string>;
    };
    /** Union type return by the addInternalDirectDebitPaymentMandate mutation */
    ['AddInternalDirectDebitPaymentMandatePayload']: AliasType<{
        ['...on AddInternalDirectDebitPaymentMandateSuccessPayload']: ValueTypes['AddInternalDirectDebitPaymentMandateSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: ValueTypes['NotFoundRejection'];
        ['...on DebtorAccountNotAllowedRejection']: ValueTypes['DebtorAccountNotAllowedRejection'];
        ['...on DebtorAccountClosedRejection']: ValueTypes['DebtorAccountClosedRejection'];
        ['...on SchemeWrongRejection']: ValueTypes['SchemeWrongRejection'];
        ['...on PaymentMandateReferenceAlreadyUsedRejection']: ValueTypes['PaymentMandateReferenceAlreadyUsedRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the addInternalDirectDebitPaymentMandate mutation */
    ['AddInternalDirectDebitPaymentMandateSuccessPayload']: AliasType<{
        paymentMandate?: ValueTypes['InternalPaymentDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a Merchant Profile */
    ['AddMerchantProfileInput']: {
        /** ID of the Swan account which the merchantProfile is associated to */
        accountId: string | Variable<any, string>;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string | Variable<any, string>;
        /** Url of the merchant's website */
        merchantWebsite?: string | undefined | null | Variable<any, string>;
        /** base64 encoded merchant's logo */
        merchantLogo?: string | undefined | null | Variable<any, string>;
        /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: ValueTypes['ProductType'] | Variable<any, string>;
        /** Expected annual activity volumes for all payment methods. */
        expectedMonthlyPaymentVolume: ValueTypes['AmountInput'] | Variable<any, string>;
        /** expected average basket value. */
        expectedAverageBasket: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page. */
        accentColor?: string | undefined | null | Variable<any, string>;
    };
    /** Add Merchant Profile Payload */
    ['AddMerchantProfilePayload']: AliasType<{
        ['...on AddMerchantProfileSuccessPayload']: ValueTypes['AddMerchantProfileSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Add Merchant Profile Success Payload */
    ['AddMerchantProfileSuccessPayload']: AliasType<{
        /** Merchant Profile */
        merchantProfile?: ValueTypes['MerchantProfile'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddOrUpdateExternalAccountBalanceInput']: {
        /** Unique identifier of a given external account */
        externalAccountId: string | Variable<any, string>;
        /** Amount of the balance */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Type of the balance */
        type: ValueTypes['ExternalAccountBalanceType'] | Variable<any, string>;
        /** Last changed Date */
        lastChangedAt: ValueTypes['DateTime'] | Variable<any, string>;
    };
    ['AddOrUpdateExternalAccountBalancePayload']: AliasType<{
        ['...on AddOrUpdateExternalAccountBalanceSuccessPayload']: ValueTypes['AddOrUpdateExternalAccountBalanceSuccessPayload'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddOrUpdateExternalAccountBalanceSuccessPayload']: AliasType<{
        /** The added external balance */
        externalAccountBalance?: ValueTypes['ExternalAccountBalance'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a received internal direct debit mandate B2b. */
    ['AddReceivedInternalDirectDebitB2bMandateInput']: {
        /** The associated Payment Mandate ID */
        paymentMandateId: string | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined | null | Variable<any, string>;
    };
    /** Union type return by the addReceivedInternalDirectDebitB2bMandate mutation */
    ['AddReceivedInternalDirectDebitB2bMandatePayload']: AliasType<{
        ['...on AddReceivedInternalDirectDebitB2bMandateSuccessPayload']: ValueTypes['AddReceivedInternalDirectDebitB2bMandateSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on PaymentMandateMandateNotFoundRejection']: ValueTypes['PaymentMandateMandateNotFoundRejection'];
        ['...on AccountHolderTypeIndividualRejection']: ValueTypes['AccountHolderTypeIndividualRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the addReceivedInternalDirectDebitB2bMandate mutation */
    ['AddReceivedInternalDirectDebitB2bMandateSuccessPayload']: AliasType<{
        /** The received direct debit mandate is added */
        receivedDirectDebitMandate?: ValueTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a received sepa direct debit mandate B2b. */
    ['AddReceivedSepaDirectDebitB2bMandateInput']: {
        /** The unique identifier of the received direct debit mandate */
        mandateReference: string | Variable<any, string>;
        /** The Sepa Creditor Identifier of the creditor */
        creditorIdentifier: string | Variable<any, string>;
        /** The name of the creditor */
        creditorName: string | Variable<any, string>;
        /** The Swan Iban of the debtor */
        iban: string | Variable<any, string>;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined | null | Variable<any, string>;
        /** Sequence of the mandate */
        sequence: ValueTypes['SEPAReceivedDirectDebitMandateSequence'] | Variable<any, string>;
        /** Date of signature of the mandate */
        signatureDate?: ValueTypes['Date'] | undefined | null | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    /** Union type return by the addReceivedSepaDirectDebitB2bMandate mutation */
    ['AddReceivedSepaDirectDebitB2bMandatePayload']: AliasType<{
        ['...on AddReceivedSepaDirectDebitB2bMandateSuccessPayload']: ValueTypes['AddReceivedSepaDirectDebitB2bMandateSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on AccountHolderTypeIndividualRejection']: ValueTypes['AccountHolderTypeIndividualRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the addReceivedSepaDirectDebitB2bMandate mutation */
    ['AddReceivedSepaDirectDebitB2bMandateSuccessPayload']: AliasType<{
        /** The received direct debit mandate is added */
        receivedDirectDebitMandate?: ValueTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Address Information */
    ['Address']: AliasType<{
        /** address line 1 */
        addressLine1?: boolean | `@${string}`;
        /** addressLine2 */
        addressLine2?: boolean | `@${string}`;
        /** city */
        city?: boolean | `@${string}`;
        /** postal code (max 10 characters) */
        postalCode?: boolean | `@${string}`;
        /** state */
        state?: boolean | `@${string}`;
        /** country */
        country?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Address information. */
    ['AddressInfo']: AliasType<{
        /** Address line 1. */
        addressLine1?: boolean | `@${string}`;
        /** Address line 2. */
        addressLine2?: boolean | `@${string}`;
        /** City. */
        city?: boolean | `@${string}`;
        /** Postal code. */
        postalCode?: boolean | `@${string}`;
        /** State. */
        state?: boolean | `@${string}`;
        /** Country. */
        country?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Address */
    ['AddressInformation']: AliasType<{
        /** Address */
        addressLine1?: boolean | `@${string}`;
        /** Address */
        addressLine2?: boolean | `@${string}`;
        /** City */
        city?: boolean | `@${string}`;
        /** Country */
        country?: boolean | `@${string}`;
        /** Postal code */
        postalCode?: boolean | `@${string}`;
        /** State */
        state?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Address */
    ['AddressInformationInput']: {
        /** Address */
        addressLine1: string | Variable<any, string>;
        /** Address */
        addressLine2?: string | undefined | null | Variable<any, string>;
        /** City */
        city: string | Variable<any, string>;
        /** Country */
        country: ValueTypes['CCA3'] | Variable<any, string>;
        /** Postal code */
        postalCode: string | Variable<any, string>;
        /** State */
        state?: string | undefined | null | Variable<any, string>;
    };
    /** Address Information */
    ['AddressInput']: {
        /** address line 1 (max 100 characters) */
        addressLine1?: string | undefined | null | Variable<any, string>;
        /** address line 2 (max 100 characters) */
        addressLine2?: string | undefined | null | Variable<any, string>;
        /** city (max 100 characters) */
        city?: string | undefined | null | Variable<any, string>;
        /** postal code (max 10 characters) */
        postalCode?: string | undefined | null | Variable<any, string>;
        /** state (max 100 characters) */
        state?: string | undefined | null | Variable<any, string>;
        /** country code */
        country: ValueTypes['CCA3'] | Variable<any, string>;
    };
    ['AddSepaDirectDebitPaymentMandateInput']: {
        /** Specifies payment ID of a SEPA Direct Debit CORE or B2B payment method. */
        paymentMethodId: string | Variable<any, string>;
        /** Determines whether the payment mandate is a one-off or recurrent */
        sequence: ValueTypes['DirectDebitSequence'] | Variable<any, string>;
        /** Unique reference of the SEPA Direct Debit Payment Mandate. */
        reference?: string | undefined | null | Variable<any, string>;
        /** Language that will be used to produce the mandate PDF document */
        language: ValueTypes['MandateLanguage'] | Variable<any, string>;
        /** Signature date of the SEPA Direct Debit Payment Mandate */
        signatureDate: ValueTypes['Date'] | Variable<any, string>;
        /** Debtor of the SEPA Direct Debit Payment Mandate */
        debtor: ValueTypes['SepaPaymentMandateDebtorInput'] | Variable<any, string>;
        /** Custom name of the SEPA Direct Debit Payment Mandate */
        name?: string | undefined | null | Variable<any, string>;
    };
    /** Union type return by the addSepaDirectDebitPaymentMandate mutation */
    ['AddSepaDirectDebitPaymentMandatePayload']: AliasType<{
        ['...on AddSepaDirectDebitPaymentMandateSuccessPayload']: ValueTypes['AddSepaDirectDebitPaymentMandateSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: ValueTypes['NotFoundRejection'];
        ['...on DebtorAccountNotAllowedRejection']: ValueTypes['DebtorAccountNotAllowedRejection'];
        ['...on DebtorAccountClosedRejection']: ValueTypes['DebtorAccountClosedRejection'];
        ['...on SchemeWrongRejection']: ValueTypes['SchemeWrongRejection'];
        ['...on PaymentMandateReferenceAlreadyUsedRejection']: ValueTypes['PaymentMandateReferenceAlreadyUsedRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        ['...on PaymentMethodNotCompatibleRejection']: ValueTypes['PaymentMethodNotCompatibleRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the addSepaDirectDebitPaymentMandate mutation */
    ['AddSepaDirectDebitPaymentMandateSuccessPayload']: AliasType<{
        paymentMandate?: ValueTypes['SEPAPaymentDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new card */
    ['AddSingleUseVirtualCardInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string | Variable<any, string>;
        /** Spending limit */
        spendingLimit: ValueTypes['SpendingLimitInput'] | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** Card name */
        name?: string | undefined | null | Variable<any, string>;
        /** `true` to show the card confidential information in the same request */
        viewCardNumber?: boolean | undefined | null | Variable<any, string>;
        /** The id of the card product to use to create the new card. */
        cardProductId?: string | undefined | null | Variable<any, string>;
    };
    ['AddSingleUseVirtualCardPayload']: AliasType<{
        ['...on AddSingleUseVirtualCardSuccessForUserPayload']: ValueTypes['AddSingleUseVirtualCardSuccessForUserPayload'];
        ['...on AddSingleUseVirtualCardSuccessForProjectOwnerPayload']: ValueTypes['AddSingleUseVirtualCardSuccessForProjectOwnerPayload'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardProductSuspendedRejection']: ValueTypes['CardProductSuspendedRejection'];
        ['...on CardProductDisabledRejection']: ValueTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: ValueTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: ValueTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a new single-use virtual cards */
    ['AddSingleUseVirtualCardsInput']: {
        /** The configuration of all the cards you want to add */
        cards: Array<ValueTypes['SingleUseVirtualCardConfigInput']> | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined | null | Variable<any, string>;
    };
    ['AddSingleUseVirtualCardsPayload']: AliasType<{
        ['...on AddSingleUseVirtualCardsSuccessPayload']: ValueTypes['AddSingleUseVirtualCardsSuccessPayload'];
        ['...on AddingCardsToDifferentAccountsRejection']: ValueTypes['AddingCardsToDifferentAccountsRejection'];
        ['...on TooManyItemsRejection']: ValueTypes['TooManyItemsRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardProductSuspendedRejection']: ValueTypes['CardProductSuspendedRejection'];
        ['...on CardProductDisabledRejection']: ValueTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: ValueTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: ValueTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddSingleUseVirtualCardsSuccessPayload']: AliasType<{
        /** The newly created single use virtual cards */
        cards?: ValueTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddSingleUseVirtualCardSuccessForProjectOwnerPayload']: AliasType<{
        /** The new card added */
        card?: ValueTypes['Card'];
        /** Card confidential */
        confidential?: ValueTypes['CardConfidential'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddSingleUseVirtualCardSuccessForUserPayload']: AliasType<{
        /** The new card added */
        card?: ValueTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddVirtualIbanEntryPayload']: AliasType<{
        ['...on AddVirtualIbanEntrySuccessPayload']: ValueTypes['AddVirtualIbanEntrySuccessPayload'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddVirtualIbanEntrySuccessPayload']: AliasType<{
        virtualIbanEntry?: ValueTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to Add a Virtual IBAN */
    ['AddVirtualIbanInput']: {
        /** Unique identifier of a given account */
        accountId: string | Variable<any, string>;
    };
    /** Input values needed to add a webhook subscription */
    ['AddWebhookSubscriptionInput']: {
        /** A short descriptive label for the subscription
    (max 255 characters) */
        label: string | Variable<any, string>;
        /** The endpoint URL events will be sent to
    (max 255 characters) */
        endpoint: string | Variable<any, string>;
        /** The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
    (max 36 characters) */
        secret?: string | undefined | null | Variable<any, string>;
        /** The types of subscribed events
    A subset of unique IDs from `webhookEventTypes` */
        eventTypes: Array<string> | Variable<any, string>;
        /** Control if the subscription should be enabled on creation */
        status: ValueTypes['WebhookSubscriptionCreationStatus'] | Variable<any, string>;
    };
    ['AllowedValue']: AliasType<{
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to Allow SDD */
    ['AllowSddInput']: {
        /** Unique identifier of a given account */
        accountId: string | Variable<any, string>;
    };
    ['AllowSddPayload']: AliasType<{
        ['...on AllowSddSuccessPayload']: ValueTypes['AllowSddSuccessPayload'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AllowSddSuccessPayload']: AliasType<{
        account?: ValueTypes['Account'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AllowSddVirtualIbanEntryInput']: {
        ibanEntryId: string | Variable<any, string>;
    };
    ['AllowSddVirtualIbanEntryPayload']: AliasType<{
        ['...on AllowSddVirtualIbanEntrySuccessPayload']: ValueTypes['AllowSddVirtualIbanEntrySuccessPayload'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AllowSddVirtualIbanEntrySuccessPayload']: AliasType<{
        virtualIbanEntry?: ValueTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if card already has a valid Physical Card */
    ['AlreadyValidPhysicalCardRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AmlRiskLevel']: AmlRiskLevel;
    /** Amount with its currency */
    ['Amount']: AliasType<{
        /** currency */
        currency?: boolean | `@${string}`;
        /** value of the amount */
        value?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Amount with its currency */
    ['AmountInput']: {
        /** value of the amount */
        value: ValueTypes['AmountValue'] | Variable<any, string>;
        /** currency */
        currency: ValueTypes['Currency'] | Variable<any, string>;
    };
    /** The amount given with fractional digits, where fractions must be compliant to the currency definition. Up to 14 significant figures. Negative amounts are signed by minus. The decimal separator is a dot.
  
  Example: Valid representations for EUR with up to two decimals are:
  
  1056
  5768.2
  -1.50
  5877.78 */
    ['AmountValue']: unknown;
    /** Rejection return if the project is not configured to allow Apple Pay */
    ['ApplePayNotAllowedForProjectRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Approved Funding Limit */
    ['ApprovedFundingLimit']: AliasType<{
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit?: ValueTypes['FundingLimitAmount'];
        /** Requested amount settings for the funding limit */
        fundingLimit?: ValueTypes['FundingLimitAmount'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AuditId']: unknown;
    /** A method used to authenticate a user */
    ['Authenticator']: AliasType<{
        /** Operating System parsed from the user agent (eg AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, ...) */
        os?: boolean | `@${string}`;
        /** Device Brand parsed from the user agent (eg: Acer, Alcatel, Amazon, Apple, ...) */
        brand?: boolean | `@${string}`;
        /** Device Model parsed from the user agent */
        model?: boolean | `@${string}`;
        /** Type of authenticator */
        type?: boolean | `@${string}`;
        /** Raw user agent */
        userAgent?: boolean | `@${string}`;
        /** Accept-Language header used during registration */
        acceptLanguage?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AuthenticatorType']: AuthenticatorType;
    ['AuthorizationId']: unknown;
    /** Type of the card authorization transaction */
    ['AuthorizationType']: AuthorizationType;
    /** Rejection returned if the status account is not valid */
    ['BadAccountStatusRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['BadRequestRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Balance Information */
    ['Balance']: AliasType<{
        /** Matching account for this balance */
        account?: ValueTypes['Account'];
        /** A list of balances regarding an account. */
        balances?: ValueTypes['AccountBalances'];
        /** Last SCT OUT transaction */
        lastSctOut?: ValueTypes['SEPACreditTransferTransaction'];
        /** Last SCT IN transaction */
        lastSctIn?: ValueTypes['SEPACreditTransferTransaction'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information about the banking institution */
    ['Bank']: AliasType<{
        /** Bank name */
        name?: boolean | `@${string}`;
        /** Bank Branch Code */
        branch?: boolean | `@${string}`;
        /** Bank local identifier (unique by country) */
        nationalId?: boolean | `@${string}`;
        /** Bank BIC code */
        bic?: boolean | `@${string}`;
        /** Bank address (We might only be able to fill in the country) */
        address?: ValueTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Basic Physical Card Info */
    ['BasicPhysicalCardInfo']: AliasType<{
        /** Physical Card expiration date  with MM/YY string format */
        expiryDate?: boolean | `@${string}`;
        /** Offline Spending limit defined by Swan */
        offlineSpendingLimit?: ValueTypes['Amount'];
        /** Masked Card Number */
        cardMaskedNumber?: boolean | `@${string}`;
        /** Custom Options */
        customOptions?: ValueTypes['PhysicalCardCustomOptions'];
        __typename?: boolean | `@${string}`;
    }>;
    /** BeneficiaryAccountHolderType */
    ['BeneficiaryAccountHolderType']: BeneficiaryAccountHolderType;
    /** BeneficiaryAccountStatus */
    ['BeneficiaryAccountStatus']: BeneficiaryAccountStatus;
    /** Beneficiary name and IBAN match */
    ['BeneficiaryMatch']: AliasType<{
        accountStatus?: boolean | `@${string}`;
        accountHolderType?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Beneficiary name and IBAN did not match */
    ['BeneficiaryMismatch']: AliasType<{
        accountStatus?: boolean | `@${string}`;
        accountHolderType?: boolean | `@${string}`;
        /** Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank */
        nameSuggestion?: boolean | `@${string}`;
        /** Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank */
        accountHolderResidencyCity?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Beneficiary type */
    ['BeneficiaryType']: BeneficiaryType;
    /** Beneficiary name and IBAN did not match entirely possibly caused by a mistype */
    ['BeneficiaryTypo']: AliasType<{
        accountStatus?: boolean | `@${string}`;
        accountHolderType?: boolean | `@${string}`;
        /** Only returned if the information is provided by the beneficiary's bank */
        nameSuggestion?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** BeneficiaryVerification input */
    ['BeneficiaryVerificationInput']: {
        /** IBAN to verify */
        iban: ValueTypes['IBAN'] | Variable<any, string>;
        /** Name to correlate */
        name: string | Variable<any, string>;
        /** AccountId of the initiator of the payment */
        debtorAccountId: string | Variable<any, string>;
    };
    /** BeneficiaryVerificationResult */
    ['BeneficiaryVerificationResult']: AliasType<{
        ['...on BeneficiaryMatch']: ValueTypes['BeneficiaryMatch'];
        ['...on BeneficiaryTypo']: ValueTypes['BeneficiaryTypo'];
        ['...on BeneficiaryMismatch']: ValueTypes['BeneficiaryMismatch'];
        ['...on InvalidBeneficiaryVerification']: ValueTypes['InvalidBeneficiaryVerification'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Bank Identifier Code */
    ['BIC']: unknown;
    ['BindAccountMembershipInput']: {
        accountMembershipId: string | Variable<any, string>;
    };
    ['BindAccountMembershipPayload']: AliasType<{
        ['...on BindAccountMembershipSuccessPayload']: ValueTypes['BindAccountMembershipSuccessPayload'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on AccountMembershipNotFoundRejection']: ValueTypes['AccountMembershipNotFoundRejection'];
        ['...on AccountMembershipNotReadyToBeBoundRejection']: ValueTypes['AccountMembershipNotReadyToBeBoundRejection'];
        ['...on IdentityAlreadyBindToAccountMembershipRejection']: ValueTypes['IdentityAlreadyBindToAccountMembershipRejection'];
        ['...on RestrictedToUserRejection']: ValueTypes['RestrictedToUserRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['BindAccountMembershipSuccessPayload']: AliasType<{
        accountMembership?: ValueTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Booked transaction status information */
    ['BookedTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The Date when the transaction is posted to an account on the Swan books. */
        bookingDate?: boolean | `@${string}`;
        /** The Date when the transaction is considered effective in accounting */
        valueDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Business activity. */
    ['BusinessActivity']: BusinessActivity;
    /** Inputs to cancel a card */
    ['CancelCardInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
    };
    ['CancelCardPayload']: AliasType<{
        ['...on CancelCardSuccessPayload']: ValueTypes['CancelCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelCardSuccessPayload']: AliasType<{
        /** The canceled card */
        card?: ValueTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input of the `cancelConsent` mutation */
    ['CancelConsentInput']: {
        consentId: string | Variable<any, string>;
    };
    /** Payload of the `cancelConsent` mutation */
    ['CancelConsentPayload']: AliasType<{
        ['...on CancelConsentSuccessPayload']: ValueTypes['CancelConsentSuccessPayload'];
        ['...on ConsentNotFoundRejection']: ValueTypes['ConsentNotFoundRejection'];
        ['...on NotReachableConsentStatusRejection']: ValueTypes['NotReachableConsentStatusRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Success payload of the `cancelConsent` mutation */
    ['CancelConsentSuccessPayload']: AliasType<{
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to cancel a digital card */
    ['CancelDigitalCardInput']: {
        /** Unique identifier of a digital card */
        digitalCardId: string | Variable<any, string>;
    };
    ['CancelDigitalCardPayload']: AliasType<{
        ['...on CancelDigitalCardSuccessPayload']: ValueTypes['CancelDigitalCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on DigitalCardNotFoundRejection']: ValueTypes['DigitalCardNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelDigitalCardSuccessPayload']: AliasType<{
        /** The canceled digital card */
        digitalCard?: ValueTypes['DigitalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source Canceled Reason */
    ['CanceledFundingSourceReason']: CanceledFundingSourceReason;
    /** Funding Source Canceled status information */
    ['CanceledFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Canceled status */
        status?: boolean | `@${string}`;
        /** Date at which the funding source was enabled */
        enabledAt?: boolean | `@${string}`;
        /** Date at which the funding source was canceled */
        canceledAt?: boolean | `@${string}`;
        /** Reason code of the cancellation */
        reasonCode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level for the process associated to this identification that has been cancelled by the end-user */
    ['CanceledIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Cancelled` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** CanceledMerchantPaymentMethodStatusInfo */
    ['CanceledMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method canceled date */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** CanceledMerchantProfileStatusInfo */
    ['CanceledMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        canceledAt?: boolean | `@${string}`;
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Canceled transaction status information */
    ['CanceledTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The date when the transaction was canceled */
        canceledDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Cancel Funding Source Input */
    ['CancelFundingSourceInput']: {
        /** ID of the funding source to cancel */
        id: string | Variable<any, string>;
    };
    /** Cancel Funding Source Payload */
    ['CancelFundingSourcePayload']: AliasType<{
        ['...on CancelFundingSourceSuccessPayload']: ValueTypes['CancelFundingSourceSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: ValueTypes['NotFoundRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Cancel Funding Source Success Payload */
    ['CancelFundingSourceSuccessPayload']: AliasType<{
        /** Canceled Funding Source */
        fundingSource?: ValueTypes['FundingSource'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to cancel a physical card */
    ['CancelPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
        /** Reason why the physical card is canceled */
        reason: ValueTypes['CancelPhysicalCardReason'] | Variable<any, string>;
    };
    ['CancelPhysicalCardPayload']: AliasType<{
        ['...on CancelPhysicalCardSuccessPayload']: ValueTypes['CancelPhysicalCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on PhysicalCardNotFoundRejection']: ValueTypes['PhysicalCardNotFoundRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** reason why the physical card is canceled */
    ['CancelPhysicalCardReason']: CancelPhysicalCardReason;
    ['CancelPhysicalCardSuccessPayload']: AliasType<{
        /** The canceled physical card */
        physicalCard?: ValueTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelStandingOrderInput']: {
        standingOrderId: string | Variable<any, string>;
    };
    ['CancelStandingOrderPayload']: AliasType<{
        ['...on CancelStandingOrderSuccessPayload']: ValueTypes['CancelStandingOrderSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on StandingOrderNotFoundRejection']: ValueTypes['StandingOrderNotFoundRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelStandingOrderSuccessPayload']: AliasType<{
        standingOrder?: ValueTypes['StandingOrder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Cancel transaction */
    ['CancelTransactionInput']: {
        /** transaction ID to cancel */
        transactionId: string | Variable<any, string>;
    };
    ['CancelTransactionPayload']: AliasType<{
        ['...on CancelTransactionSuccessPayload']: ValueTypes['CancelTransactionSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelTransactionSuccessPayload']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelVirtualIbanEntryInput']: {
        virtualIbanEntryId: string | Variable<any, string>;
    };
    ['CancelVirtualIbanEntryPayload']: AliasType<{
        ['...on CancelVirtualIbanEntrySuccessPayload']: ValueTypes['CancelVirtualIbanEntrySuccessPayload'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelVirtualIbanEntrySuccessPayload']: AliasType<{
        virtualIbanEntry?: ValueTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Physical Card cannot be activated */
    ['CannotActivatePhysicalCardRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Capital deposit case for a company. */
    ['CapitalDepositCase']: AliasType<{
        /** Unique identifier of a capital deposit case. */
        id?: boolean | `@${string}`;
        /** List of the company’s shareholders. */
        shareholders?: ValueTypes['Shareholder'];
        /** Amount of the capital deposit. */
        totalCapitalDepositAmount?: ValueTypes['Amount'];
        /** Name of the company. */
        companyName?: boolean | `@${string}`;
        /** Onboarding information of the company. */
        companyOnboarding?: ValueTypes['Onboarding'];
        /** Unique identifier of the company account. */
        companyAccountId?: boolean | `@${string}`;
        /** Status of the capital deposit case. */
        status?: boolean | `@${string}`;
        /** Documents to provide to fulfill the capital deposit case. */
        documents?: ValueTypes['CapitalDepositDocument'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of elements ([Learn More](https://docs.swan.io/api/pagination)) */
    ['CapitalDepositCaseConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** CapitalDepositCaseEdge list */
        edges?: ValueTypes['CapitalDepositCaseEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['CapitalDepositCaseEdge']: AliasType<{
        /** Opaque identifier pointing to this capital deposit case node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The CapitalDepositCase */
        node?: ValueTypes['CapitalDepositCase'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseFiltersInput']: {
        /** Searches company shareholder name, individual shareholder first name, last name, and id */
        search?: string | undefined | null | Variable<any, string>;
        /** Status we want to filter on */
        status?: Array<ValueTypes['CapitalDepositCaseStatus']> | undefined | null | Variable<any, string>;
    };
    /** Field we can use when ordering that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseOrderByFieldInput']: CapitalDepositCaseOrderByFieldInput;
    /** Order that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseOrderByInput']: {
        field?: ValueTypes['CapitalDepositCaseOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Status of a capital deposit case. */
    ['CapitalDepositCaseStatus']: CapitalDepositCaseStatus;
    /** Document provided for a capital deposit case. */
    ['CapitalDepositDocument']: AliasType<{
        /** Unique identifier of a document. */
        id?: boolean | `@${string}`;
        /** Type of the document. */
        type?: boolean | `@${string}`;
        /** Url to download the document, null if it has not already been uploaded. */
        downloadUrl?: boolean | `@${string}`;
        /** Date when the last version of the document has been uploaded. */
        uploadedAt?: boolean | `@${string}`;
        /** Status of the document. */
        status?: boolean | `@${string}`;
        /** Status info of the document. */
        statusInfo?: ValueTypes['CapitalDepositDocumentStatusInfo'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Information about capital deposit case. */
        relatedCapitalDepositCase?: ValueTypes['CapitalDepositCase'];
        /** Information about shareholder. */
        relatedShareholder?: ValueTypes['Shareholder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the document from a capital deposit case cannot be uploaded in its context
  @deprecated(reason: "use `CapitalDepositDocumentCanNotBeUploadedRejection` instead") */
    ['CapitalDepositDocumentCanNotBeUploaded']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the document from a capital deposit case cannot be uploaded in its context */
    ['CapitalDepositDocumentCanNotBeUploadedRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Capital Deposit Document with Pending status */
    ['CapitalDepositDocumentPendingStatusInfo']: AliasType<{
        /** Pending */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Capital Deposit Document with Refused status */
    ['CapitalDepositDocumentRefusedStatusInfo']: AliasType<{
        /** Refused */
        status?: boolean | `@${string}`;
        /** Reason for the rejection. */
        reasonCode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Status of the Capital Deposit Case */
    ['CapitalDepositDocumentStatus']: CapitalDepositDocumentStatus;
    /** Status info of the document. */
    ['CapitalDepositDocumentStatusInfo']: AliasType<{
        /** Status of the document. */
        status?: boolean | `@${string}`;
        ['...on CapitalDepositDocumentPendingStatusInfo']?: Omit<ValueTypes['CapitalDepositDocumentPendingStatusInfo'], keyof ValueTypes['CapitalDepositDocumentStatusInfo']>;
        ['...on CapitalDepositDocumentRefusedStatusInfo']?: Omit<ValueTypes['CapitalDepositDocumentRefusedStatusInfo'], keyof ValueTypes['CapitalDepositDocumentStatusInfo']>;
        ['...on CapitalDepositDocumentUploadedStatusInfo']?: Omit<ValueTypes['CapitalDepositDocumentUploadedStatusInfo'], keyof ValueTypes['CapitalDepositDocumentStatusInfo']>;
        ['...on CapitalDepositDocumentValidatedStatusInfo']?: Omit<ValueTypes['CapitalDepositDocumentValidatedStatusInfo'], keyof ValueTypes['CapitalDepositDocumentStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Type of the document. */
    ['CapitalDepositDocumentType']: CapitalDepositDocumentType;
    /** Capital Deposit Document with Uploaded status */
    ['CapitalDepositDocumentUploadedStatusInfo']: AliasType<{
        /** Uploaded */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Capital Deposit Document with Validated status */
    ['CapitalDepositDocumentValidatedStatusInfo']: AliasType<{
        /** Validated */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card */
    ['Card']: AliasType<{
        /** Unique identifier of a card */
        id?: boolean | `@${string}`;
        /** Type of a card */
        type?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Account membership to define the card holder and the account linked to the card. */
        accountMembership?: ValueTypes['AccountMembership'];
        /** Main Currency */
        mainCurrency?: boolean | `@${string}`;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: boolean | `@${string}`;
        /** URL of the card design */
        cardDesignUrl?: boolean | `@${string}`;
        /** URL of the card with masked card information (like its number) and with full card information if connected user consented beforehand */
        cardUrl?: boolean | `@${string}`;
        /** Card status information */
        statusInfo?: ValueTypes['CardStatusInfo'];
        /** `true` if this card allows cash withdrawals */
        withdrawal?: boolean | `@${string}`;
        /** `true` if this card allows payments outside of the country */
        international?: boolean | `@${string}`;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions?: boolean | `@${string}`;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce?: boolean | `@${string}`;
        /** Periodic Spending limit list */
        spendingLimits?: ValueTypes['SpendingLimit'];
        /** Physical card if the card holder has ordered one */
        physicalCard?: ValueTypes['PhysicalCard'];
        /** Masked Card Number */
        cardMaskedNumber?: boolean | `@${string}`;
        /** Card expiry date with MM/YY format */
        expiryDate?: boolean | `@${string}`;
        /** Card name */
        name?: boolean | `@${string}`;
        /** Card product */
        cardProduct?: ValueTypes['CardProduct'];
        /** Issuing Country */
        issuingCountry?: boolean | `@${string}`;
        digitalCards?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['DigitalCardOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['DigitalCardFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['DigitalCardConnection']
        ];
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['TransactionsOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['TransactionsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TransactionConnection']
        ];
        /** Periodic Spending */
        spending?: ValueTypes['Spending'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CardAuthorizationOutcome']: CardAuthorizationOutcome;
    ['CardAuthorizationType']: CardAuthorizationType;
    /** Card Canceled Status Information */
    ['CardCanceledStatusInfo']: AliasType<{
        /** Card status (always Canceled for type CardCanceledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is canceled */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Canceling Status Information */
    ['CardCancelingStatusInfo']: AliasType<{
        /** Card status (always Canceling for type CardCancelingStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is about to be canceled. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the card could not be digitalized */
    ['CardCanNotBeDigitalizedRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardConfidential']: AliasType<{
        /** Card number */
        pan?: boolean | `@${string}`;
        /** Card verification value */
        cvv?: boolean | `@${string}`;
        /** Expiration date */
        expiryDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardConfigInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string | Variable<any, string>;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean | Variable<any, string>;
        /** `true` if this card allows payments outside of the country */
        international: boolean | Variable<any, string>;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean | Variable<any, string>;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean | Variable<any, string>;
        /** Card name */
        name?: string | undefined | null | Variable<any, string>;
        /** Spending limit */
        spendingLimit: ValueTypes['SpendingLimitInput'] | Variable<any, string>;
        /** If used a physical card will be printed and sent to the given address */
        physicalCard?: ValueTypes['PhysicalCardConfigInput'] | undefined | null | Variable<any, string>;
    };
    ['CardConfigWithGroupDeliveryInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string | Variable<any, string>;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean | Variable<any, string>;
        /** `true` if this card allows payments outside of the country */
        international: boolean | Variable<any, string>;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean | Variable<any, string>;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean | Variable<any, string>;
        /** Card name */
        name?: string | undefined | null | Variable<any, string>;
        /** Spending limit */
        spendingLimit: ValueTypes['SpendingLimitInput'] | Variable<any, string>;
        /** `true` when you wish for print an associated physical card */
        printPhysicalCard: boolean | Variable<any, string>;
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: ValueTypes['PhysicalCardCustomOptionsForGroupDeliveryInput'] | undefined | null | Variable<any, string>;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['CardConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** CardEdge list */
        edges?: ValueTypes['CardEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when the user has to consent to add this card */
    ['CardConsentPendingStatusInfo']: AliasType<{
        /** Card status (always ConsentPending for type CardConsentPendingStatusInfo) */
        status?: boolean | `@${string}`;
        /** The consent required to add this card */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CardDesignBackground']: AliasType<{
        /** Unique identifier of a project card design background */
        id?: boolean | `@${string}`;
        /** Card design background name */
        name?: boolean | `@${string}`;
        /** Card design background type */
        type?: boolean | `@${string}`;
        /** Card design background text color */
        cardTextColor?: boolean | `@${string}`;
        /** Card design background url */
        cardBackgroundUrl?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Project Card Design Background Type */
    ['CardDesignBackgroundType']: CardDesignBackgroundType;
    /** Card designs Status */
    ['CardDesignStatus']: CardDesignStatus;
    /** Implements the Relay Edge interface */
    ['CardEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The Card entry */
        node?: ValueTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Enabled Status Information */
    ['CardEnabledStatusInfo']: AliasType<{
        /** Card status (always Enabled for type CardEnabledStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing cards */
    ['CardFiltersInput']: {
        /** The status of the card.
    
    @deprecated(reason: "use `statuses` instead") */
        status?: ValueTypes['CardStatus'] | undefined | null | Variable<any, string>;
        /** Statuses of the card. */
        statuses?: Array<ValueTypes['CardStatus']> | undefined | null | Variable<any, string>;
        /** Type of card
    
    @deprecated(reason: "use `types` instead") */
        type?: ValueTypes['CardType'] | undefined | null | Variable<any, string>;
        /** Types of card */
        types?: Array<ValueTypes['CardType']> | undefined | null | Variable<any, string>;
        /** String searched */
        search?: string | undefined | null | Variable<any, string>;
        /** Account identifier
    
    This filter is only available for User Access Token, for the moment */
        accountId?: string | undefined | null | Variable<any, string>;
    };
    /** COMING SOON */
    ['CardMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ValueTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ValueTypes['RollingReserve'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the card was not found or if the user does not have the rights to know that the account exists */
    ['CardNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing cards */
    ['CardOrderByFieldInput']: CardOrderByFieldInput;
    /** Order that can be applied when listing cards */
    ['CardOrderByInput']: {
        field?: ValueTypes['CardOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    ['CardPaymentMethodInput']: {
        /** Determine whether the payment method must be activated or not */
        activate?: boolean | undefined | null | Variable<any, string>;
    };
    /** when the card is in the process of being ready to use */
    ['CardProcessingStatusInfo']: AliasType<{
        /** Card status (always Processing for type CardProcessingStatusInfo) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Product */
    ['CardProduct']: AliasType<{
        id?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        projectId?: boolean | `@${string}`;
        status?: boolean | `@${string}`;
        createdAt?: boolean | `@${string}`;
        updatedAt?: boolean | `@${string}`;
        applicableToPhysicalCards?: boolean | `@${string}`;
        cardDesigns?: ValueTypes['CardProductDesign'];
        defaultCardProduct?: boolean | `@${string}`;
        individualSpendingLimit?: ValueTypes['SpendingLimit'];
        companySpendingLimit?: ValueTypes['SpendingLimit'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Card design of a Card Product */
    ['CardProductDesign']: AliasType<{
        /** Unique identifier of a card design */
        id?: boolean | `@${string}`;
        /** Design version */
        version?: boolean | `@${string}`;
        /** Logo url svg */
        cardProjectLogoSvgUrl?: boolean | `@${string}`;
        /** Logo url 300 dpi */
        cardProjectLogo300dpiUrl?: boolean | `@${string}`;
        /** Logo url 300 dpi */
        cardProjectLogo600dpiUrl?: boolean | `@${string}`;
        /** Zoom level */
        zoomRatioProjectLogo?: boolean | `@${string}`;
        /** Card Design URL */
        cardDesignUrl?: boolean | `@${string}`;
        /** Accent color */
        accentColor?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Status of the card design */
        status?: boolean | `@${string}`;
        /** Card Background of the Card design */
        cardBackground?: ValueTypes['CardDesignBackground'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the card product is disabled. */
    ['CardProductDisabledRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the card product is not applicable to physical card. */
    ['CardProductNotApplicableToPhysicalCardsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardProductNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Product Status */
    ['CardProductStatus']: CardProductStatus;
    /** Rejection returned if the card product is suspended. */
    ['CardProductSuspendedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardProductUsedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card settings for a Project */
    ['CardSettings']: AliasType<{
        /** Unique identifier of a project card settings */
        id?: boolean | `@${string}`;
        /** Flag used to indicate if ApplePay is activated for the project */
        allowsApplePay?: boolean | `@${string}`;
        /** Settings version */
        version?: boolean | `@${string}`;
        /** Logo url svg */
        cardProjectLogoSvgUrl?: boolean | `@${string}`;
        /** Logo url 300 dpi */
        cardProjectLogo300dpiUrl?: boolean | `@${string}`;
        /** Logo url 300 dpi */
        cardProjectLogo600dpiUrl?: boolean | `@${string}`;
        /** Zoom level */
        zoomRatioProjectLogo?: boolean | `@${string}`;
        /** Card Design URL */
        cardDesignUrl?: boolean | `@${string}`;
        /** Accent color */
        accentColor?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Status of the card settings */
        status?: boolean | `@${string}`;
        /** Card Background of the Card Settings */
        cardBackground?: ValueTypes['CardSettingsBackground'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CardSettingsBackground']: AliasType<{
        /** Unique identifier of a project card settings */
        id?: boolean | `@${string}`;
        /** Card settings background name */
        name?: boolean | `@${string}`;
        /** Card settings background type */
        type?: boolean | `@${string}`;
        /** Card settings background text color */
        cardTextColor?: boolean | `@${string}`;
        /** Card settings background url */
        cardBackgroundUrl?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Settings Background Type */
    ['CardSettingsBackgroundType']: CardSettingsBackgroundType;
    /** Card Status */
    ['CardStatus']: CardStatus;
    /** Card Status Information */
    ['CardStatusInfo']: AliasType<{
        /** Status of the card. */
        status?: boolean | `@${string}`;
        ['...on CardCanceledStatusInfo']?: Omit<ValueTypes['CardCanceledStatusInfo'], keyof ValueTypes['CardStatusInfo']>;
        ['...on CardCancelingStatusInfo']?: Omit<ValueTypes['CardCancelingStatusInfo'], keyof ValueTypes['CardStatusInfo']>;
        ['...on CardConsentPendingStatusInfo']?: Omit<ValueTypes['CardConsentPendingStatusInfo'], keyof ValueTypes['CardStatusInfo']>;
        ['...on CardEnabledStatusInfo']?: Omit<ValueTypes['CardEnabledStatusInfo'], keyof ValueTypes['CardStatusInfo']>;
        ['...on CardProcessingStatusInfo']?: Omit<ValueTypes['CardProcessingStatusInfo'], keyof ValueTypes['CardStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardToken']: unknown;
    /** Card transaction */
    ['CardTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** external identifier of the transaction */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ValueTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ValueTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ValueTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** card numbers masked (Primary Account Number) */
        maskedPan?: boolean | `@${string}`;
        /** unique identifier of the card */
        cardId?: boolean | `@${string}`;
        /** card used for this transaction */
        card?: ValueTypes['Card'];
        /** unique identifier of the terminal */
        terminalId?: boolean | `@${string}`;
        /** original amount and currency of the transaction */
        originalAmount?: ValueTypes['Amount'];
        /** currency exchange if any */
        currencyExchange?: ValueTypes['ReportExchangeRate'];
        /** unique identifier of the merchant */
        merchantId?: boolean | `@${string}`;
        /** merchant name */
        merchantName?: boolean | `@${string}`;
        /** merchant city */
        merchantCity?: boolean | `@${string}`;
        /** merchant country */
        merchantCountry?: boolean | `@${string}`;
        /** merchant postal code */
        merchantPostalCode?: boolean | `@${string}`;
        /** merchant category code (MCC) */
        merchantCategoryCode?: boolean | `@${string}`;
        /** merchant category description
    Enum that explains what the MCC corresponds to in a more readable way */
        merchantCategoryDescription?: boolean | `@${string}`;
        /** category of the payment flow */
        category?: boolean | `@${string}`;
        /** type of the authorization.
    Only available for:
    - authorization transaction
    - debit transaction linked to a previous authorization transaction */
        authorizationType?: boolean | `@${string}`;
        /** matching account for the transaction */
        account?: ValueTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ValueTypes['Transaction'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CardTransactionCategory']: CardTransactionCategory;
    /** Card Type */
    ['CardType']: CardType;
    /** Rejection returned when the Card is not the expected status */
    ['CardWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        expectedStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Cash account type (Always Current) */
    ['CashAccountType']: CashAccountType;
    /** Payment flow available options */
    ['Category']: Category;
    /** Country code alpha 2 (ISO 3166) */
    ['CCA2']: unknown;
    /** Country code alpha 3 (ISO 3166) */
    ['CCA3']: unknown;
    /** Certificate */
    ['Certificate']: {
        /** CertificateType
    
    Can be either LEAF or INTERMEDIATE */
        key: string | Variable<any, string>;
        /** Base64 value of the certificate */
        value: string | Variable<any, string>;
    };
    /** CheckMerchantPaymentMethod */
    ['CheckMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ValueTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ValueTypes['RollingReserve'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CheckPaymentMethodInput']: {
        /** Determine whether the payment method must be activated or not */
        activate?: boolean | undefined | null | Variable<any, string>;
    };
    ['CheckRejection']: AliasType<{
        message?: boolean | `@${string}`;
        fnciInfo?: ValueTypes['FnciInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Check transaction */
    ['CheckTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction: check number */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** 31-caracter unique identifier located at the bottom of the check.
    CMC7 is composed of 3 sections (check number (7 char.), check issuing bank code (12 char.), check holder account number (12 char.)).
    Combined with RLMC key, it  allows the check traceability. */
        cmc7?: boolean | `@${string}`;
        /** 2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
    Combined with CMC7 line, it allows the check traceability. */
        rlmcKey?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ValueTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ValueTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ValueTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** matching account for the transaction */
        account?: ValueTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ValueTypes['Transaction'];
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: ValueTypes['Amount'];
        /** date on which reserved funds become available */
        reservedAmountReleasedAt?: boolean | `@${string}`;
        /** return reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CloseAccountInput']: {
        accountId: string | Variable<any, string>;
        reason: ValueTypes['PartnerCloseAccountReasonInput'] | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    ['CloseAccountPayload']: AliasType<{
        ['...on CloseAccountSuccessPayload']: ValueTypes['CloseAccountSuccessPayload'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Define a reason with a message and a specific type for closing account action */
    ['CloseAccountReason']: AliasType<{
        type?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Specific type for closing account action */
    ['CloseAccountReasonType']: CloseAccountReasonType;
    /** Union between PartnerCloseAccountReasonType and InternalCloseAccountReason */
    ['CloseAccountStatusReason']: AliasType<{
        ['...on CloseAccountReason']: ValueTypes['CloseAccountReason'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CloseAccountSuccessPayload']: AliasType<{
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Data provided following the search for company information by siren number */
    ['CompanyInfo']: AliasType<{
        siren?: boolean | `@${string}`;
        companyName?: boolean | `@${string}`;
        headquarters?: ValueTypes['Headquarters'];
        vatNumber?: boolean | `@${string}`;
        taxIdentificationNumber?: boolean | `@${string}`;
        legalRepresentativePersonalAddress?: ValueTypes['AddressInformation'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Company shareholder info. */
    ['CompanyShareholder']: AliasType<{
        /** Whether the shareholder is an individual or a company. */
        type?: boolean | `@${string}`;
        /** Company name. */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Type of company. */
    ['CompanyType']: CompanyType;
    /** Complete Address Information */
    ['CompleteAddressInput']: {
        /** address line 1 (max 38 characters) */
        addressLine1: string | Variable<any, string>;
        /** address line 2 (max 38 characters) */
        addressLine2?: string | undefined | null | Variable<any, string>;
        /** city (max 30 characters) */
        city: string | Variable<any, string>;
        /** postal code (max 10 characters) */
        postalCode: string | Variable<any, string>;
        /** state (max 30 characters) */
        state?: string | undefined | null | Variable<any, string>;
        /** country code */
        country: ValueTypes['CCA3'] | Variable<any, string>;
    };
    /** Complete Address Information with a contact */
    ['CompleteAddressWithContactInput']: {
        /** address line 1 (max 38 characters) */
        addressLine1: string | Variable<any, string>;
        /** address line 2 (max 38 characters) */
        addressLine2?: string | undefined | null | Variable<any, string>;
        /** city (max 30 characters) */
        city: string | Variable<any, string>;
        /** postal code (max 10 characters) */
        postalCode: string | Variable<any, string>;
        /** state (max 30 characters) */
        state?: string | undefined | null | Variable<any, string>;
        /** country code */
        country: ValueTypes['CCA3'] | Variable<any, string>;
        /** contact first name */
        firstName: string | Variable<any, string>;
        /** contact last name */
        lastName: string | Variable<any, string>;
        /** contact phone number */
        phoneNumber: ValueTypes['PhoneNumber'] | Variable<any, string>;
        /** contact company name (max 38 characters) */
        companyName?: string | undefined | null | Variable<any, string>;
    };
    /** Complete Digital Card used for ApplePay or GooglePay
  
  Once the pending phase is over, more data will be available in the response */
    ['CompleteDigitalCard']: AliasType<{
        /** Unique identifier of a digital card */
        id?: boolean | `@${string}`;
        /** The type of digitalization that created this digital card. */
        type?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider?: ValueTypes['WalletProvider'];
        /** Device
    In case of a wallet application, some information about the device will be provided */
        device?: ValueTypes['Device'];
        /** Id of the wallet application.
    Will not be present for Merchant */
        walletId?: boolean | `@${string}`;
        /** Masked DPAN with the last four digits visible
    
    This value is present in the user wallet application */
        cardMaskedNumber?: boolean | `@${string}`;
        /** Digital Card status information
    
    In this type the status will be either ConsentPending or Pending */
        statusInfo?: ValueTypes['CompleteDigitalCardStatusInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Complete Digital Card Status */
    ['CompleteDigitalCardStatus']: CompleteDigitalCardStatus;
    /** Complete Digital Card Status Information */
    ['CompleteDigitalCardStatusInfo']: AliasType<{
        /** Status of the digital card. */
        status?: boolean | `@${string}`;
        ['...on DigitalCardCanceledStatusInfo']?: Omit<ValueTypes['DigitalCardCanceledStatusInfo'], keyof ValueTypes['CompleteDigitalCardStatusInfo']>;
        ['...on DigitalCardEnabledStatusInfo']?: Omit<ValueTypes['DigitalCardEnabledStatusInfo'], keyof ValueTypes['CompleteDigitalCardStatusInfo']>;
        ['...on DigitalCardSuspendedStatusInfo']?: Omit<ValueTypes['DigitalCardSuspendedStatusInfo'], keyof ValueTypes['CompleteDigitalCardStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['CompletedMerchantPaymentLinkStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** The time when the customer completed the payment. */
        completedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to confirm physical card renewal */
    ['ConfirmPhysicalCardRenewalInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
        /** Address to deliver the physical card */
        address: ValueTypes['CompleteAddressInput'] | Variable<any, string>;
        /** Custom Options */
        customOptions?: ValueTypes['PhysicalCardCustomOptionsInput'] | undefined | null | Variable<any, string>;
    };
    ['ConfirmPhysicalCardRenewalPayload']: AliasType<{
        ['...on ConfirmPhysicalCardRenewalSuccessPayload']: ValueTypes['ConfirmPhysicalCardRenewalSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        ['...on PhysicalCardWrongStatusRejection']: ValueTypes['PhysicalCardWrongStatusRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ConfirmPhysicalCardRenewalSuccessPayload']: AliasType<{
        /** Physical card has been updated */
        physicalCard?: ValueTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Relay Connection type, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['Connection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** Edge list */
        edges?: ValueTypes['Edge'];
        ['...on AccountConnection']?: Omit<ValueTypes['AccountConnection'], keyof ValueTypes['Connection']>;
        ['...on AccountHolderConnection']?: Omit<ValueTypes['AccountHolderConnection'], keyof ValueTypes['Connection']>;
        ['...on AccountMembershipConnection']?: Omit<ValueTypes['AccountMembershipConnection'], keyof ValueTypes['Connection']>;
        ['...on CapitalDepositCaseConnection']?: Omit<ValueTypes['CapitalDepositCaseConnection'], keyof ValueTypes['Connection']>;
        ['...on CardConnection']?: Omit<ValueTypes['CardConnection'], keyof ValueTypes['Connection']>;
        ['...on ConsentConnection']?: Omit<ValueTypes['ConsentConnection'], keyof ValueTypes['Connection']>;
        ['...on DigitalCardConnection']?: Omit<ValueTypes['DigitalCardConnection'], keyof ValueTypes['Connection']>;
        ['...on ExternalAccountConnection']?: Omit<ValueTypes['ExternalAccountConnection'], keyof ValueTypes['Connection']>;
        ['...on ExternalBalanceConnection']?: Omit<ValueTypes['ExternalBalanceConnection'], keyof ValueTypes['Connection']>;
        ['...on FundingLimitSettingsChangeRequestConnection']?: Omit<ValueTypes['FundingLimitSettingsChangeRequestConnection'], keyof ValueTypes['Connection']>;
        ['...on FundingSourceConnection']?: Omit<ValueTypes['FundingSourceConnection'], keyof ValueTypes['Connection']>;
        ['...on InvoiceConnection']?: Omit<ValueTypes['InvoiceConnection'], keyof ValueTypes['Connection']>;
        ['...on LegalDocumentConnection']?: Omit<ValueTypes['LegalDocumentConnection'], keyof ValueTypes['Connection']>;
        ['...on MerchantProfileConnection']?: Omit<ValueTypes['MerchantProfileConnection'], keyof ValueTypes['Connection']>;
        ['...on OnboardingConnection']?: Omit<ValueTypes['OnboardingConnection'], keyof ValueTypes['Connection']>;
        ['...on PaymentConnection']?: Omit<ValueTypes['PaymentConnection'], keyof ValueTypes['Connection']>;
        ['...on PaymentMandateConnection']?: Omit<ValueTypes['PaymentMandateConnection'], keyof ValueTypes['Connection']>;
        ['...on ReceivedDirectDebitMandateConnection']?: Omit<ValueTypes['ReceivedDirectDebitMandateConnection'], keyof ValueTypes['Connection']>;
        ['...on StandingOrderConnection']?: Omit<ValueTypes['StandingOrderConnection'], keyof ValueTypes['Connection']>;
        ['...on StatementConnection']?: Omit<ValueTypes['StatementConnection'], keyof ValueTypes['Connection']>;
        ['...on SupportingDocumentCollectionConnection']?: Omit<ValueTypes['SupportingDocumentCollectionConnection'], keyof ValueTypes['Connection']>;
        ['...on TransactionConnection']?: Omit<ValueTypes['TransactionConnection'], keyof ValueTypes['Connection']>;
        ['...on TrustedBeneficiaryConnection']?: Omit<ValueTypes['TrustedBeneficiaryConnection'], keyof ValueTypes['Connection']>;
        ['...on UserConnection']?: Omit<ValueTypes['UserConnection'], keyof ValueTypes['Connection']>;
        ['...on VirtualIBANEntryConnection']?: Omit<ValueTypes['VirtualIBANEntryConnection'], keyof ValueTypes['Connection']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Some sensitive operation at Swan, such as initiating a payment, require consent */
    ['Consent']: AliasType<{
        /** unique identifier of the consent */
        id?: boolean | `@${string}`;
        /** `true` if the consent requires a Strong Customer Authentication */
        requireSCA?: boolean | `@${string}`;
        /** status of the consent */
        status?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** date when the `consentUrl` was request the first time */
        startedAt?: boolean | `@${string}`;
        /** date when the consent expire */
        expiredAt?: boolean | `@${string}`;
        /** purpose of the consent */
        purpose?: boolean | `@${string}`;
        /** Redirect the user to this URL to start the consent flow */
        consentUrl?: boolean | `@${string}`;
        /** When the consent flow is finished the user is redirected to this URL */
        redirectUrl?: boolean | `@${string}`;
        /** userId who initiated the consent */
        userId?: boolean | `@${string}`;
        /** user who initiated the consent */
        user?: ValueTypes['User'];
        /** unique hash of the consent */
        challenge?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ConsentConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** ConsentEdge list */
        edges?: ValueTypes['ConsentEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['ConsentEdge']: AliasType<{
        /** Opaque identifier pointing to this consent node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The consent */
        node?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Consent ID with related execution order */
    ['ConsentIdWithOrder']: {
        /** Execution order. Consents are granted in ascending order. Consents with the same order may be granted in parallel. */
        order: number | Variable<any, string>;
        /** Consent ID */
        consentId: string | Variable<any, string>;
    };
    /** Rejection returned if a consent was not found */
    ['ConsentNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        consentId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Purpose of a consent */
    ['ConsentPurpose']: ConsentPurpose;
    /** Rejection returned when a the consent is already linked to another multi consent */
    ['ConsentsAlreadyLinkedToMultiConsentRejection']: AliasType<{
        message?: boolean | `@${string}`;
        /** IDs of the consents that are already linked to another multi consent */
        consentIds?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ConsentsFiltersInput']: {
        userId?: string | undefined | null | Variable<any, string>;
    };
    /** Rejection returned when all provided consents are not in created status */
    ['ConsentsNotAllInCreatedStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        /** IDs of the consents that are not in created status */
        consentIds?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when a consent ID passed as input does not exist. */
    ['ConsentsNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        ids?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Status of a consent */
    ['ConsentStatus']: ConsentStatus;
    ['ConsentTypeNotSupportedByServerConsentRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to create a capital deposit case. */
    ['CreateCapitalDepositCaseInput']: {
        /** Name ("Dénomination sociale") of the company being registered and for which the capital is being deposited. */
        companyName: string | Variable<any, string>;
        /** Array of shareholders of type company ("personne morale"). */
        companyShareholders: Array<ValueTypes['OnboardCompanyShareholderInput'] | undefined | null> | Variable<any, string>;
        /** Array of shareholders of type individual ("personne physique"). */
        individualShareholders: Array<ValueTypes['OnboardIndividualShareholderInput'] | undefined | null> | Variable<any, string>;
        /** Amount of the capital deposit. */
        totalCapitalDepositAmount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Information required for the onboarding of a company. */
        onboardingCapitalDepositCompany: ValueTypes['OnboardCompanyAccountHolderInput'] | Variable<any, string>;
    };
    ['CreateCapitalDepositCasePayload']: AliasType<{
        ['...on CreateCapitalDepositCaseSuccessPayload']: ValueTypes['CreateCapitalDepositCaseSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on BadRequestRejection']: ValueTypes['BadRequestRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CreateCapitalDepositCaseSuccessPayload']: AliasType<{
        capitalDepositCase?: ValueTypes['CapitalDepositCase'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CreateMerchantPaymentLinkInput']: {
        /** The Merchant Profile to link this Payment Link to */
        merchantProfileId: string | Variable<any, string>;
        /** Amount to be paid to sucessfully complete the payment. */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Merchant Website URL to redirect the user to when the payment is completed. */
        redirectUrl: ValueTypes['URL'] | Variable<any, string>;
        /** URL to redirect the user to if they cancel their payment */
        cancelRedirectUrl: ValueTypes['URL'] | Variable<any, string>;
        /** The customer billing Address
    These fields should be completed also to pre-fill a SEPA direct debit mandate.
    
    We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes */
        billingAddress?: ValueTypes['AddressInput'] | undefined | null | Variable<any, string>;
        /** The date when the payment link expires.
    If not specified, the default time will be 120 days */
        expiresAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** A date that reflects the time at which the user asked the transaction to be executed.
    For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
    For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
    
    Default value means that the execution will be as soon as possible */
        requestedExecutionAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** Controls if the payment mandate created from this payment link is for one-time use or can be reused
    This is applicable for card and SEPA Direct Debit payment methods only.
    If not specified, the default value is OneOff. */
        sequence?: ValueTypes['PaymentMandateSequence'] | undefined | null | Variable<any, string>;
        /** Any string that you want to be attached to this payment link.
    Usually something to help you reference the link in an external system. */
        externalReference?: string | undefined | null | Variable<any, string>;
        /** Optional field intended to provide a way for you to include a reference number or code.
    The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different. */
        reference?: string | undefined | null | Variable<any, string>;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page. */
        label?: string | undefined | null | Variable<any, string>;
        /** The language used for the payment page.
    Default is the browser's language, or English if not available. */
        language?: ValueTypes['Language'] | undefined | null | Variable<any, string>;
        /** We will use the information specified here to prefill the payment link fields
    depending on the payment method the end user chooses.
    Keep in mind that your end customer will be able to edit these fields. */
        customer?: ValueTypes['CustomerInput'] | undefined | null | Variable<any, string>;
        /** List of payment methods enabled for this payment link.
    If the array is empty, Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit)
    If you want to make payment possible via SEPA Direct Debit, the list should be populated either by a SEPA Direct Debit CORE or B2B. */
        paymentMethodIds?: Array<string> | undefined | null | Variable<any, string>;
    };
    ['CreateMerchantPaymentLinkPayload']: AliasType<{
        ['...on CreateMerchantPaymentLinkSuccessPayload']: ValueTypes['CreateMerchantPaymentLinkSuccessPayload'];
        ['...on MerchantProfileWrongStatusRejection']: ValueTypes['MerchantProfileWrongStatusRejection'];
        ['...on MerchantPaymentMethodNotActiveRejection']: ValueTypes['MerchantPaymentMethodNotActiveRejection'];
        ['...on PaymentMethodNotCompatibleRejection']: ValueTypes['PaymentMethodNotCompatibleRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CreateMerchantPaymentLinkSuccessPayload']: AliasType<{
        merchantPaymentLink?: ValueTypes['MerchantPaymentLink'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input of the `createMultiConsent` mutation */
    ['CreateMultiConsentInput']: {
        /** A list of consent IDs with their related execution orders */
        orderedConsentIds: Array<ValueTypes['ConsentIdWithOrder']> | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        redirectUrl: string | Variable<any, string>;
    };
    /** Payload of the `createMultiConsent` mutation */
    ['CreateMultiConsentPayload']: AliasType<{
        ['...on CreateMultiConsentSuccessPayload']: ValueTypes['CreateMultiConsentSuccessPayload'];
        ['...on ConsentsNotAllInCreatedStatusRejection']: ValueTypes['ConsentsNotAllInCreatedStatusRejection'];
        ['...on ConsentsNotFoundRejection']: ValueTypes['ConsentsNotFoundRejection'];
        ['...on TooManyChildConsentsRejection']: ValueTypes['TooManyChildConsentsRejection'];
        ['...on ConsentsAlreadyLinkedToMultiConsentRejection']: ValueTypes['ConsentsAlreadyLinkedToMultiConsentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Success payload of the `createMultiConsent` mutation */
    ['CreateMultiConsentSuccessPayload']: AliasType<{
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Credit transfer */
    ['CreditTransferInput']: {
        /** if the transfer will credit a beneficiary already created */
        beneficiaryId?: string | undefined | null | Variable<any, string>;
        /** if the transfer will credit a new swan account beneficiary */
        swanAccountBeneficiary?: ValueTypes['SwanAccountBeneficiaryInput'] | undefined | null | Variable<any, string>;
        /** if the transfer will credit a new SEPA beneficiary */
        sepaBeneficiary?: ValueTypes['SepaBeneficiaryInput'] | undefined | null | Variable<any, string>;
        /** amount of the transfer */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined | null | Variable<any, string>;
        /** label (max 140 characters) */
        label?: string | undefined | null | Variable<any, string>;
        /** requested date at which the credit transfer will try to be executed, if `null` the credit transfer is executed right away */
        requestedExecutionAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** an arbitrary identifier that you can define to easily identify this transaction later */
        externalReference?: string | undefined | null | Variable<any, string>;
        /** if the transfer will execute as instant and fallbacked to a regular one if an error happend during the instant transfer */
        mode?: ValueTypes['CreditTransferMode'] | undefined | null | Variable<any, string>;
    };
    ['CreditTransferMode']: CreditTransferMode;
    /** Custom information for a CSV statement */
    ['CsvStatement']: AliasType<{
        /** statement type */
        type?: boolean | `@${string}`;
        /** temporary public url on which the file can be accessed */
        url?: boolean | `@${string}`;
        /** date at which the link will not be useable anymore */
        expiresAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** currency code alpha 3 (ISO 4217) */
    ['Currency']: unknown;
    ['Customer']: AliasType<{
        /** A customer id present in a third-party system.
    Alows to link a customer to a payment link and by extension, to a Merchant Payment. */
        externalCustomerId?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        iban?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CustomerInput']: {
        /** A customer ID present in a third-party system.
    Alows to link a customer to a payment link and by extension, to a merchant payment. */
        externalCustomerId?: string | undefined | null | Variable<any, string>;
        /** Customer name */
        name?: string | undefined | null | Variable<any, string>;
        /** Customer IBAN */
        iban?: string | undefined | null | Variable<any, string>;
    };
    /** Date with YYYY-MM-DD format */
    ['Date']: unknown;
    ['DateField']: AliasType<{
        example?: boolean | `@${string}`;
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        validationRegex?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Date time (ISO 8601 with time information)
  ex: 2021-04-12T16:28:22.867Z */
    ['DateTime']: unknown;
    /** Rejection returned when the Debtor is closed */
    ['DebtorAccountClosedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Debtor does not belong to the same project as the creditor */
    ['DebtorAccountNotAllowedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['DeleteSupportingDocumentInput']: {
        /** Id of the supporting document to delete */
        id: string | Variable<any, string>;
    };
    ['DeleteSupportingDocumentPayload']: AliasType<{
        ['...on DeleteSupportingDocumentSuccessPayload']: ValueTypes['DeleteSupportingDocumentSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on SupportingDocumentCollectionNotFoundRejection']: ValueTypes['SupportingDocumentCollectionNotFoundRejection'];
        ['...on SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection']: ValueTypes['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection'];
        ['...on SupportingDocumentNotFoundRejection']: ValueTypes['SupportingDocumentNotFoundRejection'];
        ['...on SupportingDocumentStatusDoesNotAllowDeletionRejection']: ValueTypes['SupportingDocumentStatusDoesNotAllowDeletionRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DeleteSupportingDocumentSuccessPayload']: AliasType<{
        id?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['DenySddInput']: {
        accountId: string | Variable<any, string>;
    };
    ['DenySddPayload']: AliasType<{
        ['...on DenySddSuccessPayload']: ValueTypes['DenySddSuccessPayload'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on InvalidArgumentRejection']: ValueTypes['InvalidArgumentRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DenySddSuccessPayload']: AliasType<{
        account?: ValueTypes['Account'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DenySddVirtualIbanEntryInput']: {
        ibanEntryId: string | Variable<any, string>;
    };
    ['DenySddVirtualIbanEntryPayload']: AliasType<{
        ['...on DenySddVirtualIbanEntrySuccessPayload']: ValueTypes['DenySddVirtualIbanEntrySuccessPayload'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DenySddVirtualIbanEntrySuccessPayload']: AliasType<{
        virtualIbanEntry?: ValueTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Device */
    ['Device']: AliasType<{
        /** The type of device. It can be a Phone, Tablet, Watch */
        type?: boolean | `@${string}`;
        /** Device name
    End user defined name of the device on which the card id provided */
        name?: boolean | `@${string}`;
        /** Secure Element ID */
        SEID?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card used for ApplePay or GooglePay */
    ['DigitalCard']: AliasType<{
        /** Unique identifier of a digital card */
        id?: boolean | `@${string}`;
        /** The type of digitalization that created this digital card. */
        type?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider?: ValueTypes['WalletProvider'];
        ['...on CompleteDigitalCard']?: Omit<ValueTypes['CompleteDigitalCard'], keyof ValueTypes['DigitalCard']>;
        ['...on PendingDigitalCard']?: Omit<ValueTypes['PendingDigitalCard'], keyof ValueTypes['DigitalCard']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card Canceled Status Information */
    ['DigitalCardCanceledStatusInfo']: AliasType<{
        /** Card status (always Canceled for type DigitalCardCanceledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Enable Date */
        enabledAt?: boolean | `@${string}`;
        /** Cancel Date */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['DigitalCardConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** CardEdge list */
        edges?: ValueTypes['DigitalCardEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card ConsentPending Status Information */
    ['DigitalCardConsentPendingStatusInfo']: AliasType<{
        /** Digital Card status (always ConsentPending for type DigitalCardConsentPendingStatusInfo). */
        status?: boolean | `@${string}`;
        /** A reference to the consent to validate */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card Declined Status Information */
    ['DigitalCardDeclinedStatusInfo']: AliasType<{
        /** Digital Card status (always Declined for type DigitalCardDeclinedStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['DigitalCardEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The Card entry */
        node?: ValueTypes['DigitalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card Enabled Status Information */
    ['DigitalCardEnabledStatusInfo']: AliasType<{
        /** Digital Card status (always Enabled for type DigitalCardEnabledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Enable Date */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing digitalCards */
    ['DigitalCardFiltersInput']: {
        /** The id of the digitalCard */
        id?: string | undefined | null | Variable<any, string>;
        /** The status of the digital card. It can be a CompleteDigitalCardStatus or a PendingDigitalCardStatus */
        status?: string | undefined | null | Variable<any, string>;
        /** The Secure Element ID
    Mostly present on APple Devices */
        SEID?: string | undefined | null | Variable<any, string>;
        /** The digital card masker number */
        cardMaskedNumber?: string | undefined | null | Variable<any, string>;
        /** The ID of the wallet provider in the scheme system */
        walletProviderId?: string | undefined | null | Variable<any, string>;
        /** Either ApplePay, GooglePay or Merchant */
        walletProviderName?: string | undefined | null | Variable<any, string>;
        /** The wallet application ID in the user phone */
        walletId?: string | undefined | null | Variable<any, string>;
    };
    /** Rejection returned when the Digital Card does not exist */
    ['DigitalCardNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing digital cards */
    ['DigitalCardOrderByFieldInput']: DigitalCardOrderByFieldInput;
    /** Order that can be applied when listing digital cards */
    ['DigitalCardOrderByInput']: {
        field?: ValueTypes['DigitalCardOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Digital Card Pending Status Information */
    ['DigitalCardPendingStatusInfo']: AliasType<{
        /** Digital Card status (always Pending for type DigitalCardPendingStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card Suspended Status Information */
    ['DigitalCardSuspendedStatusInfo']: AliasType<{
        /** Digital Card status (always Suspended for type DigitalCardSuspendedStatusInfo). */
        status?: boolean | `@${string}`;
        /** Enable Date */
        enabledAt?: boolean | `@${string}`;
        /** Suspend Date */
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Digitalization Type */
    ['DigitalizationType']: DigitalizationType;
    /** Direct Debit Account Verification */
    ['DirectDebitAccountVerification']: AliasType<{
        /** Creation date of the account verification */
        createdAt?: boolean | `@${string}`;
        /** IBAN of the account to cross check with account holder information */
        iban?: boolean | `@${string}`;
        /** Unique identifier of the Account Verification */
        id?: boolean | `@${string}`;
        /** Account Verification Status Information */
        statusInfo?: ValueTypes['AccountVerificationStatusInfo'];
        /** Last update date of the account verification */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source with Direct Debit Mandate */
    ['DirectDebitFundingSource']: AliasType<{
        /** ID of the Funding Source */
        id?: boolean | `@${string}`;
        /** Name of the Funding Source */
        name?: boolean | `@${string}`;
        /** Funding Source status information */
        statusInfo?: ValueTypes['FundingSourceStatusInfo'];
        /** IBAN to use in the direct debit transaction that will be triggered when funding the account.
    Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source */
        iban?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Last updated date */
        updatedAt?: boolean | `@${string}`;
        /** Can be queried to check the status of the account verification for this funding source.
    If the account verification is PendingVerification, you should ask your account holder to wire some money from his external account to any swan account */
        accountVerification?: ValueTypes['DirectDebitAccountVerification'];
        /** Can be queried to check the status of payment payment Mandate.
    If the payment mandate is ConsentPending, you should confirm it to enable this funding source */
        paymentMandate?: ValueTypes['PaymentDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DirectDebitSequence']: DirectDebitSequence;
    /** Input to disable an account membership */
    ['DisableAccountMembershipInput']: {
        /** Unique identifier of the account membership to disable */
        accountMembershipId: string | Variable<any, string>;
    };
    ['DisableAccountMembershipPayload']: AliasType<{
        ['...on DisableAccountMembershipSuccessPayload']: ValueTypes['DisableAccountMembershipSuccessPayload'];
        ['...on AccountMembershipCannotBeDisabledRejection']: ValueTypes['AccountMembershipCannotBeDisabledRejection'];
        ['...on AccountMembershipNotFoundRejection']: ValueTypes['AccountMembershipNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on LegalRepresentativeAccountMembershipCannotBeDisabledRejection']: ValueTypes['LegalRepresentativeAccountMembershipCannotBeDisabledRejection'];
        ['...on UserNotAllowedToDisableItsOwnAccountMembershipRejection']: ValueTypes['UserNotAllowedToDisableItsOwnAccountMembershipRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DisableAccountMembershipSuccessPayload']: AliasType<{
        accountMembership?: ValueTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings has been disabled */
    ['DisabledFundingLimitSettingsStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** EnabledMerchantPaymentMethodStatusInfo */
    ['DisabledMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method disabled date */
        disabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Retrieved document extracted from the identity verification */
    ['DocumentFile']: AliasType<{
        downloadUrl?: boolean | `@${string}`;
        ['...on DriversLicenseDocumentFile']?: Omit<ValueTypes['DriversLicenseDocumentFile'], keyof ValueTypes['DocumentFile']>;
        ['...on IdCardDocumentFile']?: Omit<ValueTypes['IdCardDocumentFile'], keyof ValueTypes['DocumentFile']>;
        ['...on PassportDocumentFile']?: Omit<ValueTypes['PassportDocumentFile'], keyof ValueTypes['DocumentFile']>;
        ['...on ReportDocumentFile']?: Omit<ValueTypes['ReportDocumentFile'], keyof ValueTypes['DocumentFile']>;
        ['...on ResidencePermitDocumentFile']?: Omit<ValueTypes['ResidencePermitDocumentFile'], keyof ValueTypes['DocumentFile']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** From which side the document picture was taken */
    ['DocumentFileSide']: DocumentFileSide;
    /** Reason code of the document. */
    ['DocumentReasonCode']: DocumentReasonCode;
    /** The type of the document */
    ['DocumentType']: DocumentType;
    /** The document corresponding to a driver's license */
    ['DriversLicenseDocument']: AliasType<{
        /** Unique identifier of the driver's license document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ValueTypes['DriversLicenseDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the driver's license document */
    ['DriversLicenseDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        /** From which side the deiver's license's picture was taken */
        side?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Edge type containing the node and cursor. The node is not defined in the interface because generic is not supported by GraphQL
  but all implementation contains its own node property according to the paginated type. */
    ['Edge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        ['...on AccountEdge']?: Omit<ValueTypes['AccountEdge'], keyof ValueTypes['Edge']>;
        ['...on AccountHolderEdge']?: Omit<ValueTypes['AccountHolderEdge'], keyof ValueTypes['Edge']>;
        ['...on AccountMembershipEdge']?: Omit<ValueTypes['AccountMembershipEdge'], keyof ValueTypes['Edge']>;
        ['...on CapitalDepositCaseEdge']?: Omit<ValueTypes['CapitalDepositCaseEdge'], keyof ValueTypes['Edge']>;
        ['...on CardEdge']?: Omit<ValueTypes['CardEdge'], keyof ValueTypes['Edge']>;
        ['...on ConsentEdge']?: Omit<ValueTypes['ConsentEdge'], keyof ValueTypes['Edge']>;
        ['...on DigitalCardEdge']?: Omit<ValueTypes['DigitalCardEdge'], keyof ValueTypes['Edge']>;
        ['...on ExternalAccountEdge']?: Omit<ValueTypes['ExternalAccountEdge'], keyof ValueTypes['Edge']>;
        ['...on ExternalBalanceEdge']?: Omit<ValueTypes['ExternalBalanceEdge'], keyof ValueTypes['Edge']>;
        ['...on FundingLimitSettingsChangeRequestEdge']?: Omit<ValueTypes['FundingLimitSettingsChangeRequestEdge'], keyof ValueTypes['Edge']>;
        ['...on FundingSourceEdge']?: Omit<ValueTypes['FundingSourceEdge'], keyof ValueTypes['Edge']>;
        ['...on IdentificationEdge']?: Omit<ValueTypes['IdentificationEdge'], keyof ValueTypes['Edge']>;
        ['...on InvoiceEdge']?: Omit<ValueTypes['InvoiceEdge'], keyof ValueTypes['Edge']>;
        ['...on LegalDocumentEdge']?: Omit<ValueTypes['LegalDocumentEdge'], keyof ValueTypes['Edge']>;
        ['...on MerchantProfileEdge']?: Omit<ValueTypes['MerchantProfileEdge'], keyof ValueTypes['Edge']>;
        ['...on OnboardingEdge']?: Omit<ValueTypes['OnboardingEdge'], keyof ValueTypes['Edge']>;
        ['...on PaymentEdge']?: Omit<ValueTypes['PaymentEdge'], keyof ValueTypes['Edge']>;
        ['...on PaymentMandateEdge']?: Omit<ValueTypes['PaymentMandateEdge'], keyof ValueTypes['Edge']>;
        ['...on ReceivedDirectDebitMandateEdge']?: Omit<ValueTypes['ReceivedDirectDebitMandateEdge'], keyof ValueTypes['Edge']>;
        ['...on StandingOrderEdge']?: Omit<ValueTypes['StandingOrderEdge'], keyof ValueTypes['Edge']>;
        ['...on StatementEdge']?: Omit<ValueTypes['StatementEdge'], keyof ValueTypes['Edge']>;
        ['...on SupportingDocumentCollectionEdge']?: Omit<ValueTypes['SupportingDocumentCollectionEdge'], keyof ValueTypes['Edge']>;
        ['...on TransactionEdge']?: Omit<ValueTypes['TransactionEdge'], keyof ValueTypes['Edge']>;
        ['...on TrustedBeneficiaryEdge']?: Omit<ValueTypes['TrustedBeneficiaryEdge'], keyof ValueTypes['Edge']>;
        ['...on UserEdge']?: Omit<ValueTypes['UserEdge'], keyof ValueTypes['Edge']>;
        ['...on VirtualIBANEntryEdge']?: Omit<ValueTypes['VirtualIBANEntryEdge'], keyof ValueTypes['Edge']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['EmailAddress']: unknown;
    /** Employment status. */
    ['EmploymentStatus']: EmploymentStatus;
    /** Rejection returned if the card product don't have a card design enabled */
    ['EnabledCardDesignNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when the funding limit settings is enabled */
    ['EnabledFundingLimitSettingsStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source Enabled status information */
    ['EnabledFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Enabled status */
        status?: boolean | `@${string}`;
        /** Date at which the funding source was enabled */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** EnabledMerchantPaymentMethodStatusInfo */
    ['EnabledMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method enabled date */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** EnabledMerchantProfileStatusInfo */
    ['EnabledMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to enable a received direct debit mandate, i.e. to move its status back from suspended. */
    ['EnableReceivedDirectDebitMandateInput']: {
        /** The received direct debit id to enable */
        receivedDirectDebitMandateId: string | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl?: string | undefined | null | Variable<any, string>;
    };
    /** Union type return by the enableReceivedDirectDebitMandate mutation */
    ['EnableReceivedDirectDebitMandatePayload']: AliasType<{
        ['...on EnableReceivedDirectDebitMandateSuccessPayload']: ValueTypes['EnableReceivedDirectDebitMandateSuccessPayload'];
        ['...on ReceivedDirectDebitMandateNotFoundRejection']: ValueTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ['...on ReceivedDirectDebitMandateCanceledRejection']: ValueTypes['ReceivedDirectDebitMandateCanceledRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the enableReceivedDirectDebitMandate mutation */
    ['EnableReceivedDirectDebitMandateSuccessPayload']: AliasType<{
        /** The received direct debit mandate is enable, i.e that it is moved back to from the suspended to the enabled status */
        receivedDirectDebitMandate?: ValueTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    ['EnvType']: EnvType;
    /** Describes an identification level for the process associated to this identification that has expired and is no longer considered valid */
    ['ExpiredIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Expired` */
        status?: boolean | `@${string}`;
        /** When this identification level expired */
        expiredAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExpiredMerchantPaymentLinkStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** The date when the payment link expired.
    By default the payment link expires 120 days after it was created. */
        expiredAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccount']: AliasType<{
        /** Unique identifier of an external account */
        id?: boolean | `@${string}`;
        /** External account identifier following ISO-20022 standard */
        externalId?: boolean | `@${string}`;
        /** Name of the account */
        name?: boolean | `@${string}`;
        /** Type of the account */
        cashAccountType?: boolean | `@${string}`;
        /** Bank Identifier Code */
        BIC?: boolean | `@${string}`;
        /** International Bank Account Number */
        IBAN?: boolean | `@${string}`;
        /** Currency */
        currency?: boolean | `@${string}`;
        /** Account Holder name */
        holderName?: boolean | `@${string}`;
        /** Country */
        country?: boolean | `@${string}`;
        /** Original Created date */
        originalCreatedAt?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        balances?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>;
            },
            ValueTypes['ExternalBalanceConnection']
        ];
        /** Source used for this account */
        source?: ValueTypes['ExternalAccountDataSource'];
        /** Financial institution */
        institution?: ValueTypes['FinancialInstitution'];
        /** Usage information of the account */
        usage?: boolean | `@${string}`;
        /** Account holder for the external account */
        accountHolder?: ValueTypes['AccountHolder'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountAlreadyExistsRejection']: AliasType<{
        iban?: boolean | `@${string}`;
        accountHolderId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountBalance']: AliasType<{
        /** Unique identifier of an external balance */
        id?: boolean | `@${string}`;
        /** Amount with currency */
        amount?: ValueTypes['Amount'];
        /** Type of Balance */
        type?: boolean | `@${string}`;
        /** Last changed Date */
        lastChangedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountBalanceAlreadyExistsRejection']: AliasType<{
        type?: boolean | `@${string}`;
        lastChangedAt?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountBalanceInput']: {
        /** Amount with currency */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Type of Balance */
        type: ValueTypes['ExternalAccountBalanceType'] | Variable<any, string>;
        /** Last changed Date */
        lastChangedAt: ValueTypes['DateTime'] | Variable<any, string>;
    };
    ['ExternalAccountBalanceType']: ExternalAccountBalanceType;
    /** Implements the Relay Connection interface, used to paginate the list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ExternalAccountConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** ExternalAccountEdge list */
        edges?: ValueTypes['ExternalAccountEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountDataSource']: AliasType<{
        type?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountDataSourceType']: ExternalAccountDataSourceType;
    /** Implements the Relay Edge interface */
    ['ExternalAccountEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The external account */
        node?: ValueTypes['ExternalAccount'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountUsage']: ExternalAccountUsage;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ExternalBalanceConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** ExternalBalanceEdge list */
        edges?: ValueTypes['ExternalBalanceEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['ExternalBalanceEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The external balance */
        node?: ValueTypes['ExternalAccountBalance'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to a face photo */
    ['FacePhotoDocument']: AliasType<{
        /** Unique identifier of the face photo document. For privacy reasons, no temporary download url is exposed for this document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee creditor */
    ['FeeCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        ['...on FeeInCreditor']?: Omit<ValueTypes['FeeInCreditor'], keyof ValueTypes['FeeCreditor']>;
        ['...on FeeOutCreditor']?: Omit<ValueTypes['FeeOutCreditor'], keyof ValueTypes['FeeCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['FeeDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        ['...on FeeInDebtor']?: Omit<ValueTypes['FeeInDebtor'], keyof ValueTypes['FeeDebtor']>;
        ['...on FeeOutDebtor']?: Omit<ValueTypes['FeeOutDebtor'], keyof ValueTypes['FeeDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee creditor for Incoming transaction */
    ['FeeInCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee debtor for Incoming transaction */
    ['FeeInDebtor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee creditor for Outgoing transaction */
    ['FeeOutCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee debtor for Outgoing transaction */
    ['FeeOutDebtor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['FeeSettingsNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fees type */
    ['FeesTypeEnum']: FeesTypeEnum;
    /** Fee Transaction */
    ['FeeTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ValueTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** feesType */
        feesType?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ValueTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ValueTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ValueTypes['FeeCreditor'];
        /** debtor information */
        debtor?: ValueTypes['FeeDebtor'];
        /** matching account for the transaction */
        account?: ValueTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ValueTypes['Transaction'];
        __typename?: boolean | `@${string}`;
    }>;
    ['Field']: AliasType<{
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        ['...on DateField']?: Omit<ValueTypes['DateField'], keyof ValueTypes['Field']>;
        ['...on RadioField']?: Omit<ValueTypes['RadioField'], keyof ValueTypes['Field']>;
        ['...on SelectField']?: Omit<ValueTypes['SelectField'], keyof ValueTypes['Field']>;
        ['...on TextField']?: Omit<ValueTypes['TextField'], keyof ValueTypes['Field']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['FieldValidationError']: FieldValidationError;
    ['FinalizeOnboardingInput']: {
        onboardingId: string | Variable<any, string>;
    };
    ['FinalizeOnboardingPayload']: AliasType<{
        ['...on FinalizeOnboardingSuccessPayload']: ValueTypes['FinalizeOnboardingSuccessPayload'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on OnboardingNotCompletedRejection']: ValueTypes['OnboardingNotCompletedRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['FinalizeOnboardingSuccessPayload']: AliasType<{
        onboarding?: ValueTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    ['FinancialInstitution']: AliasType<{
        id?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        country?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['FnciInfo']: AliasType<{
        colorCode?: boolean | `@${string}`;
        cpt1?: boolean | `@${string}`;
        cpt2?: boolean | `@${string}`;
        cpt3?: boolean | `@${string}`;
        holderEstablishment?: boolean | `@${string}`;
        responseCode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ForbiddenRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['FundingLimit']: AliasType<{
        /** Maximum Funding Amount authorized */
        amount?: ValueTypes['Amount'];
        /** Funding Amount that has already been used during the interval */
        funding?: ValueTypes['Amount'];
        /** Interval in number of calendar days where the limit is applied */
        rollingDays?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Amount */
    ['FundingLimitAmount']: AliasType<{
        /** The amount settings */
        amount?: ValueTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Amount Input */
    ['FundingLimitAmountInput']: {
        /** The amount settings */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
    };
    /** Rejection returned when the Account Holder Funding has been exceeded */
    ['FundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['FundingLimitSettings']: AliasType<{
        /** Instant funding limit */
        instantFundingLimit?: ValueTypes['InstantFundingLimit'];
        /** Periodic funding limit */
        fundingLimit?: ValueTypes['FundingLimit'];
        /** Related change request */
        fundingLimitSettingsChangeRequest?: ValueTypes['FundingLimitSettingsChangeRequest'];
        /** Status of the resource */
        statusInfo?: ValueTypes['FundingLimitSettingsStatusInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Settings Change Request */
    ['FundingLimitSettingsChangeRequest']: AliasType<{
        /** Unique identifier of a funding limit settings change request */
        id?: boolean | `@${string}`;
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit?: ValueTypes['FundingLimitAmount'];
        /** Requested amount settings for the funding limit */
        fundingLimit?: ValueTypes['FundingLimitAmount'];
        /** Approved amount settings for the the instant funding limit and the funding limit */
        approved?: ValueTypes['ApprovedFundingLimit'];
        /** Status of the request */
        statusInfo?: ValueTypes['FundingLimitSettingsChangeRequestStatusInfo'];
        /** Date of creation */
        createdAt?: boolean | `@${string}`;
        /** Date of last update */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings change request has been approved */
    ['FundingLimitSettingsChangeRequestApprovedStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Settings Change Request Bad Amount Rejection */
    ['FundingLimitSettingsChangeRequestBadAmountRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['FundingLimitSettingsChangeRequestConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** FundingLimitSettingsChangeRequestEdge list */
        edges?: ValueTypes['FundingLimitSettingsChangeRequestEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['FundingLimitSettingsChangeRequestEdge']: AliasType<{
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The FundingLimitSettingsChangeRequest */
        node?: ValueTypes['FundingLimitSettingsChangeRequest'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestFiltersInput']: {
        /** The ids of the funding limit settings change requests */
        id?: Array<string> | undefined | null | Variable<any, string>;
        /** Status we want to filter on */
        status?: Array<ValueTypes['FundingLimitSettingsChangeRequestStatus']> | undefined | null | Variable<any, string>;
    };
    /** Field we can use when ordering that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestOrderByFieldInput']: FundingLimitSettingsChangeRequestOrderByFieldInput;
    /** Order that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestOrderByInput']: {
        field?: ValueTypes['FundingLimitSettingsChangeRequestOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** StatusInfo when funding limit settings change request is pending */
    ['FundingLimitSettingsChangeRequestPendingStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings change request has been rejected */
    ['FundingLimitSettingsChangeRequestRefusedStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Settings Change Request Status */
    ['FundingLimitSettingsChangeRequestStatus']: FundingLimitSettingsChangeRequestStatus;
    /** Object containing details about funding limit settings change request status */
    ['FundingLimitSettingsChangeRequestStatusInfo']: AliasType<{
        /** Current limit settings change request status. */
        status?: boolean | `@${string}`;
        ['...on FundingLimitSettingsChangeRequestApprovedStatusInfo']?: Omit<ValueTypes['FundingLimitSettingsChangeRequestApprovedStatusInfo'], keyof ValueTypes['FundingLimitSettingsChangeRequestStatusInfo']>;
        ['...on FundingLimitSettingsChangeRequestPendingStatusInfo']?: Omit<ValueTypes['FundingLimitSettingsChangeRequestPendingStatusInfo'], keyof ValueTypes['FundingLimitSettingsChangeRequestStatusInfo']>;
        ['...on FundingLimitSettingsChangeRequestRefusedStatusInfo']?: Omit<ValueTypes['FundingLimitSettingsChangeRequestRefusedStatusInfo'], keyof ValueTypes['FundingLimitSettingsChangeRequestStatusInfo']>;
        ['...on FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo']?: Omit<ValueTypes['FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo'], keyof ValueTypes['FundingLimitSettingsChangeRequestStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings change request is waiting for more information */
    ['FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Possible values for funding limit settings status */
    ['FundingLimitSettingsStatus']: FundingLimitSettingsStatus;
    /** Object containing details about funding limit settings status */
    ['FundingLimitSettingsStatusInfo']: AliasType<{
        /** Current funding limit settings. */
        status?: boolean | `@${string}`;
        ['...on DisabledFundingLimitSettingsStatusInfo']?: Omit<ValueTypes['DisabledFundingLimitSettingsStatusInfo'], keyof ValueTypes['FundingLimitSettingsStatusInfo']>;
        ['...on EnabledFundingLimitSettingsStatusInfo']?: Omit<ValueTypes['EnabledFundingLimitSettingsStatusInfo'], keyof ValueTypes['FundingLimitSettingsStatusInfo']>;
        ['...on SuspendedFundingLimitSettingsStatusInfo']?: Omit<ValueTypes['SuspendedFundingLimitSettingsStatusInfo'], keyof ValueTypes['FundingLimitSettingsStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source */
    ['FundingSource']: AliasType<{
        /** ID of the Funding Source */
        id?: boolean | `@${string}`;
        /** Name of the Funding Source */
        name?: boolean | `@${string}`;
        /** Funding Source status information */
        statusInfo?: ValueTypes['FundingSourceStatusInfo'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Last updated date */
        updatedAt?: boolean | `@${string}`;
        ['...on DirectDebitFundingSource']?: Omit<ValueTypes['DirectDebitFundingSource'], keyof ValueTypes['FundingSource']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['FundingSourceConnection']: AliasType<{
        pageInfo?: ValueTypes['PageInfo'];
        edges?: ValueTypes['FundingSourceEdge'];
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['FundingSourceEdge']: AliasType<{
        node?: ValueTypes['FundingSource'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing Funding Sources */
    ['FundingSourceFiltersInput']: {
        status: Array<ValueTypes['FundingSourceStatus']> | Variable<any, string>;
    };
    ['FundingSourceNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing funding source results */
    ['FundingSourceOrderByFieldInput']: FundingSourceOrderByFieldInput;
    /** Order that can be applied when listing funding source results */
    ['FundingSourceOrderByInput']: {
        field?: ValueTypes['FundingSourceOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Funding Source Statuses */
    ['FundingSourceStatus']: FundingSourceStatus;
    /** Funding Source status information */
    ['FundingSourceStatusInfo']: AliasType<{
        /** Funding Source Pending status */
        status?: boolean | `@${string}`;
        ['...on CanceledFundingSourceStatusInfo']?: Omit<ValueTypes['CanceledFundingSourceStatusInfo'], keyof ValueTypes['FundingSourceStatusInfo']>;
        ['...on EnabledFundingSourceStatusInfo']?: Omit<ValueTypes['EnabledFundingSourceStatusInfo'], keyof ValueTypes['FundingSourceStatusInfo']>;
        ['...on PendingFundingSourceStatusInfo']?: Omit<ValueTypes['PendingFundingSourceStatusInfo'], keyof ValueTypes['FundingSourceStatusInfo']>;
        ['...on RejectedFundingSourceStatusInfo']?: Omit<ValueTypes['RejectedFundingSourceStatusInfo'], keyof ValueTypes['FundingSourceStatusInfo']>;
        ['...on SuspendedFundingSourceStatusInfo']?: Omit<ValueTypes['SuspendedFundingSourceStatusInfo'], keyof ValueTypes['FundingSourceStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Funding Source is not in the expected status */
    ['FundingSourceWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        expectedStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to generate an account */
    ['GenerateAccountStatementInput']: {
        /** Unique identifier of an account */
        accountId: string | Variable<any, string>;
        /** starting date of the date window */
        openingDate: ValueTypes['DateTime'] | Variable<any, string>;
        /** ending date of the date window */
        closingDate: ValueTypes['DateTime'] | Variable<any, string>;
        /** language to generate the statement in (default to account's language) */
        language?: ValueTypes['AccountLanguage'] | undefined | null | Variable<any, string>;
        /** Type of statement to generate */
        statementType?: ValueTypes['StatementType'] | undefined | null | Variable<any, string>;
    };
    ['GenerateCapitalDepositDocumentUploadUrlInput']: {
        /** Unique identifier of the document. */
        documentId: string | Variable<any, string>;
        /** Unique identifier of the capitalDepositCase associated to the document. */
        capitalDepositCaseId: string | Variable<any, string>;
        /** Filename of the document. */
        filename: string | Variable<any, string>;
    };
    ['GenerateCapitalDepositDocumentUploadUrlPayload']: AliasType<{
        ['...on GenerateCapitalDepositDocumentUploadUrlSuccessPayload']: ValueTypes['GenerateCapitalDepositDocumentUploadUrlSuccessPayload'];
        ['...on CapitalDepositDocumentCanNotBeUploaded']: ValueTypes['CapitalDepositDocumentCanNotBeUploaded'];
        ['...on CapitalDepositDocumentCanNotBeUploadedRejection']: ValueTypes['CapitalDepositDocumentCanNotBeUploadedRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on BadRequestRejection']: ValueTypes['BadRequestRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['GenerateCapitalDepositDocumentUploadUrlSuccessPayload']: AliasType<{
        /** URL to be used to upload the document. */
        uploadUrl?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['GenerateSupportingDocumentUploadUrlInput']: {
        /** Unique identifier of a supporting document collection */
        supportingDocumentCollectionId: string | Variable<any, string>;
        /** Type of document */
        supportingDocumentType?: ValueTypes['SupportingDocumentType'] | undefined | null | Variable<any, string>;
        /** Name of the document which will be sent */
        filename: string | Variable<any, string>;
        /** Purpose of document */
        supportingDocumentPurpose?: ValueTypes['SupportingDocumentPurposeEnum'] | undefined | null | Variable<any, string>;
    };
    ['GenerateSupportingDocumentUploadUrlPayload']: AliasType<{
        ['...on GenerateSupportingDocumentUploadUrlSuccessPayload']: ValueTypes['GenerateSupportingDocumentUploadUrlSuccessPayload'];
        ['...on SupportingDocumentCollectionNotFoundRejection']: ValueTypes['SupportingDocumentCollectionNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on SupportingDocumentUploadNotAllowedRejection']: ValueTypes['SupportingDocumentUploadNotAllowedRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['GenerateSupportingDocumentUploadUrlSuccessPayload']: AliasType<{
        /** Id of the supporting document created for this uploadUrl */
        supportingDocumentId?: boolean | `@${string}`;
        /** Info to upload the document : url and fields to add along file in form (POST) */
        upload?: ValueTypes['SupportingDocumentUploadInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Global Funding has been exceeded */
    ['GlobalFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Global Instant Funding limit has been exceeded */
    ['GlobalInstantFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignatureInput']: {
        /** ID of the consent to grant */
        consentId: string | Variable<any, string>;
        /** Consent challenge signed with server consent credentials */
        signature: string | Variable<any, string>;
    };
    /** Payload of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignaturePayload']: AliasType<{
        ['...on GrantConsentWithServerSignatureSuccessPayload']: ValueTypes['GrantConsentWithServerSignatureSuccessPayload'];
        ['...on ConsentNotFoundRejection']: ValueTypes['ConsentNotFoundRejection'];
        ['...on NotReachableConsentStatusRejection']: ValueTypes['NotReachableConsentStatusRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ConsentTypeNotSupportedByServerConsentRejection']: ValueTypes['ConsentTypeNotSupportedByServerConsentRejection'];
        ['...on ServerConsentNotAllowedForConsentOperationRejection']: ValueTypes['ServerConsentNotAllowedForConsentOperationRejection'];
        ['...on ProjectNotFoundRejection']: ValueTypes['ProjectNotFoundRejection'];
        ['...on ServerConsentNotAllowedForProjectRejection']: ValueTypes['ServerConsentNotAllowedForProjectRejection'];
        ['...on ServerConsentProjectSettingsNotFoundRejection']: ValueTypes['ServerConsentProjectSettingsNotFoundRejection'];
        ['...on ServerConsentProjectCredentialMissingRejection']: ValueTypes['ServerConsentProjectCredentialMissingRejection'];
        ['...on ServerConsentProjectCredentialNotFoundRejection']: ValueTypes['ServerConsentProjectCredentialNotFoundRejection'];
        ['...on ServerConsentCredentialsNotValidOrOutdatedRejection']: ValueTypes['ServerConsentCredentialsNotValidOrOutdatedRejection'];
        ['...on ServerConsentSignatureNotValidRejection']: ValueTypes['ServerConsentSignatureNotValidRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Success payload of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignatureSuccessPayload']: AliasType<{
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['Headquarters']: AliasType<{
        town?: boolean | `@${string}`;
        zipCode?: boolean | `@${string}`;
        address?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['HexColorCode']: unknown;
    /** International Bank Account Number */
    ['IBAN']: unknown;
    /** Rejection returned when the IBAN is not reachable */
    ['IBANNotReachableRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the IBAN is not valid */
    ['IBANNotValidRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Virtual IBAN Status */
    ['IBANStatus']: IBANStatus;
    /** ibanValidation input */
    ['IbanValidationInput']: {
        /** IBAN to validate */
        iban: ValueTypes['IBAN'] | Variable<any, string>;
    };
    ['IbanValidationRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** IbanValidationResult */
    ['IbanValidationResult']: AliasType<{
        ['...on ValidIban']: ValueTypes['ValidIban'];
        ['...on InvalidIban']: ValueTypes['InvalidIban'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to an ID card */
    ['IdCardDocument']: AliasType<{
        /** Unique identifier of the ID card document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** The date at which the ID card was issued */
        issueDate?: boolean | `@${string}`;
        /** The date at which the ID card expires */
        expiryDate?: boolean | `@${string}`;
        /** Machine-readable zone code of the ID card */
        mrz?: boolean | `@${string}`;
        /** Number of the ID card */
        number?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ValueTypes['IdCardDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the ID card document */
    ['IdCardDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        /** From which side the ID card's picture was taken */
        side?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The identification represents an ongoing identification process or its result */
    ['Identification']: AliasType<{
        /** Unique identifier of the identification */
        id?: boolean | `@${string}`;
        /** Creation date of the identification */
        createdAt?: boolean | `@${string}`;
        /** Last update date of the identification */
        updatedAt?: boolean | `@${string}`;
        /** The global status of the identification */
        status?: boolean | `@${string}`;
        /** The process that was used for this identification */
        process?: boolean | `@${string}`;
        /** The status and results associated to the available identification processes */
        levels?: ValueTypes['IdentificationLevelStatusesInfo'];
        /** The available documents related to the identification (id doc, selfie, report...) */
        documents?: ValueTypes['IdentificationDocument'];
        /** The identity document type used for the current identification (passport, id card ...) */
        identityDocumentType?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fields we can use when ordering that can be applied when listing identifications */
    ['IdentificationConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** IdentificationEdge list */
        edges?: ValueTypes['IdentificationEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Union representing all the possible identification document types */
    ['IdentificationDocument']: AliasType<{
        ['...on IdCardDocument']: ValueTypes['IdCardDocument'];
        ['...on PassportDocument']: ValueTypes['PassportDocument'];
        ['...on ResidencePermitDocument']: ValueTypes['ResidencePermitDocument'];
        ['...on DriversLicenseDocument']: ValueTypes['DriversLicenseDocument'];
        ['...on FacePhotoDocument']: ValueTypes['FacePhotoDocument'];
        ['...on ReportDocument']: ValueTypes['ReportDocument'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['IdentificationEdge']: AliasType<{
        /** The identification entry */
        node?: ValueTypes['Identification'];
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filter that can be passed to get the identifications in specific data ranges */
    ['IdentificationFiltersInput']: {
        /** To filter on status values */
        statuses?: Array<ValueTypes['SwanIdentificationStatus']> | undefined | null | Variable<any, string>;
        /** To filter on level values */
        levels?: Array<ValueTypes['IdentificationLevel']> | undefined | null | Variable<any, string>;
        /** To filter on process values */
        processes?: Array<ValueTypes['IdentificationProcess']> | undefined | null | Variable<any, string>;
    };
    /** The various reasons that can lead to an invalid identification level */
    ['IdentificationInvalidReason']: IdentificationInvalidReason;
    /** Possible value for the field IdentificationLevel */
    ['IdentificationLevel']: IdentificationLevel;
    /** User identification levels input payload. */
    ['IdentificationLevelInput']: IdentificationLevelInput;
    /** Identification levels */
    ['IdentificationLevels']: AliasType<{
        PVID?: boolean | `@${string}`;
        QES?: boolean | `@${string}`;
        expert?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The status and results associated to the available identification processes */
    ['IdentificationLevelStatusesInfo']: AliasType<{
        /** The status and results associated to the expert level */
        expert?: ValueTypes['IdentificationLevelStatusInfo'];
        /** The status and results associated to the Qualified Electronic Signature level */
        qes?: ValueTypes['IdentificationLevelStatusInfo'];
        /** The status and results associated to the Remote Identity Verification Service level */
        pvid?: ValueTypes['IdentificationLevelStatusInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Union representing all the possible statuses: not supported, not started, pending, valid, invalid, cancelled, expired
  Each variant contains its relevant data, for example invalid contains a `reason` field, expired contains an `expiredAt` field, valid contains a `documents` field */
    ['IdentificationLevelStatusInfo']: AliasType<{
        ['...on NotSupportedIdentificationLevelStatusInfo']: ValueTypes['NotSupportedIdentificationLevelStatusInfo'];
        ['...on NotStartedIdentificationLevelStatusInfo']: ValueTypes['NotStartedIdentificationLevelStatusInfo'];
        ['...on StartedIdentificationLevelStatusInfo']: ValueTypes['StartedIdentificationLevelStatusInfo'];
        ['...on PendingIdentificationLevelStatusInfo']: ValueTypes['PendingIdentificationLevelStatusInfo'];
        ['...on ValidIdentificationLevelStatusInfo']: ValueTypes['ValidIdentificationLevelStatusInfo'];
        ['...on InvalidIdentificationLevelStatusInfo']: ValueTypes['InvalidIdentificationLevelStatusInfo'];
        ['...on CanceledIdentificationLevelStatusInfo']: ValueTypes['CanceledIdentificationLevelStatusInfo'];
        ['...on ExpiredIdentificationLevelStatusInfo']: ValueTypes['ExpiredIdentificationLevelStatusInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Process of the identification */
    ['IdentificationProcess']: IdentificationProcess;
    /** Fields we can use when ordering that can be applied when listing identifications */
    ['IdentificationsOrderByField']: IdentificationsOrderByField;
    /** Order that can be applied when listing identifications */
    ['IdentificationsOrderByInput']: {
        /** The field by which the Identification list should be ordered */
        field?: ValueTypes['IdentificationsOrderByField'] | undefined | null | Variable<any, string>;
        /** The order in which the Identification list should be ordered */
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Identification status */
    ['IdentificationStatus']: IdentificationStatus;
    /** Rejection returned if identity and the account memberships are already bind */
    ['IdentityAlreadyBindToAccountMembershipRejection']: AliasType<{
        accountId?: boolean | `@${string}`;
        identityId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The type of the identity document */
    ['IdentityDocumentType']: IdentityDocumentType;
    /** Data used for in app provisioning */
    ['InAppProvisioningData']: AliasType<{
        /** Cryptographic OTP used to pre-validate digitalization */
        activationData?: boolean | `@${string}`;
        /** Base64 public key used with the wallet provider public key to encrypt the card data */
        ephemeralPublicKey?: boolean | `@${string}`;
        /** Encrypted card data */
        encryptedData?: boolean | `@${string}`;
        /** IV used to encrypt the card Data (Useful for Google Pay) */
        iv?: boolean | `@${string}`;
        /** public key fingerprint of the key used to encrypt card data (Useful for Google Pay) */
        publicKeyFingerprint?: boolean | `@${string}`;
        /** hash algorithm used during encryption of the card data (Useful for Google Pay) */
        oaepHashingAlgorithm?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual shareholder info. */
    ['IndividualShareholder']: AliasType<{
        /** Whether the shareholder is an individual or a company. */
        type?: boolean | `@${string}`;
        /** First name of the shareholder. */
        firstName?: boolean | `@${string}`;
        /** Last name of the shareholder. */
        lastName?: boolean | `@${string}`;
        /** Birth date of the shareholder. */
        birthDate?: boolean | `@${string}`;
        /** CCA3 code for the country of nationality of the shareholder. */
        nationality?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual Ultimate Beneficial Owner
  You need to describe the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company.
  Please describe the company (s) that owns the company that wishes to open an account, when an individual holds in fine more than 25% */
    ['IndividualUltimateBeneficialOwner']: AliasType<{
        /** individual first name */
        firstName?: boolean | `@${string}`;
        /** individual last name */
        lastName?: boolean | `@${string}`;
        /** individual birth date */
        birthDate?: boolean | `@${string}`;
        /** individual birth city */
        birthCity?: boolean | `@${string}`;
        /** individual birth city postal code */
        birthCityPostalCode?: boolean | `@${string}`;
        /** individual birth country code */
        birthCountryCode?: boolean | `@${string}`;
        /** Information relating to the type of the UBO */
        info?: ValueTypes['IndividualUltimateBeneficialOwnerInfo'];
        /** Individual beneficial owner Tax or Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        /** Individual beneficial owner residency Address */
        residencyAddress?: ValueTypes['AddressInformation'];
        /** Individual beneficial owner title (Mr/Ms) */
        title?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Define the type of the UBO */
    ['IndividualUltimateBeneficialOwnerInfo']: AliasType<{
        /** Individual type */
        type?: boolean | `@${string}`;
        ['...on IndividualUltimateBeneficialOwnerTypeHasCapital']?: Omit<ValueTypes['IndividualUltimateBeneficialOwnerTypeHasCapital'], keyof ValueTypes['IndividualUltimateBeneficialOwnerInfo']>;
        ['...on IndividualUltimateBeneficialOwnerTypeLegalRepresentative']?: Omit<ValueTypes['IndividualUltimateBeneficialOwnerTypeLegalRepresentative'], keyof ValueTypes['IndividualUltimateBeneficialOwnerInfo']>;
        ['...on IndividualUltimateBeneficialOwnerTypeOther']?: Omit<ValueTypes['IndividualUltimateBeneficialOwnerTypeOther'], keyof ValueTypes['IndividualUltimateBeneficialOwnerInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['IndividualUltimateBeneficialOwnerInput']: {
        /** Individual beneficial owner first name. Length must be from 0 to 100 characters */
        firstName?: string | undefined | null | Variable<any, string>;
        /** Individual beneficial owner last name. Length must be from 0 to 100 characters */
        lastName?: string | undefined | null | Variable<any, string>;
        /** Individual birth date. Must be a valid date in the YYYY/MM/DD format */
        birthDate?: string | undefined | null | Variable<any, string>;
        /** Individual birth city. Length must be from 0 to 100 characters */
        birthCity?: string | undefined | null | Variable<any, string>;
        /** Individual birth city postal code. Length must be from 0 to 50 characters */
        birthCityPostalCode?: string | undefined | null | Variable<any, string>;
        /** Individual birth country code */
        birthCountryCode?: ValueTypes['CCA3'] | undefined | null | Variable<any, string>;
        /** Define UBO is an Indirect Owner */
        indirect?: boolean | undefined | null | Variable<any, string>;
        /** Define UBO is a Direct Owner */
        direct?: boolean | undefined | null | Variable<any, string>;
        /** Total of capital (in percentage, ex: 50 = 50%). Must be between 1 and 100. */
        totalCapitalPercentage?: number | undefined | null | Variable<any, string>;
        /** Define UBO is a Legal Representative */
        type: ValueTypes['IndividualUltimateBeneficialOwnerTypeEnum'] | Variable<any, string>;
        /** Individual beneficial owner Tax or Identification Number */
        taxIdentificationNumber?: string | undefined | null | Variable<any, string>;
        /** Individual beneficial owner residency address */
        residencyAddress?: ValueTypes['AddressInformationInput'] | undefined | null | Variable<any, string>;
        /** Individual ultimate beneficial owner title (Mr/Ms) */
        title?: ValueTypes['TitleEnum'] | undefined | null | Variable<any, string>;
    };
    /** Individual Ultimate beneficial owner nature */
    ['IndividualUltimateBeneficialOwnerTypeEnum']: IndividualUltimateBeneficialOwnerTypeEnum;
    /** Individual Ultimate Beneficial Owner Type Has Capital */
    ['IndividualUltimateBeneficialOwnerTypeHasCapital']: AliasType<{
        /** Individual type */
        type?: boolean | `@${string}`;
        /** Define UBO is an Indirect Owner */
        indirect?: boolean | `@${string}`;
        /** Define UBO is an Direct Owner */
        direct?: boolean | `@${string}`;
        /** Total of capital (in percentage, ex: 50 = 50%) */
        totalCapitalPercentage?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual Ultimate Beneficial Owner Type Legal Representative */
    ['IndividualUltimateBeneficialOwnerTypeLegalRepresentative']: AliasType<{
        /** Individual type */
        type?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual Ultimate Beneficial Owner Type Other */
    ['IndividualUltimateBeneficialOwnerTypeOther']: AliasType<{
        /** Individual type */
        type?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateCheckMerchantPaymentInput']: {
        /** Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€. */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement.
    If empty, default label will be set as "Check N° [1st 7 characters of CMC7] */
        label?: string | undefined | null | Variable<any, string>;
        /** End-to-end reference of the concerned payment collection. */
        reference?: string | undefined | null | Variable<any, string>;
        /** ID of the merchant profile associated to the Swan creditor account. */
        merchantProfileId: string | Variable<any, string>;
        /** 31-character unique identifier located at the bottom of the check.
    CMC7 is composed of 3 sections (check number (7 characters), check issuing bank code (12 characters), check holder account number (12 characters)).
    Combined with RLMC key, it  allows the check to be traced. */
        cmc7: string | Variable<any, string>;
        /** 2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
    Combined with CMC7 line, it allows the check to be traced. */
        rlmcKey: string | Variable<any, string>;
    };
    ['InitiateCheckMerchantPaymentPayload']: AliasType<{
        ['...on InitiateCheckMerchantPaymentSuccessPayload']: ValueTypes['InitiateCheckMerchantPaymentSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: ValueTypes['NotFoundRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        ['...on CheckRejection']: ValueTypes['CheckRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateCheckMerchantPaymentSuccessPayload']: AliasType<{
        merchantPayment?: ValueTypes['Payment'];
        /** Details of the FNCI (Fichier national des chèques irréguliers) response */
        fnciInfo?: ValueTypes['FnciInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Initiate credit transfers */
    ['InitiateCreditTransfersInput']: {
        /** account to be debited identified by number */
        accountNumber?: ValueTypes['AccountNumber'] | undefined | null | Variable<any, string>;
        /** account id to be debited identified by id */
        accountId?: string | undefined | null | Variable<any, string>;
        /** credit transfers (max 2500 records) */
        creditTransfers: Array<ValueTypes['CreditTransferInput']> | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    ['InitiateCreditTransfersPayload']: AliasType<{
        ['...on InitiateCreditTransfersSuccessPayload']: ValueTypes['InitiateCreditTransfersSuccessPayload'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateCreditTransfersSuccessPayload']: AliasType<{
        payment?: ValueTypes['Payment'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to initiate a funding request */
    ['InitiateFundingRequestInput']: {
        /** ID of the funding source to be used to fund the concerned account */
        fundingSourceId: string | Variable<any, string>;
        /** Amount of the requested funding, i.e. amount that will credit the concerned Swan account and debit the external funding source. */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Reference of the funding request that will be shown on the account holder statement and on the debtor account used. */
        reference?: string | undefined | null | Variable<any, string>;
        /** Label of the funding request that will be shown on the account holder statement and on the debtor account used
    Always starts with 'Partner Name' truncated at 19 characters followed by a space.
    If empty, default label is "Partner Name - Account Holder Name". */
        label?: string | undefined | null | Variable<any, string>;
        /** Url to which the authorized account member must be redirected once the consent has been finalized. */
        consentRedirectUrl: string | Variable<any, string>;
        /** When the funding request should be executed. If `null`, it will be executed as soon as possible.
    It is not possible to define this value when the option `isInstant` is set to true. */
        requestedExecutionAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** *SOON TO BE DEPRECATED*
    If `true` the funds should be available immediately. If `false` or `null`, the funds will be available
    after the resolution of the credit transaction. */
        isInstant?: boolean | undefined | null | Variable<any, string>;
    };
    /** Initiate A Funding Request Payload */
    ['InitiateFundingRequestPayload']: AliasType<{
        ['...on InitiateFundingRequestSuccessPayload']: ValueTypes['InitiateFundingRequestSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        ['...on FundingLimitExceededRejection']: ValueTypes['FundingLimitExceededRejection'];
        ['...on ProjectFundingLimitExceededRejection']: ValueTypes['ProjectFundingLimitExceededRejection'];
        ['...on GlobalFundingLimitExceededRejection']: ValueTypes['GlobalFundingLimitExceededRejection'];
        ['...on FundingSourceWrongStatusRejection']: ValueTypes['FundingSourceWrongStatusRejection'];
        ['...on FundingSourceNotFoundRejection']: ValueTypes['FundingSourceNotFoundRejection'];
        ['...on InsufficientFundsRejection']: ValueTypes['InsufficientFundsRejection'];
        ['...on InstantFundingLimitExceededRejection']: ValueTypes['InstantFundingLimitExceededRejection'];
        ['...on ProjectInstantFundingLimitExceededRejection']: ValueTypes['ProjectInstantFundingLimitExceededRejection'];
        ['...on GlobalInstantFundingLimitExceededRejection']: ValueTypes['GlobalInstantFundingLimitExceededRejection'];
        ['...on AccountVerificationWrongStatusRejection']: ValueTypes['AccountVerificationWrongStatusRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Initiate A Funding Request Success Payload */
    ['InitiateFundingRequestSuccessPayload']: AliasType<{
        /** Details of the funding payment created */
        payment?: ValueTypes['Payment'];
        __typename?: boolean | `@${string}`;
    }>;
    /** *COMING SOON*
  Input to create a quote and an international beneficiary */
    ['InitiateInternationalCreditTransferInput']: {
        /** Account ID of the originator of the international credit transfer */
        accountId?: string | undefined | null | Variable<any, string>;
        /** Account number if the beneficiary is a swan account */
        accountNumber?: ValueTypes['AccountNumber'] | undefined | null | Variable<any, string>;
        /** Target amount of the international credit transfer */
        targetAmount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Beneficiary of the international credit transfer */
        internationalBeneficiary: ValueTypes['InternationalBeneficiaryInput'] | Variable<any, string>;
        /** Transfer details */
        internationalCreditTransferDetails: Array<ValueTypes['InternationalCreditTransferDetailsInput']> | Variable<any, string>;
        /** When the consent flow is finished the user is redirected to this URL */
        consentRedirectUrl: string | Variable<any, string>;
        /** External reference */
        externalReference?: string | undefined | null | Variable<any, string>;
        /** Language used to output errors */
        language?: ValueTypes['InternationalCreditTransferDisplayLanguage'] | undefined | null | Variable<any, string>;
    };
    /** Initiate International Credit Transfer Response Payload */
    ['InitiateInternationalCreditTransferResponsePayload']: AliasType<{
        ['...on InitiateInternationalCreditTransferResponseSuccessPayload']: ValueTypes['InitiateInternationalCreditTransferResponseSuccessPayload'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Initiate International Credit Transfer Response Success Payload */
    ['InitiateInternationalCreditTransferResponseSuccessPayload']: AliasType<{
        /** Details of the international credit transfer created */
        payment?: ValueTypes['Payment'];
        /** Details for the quote of international credit transfer */
        quote?: ValueTypes['InternationalCreditTransferQuote'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateMerchantPaymentCollectionInput']: {
        /** Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€. */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement -
    For checks transaction, if empty, default label will be set as "Check N° [1st part of CMC7 - 7 char.] */
        label?: string | undefined | null | Variable<any, string>;
        /** end-to-end reference of the concerned payment collection */
        reference?: string | undefined | null | Variable<any, string>;
        /** external reference (JSON) that can be used by the Swan merchant for reconciliation purposes */
        externalReference?: string | undefined | null | Variable<any, string>;
        /** Internal direct debit type of payment collection */
        internalDirectDebit?: ValueTypes['InternalDirectDebitPaymentCollectionInput'] | undefined | null | Variable<any, string>;
        /** Sepa Direct Debit type of payment collection */
        sepaDirectDebit?: ValueTypes['SepaDirectDebitPaymentCollectionInput'] | undefined | null | Variable<any, string>;
    };
    ['InitiateMerchantPaymentCollectionPayload']: AliasType<{
        ['...on InitiateMerchantPaymentCollectionSuccessPayload']: ValueTypes['InitiateMerchantPaymentCollectionSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: ValueTypes['NotFoundRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateMerchantPaymentCollectionSuccessPayload']: AliasType<{
        merchantPaymentCollection?: ValueTypes['Payment'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InstantFundingLimit']: AliasType<{
        /** Maximum Instant Funding Amount authorized */
        amount?: ValueTypes['Amount'];
        /** Instant Funding Amount that has already been used */
        funding?: ValueTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Account Holder Instant Funding limit has been exceeded */
    ['InstantFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Available balance is insufficient */
    ['InsufficientFundsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Beneficiary */
    ['InternalBeneficiary']: AliasType<{
        /** unique identifier of a beneficiary
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        id?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** `true` if this new beneficiary is the account holder himself in an other financial institution.
    *SOON TO BE DEPRECATED*
    Not used. It will be removed soon. */
        isMyOwnIban?: boolean | `@${string}`;
        /** account number if the beneficiary is a swan account */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer transaction */
    ['InternalCreditTransfer']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ValueTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ValueTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ValueTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ValueTypes['InternalCreditTransferCreditor'];
        /** debtor information */
        debtor?: ValueTypes['InternalCreditTransferDebtor'];
        /** matching account for the transaction */
        account?: ValueTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ValueTypes['Transaction'];
        /** r-transaction reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer creditor */
    ['InternalCreditTransferCreditor']: AliasType<{
        /** full name of the Creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        ['...on InternalCreditTransferInCreditor']?: Omit<ValueTypes['InternalCreditTransferInCreditor'], keyof ValueTypes['InternalCreditTransferCreditor']>;
        ['...on InternalCreditTransferOutCreditor']?: Omit<ValueTypes['InternalCreditTransferOutCreditor'], keyof ValueTypes['InternalCreditTransferCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer debtor */
    ['InternalCreditTransferDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        ['...on InternalCreditTransferInDebtor']?: Omit<ValueTypes['InternalCreditTransferInDebtor'], keyof ValueTypes['InternalCreditTransferDebtor']>;
        ['...on InternalCreditTransferOutDebtor']?: Omit<ValueTypes['InternalCreditTransferOutDebtor'], keyof ValueTypes['InternalCreditTransferDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer creditor for Incoming transaction */
    ['InternalCreditTransferInCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer debtor for Incoming transaction */
    ['InternalCreditTransferInDebtor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer creditor for Outgoing transaction */
    ['InternalCreditTransferOutCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer debtor for Outgoing transaction */
    ['InternalCreditTransferOutDebtor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** InternalDirectDebitB2BMerchantPaymentMethod */
    ['InternalDirectDebitB2BMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ValueTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ValueTypes['RollingReserve'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalDirectDebitB2BPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined | null | Variable<any, string>;
    };
    /** Internal Direct Debit Creditor */
    ['InternalDirectDebitCreditor']: AliasType<{
        /** unique identifier of the creditor account */
        accountId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Direct Debit Debtor */
    ['InternalDirectDebitDebtor']: AliasType<{
        /** unique identifier of the debtor account */
        accountId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalDirectDebitMandate']: AliasType<{
        /** Unique identifier of the internal direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        ['...on InternalPaymentDirectDebitMandate']?: Omit<ValueTypes['InternalPaymentDirectDebitMandate'], keyof ValueTypes['InternalDirectDebitMandate']>;
        ['...on InternalReceivedDirectDebitMandate']?: Omit<ValueTypes['InternalReceivedDirectDebitMandate'], keyof ValueTypes['InternalDirectDebitMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalDirectDebitPaymentCollectionInput']: {
        /** ID of the concerned payment mandate */
        mandateId: string | Variable<any, string>;
        /** Date at which the Swan merchant wishes the payment to be executed */
        requestedExecutionAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
    };
    ['InternalDirectDebitSequence']: InternalDirectDebitSequence;
    /** InternalDirectDebitStandardMerchantPaymentMethod */
    ['InternalDirectDebitStandardMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ValueTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ValueTypes['RollingReserve'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalDirectDebitStandardPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined | null | Variable<any, string>;
    };
    /** Internal Direct Debit transaction */
    ['InternalDirectDebitTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction: accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ValueTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ValueTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ValueTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ValueTypes['InternalDirectDebitCreditor'];
        /** debtor information */
        debtor?: ValueTypes['InternalDirectDebitDebtor'];
        /** matching account for the transaction */
        account?: ValueTypes['Account'];
        /** matching Internal mandate for the transaction */
        mandate?: ValueTypes['InternalDirectDebitMandate'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ValueTypes['Transaction'];
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: ValueTypes['Amount'];
        /** date on which reserved funds become available. */
        reservedAmountReleasedAt?: boolean | `@${string}`;
        /** r-transaction reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned on unexpected server error */
    ['InternalErrorRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment direct debit mandate for Internal */
    ['InternalPaymentDirectDebitMandate']: AliasType<{
        /** Unique identifier of the Internal Direct Debit Payment Mandate */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['TransactionsOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['TransactionsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TransactionConnection']
        ];
        /** Unique reference of the Internal Direct Debit Payment Mandate */
        reference?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate scheme */
        scheme?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate status information */
        statusInfo?: ValueTypes['PaymentMandateStatusInfo'];
        /** Internal Direct Debit Payment Mandate sequence */
        sequence?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate PDF document URL */
        mandateDocumentUrl?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate debtor information */
        debtor?: ValueTypes['InternalPaymentMandateDebtor'];
        /** Internal direct debit ultimate creditor name */
        ultimateCreditorName?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate creditor information */
        creditor?: ValueTypes['InternalPaymentMandateCreditor'];
        /** Signature date of the Internal Direct Debit Payment Mandate */
        signatureDate?: boolean | `@${string}`;
        /** Creation date of the Internal Direct Debit Payment Mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the Internal Direct Debit Payment Mandate */
        updatedAt?: boolean | `@${string}`;
        /** Date of the the last transaction executed for the concerned Internal Direct Debit Payment Mandate */
        executedAt?: boolean | `@${string}`;
        /** Expiry date of the Internal Direct Debit Payment Mandate */
        expiredAt?: boolean | `@${string}`;
        /** Account Holder information */
        accountHolder?: ValueTypes['AccountHolder'];
        /** Language that will be used to produce the mandate PDF document */
        language?: boolean | `@${string}`;
        /** Custom name of the mandate */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalPaymentMandateCreditor']: AliasType<{
        /** Internal Direct Debit Payment Mandate creditor UUID */
        id?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate Creditor Idenfier */
        identifier?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate creditor name */
        name?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate creditor address */
        address?: ValueTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalPaymentMandateDebtor']: AliasType<{
        /** Internal Direct Debit Payment Mandate debtor name */
        name?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate debtor e-mail */
        email?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate debtor country */
        country?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        address?: ValueTypes['Address'];
        /** Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        accountId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalPaymentMandateScheme']: InternalPaymentMandateScheme;
    /** Internal Direct Debit Payment Mandate Sequence */
    ['InternalPaymentMandateSequence']: InternalPaymentMandateSequence;
    /** Received direct debit mandate for SEPA */
    ['InternalReceivedDirectDebitMandate']: AliasType<{
        /** Unique identifier of the received internal direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** the list of elements needs to be filtered */
                filters?: ValueTypes['TransactionsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TransactionConnection']
        ];
        /** Version of the received internal direct debit mandate */
        version?: boolean | `@${string}`;
        /** Creation date of the received internal direct debit mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the received internal direct debit mandate */
        updatedAt?: boolean | `@${string}`;
        /** Received internal direct debit Unique Mandate Reference (UMR) */
        reference?: boolean | `@${string}`;
        /** Received internal direct debit mandate scheme */
        scheme?: boolean | `@${string}`;
        /** Received internal direct debit mandate sequence */
        sequence?: boolean | `@${string}`;
        /** Received internal direct debit creditor */
        creditor?: ValueTypes['InternalReceivedDirectDebitMandateCreditor'];
        /** Received internal direct debit ultimate creditor name */
        ultimateCreditorName?: boolean | `@${string}`;
        /** Date of the last internal direct debit transaction executed for the concerned received internal direct debit mandate */
        executedAt?: boolean | `@${string}`;
        /** Date of signature of the received internal direct debit mandate */
        signatureDate?: boolean | `@${string}`;
        /** Expiry date of the received internal direct debit mandate, computed automatically (36 months from the executedAt date) */
        expiredAt?: boolean | `@${string}`;
        /** Mandate status information of the received internal direct debit mandate */
        statusInfo?: ValueTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Account of the received internal direct debit mandate debtor */
        account?: ValueTypes['Account'];
        /** Iban of the received internal direct debit mandate debtor */
        iban?: boolean | `@${string}`;
        /** Mandate name */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal received direct debit mandate creditor */
    ['InternalReceivedDirectDebitMandateCreditor']: AliasType<{
        /** Creditor identifier */
        identifier?: boolean | `@${string}`;
        /** Name of the creditor */
        name?: boolean | `@${string}`;
        /** Address of the creditor */
        address?: ValueTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Received internal direct debit mandate scheme */
    ['InternalReceivedDirectDebitMandateScheme']: InternalReceivedDirectDebitMandateScheme;
    /** Internal received direct debit mandate sequence */
    ['InternalReceivedDirectDebitMandateSequence']: InternalReceivedDirectDebitMandateSequence;
    /** Address of an international beneficiary */
    ['InternationalAddressInput']: {
        /** Address 1 */
        address1?: string | undefined | null | Variable<any, string>;
        /** City */
        city?: string | undefined | null | Variable<any, string>;
        /** Country */
        country?: string | undefined | null | Variable<any, string>;
        /** Zip Code */
        zipCode?: string | undefined | null | Variable<any, string>;
        /** State */
        state?: string | undefined | null | Variable<any, string>;
    };
    /** International Beneficiary Details */
    ['InternationalBeneficiaryDetailsInput']: {
        /** Key */
        key: string | Variable<any, string>;
        /** Value */
        value: string | Variable<any, string>;
    };
    /** *COMING SOON*
  International Beneficiary Dynamic Forms */
    ['InternationalBeneficiaryDynamicForms']: AliasType<{
        /** *COMING SOON*
    Schemes */
        schemes?: ValueTypes['Scheme'];
        __typename?: boolean | `@${string}`;
    }>;
    /** *COMING SOON*
  International Beneficiary */
    ['InternationalBeneficiaryInput']: {
        /** Account holder name */
        name: string | Variable<any, string>;
        /** Currency of the international beneficiary account */
        currency: ValueTypes['Currency'] | Variable<any, string>;
        /** *COMING SOON*
    Currency-specific details of the beneficiary */
        details: Array<ValueTypes['InternationalBeneficiaryDetailsInput']> | Variable<any, string>;
        /** *COMING SOON*
    Route that Swan will use to transfer the funds */
        route: ValueTypes['InternationalCreditTransferRouteInput'] | Variable<any, string>;
    };
    ['InternationalCreditTransferCreditor']: AliasType<{
        ['...on InternationalCreditTransferOutCreditor']: ValueTypes['InternationalCreditTransferOutCreditor'];
        ['...on InternationalCreditTransferInCreditor']: ValueTypes['InternationalCreditTransferInCreditor'];
        __typename?: boolean | `@${string}`;
    }>;
    /** International Currency Exchange / Quote */
    ['InternationalCreditTransferCurrencyExchange']: AliasType<{
        /** Rate of the quote */
        exchangeRate?: boolean | `@${string}`;
        /** Fees */
        feesAmount?: ValueTypes['Amount'];
        /** Source amount of the quote */
        sourceAmount?: ValueTypes['Amount'];
        /** target amount of the quote */
        targetAmount?: ValueTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InternationalCreditTransferDebtor']: AliasType<{
        ['...on InternationalCreditTransferOutDebtor']: ValueTypes['InternationalCreditTransferOutDebtor'];
        ['...on InternationalCreditTransferInDebtor']: ValueTypes['InternationalCreditTransferInDebtor'];
        __typename?: boolean | `@${string}`;
    }>;
    /** International Credit Transfer - Currency-specific details of the beneficiary */
    ['InternationalCreditTransferDetails']: AliasType<{
        /** Key */
        key?: boolean | `@${string}`;
        /** Value */
        value?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** *COMING SOON*
  International Credit Transfer Details */
    ['InternationalCreditTransferDetailsInput']: {
        /** *COMING SOON*
    Key */
        key: string | Variable<any, string>;
        /** *COMING SOON*
    Value */
        value: string | Variable<any, string>;
    };
    /** Language: ISO 639-1 language code */
    ['InternationalCreditTransferDisplayLanguage']: InternationalCreditTransferDisplayLanguage;
    /** *COMING SOON*
  International Credit Transfer Dynamic Form */
    ['InternationalCreditTransferDynamicForm']: AliasType<{
        /** List of international transaction fields */
        fields?: ValueTypes['Field'];
        /** *COMING SOON*
    Number of fields that need to be updated to fill the form completely. Please re run the query internationalCreditTransferTransactionDetailsDynamicForm with updated refreshableFields if the value of this field is not 0 */
        remainingFieldsToRefreshCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** International Credit Transfer In - Creditor info */
    ['InternationalCreditTransferInCreditor']: AliasType<{
        /** Account holder name */
        name?: boolean | `@${string}`;
        /** Bank Identifier Code */
        BIC?: boolean | `@${string}`;
        /** International Bank Account Number
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        IBAN?: boolean | `@${string}`;
        /** maskedIBAN if the beneficiary is a an account in an other financial institution */
        maskedIBAN?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternationalCreditTransferInDebtor']: AliasType<{
        /** Account holder name */
        name?: boolean | `@${string}`;
        /** Account Number */
        accountNumber?: boolean | `@${string}`;
        /** BIC */
        bic?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** International Credit Transfer Out - Creditor info */
    ['InternationalCreditTransferOutCreditor']: AliasType<{
        /** Currency of the international beneficiary account */
        currency?: boolean | `@${string}`;
        /** Currency-specific details of the beneficiary */
        details?: ValueTypes['InternationalCreditTransferDetails'];
        /** Account holder name */
        name?: boolean | `@${string}`;
        /** Route that Swan will use to transfer the funds */
        route?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternationalCreditTransferOutDebtor']: AliasType<{
        /** Account holder name */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** *COMING SOON*
  International Quote */
    ['InternationalCreditTransferQuote']: AliasType<{
        /** Rate of the quote */
        exchangeRate?: boolean | `@${string}`;
        /** Source amount of the quote */
        sourceAmount?: ValueTypes['Amount'];
        /** target amount of the quote */
        targetAmount?: ValueTypes['Amount'];
        /** Fees */
        feesAmount?: ValueTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** International Credit Transfer Route */
    ['InternationalCreditTransferRoute']: InternationalCreditTransferRoute;
    /** International Credit Transfer Route */
    ['InternationalCreditTransferRouteInput']: InternationalCreditTransferRouteInput;
    ['InternationalCreditTransferTransaction']: AliasType<{
        /** matching account for this transaction */
        account?: ValueTypes['Account'];
        /** amount */
        amount?: ValueTypes['Amount'];
        /** booked balance after this transaction */
        bookedBalanceAfter?: ValueTypes['Amount'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ValueTypes['InternationalCreditTransferCreditor'];
        /** debtor information */
        debtor?: ValueTypes['InternationalCreditTransferDebtor'];
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** @deprecated(reason: "use `quote.feesAmount` instead") */
        fees?: ValueTypes['Amount'];
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** instructed amount */
        instructedAmount?: ValueTypes['Amount'];
        /** instructed amount */
        intermediaryBankFees?: ValueTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ValueTypes['Transaction'];
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ValueTypes['Payment'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** quote given by our international provider */
        currencyExchange?: ValueTypes['InternationalCreditTransferCurrencyExchange'];
        /** external identifier of the transaction */
        reference?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** return reason */
        returnReason?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TransactionStatusInfo'];
        /** type */
        type?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned on invalid argument error */
    ['InvalidArgumentRejection']: AliasType<{
        message?: boolean | `@${string}`;
        code?: boolean | `@${string}`;
        fields?: ValueTypes['InvalidArgumentRejectionField'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InvalidArgumentRejectionCode']: InvalidArgumentRejectionCode;
    ['InvalidArgumentRejectionField']: AliasType<{
        name?: boolean | `@${string}`;
        errors?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** InvalidVerification */
    ['InvalidBeneficiaryVerification']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Information about the invalidity of the IBAN */
    ['InvalidIban']: AliasType<{
        /** Iban from input */
        iban?: boolean | `@${string}`;
        /** Enum that can be used to discriminate on the error */
        code?: boolean | `@${string}`;
        /** Message that give a bit of context during development */
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** InvalidIbanCode */
    ['InvalidIbanCode']: InvalidIbanCode;
    /** Describes an invalid identification level for the process associated to this identification, and the invalid reason can be accessed */
    ['InvalidIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Invalid` */
        status?: boolean | `@${string}`;
        /** The reasons why this identification level is invalid */
        reasons?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if phone number is not well formatted */
    ['InvalidPhoneNumberRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if siren number is not well formatted */
    ['InvalidSirenNumberRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Invoice */
    ['Invoice']: AliasType<{
        /** unique id */
        id?: boolean | `@${string}`;
        /** account id */
        accountId?: boolean | `@${string}`;
        /** name of the invoice */
        name?: boolean | `@${string}`;
        /** type of the invoice */
        type?: boolean | `@${string}`;
        /** status of the invoice */
        status?: boolean | `@${string}`;
        /** due amount */
        amount?: ValueTypes['Amount'];
        /** temporary public url on which the file can be accessible */
        url?: boolean | `@${string}`;
        /** date at which the link will not be useable anymore */
        expiresAt?: boolean | `@${string}`;
        /** starting date of the billing window */
        openingDate?: boolean | `@${string}`;
        /** ending date of the billing window */
        closingDate?: boolean | `@${string}`;
        /** creation date */
        createdAt?: boolean | `@${string}`;
        /** last update date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['InvoiceConnection']: AliasType<{
        pageInfo?: ValueTypes['PageInfo'];
        totalCount?: boolean | `@${string}`;
        edges?: ValueTypes['InvoiceEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Edge interface */
    ['InvoiceEdge']: AliasType<{
        node?: ValueTypes['Invoice'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The different statuses of invoice */
    ['InvoiceStatus']: InvoiceStatus;
    ['InvoiceType']: InvoiceType;
    /** Key value details */
    ['KeyValue']: AliasType<{
        /** Key */
        key?: boolean | `@${string}`;
        /** Value */
        value?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['Language']: Language;
    ['LegalDocument']: AliasType<{
        /** ID of the legal document */
        id?: boolean | `@${string}`;
        /** Type of the legal document */
        type?: boolean | `@${string}`;
        /** Status of the Legal Document */
        statusInfo?: ValueTypes['LegalDocumentStatusInfo'];
        /** Language of the Legal Document */
        language?: boolean | `@${string}`;
        /** Url to download the Document */
        url?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentActiveStatusInfo']: AliasType<{
        /** LegalDocument status (always Active for type LegalDocumentActiveStatusInfo) */
        status?: boolean | `@${string}`;
        /** Creation date */
        createdAt?: boolean | `@${string}`;
        /** Activation date */
        activatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** LegalDocumentEdge list */
        edges?: ValueTypes['LegalDocumentEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The account membership */
        node?: ValueTypes['LegalDocument'];
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentInactiveStatusInfo']: AliasType<{
        /** LegalDocument status (always Inactive for type LegalDocumentInactiveStatusInfo) */
        status?: boolean | `@${string}`;
        /** Creation date */
        createdAt?: boolean | `@${string}`;
        /** Activation date */
        activatedAt?: boolean | `@${string}`;
        /** Deactivation date */
        deactivatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentsFilterInput']: {
        status?: ValueTypes['LegalDocumentStatus'] | undefined | null | Variable<any, string>;
        type?: ValueTypes['LegalDocumentType'] | undefined | null | Variable<any, string>;
    };
    ['LegalDocumentStatus']: LegalDocumentStatus;
    ['LegalDocumentStatusInfo']: AliasType<{
        /** LegalDocument Status */
        status?: boolean | `@${string}`;
        ['...on LegalDocumentActiveStatusInfo']?: Omit<ValueTypes['LegalDocumentActiveStatusInfo'], keyof ValueTypes['LegalDocumentStatusInfo']>;
        ['...on LegalDocumentInactiveStatusInfo']?: Omit<ValueTypes['LegalDocumentInactiveStatusInfo'], keyof ValueTypes['LegalDocumentStatusInfo']>;
        ['...on LegalDocumentUpcomingStatusInfo']?: Omit<ValueTypes['LegalDocumentUpcomingStatusInfo'], keyof ValueTypes['LegalDocumentStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentType']: LegalDocumentType;
    ['LegalDocumentUpcomingStatusInfo']: AliasType<{
        /** LegalDocument status (always Upcoming for type LegalDocumentUpcomingStatusInfo) */
        status?: boolean | `@${string}`;
        /** Creation date */
        createdAt?: boolean | `@${string}`;
        /** Date when the LegalDocument will be activated */
        effectiveDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalRepresentativeAccountMembershipCannotBeDisabledRejection']: AliasType<{
        accountMembershipId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Language: ISO 639-1 language code */
    ['MandateLanguage']: MandateLanguage;
    ['MembershipInfoInput']: {
        /** Email address */
        email: string | Variable<any, string>;
        /** Restricted to a user if necessary */
        restrictedTo: ValueTypes['RestrictedToInput'] | Variable<any, string>;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean | Variable<any, string>;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean | Variable<any, string>;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean | Variable<any, string>;
        /** `true` if this account membership can invite, update, suspend or resume account membership */
        canManageAccountMembership: boolean | Variable<any, string>;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null | Variable<any, string>;
        /** Residency address of the member to be added */
        residencyAddress?: ValueTypes['ResidencyAddressInput'] | undefined | null | Variable<any, string>;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined | null | Variable<any, string>;
    };
    /** Filters that can be applied when listing accounts (Only applied in user context) */
    ['MembershipsFilterInput']: {
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null | Variable<any, string>;
        /** Can the user initiate payments on this account */
        canInitiatePayments?: boolean | undefined | null | Variable<any, string>;
        /** Can the user manage account membership */
        canManageAccountMembership?: boolean | undefined | null | Variable<any, string>;
        /** Can the user manage beneficiaries */
        canManageBeneficiaries?: boolean | undefined | null | Variable<any, string>;
        /** Can the user view account */
        canViewAccount?: boolean | undefined | null | Variable<any, string>;
        /** Account memberships status/statuses we're looking for */
        status?: Array<ValueTypes['AccountMembershipStatus']> | undefined | null | Variable<any, string>;
        /** Filtered by email */
        email?: string | undefined | null | Variable<any, string>;
        /** Filtered by first name */
        firstName?: string | undefined | null | Variable<any, string>;
        /** Filtered by last name */
        lastName?: string | undefined | null | Variable<any, string>;
        /** Searches email, first name, last name, and id */
        search?: string | undefined | null | Variable<any, string>;
    };
    /** MerchantCategoryDescription */
    ['MerchantCategoryDescription']: MerchantCategoryDescription;
    ['MerchantPaymentLink']: AliasType<{
        /** Merchant payment link's unique ID. */
        id?: boolean | `@${string}`;
        /** ID of the related project */
        projectId?: boolean | `@${string}`;
        /** The URL at which the customer can complete the payment. */
        url?: boolean | `@${string}`;
        /** The merchant payment link status. */
        statusInfo?: ValueTypes['MerchantPaymentLinkStatusInfo'];
        /** The Merchant Profile to link this Payment Link to */
        merchantProfile?: ValueTypes['MerchantProfile'];
        /** Amount to be paid to sucessfully complete the payment. */
        amount?: ValueTypes['Amount'];
        /** Merchant Website URL to redirect the user to when the payment is completed. */
        redirectUrl?: boolean | `@${string}`;
        /** URL to redirect the user to if they cancel their payment */
        cancelRedirectUrl?: boolean | `@${string}`;
        /** Controls if the payment mandate created from this payment link is for one-time use or can be reused
    This is applicable for card and SEPA Direct Debit payment methods only. */
        sequence?: boolean | `@${string}`;
        /** The customer billing Address
    These fields should be completed also to pre-fill a SEPA direct debit mandate.
    
    We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes */
        billingAddress?: ValueTypes['Address'];
        /**   A date that reflects the time at which the user asked the transaction to be executed.
    For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
    For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
    
    Default value means that the execution will be as soon as possible */
        requestedExecutionAt?: boolean | `@${string}`;
        /** Any string that you want to be attached to this payment link.
    Usually something to help you reference the link in an external system. */
        externalReference?: boolean | `@${string}`;
        /** Optional field intended to provide a way for you to include a reference number or code.
    The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different. */
        reference?: boolean | `@${string}`;
        /** The language used for the payment page.
    Default is the browser's language, or English if not available. */
        language?: boolean | `@${string}`;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page. */
        label?: boolean | `@${string}`;
        /**  We will use the information specified here to prefill the payment link fields
    depending on the payment method the end user chooses.
    Keep in mind that your end customer will be able to edit these fields. */
        customer?: ValueTypes['Customer'];
        /** List of payment methods IDs enabled for this payment link.
    If the array is empty Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit) */
        paymentMethods?: ValueTypes['MerchantPaymentMethod'];
        __typename?: boolean | `@${string}`;
    }>;
    ['MerchantPaymentLinkStatus']: MerchantPaymentLinkStatus;
    ['MerchantPaymentLinkStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        ['...on ActiveMerchantPaymentLinkStatusInfo']?: Omit<ValueTypes['ActiveMerchantPaymentLinkStatusInfo'], keyof ValueTypes['MerchantPaymentLinkStatusInfo']>;
        ['...on CompletedMerchantPaymentLinkStatusInfo']?: Omit<ValueTypes['CompletedMerchantPaymentLinkStatusInfo'], keyof ValueTypes['MerchantPaymentLinkStatusInfo']>;
        ['...on ExpiredMerchantPaymentLinkStatusInfo']?: Omit<ValueTypes['ExpiredMerchantPaymentLinkStatusInfo'], keyof ValueTypes['MerchantPaymentLinkStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Base object for the different Payment Methods available */
    ['MerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ValueTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ValueTypes['RollingReserve'];
        ['...on CardMerchantPaymentMethod']?: Omit<ValueTypes['CardMerchantPaymentMethod'], keyof ValueTypes['MerchantPaymentMethod']>;
        ['...on CheckMerchantPaymentMethod']?: Omit<ValueTypes['CheckMerchantPaymentMethod'], keyof ValueTypes['MerchantPaymentMethod']>;
        ['...on InternalDirectDebitB2BMerchantPaymentMethod']?: Omit<ValueTypes['InternalDirectDebitB2BMerchantPaymentMethod'], keyof ValueTypes['MerchantPaymentMethod']>;
        ['...on InternalDirectDebitStandardMerchantPaymentMethod']?: Omit<ValueTypes['InternalDirectDebitStandardMerchantPaymentMethod'], keyof ValueTypes['MerchantPaymentMethod']>;
        ['...on SepaDirectDebitB2BMerchantPaymentMethod']?: Omit<ValueTypes['SepaDirectDebitB2BMerchantPaymentMethod'], keyof ValueTypes['MerchantPaymentMethod']>;
        ['...on SepaDirectDebitCoreMerchantPaymentMethod']?: Omit<ValueTypes['SepaDirectDebitCoreMerchantPaymentMethod'], keyof ValueTypes['MerchantPaymentMethod']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Merchant Payment Method is not active */
    ['MerchantPaymentMethodNotActiveRejection']: AliasType<{
        paymentMethodIds?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The different statuses a MerchantPaymentMethod can have */
    ['MerchantPaymentMethodStatus']: MerchantPaymentMethodStatus;
    /** The payment method status information */
    ['MerchantPaymentMethodStatusInfo']: AliasType<{
        /** Merchant Payment Method Status */
        status?: boolean | `@${string}`;
        ['...on CanceledMerchantPaymentMethodStatusInfo']?: Omit<ValueTypes['CanceledMerchantPaymentMethodStatusInfo'], keyof ValueTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on DisabledMerchantPaymentMethodStatusInfo']?: Omit<ValueTypes['DisabledMerchantPaymentMethodStatusInfo'], keyof ValueTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on EnabledMerchantPaymentMethodStatusInfo']?: Omit<ValueTypes['EnabledMerchantPaymentMethodStatusInfo'], keyof ValueTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on PendingMerchantPaymentMethodStatusInfo']?: Omit<ValueTypes['PendingMerchantPaymentMethodStatusInfo'], keyof ValueTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on RejectedMerchantPaymentMethodStatusInfo']?: Omit<ValueTypes['RejectedMerchantPaymentMethodStatusInfo'], keyof ValueTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on SuspendedMerchantPaymentMethodStatusInfo']?: Omit<ValueTypes['SuspendedMerchantPaymentMethodStatusInfo'], keyof ValueTypes['MerchantPaymentMethodStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** The different statuses a MerchantPaymentMethod can have */
    ['MerchantPaymentMethodType']: MerchantPaymentMethodType;
    /** Merchant Profile */
    ['MerchantProfile']: AliasType<{
        /** The Merchant Profile ID */
        id?: boolean | `@${string}`;
        /** The Account ID this Merchant Profile is linked to */
        accountId?: boolean | `@${string}`;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName?: boolean | `@${string}`;
        /** Url of the merchant's website */
        merchantWebsite?: boolean | `@${string}`;
        /** Url of the merchant's logo */
        merchantLogoUrl?: boolean | `@${string}`;
        /** The status of the merchant profile */
        statusInfo?: ValueTypes['MerchantProfileStatusInfo'];
        /** Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType?: boolean | `@${string}`;
        /** Expected annual activity volumes for all payment method */
        expectedMonthlyPaymentVolume?: ValueTypes['Amount'];
        /** Payment Methods associated */
        merchantPaymentMethods?: ValueTypes['MerchantPaymentMethod'];
        /** Updates Requested associated */
        requestedMerchantProfileUpdates?: ValueTypes['RequestMerchantProfileUpdate'];
        /** expected average basket value. */
        expectedAverageBasket?: ValueTypes['Amount'];
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page. */
        accentColor?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['MerchantProfileConnection']: AliasType<{
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** Edge list */
        edges?: ValueTypes['MerchantProfileEdge'];
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['MerchantProfileEdge']: AliasType<{
        node?: ValueTypes['MerchantProfile'];
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing Funding Sources */
    ['MerchantProfileFiltersInput']: {
        status: Array<ValueTypes['MerchantProfileStatus']> | Variable<any, string>;
    };
    ['MerchantProfileOrderByFieldInput']: MerchantProfileOrderByFieldInput;
    ['MerchantProfileOrderByInput']: {
        field?: ValueTypes['MerchantProfileOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Merchant Profile Statuses */
    ['MerchantProfileStatus']: MerchantProfileStatus;
    /** Merchant Profile Status Information */
    ['MerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        ['...on CanceledMerchantProfileStatusInfo']?: Omit<ValueTypes['CanceledMerchantProfileStatusInfo'], keyof ValueTypes['MerchantProfileStatusInfo']>;
        ['...on EnabledMerchantProfileStatusInfo']?: Omit<ValueTypes['EnabledMerchantProfileStatusInfo'], keyof ValueTypes['MerchantProfileStatusInfo']>;
        ['...on PendingReviewMerchantProfileStatusInfo']?: Omit<ValueTypes['PendingReviewMerchantProfileStatusInfo'], keyof ValueTypes['MerchantProfileStatusInfo']>;
        ['...on RejectedMerchantProfileStatusInfo']?: Omit<ValueTypes['RejectedMerchantProfileStatusInfo'], keyof ValueTypes['MerchantProfileStatusInfo']>;
        ['...on SuspendedMerchantProfileStatusInfo']?: Omit<ValueTypes['SuspendedMerchantProfileStatusInfo'], keyof ValueTypes['MerchantProfileStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Merchant Profile is not in the expected status */
    ['MerchantProfileWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        expectedStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when mandatory fields are missing from the call. */
    ['MissingMandatoryFieldRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Monthly income. */
    ['MonthlyIncome']: MonthlyIncome;
    /** Monthly payment volume. */
    ['MonthlyPaymentVolume']: MonthlyPaymentVolume;
    ['Mutation']: AliasType<{
        activatePhysicalCard?: [
            {
                input: ValueTypes['ActivatePhysicalCardInput'] | Variable<any, string>;
            },
            ValueTypes['ActivatePhysicalCardPayload']
        ];
        addAccountMembership?: [
            {
                input: ValueTypes['AddAccountMembershipInput'] | Variable<any, string>;
            },
            ValueTypes['AddAccountMembershipPayload']
        ];
        addAccountMemberships?: [
            {
                input: ValueTypes['AddAccountMembershipsInput'] | Variable<any, string>;
            },
            ValueTypes['AddAccountMembershipsPayload']
        ];
        addCard?: [
            {
                input: ValueTypes['AddCardInput'] | Variable<any, string>;
            },
            ValueTypes['AddCardPayload']
        ];
        addCardsWithGroupDelivery?: [
            {
                input: ValueTypes['AddCardsWithGroupDeliveryInput'] | Variable<any, string>;
            },
            ValueTypes['AddCardsWithGroupDeliveryPayload']
        ];
        addCards?: [
            {
                input: ValueTypes['AddCardsInput'] | Variable<any, string>;
            },
            ValueTypes['AddCardsPayload']
        ];
        addDigitalCard?: [
            {
                input?: ValueTypes['AddDigitalCardInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['AddDigitalCardPayload']
        ];
        addExternalAccountBalance?: [
            {
                input: ValueTypes['AddExternalAccountBalanceInput'] | Variable<any, string>;
            },
            ValueTypes['AddExternalAccountBalancePayload']
        ];
        addExternalAccount?: [
            {
                input: ValueTypes['AddExternalAccountInput'] | Variable<any, string>;
            },
            ValueTypes['AddExternalAccountPayload']
        ];
        addFundingLimitSettingsChangeRequest?: [
            {
                input: ValueTypes['AddFundingLimitSettingsChangeRequestInput'] | Variable<any, string>;
            },
            ValueTypes['AddFundingLimitSettingsChangeRequestPayload']
        ];
        addOrUpdateExternalAccountBalance?: [
            {
                input: ValueTypes['AddOrUpdateExternalAccountBalanceInput'] | Variable<any, string>;
            },
            ValueTypes['AddOrUpdateExternalAccountBalancePayload']
        ];
        addSingleUseVirtualCard?: [
            {
                input: ValueTypes['AddSingleUseVirtualCardInput'] | Variable<any, string>;
            },
            ValueTypes['AddSingleUseVirtualCardPayload']
        ];
        addSingleUseVirtualCards?: [
            {
                input: ValueTypes['AddSingleUseVirtualCardsInput'] | Variable<any, string>;
            },
            ValueTypes['AddSingleUseVirtualCardsPayload']
        ];
        addVirtualIbanEntry?: [
            {
                input?: ValueTypes['AddVirtualIbanInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['AddVirtualIbanEntryPayload']
        ];
        allowSddVirtualIbanEntry?: [
            {
                input: ValueTypes['AllowSddVirtualIbanEntryInput'] | Variable<any, string>;
            },
            ValueTypes['AllowSddVirtualIbanEntryPayload']
        ];
        allowSdd?: [
            {
                input: ValueTypes['AllowSddInput'] | Variable<any, string>;
            },
            ValueTypes['AllowSddPayload']
        ];
        bindAccountMembership?: [
            {
                input: ValueTypes['BindAccountMembershipInput'] | Variable<any, string>;
            },
            ValueTypes['BindAccountMembershipPayload']
        ];
        cancelCard?: [
            {
                input?: ValueTypes['CancelCardInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['CancelCardPayload']
        ];
        cancelDigitalCard?: [
            {
                input?: ValueTypes['CancelDigitalCardInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['CancelDigitalCardPayload']
        ];
        cancelPhysicalCard?: [
            {
                input?: ValueTypes['CancelPhysicalCardInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['CancelPhysicalCardPayload']
        ];
        cancelVirtualIbanEntry?: [
            {
                input: ValueTypes['CancelVirtualIbanEntryInput'] | Variable<any, string>;
            },
            ValueTypes['CancelVirtualIbanEntryPayload']
        ];
        closeAccount?: [
            {
                input: ValueTypes['CloseAccountInput'] | Variable<any, string>;
            },
            ValueTypes['CloseAccountPayload']
        ];
        confirmPhysicalCardRenewal?: [
            {
                input: ValueTypes['ConfirmPhysicalCardRenewalInput'] | Variable<any, string>;
            },
            ValueTypes['ConfirmPhysicalCardRenewalPayload']
        ];
        deleteSupportingDocument?: [
            {
                input: ValueTypes['DeleteSupportingDocumentInput'] | Variable<any, string>;
            },
            ValueTypes['DeleteSupportingDocumentPayload']
        ];
        denySddVirtualIbanEntry?: [
            {
                input: ValueTypes['DenySddVirtualIbanEntryInput'] | Variable<any, string>;
            },
            ValueTypes['DenySddVirtualIbanEntryPayload']
        ];
        denySdd?: [
            {
                input?: ValueTypes['DenySddInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['DenySddPayload']
        ];
        disableAccountMembership?: [
            {
                input?: ValueTypes['DisableAccountMembershipInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['DisableAccountMembershipPayload']
        ];
        finalizeOnboarding?: [
            {
                input: ValueTypes['FinalizeOnboardingInput'] | Variable<any, string>;
            },
            ValueTypes['FinalizeOnboardingPayload']
        ];
        onboardCompanyAccountHolder?: [
            {
                input?: ValueTypes['OnboardCompanyAccountHolderInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['OnboardCompanyAccountHolderPayload']
        ];
        onboardIndividualAccountHolder?: [
            {
                input?: ValueTypes['OnboardIndividualAccountHolderInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['OnboardIndividualAccountHolderPayload']
        ];
        printPhysicalCard?: [
            {
                input: ValueTypes['PrintPhysicalCardInput'] | Variable<any, string>;
            },
            ValueTypes['PrintPhysicalCardPayload']
        ];
        resumeAccountMembership?: [
            {
                input?: ValueTypes['ResumeAccountMembershipInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['ResumeAccountMembershipPayload']
        ];
        resumePhysicalCard?: [
            {
                input?: ValueTypes['ResumePhysicalCardInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['ResumePhysicalCardPayload']
        ];
        suspendAccountMembership?: [
            {
                input: ValueTypes['SuspendAccountMembershipInput'] | Variable<any, string>;
            },
            ValueTypes['SuspendAccountMembershipPayload']
        ];
        suspendPhysicalCard?: [
            {
                input?: ValueTypes['SuspendPhysicalCardInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['SuspendPhysicalCardPayload']
        ];
        updateAccountHolder?: [
            {
                input: ValueTypes['UpdateAccountHolderInput'] | Variable<any, string>;
            },
            ValueTypes['UpdateAccountHolderPayload']
        ];
        updateAccountMembership?: [
            {
                input: ValueTypes['UpdateAccountMembershipInput'] | Variable<any, string>;
            },
            ValueTypes['UpdateAccountMembershipPayload']
        ];
        updateAccount?: [
            {
                input: ValueTypes['UpdateAccountInput'] | Variable<any, string>;
            },
            ValueTypes['UpdateAccountPayload']
        ];
        updateCard?: [
            {
                input?: ValueTypes['UpdateCardInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['UpdateCardPayload']
        ];
        updateCompanyOnboarding?: [
            {
                input?: ValueTypes['UpdateCompanyOnboardingInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['UpdateCompanyOnboardingPayload']
        ];
        updateIndividualOnboarding?: [
            {
                input: ValueTypes['UpdateIndividualOnboardingInput'] | Variable<any, string>;
            },
            ValueTypes['UpdateIndividualOnboardingPayload']
        ];
        updateSupportingDocument?: [
            {
                input: ValueTypes['UpdateSupportingDocumentInput'] | Variable<any, string>;
            },
            ValueTypes['UpdateSupportingDocumentPayload']
        ];
        viewCardNumbers?: [
            {
                input: ValueTypes['ViewCardNumbersInput'] | Variable<any, string>;
            },
            ValueTypes['ViewCardNumbersPayload']
        ];
        viewPhysicalCardNumbers?: [
            {
                input: ValueTypes['ViewPhysicalCardNumbersInput'] | Variable<any, string>;
            },
            ValueTypes['ViewPhysicalCardNumbersPayload']
        ];
        viewPhysicalCardPin?: [
            {
                input: ValueTypes['ViewPhysicalCardPinInput'] | Variable<any, string>;
            },
            ValueTypes['ViewPhysicalCardPinPayload']
        ];
        generateSupportingDocumentUploadUrl?: [
            {
                input: ValueTypes['GenerateSupportingDocumentUploadUrlInput'] | Variable<any, string>;
            },
            ValueTypes['GenerateSupportingDocumentUploadUrlPayload']
        ];
        requestSupportingDocumentCollectionReview?: [
            {
                input?: ValueTypes['RequestSupportingDocumentCollectionReviewInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['RequestSupportingDocumentCollectionReviewPayload']
        ];
        generateAccountStatement?: [
            {
                input: ValueTypes['GenerateAccountStatementInput'] | Variable<any, string>;
            },
            ValueTypes['Statement']
        ];
        createCapitalDepositCase?: [
            {
                input: ValueTypes['CreateCapitalDepositCaseInput'] | Variable<any, string>;
            },
            ValueTypes['CreateCapitalDepositCasePayload']
        ];
        generateCapitalDepositDocumentUploadUrl?: [
            {
                input: ValueTypes['GenerateCapitalDepositDocumentUploadUrlInput'] | Variable<any, string>;
            },
            ValueTypes['GenerateCapitalDepositDocumentUploadUrlPayload']
        ];
        cancelConsent?: [
            {
                input: ValueTypes['CancelConsentInput'] | Variable<any, string>;
            },
            ValueTypes['CancelConsentPayload']
        ];
        createMultiConsent?: [
            {
                input: ValueTypes['CreateMultiConsentInput'] | Variable<any, string>;
            },
            ValueTypes['CreateMultiConsentPayload']
        ];
        grantConsentWithServerSignature?: [
            {
                input: ValueTypes['GrantConsentWithServerSignatureInput'] | Variable<any, string>;
            },
            ValueTypes['GrantConsentWithServerSignaturePayload']
        ];
        updateUserConsentSettings?: [
            {
                input: ValueTypes['UpdateUserConsentSettingsInput'] | Variable<any, string>;
            },
            ValueTypes['UpdateUserConsentSettingsPayload']
        ];
        addReceivedInternalDirectDebitB2bMandate?: [
            {
                input: ValueTypes['AddReceivedInternalDirectDebitB2bMandateInput'] | Variable<any, string>;
            },
            ValueTypes['AddReceivedInternalDirectDebitB2bMandatePayload']
        ];
        addReceivedSepaDirectDebitB2bMandate?: [
            {
                input: ValueTypes['AddReceivedSepaDirectDebitB2bMandateInput'] | Variable<any, string>;
            },
            ValueTypes['AddReceivedSepaDirectDebitB2bMandatePayload']
        ];
        enableReceivedDirectDebitMandate?: [
            {
                input: ValueTypes['EnableReceivedDirectDebitMandateInput'] | Variable<any, string>;
            },
            ValueTypes['EnableReceivedDirectDebitMandatePayload']
        ];
        suspendReceivedDirectDebitMandate?: [
            {
                input: ValueTypes['SuspendReceivedDirectDebitMandateInput'] | Variable<any, string>;
            },
            ValueTypes['SuspendReceivedDirectDebitMandatePayload']
        ];
        updateReceivedSepaDirectDebitB2bMandate?: [
            {
                input: ValueTypes['UpdateReceivedSepaDirectDebitB2bMandateInput'] | Variable<any, string>;
            },
            ValueTypes['UpdateReceivedSepaDirectDebitB2bMandatePayload']
        ];
        addInternalDirectDebitPaymentMandate?: [
            {
                input: ValueTypes['AddInternalDirectDebitPaymentMandateInput'] | Variable<any, string>;
            },
            ValueTypes['AddInternalDirectDebitPaymentMandatePayload']
        ];
        addMerchantProfile?: [
            {
                input: ValueTypes['AddMerchantProfileInput'] | Variable<any, string>;
            },
            ValueTypes['AddMerchantProfilePayload']
        ];
        addSepaDirectDebitPaymentMandate?: [
            {
                input: ValueTypes['AddSepaDirectDebitPaymentMandateInput'] | Variable<any, string>;
            },
            ValueTypes['AddSepaDirectDebitPaymentMandatePayload']
        ];
        initiateCheckMerchantPayment?: [
            {
                input: ValueTypes['InitiateCheckMerchantPaymentInput'] | Variable<any, string>;
            },
            ValueTypes['InitiateCheckMerchantPaymentPayload']
        ];
        createMerchantPaymentLink?: [
            {
                input: ValueTypes['CreateMerchantPaymentLinkInput'] | Variable<any, string>;
            },
            ValueTypes['CreateMerchantPaymentLinkPayload']
        ];
        initiateMerchantPaymentCollection?: [
            {
                input: ValueTypes['InitiateMerchantPaymentCollectionInput'] | Variable<any, string>;
            },
            ValueTypes['InitiateMerchantPaymentCollectionPayload']
        ];
        requestMerchantPaymentMethods?: [
            {
                input: ValueTypes['RequestMerchantPaymentMethodsInput'] | Variable<any, string>;
            },
            ValueTypes['RequestMerchantPaymentMethodsPayload']
        ];
        requestMerchantProfileUpdate?: [
            {
                input: ValueTypes['RequestMerchantProfileUpdateInput'] | Variable<any, string>;
            },
            ValueTypes['RequestMerchantProfileUpdatePayload']
        ];
        cancelTransaction?: [
            {
                input: ValueTypes['CancelTransactionInput'] | Variable<any, string>;
            },
            ValueTypes['CancelTransactionPayload']
        ];
        initiateCreditTransfers?: [
            {
                input: ValueTypes['InitiateCreditTransfersInput'] | Variable<any, string>;
            },
            ValueTypes['InitiateCreditTransfersPayload']
        ];
        refund?: [
            {
                input: ValueTypes['RefundInput'] | Variable<any, string>;
            },
            ValueTypes['RefundPayload']
        ];
        addDirectDebitFundingSource?: [
            {
                input: ValueTypes['AddDirectDebitFundingSourceInput'] | Variable<any, string>;
            },
            ValueTypes['AddDirectDebitFundingSourcePayload']
        ];
        cancelFundingSource?: [
            {
                input: ValueTypes['CancelFundingSourceInput'] | Variable<any, string>;
            },
            ValueTypes['CancelFundingSourcePayload']
        ];
        cancelStandingOrder?: [
            {
                input: ValueTypes['CancelStandingOrderInput'] | Variable<any, string>;
            },
            ValueTypes['CancelStandingOrderPayload']
        ];
        initiateFundingRequest?: [
            {
                input: ValueTypes['InitiateFundingRequestInput'] | Variable<any, string>;
            },
            ValueTypes['InitiateFundingRequestPayload']
        ];
        initiateInternationalCreditTransfer?: [
            {
                input: ValueTypes['InitiateInternationalCreditTransferInput'] | Variable<any, string>;
            },
            ValueTypes['InitiateInternationalCreditTransferResponsePayload']
        ];
        scheduleStandingOrder?: [
            {
                input: ValueTypes['ScheduleStandingOrderInput'] | Variable<any, string>;
            },
            ValueTypes['ScheduleStandingOrderPayload']
        ];
        replayWebhookEvent?: [
            {
                input: ValueTypes['ReplayWebhookEventInput'] | Variable<any, string>;
            },
            ValueTypes['ReplayWebhookEventPayload']
        ];
        addWebhookSubscription?: [
            {
                input: ValueTypes['AddWebhookSubscriptionInput'] | Variable<any, string>;
            },
            ValueTypes['WebhookSubscriptionPayload']
        ];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the entity was not found or if the user does not have the rights to know that the account exists */
    ['NotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when consent status couldn't change */
    ['NotReachableConsentStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        unreachableStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level that hasn't started for the process of the current identification */
    ['NotStartedIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `NotStarted` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the queried service doesn't support the country code */
    ['NotSupportedCountryRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level that's not supported for the process of the current identification */
    ['NotSupportedIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `NotSupported` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Extra parameters provided by partner */
    ['OAuthRedirectParameters']: AliasType<{
        /** Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. */
        state?: boolean | `@${string}`;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['OAuthRedirectParametersInput']: {
        /** Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. Length must be from 0 to 255 characters */
        state?: string | undefined | null | Variable<any, string>;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined | null | Variable<any, string>;
    };
    /** Inputs to onboard a new company account holder */
    ['OnboardCompanyAccountHolderInput']: {
        /** Account name of the company account holder.
    Length must be from 0 to 100 characters */
        accountName?: string | undefined | null | Variable<any, string>;
        /** Name of the company. Length must be from 0 to 255 characters */
        name?: string | undefined | null | Variable<any, string>;
        /** Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters */
        registrationNumber?: string | undefined | null | Variable<any, string>;
        /** Type of the company (Association ...) */
        companyType?: ValueTypes['CompanyType'] | undefined | null | Variable<any, string>;
        /** Business activity */
        businessActivity?: ValueTypes['BusinessActivity'] | undefined | null | Variable<any, string>;
        /** Business activity description. Length must be from 0 to 1024 characters */
        businessActivityDescription?: string | undefined | null | Variable<any, string>;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ValueTypes['AccountCountry'] | undefined | null | Variable<any, string>;
        /** Estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: ValueTypes['MonthlyPaymentVolume'] | undefined | null | Variable<any, string>;
        /** The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
    
    The ultimate beneficial owner is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<ValueTypes['IndividualUltimateBeneficialOwnerInput']> | undefined | null | Variable<any, string>;
        /** Residency address of the head office (Must be in a European country) */
        residencyAddress?: ValueTypes['ResidencyAddressInput'] | undefined | null | Variable<any, string>;
        /** Email of the legal representative. Length must be from 0 to 255 characters */
        email?: string | undefined | null | Variable<any, string>;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined | null | Variable<any, string>;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
    Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined | null | Variable<any, string>;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined | null | Variable<any, string>;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ValueTypes['OAuthRedirectParametersInput'] | undefined | null | Variable<any, string>;
        /** VAT number */
        vatNumber?: string | undefined | null | Variable<any, string>;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined | null | Variable<any, string>;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ValueTypes['AddressInformationInput'] | undefined | null | Variable<any, string>;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: ValueTypes['TypeOfRepresentation'] | undefined | null | Variable<any, string>;
    };
    ['OnboardCompanyAccountHolderPayload']: AliasType<{
        ['...on OnboardCompanyAccountHolderSuccessPayload']: ValueTypes['OnboardCompanyAccountHolderSuccessPayload'];
        ['...on BadRequestRejection']: ValueTypes['BadRequestRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['OnboardCompanyAccountHolderSuccessPayload']: AliasType<{
        onboarding?: ValueTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information on the shareholder. */
    ['OnboardCompanyShareholderInput']: {
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Name ("Dénomination sociale") of the shareholder. */
        name: string | Variable<any, string>;
        /** Information required for the onboarding of a company shareholder. */
        onboardingInfo: ValueTypes['OnboardCompanyAccountHolderInput'] | Variable<any, string>;
    };
    /** Inputs to onboard a new individual account holder */
    ['OnboardIndividualAccountHolderInput']: {
        /** Account name of the individual account holder. Length must be from 0 to 255 characters */
        accountName?: string | undefined | null | Variable<any, string>;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ValueTypes['AccountCountry'] | undefined | null | Variable<any, string>;
        /** Employment status of the individual account holder */
        employmentStatus?: ValueTypes['EmploymentStatus'] | undefined | null | Variable<any, string>;
        /** Monthly income of the individual account holder */
        monthlyIncome?: ValueTypes['MonthlyIncome'] | undefined | null | Variable<any, string>;
        /** Residency address of the individual account holder (must be in a European country) */
        residencyAddress?: ValueTypes['ResidencyAddressInput'] | undefined | null | Variable<any, string>;
        /** Email. Length must be from 0 to 255 characters */
        email?: string | undefined | null | Variable<any, string>;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined | null | Variable<any, string>;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined | null | Variable<any, string>;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ValueTypes['OAuthRedirectParametersInput'] | undefined | null | Variable<any, string>;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined | null | Variable<any, string>;
    };
    ['OnboardIndividualAccountHolderPayload']: AliasType<{
        ['...on OnboardIndividualAccountHolderSuccessPayload']: ValueTypes['OnboardIndividualAccountHolderSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['OnboardIndividualAccountHolderSuccessPayload']: AliasType<{
        onboarding?: ValueTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information on the shareholder. */
    ['OnboardIndividualShareholderInput']: {
        /** First name of the shareholder. */
        firstName: string | Variable<any, string>;
        /** Last name of the shareholder. */
        lastName: string | Variable<any, string>;
        /** Birthdate of the shareholder in the YYYY/MM/DD format. */
        birthDate: string | Variable<any, string>;
        /** CCA3 code for the country of nationality of the shareholder. */
        nationality: ValueTypes['CCA3'] | Variable<any, string>;
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** Information required for the onboarding of a individual shareholder. */
        onboardingInfo: ValueTypes['OnboardIndividualAccountHolderInput'] | Variable<any, string>;
    };
    /** Information provided during the onboarding process of an individual or a company */
    ['Onboarding']: AliasType<{
        /** Unique identifier of an onboarding */
        id?: boolean | `@${string}`;
        /** Account name */
        accountName?: boolean | `@${string}`;
        /** Account Country */
        accountCountry?: boolean | `@${string}`;
        /** Creation date */
        createdAt?: boolean | `@${string}`;
        /** Email */
        email?: boolean | `@${string}`;
        /** Finalization date */
        finalizedAt?: boolean | `@${string}`;
        /** Language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
        language?: boolean | `@${string}`;
        /** Information regarding the Individual or the company to onboard */
        info?: ValueTypes['OnboardingAccountHolderInfo'];
        /** Account holder created at the end of the onboarding process */
        accountHolder?: ValueTypes['AccountHolder'];
        /** Redirect the legal representative of a new account holder to this URL to start the onboarding process */
        onboardingUrl?: boolean | `@${string}`;
        /** Current computed state of onboarding */
        onboardingState?: boolean | `@${string}`;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl?: boolean | `@${string}`;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ValueTypes['OAuthRedirectParameters'];
        /** Status (valid/invalid/finalized) and details of errors on fields */
        statusInfo?: ValueTypes['OnboardingStatusInfo'];
        /** Swan TCU URL */
        tcuUrl?: boolean | `@${string}`;
        /** List of supporting document collection owned by the account holder. */
        supportingDocumentCollection?: ValueTypes['SupportingDocumentCollection'];
        /** Creation date */
        updatedAt?: boolean | `@${string}`;
        /** Account opened after the onboarding finalization */
        account?: ValueTypes['Account'];
        /** List of accepted identification level for the legal representative */
        legalRepresentativeAcceptedIdentificationLevels?: boolean | `@${string}`;
        /** Recommended identification level for the legal representative */
        legalRepresentativeRecommendedIdentificationLevel?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The onboarding could be for an Individual or a company */
    ['OnboardingAccountHolderInfo']: AliasType<{
        /** Account holder type */
        type?: boolean | `@${string}`;
        ['...on OnboardingCompanyAccountHolderInfo']?: Omit<ValueTypes['OnboardingCompanyAccountHolderInfo'], keyof ValueTypes['OnboardingAccountHolderInfo']>;
        ['...on OnboardingIndividualAccountHolderInfo']?: Omit<ValueTypes['OnboardingIndividualAccountHolderInfo'], keyof ValueTypes['OnboardingAccountHolderInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Company Account Holder Information */
    ['OnboardingCompanyAccountHolderInfo']: AliasType<{
        /** Account holder type (always Company for type OnboardingCompanyAccountHolderInfo) */
        type?: boolean | `@${string}`;
        /** name of the company */
        name?: boolean | `@${string}`;
        /** registration number of the company (SIRET, ...) */
        registrationNumber?: boolean | `@${string}`;
        /** legal form of the company (SAS, SCI, SASU, ...) */
        companyType?: boolean | `@${string}`;
        /** business activity */
        businessActivity?: boolean | `@${string}`;
        /** business activity description
    This must be 1024 characters long maximum. */
        businessActivityDescription?: boolean | `@${string}`;
        /** estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: boolean | `@${string}`;
        /** The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
    
    The ultimate beneficiary is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: ValueTypes['IndividualUltimateBeneficialOwner'];
        /** residency address of the head office (Must be in a European country) */
        residencyAddress?: ValueTypes['AddressInfo'];
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | `@${string}`;
        /** Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT */
        vatNumber?: boolean | `@${string}`;
        /** Tax Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ValueTypes['AddressInformation'];
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['OnboardingConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** OnboardingEdge list */
        edges?: ValueTypes['OnboardingEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['OnboardingEdge']: AliasType<{
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The Onboarding */
        node?: ValueTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing onboardings */
    ['OnboardingFiltersInput']: {
        /** Type/Types we want to filter on */
        types?: Array<ValueTypes['AccountHolderType']> | undefined | null | Variable<any, string>;
        /** Email we want to filter on */
        email?: string | undefined | null | Variable<any, string>;
        /** Searches company name, first name, last name */
        search?: string | undefined | null | Variable<any, string>;
        /** Status we want to filter on */
        status?: Array<ValueTypes['OnboardingStatus']> | undefined | null | Variable<any, string>;
    };
    /** StatusInfo when onboarding has been finalized */
    ['OnboardingFinalizedStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual Account Holder Information */
    ['OnboardingIndividualAccountHolderInfo']: AliasType<{
        /** Account holder type (always Individual for type OnboardingIndividualAccountHolderInfo) */
        type?: boolean | `@${string}`;
        /** employment status of the individual account holder */
        employmentStatus?: boolean | `@${string}`;
        /** monthly income of the individual account holder */
        monthlyIncome?: boolean | `@${string}`;
        /** residency address of the individual account holder (must be in a European country) */
        residencyAddress?: ValueTypes['AddressInfo'];
        /** Tax Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['OnboardingInfo']: AliasType<{
        /** Unique identifier of an onboarding */
        id?: boolean | `@${string}`;
        /** Account name */
        accountName?: boolean | `@${string}`;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: boolean | `@${string}`;
        /** email */
        email?: boolean | `@${string}`;
        /** language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
        language?: boolean | `@${string}`;
        /** Information regarding the Individual or the company to onboard */
        info?: ValueTypes['OnboardingAccountHolderInfo'];
        /** Redirect the legal representative of a new account holder to this URL to start the onboarding process */
        onboardingUrl?: boolean | `@${string}`;
        /** Current computed state of onboarding */
        onboardingState?: boolean | `@${string}`;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl?: boolean | `@${string}`;
        /** Project infos you set in the dashboard */
        projectInfo?: ValueTypes['ProjectInfo'];
        /** Verification Flow */
        verificationFlow?: boolean | `@${string}`;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ValueTypes['OAuthRedirectParameters'];
        /** Status (valid/invalid/finalized) and details of errors on fields */
        statusInfo?: ValueTypes['OnboardingStatusInfo'];
        /** Supporting document collection related to onboarding. */
        supportingDocumentCollection?: ValueTypes['SupportingDocumentCollection'];
        /** List of accepted identification level for the legal representative */
        legalRepresentativeAcceptedIdentificationLevels?: boolean | `@${string}`;
        /** Recommended identification level for the legal representative */
        legalRepresentativeRecommendedIdentificationLevel?: boolean | `@${string}`;
        /** Swan TCU URL */
        tcuUrl?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when onboarding has still at least one incorrect field */
    ['OnboardingInvalidStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        errors?: ValueTypes['ValidationError'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if an onboarding is not completed */
    ['OnboardingNotCompletedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        /** @deprecated(reason: "use `onboarding.id` instead") */
        onboardingId?: boolean | `@${string}`;
        onboarding?: ValueTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing onboardings */
    ['OnboardingOrderByFieldInput']: OnboardingOrderByFieldInput;
    /** Order that can be applied when listing onboardings */
    ['OnboardingOrderByInput']: {
        field?: ValueTypes['OnboardingOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Onboarding process state */
    ['OnboardingState']: OnboardingState;
    /** Possible values for onboarding status */
    ['OnboardingStatus']: OnboardingStatus;
    /** Object containing details about onboarding status (valid/invalid and why it is invalid/already finalized) */
    ['OnboardingStatusInfo']: AliasType<{
        /** Current onboarding status. Onboarding can only be finalized if status is "valid" */
        status?: boolean | `@${string}`;
        ['...on OnboardingFinalizedStatusInfo']?: Omit<ValueTypes['OnboardingFinalizedStatusInfo'], keyof ValueTypes['OnboardingStatusInfo']>;
        ['...on OnboardingInvalidStatusInfo']?: Omit<ValueTypes['OnboardingInvalidStatusInfo'], keyof ValueTypes['OnboardingStatusInfo']>;
        ['...on OnboardingValidStatusInfo']?: Omit<ValueTypes['OnboardingValidStatusInfo'], keyof ValueTypes['OnboardingStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when onboarding has all onboarding fields are correctly filled */
    ['OnboardingValidStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['OrderByDirection']: OrderByDirection;
    /** Implements PageInfo from the Relay Connections Specification - information about a page in the pagination mechanism */
    ['PageInfo']: AliasType<{
        /** Indicates whether more edges exist following this page */
        hasNextPage?: boolean | `@${string}`;
        /** Indicates whether more edges exist preceding this page */
        hasPreviousPage?: boolean | `@${string}`;
        /** Opaque identifier pointing to the first node of the page */
        startCursor?: boolean | `@${string}`;
        /** Opaque identifier pointing to the last node of the page */
        endCursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input version */
    ['PartnerCloseAccountReasonInput']: {
        type: ValueTypes['PartnerCloseAccountReasonType'] | Variable<any, string>;
        message?: string | undefined | null | Variable<any, string>;
    };
    /** Specific type for closing account action */
    ['PartnerCloseAccountReasonType']: PartnerCloseAccountReasonType;
    /** Partnership Status Accepted */
    ['PartnershipAcceptedStatusInfo']: AliasType<{
        /** Partnership status (always Accepted for type PartnershipAcceptedStatusInfo) */
        status?: boolean | `@${string}`;
        /** Accepted date of the partnership for this account */
        acceptedDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Partnership Status canceled */
    ['PartnershipCanceledStatusInfo']: AliasType<{
        /** Partnership status (always Canceled for type PartnershipCanceledStatusInfo) */
        status?: boolean | `@${string}`;
        /** Accepted date of the partnership for this account */
        acceptedDate?: boolean | `@${string}`;
        /** Canceled date of the partnership for this account */
        canceledDate?: boolean | `@${string}`;
        /** Reason of the cancelation */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Partnership Status currently cancelling */
    ['PartnershipCancelingStatusInfo']: AliasType<{
        /** Partnership status (always Canceling for type PartnershipCancelingStatusInfo) */
        status?: boolean | `@${string}`;
        /** Accepted date of the partnership for this account */
        acceptedDate?: boolean | `@${string}`;
        /** Canceled date of the partnership for this account */
        canceledAfter?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PartnershipStatus']: PartnershipStatus;
    /** Partnership Status information */
    ['PartnershipStatusInfo']: AliasType<{
        /** Status of the partnership for this account */
        status?: boolean | `@${string}`;
        ['...on PartnershipAcceptedStatusInfo']?: Omit<ValueTypes['PartnershipAcceptedStatusInfo'], keyof ValueTypes['PartnershipStatusInfo']>;
        ['...on PartnershipCanceledStatusInfo']?: Omit<ValueTypes['PartnershipCanceledStatusInfo'], keyof ValueTypes['PartnershipStatusInfo']>;
        ['...on PartnershipCancelingStatusInfo']?: Omit<ValueTypes['PartnershipCancelingStatusInfo'], keyof ValueTypes['PartnershipStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to a passport */
    ['PassportDocument']: AliasType<{
        /** Unique identifier of the passport document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** The date at which the passport was issued */
        issueDate?: boolean | `@${string}`;
        /** The date at which the passport expires */
        expiryDate?: boolean | `@${string}`;
        /** Machine-readable zone code of the passport */
        mrz?: boolean | `@${string}`;
        /** Number of the passport */
        number?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ValueTypes['PassportDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the passport document */
    ['PassportDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        /** From which side the passport's picture was taken */
        side?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** A Payment represents a set of transactions linked to the same payment act.
  
  This payment act can be initiated:
  - either from a user
  - either from a merchant
  - either from you
  - either from Swan */
    ['Payment']: AliasType<{
        /** unique identifier of a payment */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['PaymentStatusInfo'];
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['TransactionsOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['TransactionsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TransactionConnection']
        ];
        /** standing order that has initiated this payment */
        standingOrder?: ValueTypes['StandingOrder'];
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentAccountType']: PaymentAccountType;
    /** Please see the Connection interface */
    ['PaymentConnection']: AliasType<{
        pageInfo?: ValueTypes['PageInfo'];
        edges?: ValueTypes['PaymentEdge'];
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment status consent pending */
    ['PaymentConsentPending']: AliasType<{
        /** status of the payment */
        status?: boolean | `@${string}`;
        /** The consent required to initiate this payment */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentDirectDebitMandate']: AliasType<{
        /** Unique identifier of the Direct Debit Payment Mandate */
        id?: boolean | `@${string}`;
        ['...on InternalPaymentDirectDebitMandate']?: Omit<ValueTypes['InternalPaymentDirectDebitMandate'], keyof ValueTypes['PaymentDirectDebitMandate']>;
        ['...on SEPAPaymentDirectDebitMandate']?: Omit<ValueTypes['SEPAPaymentDirectDebitMandate'], keyof ValueTypes['PaymentDirectDebitMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['PaymentEdge']: AliasType<{
        node?: ValueTypes['Payment'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing payments */
    ['PaymentFiltersInput']: {
        status?: Array<ValueTypes['PaymentStatus']> | undefined | null | Variable<any, string>;
    };
    /** Payment status initiated */
    ['PaymentInitiated']: AliasType<{
        /** status of the payment */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment Level of the account */
    ['PaymentLevel']: PaymentLevel;
    ['PaymentLinkSequenceType']: PaymentLinkSequenceType;
    ['PaymentMandate']: AliasType<{
        /** Unique identifier of the Payment Mandate */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** number of elements in the list (default value 50) */
                first: number | Variable<any, string>; /** When the list of elements needs to start after a element */
                after?: string | undefined | null | Variable<any, string>; /** When the list of elements needs to be filtered */
                filters?: ValueTypes['TransactionsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TransactionConnection']
        ];
        /** Custom name of the mandate */
        name?: boolean | `@${string}`;
        /** Account Holder information */
        accountHolder?: ValueTypes['AccountHolder'];
        /** Creation date of the Payment Mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the Payment Mandate */
        updatedAt?: boolean | `@${string}`;
        /** Date of the the last transaction executed for the concerned Payment Mandate */
        executedAt?: boolean | `@${string}`;
        /** Expiry date of the Payment Mandate */
        expiredAt?: boolean | `@${string}`;
        /** Payment Mandate status information */
        statusInfo?: ValueTypes['PaymentMandateStatusInfo'];
        ['...on InternalPaymentDirectDebitMandate']?: Omit<ValueTypes['InternalPaymentDirectDebitMandate'], keyof ValueTypes['PaymentMandate']>;
        ['...on SEPAPaymentDirectDebitMandate']?: Omit<ValueTypes['SEPAPaymentDirectDebitMandate'], keyof ValueTypes['PaymentMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentMandateCanceledReason']: PaymentMandateCanceledReason;
    /** Payment Mandate Canceled status information */
    ['PaymentMandateCanceledStatusInfo']: AliasType<{
        /** Payment Mandate status (always Canceled for type PaymentMandateCanceledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason behind the Payment Mandate Canceled status */
        reason?: boolean | `@${string}`;
        /** Date of Cancellation of the mandate. */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['PaymentMandateConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** PaymentMandateEdge list */
        edges?: ValueTypes['PaymentMandateEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment Mandate Consent Pending status information */
    ['PaymentMandateConsentPendingStatusInfo']: AliasType<{
        /** Payment Mandate status (always Enabled for type PaymentMandateEnableedStatusInfo). */
        status?: boolean | `@${string}`;
        /** Consent information required to enable the concerned Payment Mandate */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentMandateCreditor']: AliasType<{
        /** Creditor UUID */
        id?: boolean | `@${string}`;
        /** Creditor name */
        name?: boolean | `@${string}`;
        /** Creditor address */
        address?: ValueTypes['Address'];
        ['...on InternalPaymentMandateCreditor']?: Omit<ValueTypes['InternalPaymentMandateCreditor'], keyof ValueTypes['PaymentMandateCreditor']>;
        ['...on SEPAPaymentMandateCreditor']?: Omit<ValueTypes['SEPAPaymentMandateCreditor'], keyof ValueTypes['PaymentMandateCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentMandateDebtor']: AliasType<{
        /** Debtor name */
        name?: boolean | `@${string}`;
        /** Debtor e-mail */
        email?: boolean | `@${string}`;
        /** Debtor country */
        country?: boolean | `@${string}`;
        ['...on InternalPaymentMandateDebtor']?: Omit<ValueTypes['InternalPaymentMandateDebtor'], keyof ValueTypes['PaymentMandateDebtor']>;
        ['...on SEPAPaymentMandateDebtor']?: Omit<ValueTypes['SEPAPaymentMandateDebtor'], keyof ValueTypes['PaymentMandateDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['PaymentMandateEdge']: AliasType<{
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The payment mandate */
        node?: ValueTypes['PaymentMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment Mandate Enabled status information */
    ['PaymentMandateEnabledStatusInfo']: AliasType<{
        /** Payment Mandate status (always Enabled for type PaymentMandateEnabledStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filter that can be passed to get the payment mandate in a specific data range */
    ['PaymentMandateFiltersInput']: {
        /** To filter on status values */
        status?: Array<ValueTypes['PaymentMandateStatus']> | undefined | null | Variable<any, string>;
        /** To filter on scheme values */
        scheme?: Array<ValueTypes['PaymentMandateScheme']> | undefined | null | Variable<any, string>;
    };
    /** Error returned if the payment mandate was not found */
    ['PaymentMandateMandateNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing payment mandate results */
    ['PaymentMandateOrderByFieldInput']: PaymentMandateOrderByFieldInput;
    /** Order that can be applied when listing payment mandate results */
    ['PaymentMandateOrderByInput']: {
        field?: ValueTypes['PaymentMandateOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Rejection returned if the payment mandate reference is already used for the same creditor */
    ['PaymentMandateReferenceAlreadyUsedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment Mandate Rejected status information */
    ['PaymentMandateRejectedStatusInfo']: AliasType<{
        /** Payment Mandate status (always Rejected for type PaymentMandateSuspendedStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentMandateScheme']: PaymentMandateScheme;
    /** Payment Mandate Sequence */
    ['PaymentMandateSequence']: PaymentMandateSequence;
    /** Payment Mandate status */
    ['PaymentMandateStatus']: PaymentMandateStatus;
    /** Payment Mandate status information */
    ['PaymentMandateStatusInfo']: AliasType<{
        /** Status of the payment mandate. */
        status?: boolean | `@${string}`;
        ['...on PaymentMandateCanceledStatusInfo']?: Omit<ValueTypes['PaymentMandateCanceledStatusInfo'], keyof ValueTypes['PaymentMandateStatusInfo']>;
        ['...on PaymentMandateConsentPendingStatusInfo']?: Omit<ValueTypes['PaymentMandateConsentPendingStatusInfo'], keyof ValueTypes['PaymentMandateStatusInfo']>;
        ['...on PaymentMandateEnabledStatusInfo']?: Omit<ValueTypes['PaymentMandateEnabledStatusInfo'], keyof ValueTypes['PaymentMandateStatusInfo']>;
        ['...on PaymentMandateRejectedStatusInfo']?: Omit<ValueTypes['PaymentMandateRejectedStatusInfo'], keyof ValueTypes['PaymentMandateStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when a payment method is not compatible for the requested mutation */
    ['PaymentMethodNotCompatibleRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing payment */
    ['PaymentOrderByFieldInput']: PaymentOrderByFieldInput;
    /** Order that can be applied when listing payments */
    ['PaymentOrderByInput']: {
        field?: ValueTypes['PaymentOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Payment product */
    ['PaymentProduct']: PaymentProduct;
    /** Payment status rejected */
    ['PaymentRejected']: AliasType<{
        /** status of the payment */
        status?: boolean | `@${string}`;
        /** rejected reason */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment status */
    ['PaymentStatus']: PaymentStatus;
    /** Payment Status Information */
    ['PaymentStatusInfo']: AliasType<{
        /** status of the payment */
        status?: boolean | `@${string}`;
        ['...on PaymentConsentPending']?: Omit<ValueTypes['PaymentConsentPending'], keyof ValueTypes['PaymentStatusInfo']>;
        ['...on PaymentInitiated']?: Omit<ValueTypes['PaymentInitiated'], keyof ValueTypes['PaymentStatusInfo']>;
        ['...on PaymentRejected']?: Omit<ValueTypes['PaymentRejected'], keyof ValueTypes['PaymentStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Custom information for a PDF statement */
    ['PdfStatement']: AliasType<{
        /** statement type */
        type?: boolean | `@${string}`;
        /** temporary public url on which the file can be accessed */
        url?: boolean | `@${string}`;
        /** date at which the link will not be useable anymore */
        expiresAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Consent when the account membership will be updated */
    ['PendingConsentAccountMembershipUpdate']: AliasType<{
        /** New account membership version waiting for consent */
        accountMembershipId?: ValueTypes['AccountMembership'];
        /** The consent required to update the account membership */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Digital Card used for ApplePay or GooglePay */
    ['PendingDigitalCard']: AliasType<{
        /** Unique identifier of a digital card */
        id?: boolean | `@${string}`;
        /** The type of digitalization that created this digital card. */
        type?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider?: ValueTypes['WalletProvider'];
        /** Digital Card status information
    
    In this type the status will be either ConsentPending or Pending */
        statusInfo?: ValueTypes['PendingDigitalCardStatusInfo'];
        inAppProvisioningData?: [
            {
                signatureData?: ValueTypes['SignatureData'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['InAppProvisioningData']
        ];
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Digital Card Status */
    ['PendingDigitalCardStatus']: PendingDigitalCardStatus;
    /** Pending Digital Card Status Information */
    ['PendingDigitalCardStatusInfo']: AliasType<{
        /** Status of the digital card. */
        status?: boolean | `@${string}`;
        ['...on DigitalCardConsentPendingStatusInfo']?: Omit<ValueTypes['DigitalCardConsentPendingStatusInfo'], keyof ValueTypes['PendingDigitalCardStatusInfo']>;
        ['...on DigitalCardDeclinedStatusInfo']?: Omit<ValueTypes['DigitalCardDeclinedStatusInfo'], keyof ValueTypes['PendingDigitalCardStatusInfo']>;
        ['...on DigitalCardPendingStatusInfo']?: Omit<ValueTypes['DigitalCardPendingStatusInfo'], keyof ValueTypes['PendingDigitalCardStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source Pending status information */
    ['PendingFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Pending status */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level that is pending for the process of the current identification, requiring an operation not related to the end-user to progress */
    ['PendingIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Pending` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** PendingMerchantPaymentMethodStatusInfo */
    ['PendingMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** PendingReviewMerchantProfileStatusInfo */
    ['PendingReviewMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Verification Information */
    ['PendingReviewStatusInfo']: AliasType<{
        /** Account verification status (PendingReview) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending transaction status information */
    ['PendingTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The date when the pending amount of this transaction is released on the available balance of this account if not booked */
        pendingEndDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Verification Information */
    ['PendingVerificationStatusInfo']: AliasType<{
        /** Account verification status (PendingVerification) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PermissionCannotBeGrantedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** E.164 standard format phone number
  
  Examples
  +551155256325
  +44207183875 */
    ['PhoneNumber']: unknown;
    /** Physical Card */
    ['PhysicalCard']: AliasType<{
        /** Physical Card status information */
        statusInfo?: ValueTypes['PhysicalCardStatusInfo'];
        /** Physical Card expiration date  with MM/YY string format */
        expiryDate?: boolean | `@${string}`;
        /** Unique identifier present on physical card, such identifier is null if the status is ToActivate or Canceled. This identifier is updated when a renewed card is activated */
        identifier?: boolean | `@${string}`;
        /** Offline Spending limit defined by Swan */
        offlineSpendingLimit?: ValueTypes['Amount'];
        /** Masked Card Number */
        cardMaskedNumber?: boolean | `@${string}`;
        /** Custom Options */
        customOptions?: ValueTypes['PhysicalCardCustomOptions'];
        /** every previous Physical Card information */
        previousPhysicalCards?: ValueTypes['BasicPhysicalCardInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Activated Status Information */
    ['PhysicalCardActivatedStatusInfo']: AliasType<{
        /** Physical Card status (always Activated for type PhysicalCardEnabledStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Canceled Status Information */
    ['PhysicalCardCanceledStatusInfo']: AliasType<{
        /** Physical Card status (always Canceled for type PhysicalCardCanceledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is canceled. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Canceling Status Information */
    ['PhysicalCardCancelingStatusInfo']: AliasType<{
        /** Physical Card status (always Canceling for type PhysicalCardCancelingStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is canceled. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PhysicalCardConfigInput']: {
        /** Address to deliver the physical card */
        deliveryAddress: ValueTypes['CompleteAddressInput'] | Variable<any, string>;
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: ValueTypes['PhysicalCardCustomOptionsInput'] | undefined | null | Variable<any, string>;
        /** `true` if the user must choose their PIN */
        choosePin?: boolean | undefined | null | Variable<any, string>;
    };
    /** when the user has to authorize production of the physical card */
    ['PhysicalCardConsentPendingStatusInfo']: AliasType<{
        /** Physical Card status (always ConsentPending for type PhysicalCardConsentPendingStatusInfo) */
        status?: boolean | `@${string}`;
        /** The consent required to authorize production of the physical card */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Custom options for physical card. */
    ['PhysicalCardCustomOptions']: AliasType<{
        /** Additional line embossed on the card. */
        additionalPrintedLine?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PhysicalCardCustomOptionsForGroupDeliveryInput']: {
        /** Additional line to be embossed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined | null | Variable<any, string>;
    };
    ['PhysicalCardCustomOptionsForPrintInput']: {
        /** Additional line to be printed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined | null | Variable<any, string>;
    };
    ['PhysicalCardCustomOptionsInput']: {
        /** Additional line to be embossed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined | null | Variable<any, string>;
    };
    /** Rejection returned when the Physical Card does not exist */
    ['PhysicalCardNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** when the physical card is in the process of being ready to use */
    ['PhysicalCardProcessingStatusInfo']: AliasType<{
        /** Physical card status (always Processing for type PhysicalCardProcessingStatusInfo) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Renewed Status Information */
    ['PhysicalCardRenewedStatusInfo']: AliasType<{
        /** Physical Card status (always Renewed for type PhysicalCardRenewedStatusInfo). */
        status?: boolean | `@${string}`;
        /** address to deliver the physical card */
        address?: ValueTypes['Address'];
        /** Estimated delivery date */
        estimatedDeliveryDate?: boolean | `@${string}`;
        /** Shipping tracking number */
        trackingNumber?: boolean | `@${string}`;
        /** Name of the shipping provider (Ex: LaPoste, DHL ...) */
        shippingProvider?: boolean | `@${string}`;
        /** `true` if PIN Code is available. */
        isPINReady?: boolean | `@${string}`;
        /** New physical Card info */
        newPhysicalCard?: ValueTypes['BasicPhysicalCardInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Status */
    ['PhysicalCardStatus']: PhysicalCardStatus;
    /** Physical Card Status Information */
    ['PhysicalCardStatusInfo']: AliasType<{
        /** Status of the physical card. */
        status?: boolean | `@${string}`;
        ['...on PhysicalCardActivatedStatusInfo']?: Omit<ValueTypes['PhysicalCardActivatedStatusInfo'], keyof ValueTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardCanceledStatusInfo']?: Omit<ValueTypes['PhysicalCardCanceledStatusInfo'], keyof ValueTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardCancelingStatusInfo']?: Omit<ValueTypes['PhysicalCardCancelingStatusInfo'], keyof ValueTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardConsentPendingStatusInfo']?: Omit<ValueTypes['PhysicalCardConsentPendingStatusInfo'], keyof ValueTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardProcessingStatusInfo']?: Omit<ValueTypes['PhysicalCardProcessingStatusInfo'], keyof ValueTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardRenewedStatusInfo']?: Omit<ValueTypes['PhysicalCardRenewedStatusInfo'], keyof ValueTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardSuspendedStatusInfo']?: Omit<ValueTypes['PhysicalCardSuspendedStatusInfo'], keyof ValueTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardToActivateStatusInfo']?: Omit<ValueTypes['PhysicalCardToActivateStatusInfo'], keyof ValueTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardToRenewStatusInfo']?: Omit<ValueTypes['PhysicalCardToRenewStatusInfo'], keyof ValueTypes['PhysicalCardStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Suspended Status Information */
    ['PhysicalCardSuspendedStatusInfo']: AliasType<{
        /** Physical Card status (always Suspended for type PhysicalCardSuspendedStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is suspended. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card To Activate Status Information */
    ['PhysicalCardToActivateStatusInfo']: AliasType<{
        /** Physical Card status (always ToActivate for type PhysicalCardToActivateStatusInfo). */
        status?: boolean | `@${string}`;
        /** address to deliver the physical card */
        address?: ValueTypes['Address'];
        /** Estimated delivery date */
        estimatedDeliveryDate?: boolean | `@${string}`;
        /** Shipping tracking number */
        trackingNumber?: boolean | `@${string}`;
        /** Name of the shipping provider (Ex: LaPoste, DHL ...) */
        shippingProvider?: boolean | `@${string}`;
        /** `true` if PIN Code is available. */
        isPINReady?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** when the physical card is in the process of being renewed */
    ['PhysicalCardToRenewStatusInfo']: AliasType<{
        /** Physical card status (always ToRenew for type PhysicalCardToRenewStatusInfo) */
        status?: boolean | `@${string}`;
        /** registered address to deliver the new physical card */
        address?: ValueTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Physical Card is not the expected status */
    ['PhysicalCardWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        expectedStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** 6 digits numeric passcode */
    ['PIN']: unknown;
    ['PINNotReadyRejection']: AliasType<{
        physicalCardIdentifier?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PreferredNotificationChannel']: PreferredNotificationChannel;
    ['PreProvisioningSUVCardSettings']: AliasType<{
        preProvisioningSUVCards?: boolean | `@${string}`;
        preProvisioningSUVNumberOfCards?: boolean | `@${string}`;
        ownerProvisioningSUVCards?: boolean | `@${string}`;
        preProvisioningSUVCardsAvailablePercentage?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to print a physical card */
    ['PrintPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
        /** Address to deliver the physical card */
        address: ValueTypes['CompleteAddressInput'] | Variable<any, string>;
        /** `true` if the user must choose their PIN Code (will be deprecated/removed) */
        choosePINCode: boolean | Variable<any, string>;
        /** `true` if the user must choose their PIN */
        choosePin?: boolean | undefined | null | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: ValueTypes['PhysicalCardCustomOptionsForPrintInput'] | undefined | null | Variable<any, string>;
    };
    ['PrintPhysicalCardPayload']: AliasType<{
        ['...on PrintPhysicalCardSuccessPayload']: ValueTypes['PrintPhysicalCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on AlreadyValidPhysicalCardRejection']: ValueTypes['AlreadyValidPhysicalCardRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on BadRequestRejection']: ValueTypes['BadRequestRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on CardProductNotApplicableToPhysicalCardsRejection']: ValueTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        ['...on CardProductDisabledRejection']: ValueTypes['CardProductDisabledRejection'];
        ['...on MissingMandatoryFieldRejection']: ValueTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['PrintPhysicalCardSuccessPayload']: AliasType<{
        /** The physicalCard created */
        physicalCard?: ValueTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
    ['ProductType']: ProductType;
    ['ProjectCardDesigns']: AliasType<{
        /** Unique identifier of a project */
        id?: boolean | `@${string}`;
        /** Visual Id from the issuing card processor (Monext) */
        issuingProcessorVisualId?: boolean | `@${string}`;
        /** Specific card product for companies */
        specificCardProductCodeForCompanies?: boolean | `@${string}`;
        /** Project name */
        name?: boolean | `@${string}`;
        /** Project card product designs */
        cardDesigns?: ValueTypes['CardProductDesign'];
        /** Project's pre provisioning suv card settings */
        preProvisioningSUVCardSettings?: ValueTypes['PreProvisioningSUVCardSettings'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectCardSettings']: AliasType<{
        /** Unique identifier of a project */
        id?: boolean | `@${string}`;
        /** Visual Id from the issuing card processor (Monext) */
        issuingProcessorVisualId?: boolean | `@${string}`;
        /** Specific card product for companies */
        specificCardProductCodeForCompanies?: boolean | `@${string}`;
        /** Project name */
        name?: boolean | `@${string}`;
        /** Project's card settings */
        cardSettings?: ValueTypes['CardSettings'];
        /** Project's pre provisioning suv card settings */
        preProvisioningSUVCardSettings?: ValueTypes['PreProvisioningSUVCardSettings'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Project Card Settings Background Type */
    ['ProjectCardSettingsBackgroundType']: ProjectCardSettingsBackgroundType;
    /** Card Status */
    ['ProjectCardStatus']: ProjectCardStatus;
    ['ProjectForbiddenRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Project Funding has been exceeded */
    ['ProjectFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Public information of a `Project` */
    ['ProjectInfo']: AliasType<{
        /** The card products associated with this project. */
        cardProducts?: ValueTypes['CardProduct'];
        /** the currently active card settings */
        activeCardSettings?: ValueTypes['CardSettings'];
        /** Unique identifier of the project */
        id?: boolean | `@${string}`;
        B2BMembershipIDVerification?: boolean | `@${string}`;
        supportingDocumentSettings?: ValueTypes['SupportingDocumentSettings'];
        /** Your project name displayed in white label interfaces and in the terms and conditions */
        name?: boolean | `@${string}`;
        /** The type of your project */
        type?: boolean | `@${string}`;
        /** URL of your logo */
        logoUri?: boolean | `@${string}`;
        /** Your accent color, used in white label interfaces. Most of the time for call to actions */
        accentColor?: boolean | `@${string}`;
        /** Your custom subdomain used in consents */
        customConsentSubdomain?: boolean | `@${string}`;
        /** Your OAuth client id */
        oAuthClientId?: boolean | `@${string}`;
        tcuDocumentUri?: [
            {
                /** this consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
                language: string | Variable<any, string>;
            },
            boolean | `@${string}`
        ];
        /** Unique id of your current Terms and Conditions of Use */
        tcuDocumentId?: boolean | `@${string}`;
        /** Web banking settings */
        webBankingSettings?: ValueTypes['WebBankingSettings'];
        /** Project status */
        status?: boolean | `@${string}`;
        /** Flag that determines if desktop authentication is enabled for this project */
        allowsDesktopAuthentication?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Project Instant Funding limit has been exceeded */
    ['ProjectInstantFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectInvalidStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectNotFound']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the project is not found */
    ['ProjectNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectSettingsForbiddenError']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectSettingsNotFound']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectSettingsStatusNotReachable']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectStatus']: ProjectStatus;
    ['ProjectType']: ProjectType;
    /** Rejection returned when the public onboarding is disabled */
    ['PublicOnboardingDisabledRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['Query']: AliasType<{
        fundingLimitSettingsChangeRequest?: [
            {
                fundingLimitSettingsChangeRequestId: string | Variable<any, string>;
            },
            ValueTypes['FundingLimitSettingsChangeRequest']
        ];
        ibanValidation?: [
            {
                input?: ValueTypes['IbanValidationInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['IbanValidationResult']
        ];
        accountHolder?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['AccountHolder']];
        accountHolders?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['AccountHolderFilterInput'] | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['AccountHolderOrderByInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['AccountHolderConnection']
        ];
        accountMembership?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['AccountMembership']];
        accountMemberships?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['AccountMembershipsFilterInput'] | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['AccountMembershipOrderByInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['AccountMembershipConnection']
        ];
        account?: [{
            accountId: string | Variable<any, string>;
        }, ValueTypes['Account']];
        accounts?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['AccountFilterInput'] | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['AccountOrderByInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['AccountConnection']
        ];
        beneficiaryVerification?: [
            {
                input?: ValueTypes['BeneficiaryVerificationInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['BeneficiaryVerificationResult']
        ];
        card?: [{
            cardId: string | Variable<any, string>;
        }, ValueTypes['Card']];
        cards?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['CardOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['CardFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['CardConnection']
        ];
        onboarding?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['Onboarding']];
        onboardings?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['OnboardingFiltersInput'] | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['OnboardingOrderByInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['OnboardingConnection']
        ];
        supportingDocumentCollection?: [
            {
                id: string | Variable<any, string>;
            },
            ValueTypes['SupportingDocumentCollection']
        ];
        accountStatement?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['Statement']];
        payment?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['Payment']];
        payments?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['PaymentOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['PaymentFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['PaymentConnection']
        ];
        transaction?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['Transaction']];
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['TransactionsOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['TransactionsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TransactionConnection']
        ];
        accountInvoice?: [{
            invoiceId: string | Variable<any, string>;
        }, ValueTypes['Invoice']];
        capitalDepositCase?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['CapitalDepositCase']];
        capitalDepositCases?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['CapitalDepositCaseFiltersInput'] | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections */
                orderBy?: ValueTypes['CapitalDepositCaseOrderByInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['CapitalDepositCaseConnection']
        ];
        capitalDepositDocument?: [
            {
                id: string | Variable<any, string>;
            },
            ValueTypes['CapitalDepositDocument']
        ];
        shareholder?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['Shareholder']];
        /** Returns the project infos you set in the dashboard. */
        projectInfo?: ValueTypes['ProjectInfo'];
        consent?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['Consent']];
        consents?: [
            {
                first: number | Variable<any, string>;
                after?: string | undefined | null | Variable<any, string>;
                filters?: ValueTypes['ConsentsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['ConsentConnection']
        ];
        user?: [{
            id?: string | undefined | null | Variable<any, string>;
        }, ValueTypes['User']];
        users?: [
            {
                after?: string | undefined | null | Variable<any, string>;
                before?: string | undefined | null | Variable<any, string>;
                filters?: ValueTypes['UserFilterInput'] | undefined | null | Variable<any, string>;
                first: number | Variable<any, string>; /** @deprecated(reason: "use the `search` field in `UserFilterInput`") */
                search?: string | undefined | null | Variable<any, string>;
            },
            ValueTypes['UserConnection']
        ];
        receivedDirectDebitMandate?: [
            {
                receivedDirectDebitMandateId: string | Variable<any, string>;
            },
            ValueTypes['ReceivedDirectDebitMandate']
        ];
        merchantProfile?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['MerchantProfile']];
        fundingSource?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['FundingSource']];
        internationalBeneficiaryDynamicForms?: [
            {
                amount: ValueTypes['AmountInput'] | Variable<any, string>;
                language?: ValueTypes['InternationalCreditTransferDisplayLanguage'] | undefined | null | Variable<any, string>;
                dynamicFields?: Array<ValueTypes['InternationalBeneficiaryDetailsInput']> | undefined | null | Variable<any, string>;
            },
            ValueTypes['InternationalBeneficiaryDynamicForms']
        ];
        internationalCreditTransferTransactionDetailsDynamicForm?: [
            {
                targetAmount: ValueTypes['AmountInput'] | Variable<any, string>;
                language?: ValueTypes['InternationalCreditTransferDisplayLanguage'] | undefined | null | Variable<any, string>;
                internationalBeneficiary: ValueTypes['InternationalBeneficiaryInput'] | Variable<any, string>;
                refreshableFields?: Array<ValueTypes['InternationalCreditTransferDetailsInput']> | undefined | null | Variable<any, string>;
            },
            ValueTypes['InternationalCreditTransferDynamicForm']
        ];
        internationalCreditTransferQuote?: [
            {
                accountId: string | Variable<any, string>;
                targetAmount: ValueTypes['AmountInput'] | Variable<any, string>;
                language?: ValueTypes['InternationalCreditTransferDisplayLanguage'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['InternationalCreditTransferQuote']
        ];
        standingOrder?: [
            {
                standingOrderId: string | Variable<any, string>;
            },
            ValueTypes['StandingOrder']
        ];
        webhookEventLog?: [{
            id: string | Variable<any, string>;
        }, ValueTypes['WebhookEventLog']];
        __typename?: boolean | `@${string}`;
    }>;
    ['RadioField']: AliasType<{
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        refreshDynamicFieldsOnChange?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        allowedValues?: ValueTypes['AllowedValue'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information that can be used to determine where the iban can be used */
    ['Reachability']: AliasType<{
        /** Can be used for instant transfer over SEPA */
        sepaCreditTransferInst?: boolean | `@${string}`;
        /** Can be used for direct debit over SEPA */
        sepaDirectDebitCore?: boolean | `@${string}`;
        /** Can be used for B2B direct debit over SEPA */
        sepaDirectDebitB2b?: boolean | `@${string}`;
        /** Can be used for transfer over SEPA (can be used in initiateCreditTransfer mutation) */
        sepaCreditTransfer?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Define a reason with a message */
    ['Reason']: AliasType<{
        message?: boolean | `@${string}`;
        ['...on CloseAccountReason']?: Omit<ValueTypes['CloseAccountReason'], keyof ValueTypes['Reason']>;
        ['...on SuspendAccountReason']?: Omit<ValueTypes['SuspendAccountReason'], keyof ValueTypes['Reason']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input version */
    ['ReasonInput']: {
        message?: string | undefined | null | Variable<any, string>;
    };
    /** Interface for Received Direct Debit Mandate */
    ['ReceivedDirectDebitMandate']: AliasType<{
        /** Unique identifier of the received direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        /** Version of the received direct debit mandate */
        version?: boolean | `@${string}`;
        /** Creation date of the received direct debit mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the received direct debit mandate */
        updatedAt?: boolean | `@${string}`;
        /** Date of signature of the received direct debit mandate */
        signatureDate?: boolean | `@${string}`;
        /** Date of the last direct debit transaction executed for the concerned received direct debit mandate */
        executedAt?: boolean | `@${string}`;
        /** Expiry date of the received direct debit mandate */
        expiredAt?: boolean | `@${string}`;
        /** Mandate status information of the received direct debit mandate */
        statusInfo?: ValueTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Mandate name */
        name?: boolean | `@${string}`;
        ['...on InternalReceivedDirectDebitMandate']?: Omit<ValueTypes['InternalReceivedDirectDebitMandate'], keyof ValueTypes['ReceivedDirectDebitMandate']>;
        ['...on SEPAReceivedDirectDebitMandate']?: Omit<ValueTypes['SEPAReceivedDirectDebitMandate'], keyof ValueTypes['ReceivedDirectDebitMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the received direct debit mandate already exist */
    ['ReceivedDirectDebitMandateAlreadyExistRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received direct debit mandate is canceled and therefore can't be enabled/suspended or updated */
    ['ReceivedDirectDebitMandateCanceledRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ReceivedDirectDebitMandateConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** ReceivedDirectDebitMandateEdge list */
        edges?: ValueTypes['ReceivedDirectDebitMandateEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['ReceivedDirectDebitMandateEdge']: AliasType<{
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The received direct debit mandate */
        node?: ValueTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the received direct debit mandate is not a B2b mandate */
    ['ReceivedDirectDebitMandateNotB2bRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Error returned if the received direct debit mandate was not found or if the user does not have the rights to receive information abo
  ut the existence of the received direct debit mandate */
    ['ReceivedDirectDebitMandateNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate Scheme */
    ['ReceivedDirectDebitMandateScheme']: ReceivedDirectDebitMandateScheme;
    /** Received Direct Debit Mandate Statuses */
    ['ReceivedDirectDebitMandateStatus']: ReceivedDirectDebitMandateStatus;
    /** Received Direct Debit Mandate status information */
    ['ReceivedDirectDebitMandateStatusInfo']: AliasType<{
        /** Received Direct Debit Mandate status */
        status?: boolean | `@${string}`;
        ['...on ReceivedDirectDebitMandateStatusInfoCanceled']?: Omit<ValueTypes['ReceivedDirectDebitMandateStatusInfoCanceled'], keyof ValueTypes['ReceivedDirectDebitMandateStatusInfo']>;
        ['...on ReceivedDirectDebitMandateStatusInfoConsentInitiationPending']?: Omit<ValueTypes['ReceivedDirectDebitMandateStatusInfoConsentInitiationPending'], keyof ValueTypes['ReceivedDirectDebitMandateStatusInfo']>;
        ['...on ReceivedDirectDebitMandateStatusInfoConsentPending']?: Omit<ValueTypes['ReceivedDirectDebitMandateStatusInfoConsentPending'], keyof ValueTypes['ReceivedDirectDebitMandateStatusInfo']>;
        ['...on ReceivedDirectDebitMandateStatusInfoEnabled']?: Omit<ValueTypes['ReceivedDirectDebitMandateStatusInfoEnabled'], keyof ValueTypes['ReceivedDirectDebitMandateStatusInfo']>;
        ['...on ReceivedDirectDebitMandateStatusInfoSuspended']?: Omit<ValueTypes['ReceivedDirectDebitMandateStatusInfoSuspended'], keyof ValueTypes['ReceivedDirectDebitMandateStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate Canceled status information */
    ['ReceivedDirectDebitMandateStatusInfoCanceled']: AliasType<{
        /** Received Direct Debit Mandate status (always Canceled for type ReceivedDirectDebitMandateStatusInfoCanceled) */
        status?: boolean | `@${string}`;
        /** Date of cancellation */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate ConsentInitiationPending status information */
    ['ReceivedDirectDebitMandateStatusInfoConsentInitiationPending']: AliasType<{
        /** Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate ConsentPending status information */
    ['ReceivedDirectDebitMandateStatusInfoConsentPending']: AliasType<{
        /** Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentPending) */
        status?: boolean | `@${string}`;
        /** The consent required to consent to a received direct debit mandate */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate Enabled status information */
    ['ReceivedDirectDebitMandateStatusInfoEnabled']: AliasType<{
        /** Received Direct Debit Mandate status (always Enabled for type ReceivedDirectDebitMandateStatusInfoEnabled) */
        status?: boolean | `@${string}`;
        /** Date at which the received direct debit mandate has been moved to the enabled status */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate Suspended status information */
    ['ReceivedDirectDebitMandateStatusInfoSuspended']: AliasType<{
        /** Received Direct Debit Mandate status (always Suspended for type ReceivedDirectDebitMandateStatusInfoSuspended) */
        status?: boolean | `@${string}`;
        /** Date of the last time the received direct debit mandate has been moved to the suspended status */
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to select the beneficiary and the originator to perform a refund */
    ['RefundInput']: {
        /** transactions to refund */
        refundTransactions: Array<ValueTypes['RefundTransaction']> | Variable<any, string>;
        /** url the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    /** The respond body to a refund mutation */
    ['RefundPayload']: AliasType<{
        ['...on RefundSuccessPayload']: ValueTypes['RefundSuccessPayload'];
        ['...on RefundRejection']: ValueTypes['RefundRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the transaction status is not correct for the desired action */
    ['RefundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        code?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Reason code that explains why we can't refund the transactions */
    ['RefundRejectionCode']: RefundRejectionCode;
    /** Consent generated by the refund mutation */
    ['RefundSuccessPayload']: AliasType<{
        /** optional consent that need to be validated for the refund to go through */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information about the transaction to refund */
    ['RefundTransaction']: {
        /** id of the transaction to refund */
        originTransactionId: string | Variable<any, string>;
        /** amount to refund in the same currency as the account */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
        /** reference assigned by the initiating party, to unambiguously identify the transaction.
    This reference is passed on, unchanged, throughout the entire end-to-end chain for credit transfers. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined | null | Variable<any, string>;
        /** label for the refund transaction (max 140 characters) */
        label?: string | undefined | null | Variable<any, string>;
        /** only used when the transaction was a credit transfer
    
    date when the credit transfer will be executed, if `null` the credit transfer is executed today */
        executionDate?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
    };
    /** Funding Source Rejected Reason */
    ['RejectedFundingSourceReason']: RejectedFundingSourceReason;
    /** Funding Source Rejected status information */
    ['RejectedFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Rejected status */
        status?: boolean | `@${string}`;
        /** Date at which the funding source was rejected */
        rejectedAt?: boolean | `@${string}`;
        /** Reason code of the rejection */
        reasonCode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** RejectedMerchantPaymentMethodStatusInfo */
    ['RejectedMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method rejected date */
        rejectedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** RejectedMerchantProfileStatusInfo */
    ['RejectedMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        rejectedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The following reason code for a rejected transaction are defined: */
    ['RejectedReasonCode']: RejectedReasonCode;
    /** Rejected transaction status information */
    ['RejectedTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** reason code */
        reason?: boolean | `@${string}`;
        /** `true` if the transaction had a fallback */
        hasFallback?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejected Verification Reason */
    ['RejectedVerificationReason']: RejectedVerificationReason;
    /** Rejected Information */
    ['RejectedVerificationStatusInfo']: AliasType<{
        /** Rejected Reason */
        reason?: boolean | `@${string}`;
        /** Date at which the verification was rejected */
        rejectedAt?: boolean | `@${string}`;
        /** Account verification status (Rejected) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['Rejection']: AliasType<{
        message?: boolean | `@${string}`;
        ['...on AccountHolderNotFoundRejection']?: Omit<ValueTypes['AccountHolderNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountHolderTypeIndividualRejection']?: Omit<ValueTypes['AccountHolderTypeIndividualRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountMembershipCannotBeDisabledRejection']?: Omit<ValueTypes['AccountMembershipCannotBeDisabledRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountMembershipCannotBeUpdatedRejection']?: Omit<ValueTypes['AccountMembershipCannotBeUpdatedRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountMembershipNotAllowedRejection']?: Omit<ValueTypes['AccountMembershipNotAllowedRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountMembershipNotFoundRejection']?: Omit<ValueTypes['AccountMembershipNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountMembershipNotReadyToBeBoundRejection']?: Omit<ValueTypes['AccountMembershipNotReadyToBeBoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountNotEligibleRejection']?: Omit<ValueTypes['AccountNotEligibleRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountNotFoundRejection']?: Omit<ValueTypes['AccountNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountVerificationAlreadyRejectedRejection']?: Omit<ValueTypes['AccountVerificationAlreadyRejectedRejection'], keyof ValueTypes['Rejection']>;
        ['...on AccountVerificationWrongStatusRejection']?: Omit<ValueTypes['AccountVerificationWrongStatusRejection'], keyof ValueTypes['Rejection']>;
        ['...on ActionNotAllowedRejection']?: Omit<ValueTypes['ActionNotAllowedRejection'], keyof ValueTypes['Rejection']>;
        ['...on AddingCardsToDifferentAccountsRejection']?: Omit<ValueTypes['AddingCardsToDifferentAccountsRejection'], keyof ValueTypes['Rejection']>;
        ['...on AlreadyValidPhysicalCardRejection']?: Omit<ValueTypes['AlreadyValidPhysicalCardRejection'], keyof ValueTypes['Rejection']>;
        ['...on ApplePayNotAllowedForProjectRejection']?: Omit<ValueTypes['ApplePayNotAllowedForProjectRejection'], keyof ValueTypes['Rejection']>;
        ['...on BadAccountStatusRejection']?: Omit<ValueTypes['BadAccountStatusRejection'], keyof ValueTypes['Rejection']>;
        ['...on BadRequestRejection']?: Omit<ValueTypes['BadRequestRejection'], keyof ValueTypes['Rejection']>;
        ['...on CannotActivatePhysicalCardRejection']?: Omit<ValueTypes['CannotActivatePhysicalCardRejection'], keyof ValueTypes['Rejection']>;
        ['...on CapitalDepositDocumentCanNotBeUploaded']?: Omit<ValueTypes['CapitalDepositDocumentCanNotBeUploaded'], keyof ValueTypes['Rejection']>;
        ['...on CapitalDepositDocumentCanNotBeUploadedRejection']?: Omit<ValueTypes['CapitalDepositDocumentCanNotBeUploadedRejection'], keyof ValueTypes['Rejection']>;
        ['...on CardCanNotBeDigitalizedRejection']?: Omit<ValueTypes['CardCanNotBeDigitalizedRejection'], keyof ValueTypes['Rejection']>;
        ['...on CardNotFoundRejection']?: Omit<ValueTypes['CardNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on CardProductDisabledRejection']?: Omit<ValueTypes['CardProductDisabledRejection'], keyof ValueTypes['Rejection']>;
        ['...on CardProductNotApplicableToPhysicalCardsRejection']?: Omit<ValueTypes['CardProductNotApplicableToPhysicalCardsRejection'], keyof ValueTypes['Rejection']>;
        ['...on CardProductNotFoundRejection']?: Omit<ValueTypes['CardProductNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on CardProductSuspendedRejection']?: Omit<ValueTypes['CardProductSuspendedRejection'], keyof ValueTypes['Rejection']>;
        ['...on CardProductUsedRejection']?: Omit<ValueTypes['CardProductUsedRejection'], keyof ValueTypes['Rejection']>;
        ['...on CardWrongStatusRejection']?: Omit<ValueTypes['CardWrongStatusRejection'], keyof ValueTypes['Rejection']>;
        ['...on CheckRejection']?: Omit<ValueTypes['CheckRejection'], keyof ValueTypes['Rejection']>;
        ['...on ConsentNotFoundRejection']?: Omit<ValueTypes['ConsentNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on ConsentsAlreadyLinkedToMultiConsentRejection']?: Omit<ValueTypes['ConsentsAlreadyLinkedToMultiConsentRejection'], keyof ValueTypes['Rejection']>;
        ['...on ConsentsNotAllInCreatedStatusRejection']?: Omit<ValueTypes['ConsentsNotAllInCreatedStatusRejection'], keyof ValueTypes['Rejection']>;
        ['...on ConsentsNotFoundRejection']?: Omit<ValueTypes['ConsentsNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on ConsentTypeNotSupportedByServerConsentRejection']?: Omit<ValueTypes['ConsentTypeNotSupportedByServerConsentRejection'], keyof ValueTypes['Rejection']>;
        ['...on DebtorAccountClosedRejection']?: Omit<ValueTypes['DebtorAccountClosedRejection'], keyof ValueTypes['Rejection']>;
        ['...on DebtorAccountNotAllowedRejection']?: Omit<ValueTypes['DebtorAccountNotAllowedRejection'], keyof ValueTypes['Rejection']>;
        ['...on DigitalCardNotFoundRejection']?: Omit<ValueTypes['DigitalCardNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on EnabledCardDesignNotFoundRejection']?: Omit<ValueTypes['EnabledCardDesignNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on ExternalAccountAlreadyExistsRejection']?: Omit<ValueTypes['ExternalAccountAlreadyExistsRejection'], keyof ValueTypes['Rejection']>;
        ['...on ExternalAccountBalanceAlreadyExistsRejection']?: Omit<ValueTypes['ExternalAccountBalanceAlreadyExistsRejection'], keyof ValueTypes['Rejection']>;
        ['...on FeeSettingsNotFoundRejection']?: Omit<ValueTypes['FeeSettingsNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on ForbiddenRejection']?: Omit<ValueTypes['ForbiddenRejection'], keyof ValueTypes['Rejection']>;
        ['...on FundingLimitExceededRejection']?: Omit<ValueTypes['FundingLimitExceededRejection'], keyof ValueTypes['Rejection']>;
        ['...on FundingLimitSettingsChangeRequestBadAmountRejection']?: Omit<ValueTypes['FundingLimitSettingsChangeRequestBadAmountRejection'], keyof ValueTypes['Rejection']>;
        ['...on FundingSourceNotFoundRejection']?: Omit<ValueTypes['FundingSourceNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on FundingSourceWrongStatusRejection']?: Omit<ValueTypes['FundingSourceWrongStatusRejection'], keyof ValueTypes['Rejection']>;
        ['...on GlobalFundingLimitExceededRejection']?: Omit<ValueTypes['GlobalFundingLimitExceededRejection'], keyof ValueTypes['Rejection']>;
        ['...on GlobalInstantFundingLimitExceededRejection']?: Omit<ValueTypes['GlobalInstantFundingLimitExceededRejection'], keyof ValueTypes['Rejection']>;
        ['...on IBANNotReachableRejection']?: Omit<ValueTypes['IBANNotReachableRejection'], keyof ValueTypes['Rejection']>;
        ['...on IBANNotValidRejection']?: Omit<ValueTypes['IBANNotValidRejection'], keyof ValueTypes['Rejection']>;
        ['...on IbanValidationRejection']?: Omit<ValueTypes['IbanValidationRejection'], keyof ValueTypes['Rejection']>;
        ['...on IdentityAlreadyBindToAccountMembershipRejection']?: Omit<ValueTypes['IdentityAlreadyBindToAccountMembershipRejection'], keyof ValueTypes['Rejection']>;
        ['...on InstantFundingLimitExceededRejection']?: Omit<ValueTypes['InstantFundingLimitExceededRejection'], keyof ValueTypes['Rejection']>;
        ['...on InsufficientFundsRejection']?: Omit<ValueTypes['InsufficientFundsRejection'], keyof ValueTypes['Rejection']>;
        ['...on InternalErrorRejection']?: Omit<ValueTypes['InternalErrorRejection'], keyof ValueTypes['Rejection']>;
        ['...on InvalidArgumentRejection']?: Omit<ValueTypes['InvalidArgumentRejection'], keyof ValueTypes['Rejection']>;
        ['...on InvalidPhoneNumberRejection']?: Omit<ValueTypes['InvalidPhoneNumberRejection'], keyof ValueTypes['Rejection']>;
        ['...on InvalidSirenNumberRejection']?: Omit<ValueTypes['InvalidSirenNumberRejection'], keyof ValueTypes['Rejection']>;
        ['...on LegalRepresentativeAccountMembershipCannotBeDisabledRejection']?: Omit<ValueTypes['LegalRepresentativeAccountMembershipCannotBeDisabledRejection'], keyof ValueTypes['Rejection']>;
        ['...on LegalRepresentativeAccountMembershipCannotBeSuspendedRejection']?: Omit<ValueTypes['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection'], keyof ValueTypes['Rejection']>;
        ['...on MerchantPaymentMethodNotActiveRejection']?: Omit<ValueTypes['MerchantPaymentMethodNotActiveRejection'], keyof ValueTypes['Rejection']>;
        ['...on MerchantProfileWrongStatusRejection']?: Omit<ValueTypes['MerchantProfileWrongStatusRejection'], keyof ValueTypes['Rejection']>;
        ['...on MissingMandatoryFieldRejection']?: Omit<ValueTypes['MissingMandatoryFieldRejection'], keyof ValueTypes['Rejection']>;
        ['...on NotFoundRejection']?: Omit<ValueTypes['NotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on NotReachableConsentStatusRejection']?: Omit<ValueTypes['NotReachableConsentStatusRejection'], keyof ValueTypes['Rejection']>;
        ['...on NotSupportedCountryRejection']?: Omit<ValueTypes['NotSupportedCountryRejection'], keyof ValueTypes['Rejection']>;
        ['...on OnboardingNotCompletedRejection']?: Omit<ValueTypes['OnboardingNotCompletedRejection'], keyof ValueTypes['Rejection']>;
        ['...on PaymentMandateMandateNotFoundRejection']?: Omit<ValueTypes['PaymentMandateMandateNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on PaymentMandateReferenceAlreadyUsedRejection']?: Omit<ValueTypes['PaymentMandateReferenceAlreadyUsedRejection'], keyof ValueTypes['Rejection']>;
        ['...on PaymentMethodNotCompatibleRejection']?: Omit<ValueTypes['PaymentMethodNotCompatibleRejection'], keyof ValueTypes['Rejection']>;
        ['...on PermissionCannotBeGrantedRejection']?: Omit<ValueTypes['PermissionCannotBeGrantedRejection'], keyof ValueTypes['Rejection']>;
        ['...on PhysicalCardNotFoundRejection']?: Omit<ValueTypes['PhysicalCardNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on PhysicalCardWrongStatusRejection']?: Omit<ValueTypes['PhysicalCardWrongStatusRejection'], keyof ValueTypes['Rejection']>;
        ['...on PINNotReadyRejection']?: Omit<ValueTypes['PINNotReadyRejection'], keyof ValueTypes['Rejection']>;
        ['...on ProjectForbiddenRejection']?: Omit<ValueTypes['ProjectForbiddenRejection'], keyof ValueTypes['Rejection']>;
        ['...on ProjectFundingLimitExceededRejection']?: Omit<ValueTypes['ProjectFundingLimitExceededRejection'], keyof ValueTypes['Rejection']>;
        ['...on ProjectInstantFundingLimitExceededRejection']?: Omit<ValueTypes['ProjectInstantFundingLimitExceededRejection'], keyof ValueTypes['Rejection']>;
        ['...on ProjectInvalidStatusRejection']?: Omit<ValueTypes['ProjectInvalidStatusRejection'], keyof ValueTypes['Rejection']>;
        ['...on ProjectNotFound']?: Omit<ValueTypes['ProjectNotFound'], keyof ValueTypes['Rejection']>;
        ['...on ProjectNotFoundRejection']?: Omit<ValueTypes['ProjectNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on ProjectSettingsForbiddenError']?: Omit<ValueTypes['ProjectSettingsForbiddenError'], keyof ValueTypes['Rejection']>;
        ['...on ProjectSettingsNotFound']?: Omit<ValueTypes['ProjectSettingsNotFound'], keyof ValueTypes['Rejection']>;
        ['...on ProjectSettingsStatusNotReachable']?: Omit<ValueTypes['ProjectSettingsStatusNotReachable'], keyof ValueTypes['Rejection']>;
        ['...on PublicOnboardingDisabledRejection']?: Omit<ValueTypes['PublicOnboardingDisabledRejection'], keyof ValueTypes['Rejection']>;
        ['...on ReceivedDirectDebitMandateAlreadyExistRejection']?: Omit<ValueTypes['ReceivedDirectDebitMandateAlreadyExistRejection'], keyof ValueTypes['Rejection']>;
        ['...on ReceivedDirectDebitMandateCanceledRejection']?: Omit<ValueTypes['ReceivedDirectDebitMandateCanceledRejection'], keyof ValueTypes['Rejection']>;
        ['...on ReceivedDirectDebitMandateNotB2bRejection']?: Omit<ValueTypes['ReceivedDirectDebitMandateNotB2bRejection'], keyof ValueTypes['Rejection']>;
        ['...on ReceivedDirectDebitMandateNotFoundRejection']?: Omit<ValueTypes['ReceivedDirectDebitMandateNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on RefundRejection']?: Omit<ValueTypes['RefundRejection'], keyof ValueTypes['Rejection']>;
        ['...on RestrictedToUserRejection']?: Omit<ValueTypes['RestrictedToUserRejection'], keyof ValueTypes['Rejection']>;
        ['...on SchemeWrongRejection']?: Omit<ValueTypes['SchemeWrongRejection'], keyof ValueTypes['Rejection']>;
        ['...on ServerConsentCredentialsNotValidOrOutdatedRejection']?: Omit<ValueTypes['ServerConsentCredentialsNotValidOrOutdatedRejection'], keyof ValueTypes['Rejection']>;
        ['...on ServerConsentNotAllowedForConsentOperationRejection']?: Omit<ValueTypes['ServerConsentNotAllowedForConsentOperationRejection'], keyof ValueTypes['Rejection']>;
        ['...on ServerConsentNotAllowedForProjectRejection']?: Omit<ValueTypes['ServerConsentNotAllowedForProjectRejection'], keyof ValueTypes['Rejection']>;
        ['...on ServerConsentProjectCredentialMissingRejection']?: Omit<ValueTypes['ServerConsentProjectCredentialMissingRejection'], keyof ValueTypes['Rejection']>;
        ['...on ServerConsentProjectCredentialNotFoundRejection']?: Omit<ValueTypes['ServerConsentProjectCredentialNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on ServerConsentProjectSettingsNotFoundRejection']?: Omit<ValueTypes['ServerConsentProjectSettingsNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on ServerConsentSignatureNotValidRejection']?: Omit<ValueTypes['ServerConsentSignatureNotValidRejection'], keyof ValueTypes['Rejection']>;
        ['...on StandingOrderNotFoundRejection']?: Omit<ValueTypes['StandingOrderNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on SupportingDocumentCollectionNotFoundRejection']?: Omit<ValueTypes['SupportingDocumentCollectionNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection']?: Omit<ValueTypes['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection'], keyof ValueTypes['Rejection']>;
        ['...on SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection']?: Omit<ValueTypes['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection'], keyof ValueTypes['Rejection']>;
        ['...on SupportingDocumentCollectionStatusNotAllowedRejection']?: Omit<ValueTypes['SupportingDocumentCollectionStatusNotAllowedRejection'], keyof ValueTypes['Rejection']>;
        ['...on SupportingDocumentNotFoundRejection']?: Omit<ValueTypes['SupportingDocumentNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on SupportingDocumentStatusDoesNotAllowDeletionRejection']?: Omit<ValueTypes['SupportingDocumentStatusDoesNotAllowDeletionRejection'], keyof ValueTypes['Rejection']>;
        ['...on SupportingDocumentStatusDoesNotAllowUpdateRejection']?: Omit<ValueTypes['SupportingDocumentStatusDoesNotAllowUpdateRejection'], keyof ValueTypes['Rejection']>;
        ['...on SupportingDocumentStatusNotAllowedRejection']?: Omit<ValueTypes['SupportingDocumentStatusNotAllowedRejection'], keyof ValueTypes['Rejection']>;
        ['...on SupportingDocumentUploadNotAllowedRejection']?: Omit<ValueTypes['SupportingDocumentUploadNotAllowedRejection'], keyof ValueTypes['Rejection']>;
        ['...on SuspendReceivedDirectDebitMandatedRejection']?: Omit<ValueTypes['SuspendReceivedDirectDebitMandatedRejection'], keyof ValueTypes['Rejection']>;
        ['...on SwanTCUDocumentNotFoundRejection']?: Omit<ValueTypes['SwanTCUDocumentNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on SwanTCUDocumentStatusNotAllowedRejection']?: Omit<ValueTypes['SwanTCUDocumentStatusNotAllowedRejection'], keyof ValueTypes['Rejection']>;
        ['...on TooManyChildConsentsRejection']?: Omit<ValueTypes['TooManyChildConsentsRejection'], keyof ValueTypes['Rejection']>;
        ['...on TooManyItemsRejection']?: Omit<ValueTypes['TooManyItemsRejection'], keyof ValueTypes['Rejection']>;
        ['...on TransactionNotFoundRejection']?: Omit<ValueTypes['TransactionNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on UpdateUserConsentSettingsTokenRejection']?: Omit<ValueTypes['UpdateUserConsentSettingsTokenRejection'], keyof ValueTypes['Rejection']>;
        ['...on UserNotAllowedToDisableItsOwnAccountMembershipRejection']?: Omit<ValueTypes['UserNotAllowedToDisableItsOwnAccountMembershipRejection'], keyof ValueTypes['Rejection']>;
        ['...on UserNotAllowedToManageAccountMembershipRejection']?: Omit<ValueTypes['UserNotAllowedToManageAccountMembershipRejection'], keyof ValueTypes['Rejection']>;
        ['...on UserNotAllowedToSuspendItsOwnAccountMembershipRejection']?: Omit<ValueTypes['UserNotAllowedToSuspendItsOwnAccountMembershipRejection'], keyof ValueTypes['Rejection']>;
        ['...on UserNotCardHolderRejection']?: Omit<ValueTypes['UserNotCardHolderRejection'], keyof ValueTypes['Rejection']>;
        ['...on ValidationRejection']?: Omit<ValueTypes['ValidationRejection'], keyof ValueTypes['Rejection']>;
        ['...on WebhookEventLogNotFoundRejection']?: Omit<ValueTypes['WebhookEventLogNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on WebhookSubscriptionNotFoundRejection']?: Omit<ValueTypes['WebhookSubscriptionNotFoundRejection'], keyof ValueTypes['Rejection']>;
        ['...on WrongValueProvidedRejection']?: Omit<ValueTypes['WrongValueProvidedRejection'], keyof ValueTypes['Rejection']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['ReleasedReason']: ReleasedReason;
    /** Released card transaction status information */
    ['ReleasedTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The date when the transaction was released */
        releaseDate?: boolean | `@${string}`;
        /** reason of the released transaction */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to replay a Webhook event */
    ['ReplayWebhookEventInput']: {
        /** The ID of a webhook Event */
        webhookEventId: string | Variable<any, string>;
    };
    /** Invoke Webhook Endpoint Payload */
    ['ReplayWebhookEventPayload']: AliasType<{
        ['...on ReplayWebhookEventSuccessPayload']: ValueTypes['ReplayWebhookEventSuccessPayload'];
        ['...on WebhookEventLogNotFoundRejection']: ValueTypes['WebhookEventLogNotFoundRejection'];
        ['...on WebhookSubscriptionNotFoundRejection']: ValueTypes['WebhookSubscriptionNotFoundRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on InvalidArgumentRejection']: ValueTypes['InvalidArgumentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Invoke Webhook Endpoint Success Payload */
    ['ReplayWebhookEventSuccessPayload']: AliasType<{
        webhookEventLogEntryId?: boolean | `@${string}`;
        endpointStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to a identification report */
    ['ReportDocument']: AliasType<{
        /** Unique identifier of the report document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ValueTypes['ReportDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the report document */
    ['ReportDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** here is the exchange rate detail */
    ['ReportExchangeRate']: AliasType<{
        sourceCurrency?: boolean | `@${string}`;
        exchangeRate?: boolean | `@${string}`;
        unitCurrency?: boolean | `@${string}`;
        targetCurrency?: boolean | `@${string}`;
        quotationDate?: boolean | `@${string}`;
        contractIdentification?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['RequestMerchantPaymentMethodsInput']: {
        /** ID of the Merchant Profile */
        merchantProfileId: string | Variable<any, string>;
        /** Input for the Internal Direct Debit Standard payment method */
        internalDirectDebitStandard?: ValueTypes['InternalDirectDebitStandardPaymentMethodInput'] | undefined | null | Variable<any, string>;
        /** Input for the Internal Direct Debit B2B payment method */
        internalDirectDebitB2B?: ValueTypes['InternalDirectDebitB2BPaymentMethodInput'] | undefined | null | Variable<any, string>;
        /** Input for the Sepa Direct Debit Core payment method */
        sepaDirectDebitCore?: ValueTypes['SepaDirectDebitCorePaymentMethodInput'] | undefined | null | Variable<any, string>;
        /** Input for the Sepa Direct Debit B2B payment method */
        sepaDirectDebitB2B?: ValueTypes['SepaDirectDebitB2BPaymentMethodInput'] | undefined | null | Variable<any, string>;
        /** Input for Check payment method */
        check?: ValueTypes['CheckPaymentMethodInput'] | undefined | null | Variable<any, string>;
        /** Input for Card payment method */
        card?: ValueTypes['CardPaymentMethodInput'] | undefined | null | Variable<any, string>;
    };
    ['RequestMerchantPaymentMethodsPayload']: AliasType<{
        ['...on RequestMerchantPaymentMethodsSuccessPayload']: ValueTypes['RequestMerchantPaymentMethodsSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: ValueTypes['NotFoundRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['RequestMerchantPaymentMethodsSuccessPayload']: AliasType<{
        merchantProfile?: ValueTypes['MerchantProfile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Request Update Merchant Profile */
    ['RequestMerchantProfileUpdate']: AliasType<{
        /** The Request ID */
        id?: boolean | `@${string}`;
        /** The Merchant Profile ID to update */
        merchantProfileId?: boolean | `@${string}`;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName?: boolean | `@${string}`;
        /** Url of the merchant's website */
        merchantWebsite?: boolean | `@${string}`;
        /** Url of the merchant's logo */
        merchantLogoUrl?: boolean | `@${string}`;
        /** The status of the request */
        status?: boolean | `@${string}`;
        /** Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType?: boolean | `@${string}`;
        /** Expected annual activity volumes for all payment method */
        expectedMonthlyPaymentVolume?: ValueTypes['Amount'];
        /** expected average basket value. */
        expectedAverageBasket?: ValueTypes['Amount'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to update a Merchant Profile */
    ['RequestMerchantProfileUpdateInput']: {
        /** ID of the MerchantProfile to update */
        merchantProfileId: string | Variable<any, string>;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string | Variable<any, string>;
        /** Url of the merchant's website.
    Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value. */
        merchantWebsite?: string | undefined | null | Variable<any, string>;
        /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: ValueTypes['ProductType'] | Variable<any, string>;
        /** Expected annual activity volumes for all payment methods. */
        expectedMonthlyPaymentVolume: ValueTypes['AmountInput'] | Variable<any, string>;
        /** expected average basket value. */
        expectedAverageBasket: ValueTypes['AmountInput'] | Variable<any, string>;
        /** base64 encoded merchant's logo.
    Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value. */
        merchantLogo?: string | undefined | null | Variable<any, string>;
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page.
    Unlike the other fields in this mutation, the value specified here updates the merchant profile's accent color immediately. */
        accentColor?: string | undefined | null | Variable<any, string>;
    };
    /** Add Merchant Profile Payload */
    ['RequestMerchantProfileUpdatePayload']: AliasType<{
        ['...on RequestMerchantProfileUpdateSuccessPayload']: ValueTypes['RequestMerchantProfileUpdateSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Request Merchant Profile Update Statuses */
    ['RequestMerchantProfileUpdateStatus']: RequestMerchantProfileUpdateStatus;
    /** Add Merchant Profile Success Payload */
    ['RequestMerchantProfileUpdateSuccessPayload']: AliasType<{
        /** Request Update Merchant Profile */
        requestMerchantProfileUpdate?: ValueTypes['RequestMerchantProfileUpdate'];
        __typename?: boolean | `@${string}`;
    }>;
    ['RequestSupportingDocumentCollectionReviewInput']: {
        /** Id of the supporting document collection to review. */
        supportingDocumentCollectionId: string | Variable<any, string>;
    };
    ['RequestSupportingDocumentCollectionReviewPayload']: AliasType<{
        ['...on RequestSupportingDocumentCollectionReviewSuccessPayload']: ValueTypes['RequestSupportingDocumentCollectionReviewSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on SupportingDocumentCollectionNotFoundRejection']: ValueTypes['SupportingDocumentCollectionNotFoundRejection'];
        ['...on SupportingDocumentCollectionStatusNotAllowedRejection']: ValueTypes['SupportingDocumentCollectionStatusNotAllowedRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['RequestSupportingDocumentCollectionReviewSuccessPayload']: AliasType<{
        supportingDocumentCollection?: ValueTypes['SupportingDocumentCollection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to a residence permit */
    ['ResidencePermitDocument']: AliasType<{
        /** Unique identifier of the residence permit document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** The date at which the residence permit was issued */
        issueDate?: boolean | `@${string}`;
        /** The date at which the residence permit expires */
        expiryDate?: boolean | `@${string}`;
        /** Machine-readable zone code of the residence permit */
        mrz?: boolean | `@${string}`;
        /** Number of the residence permit */
        number?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ValueTypes['ResidencePermitDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the resident permit document */
    ['ResidencePermitDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        /** From which side the residence permit's picture was taken */
        side?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ResidencyAddressInput']: {
        /** Address line 1. Length must be from 0 to 255 characters */
        addressLine1?: string | undefined | null | Variable<any, string>;
        /** AddressLine2. Length must be from 0 to 255 characters */
        addressLine2?: string | undefined | null | Variable<any, string>;
        /** City. Length must be from 0 to 100 characters */
        city?: string | undefined | null | Variable<any, string>;
        /** Postal code. Length must be from 0 to 50 characters */
        postalCode?: string | undefined | null | Variable<any, string>;
        /** State of residency. Length must be from 0 to 100 characters */
        state?: string | undefined | null | Variable<any, string>;
        /** Country */
        country?: ValueTypes['CCA3'] | undefined | null | Variable<any, string>;
    };
    /** Account membership restricted to */
    ['RestrictedTo']: AliasType<{
        /** first name */
        firstName?: boolean | `@${string}`;
        /** last name */
        lastName?: boolean | `@${string}`;
        /** birth date */
        birthDate?: boolean | `@${string}`;
        /** phone number */
        phoneNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input when the account membership is restricted to a verified user */
    ['RestrictedToInput']: {
        /** Account member first name */
        firstName: string | Variable<any, string>;
        /** Account member last name */
        lastName: string | Variable<any, string>;
        /** Account member birth date */
        birthDate?: ValueTypes['Date'] | undefined | null | Variable<any, string>;
        /** Account member phone number */
        phoneNumber: ValueTypes['PhoneNumber'] | Variable<any, string>;
    };
    /** Rejection returned if the mutation cannot be executed in another context than user */
    ['RestrictedToUserRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ResumeAccountMembershipInput']: {
        /** Unique identifier of a given account membership to resume */
        accountMembershipId: string | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    ['ResumeAccountMembershipPayload']: AliasType<{
        ['...on ResumeAccountMembershipSuccessPayload']: ValueTypes['ResumeAccountMembershipSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on UserNotAllowedToManageAccountMembershipRejection']: ValueTypes['UserNotAllowedToManageAccountMembershipRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ResumeAccountMembershipSuccessPayload']: AliasType<{
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to resume a physical card */
    ['ResumePhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    ['ResumePhysicalCardPayload']: AliasType<{
        ['...on ResumePhysicalCardSuccessPayload']: ValueTypes['ResumePhysicalCardSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on UserNotCardHolderRejection']: ValueTypes['UserNotCardHolderRejection'];
        ['...on PhysicalCardNotFoundRejection']: ValueTypes['PhysicalCardNotFoundRejection'];
        ['...on PhysicalCardWrongStatusRejection']: ValueTypes['PhysicalCardWrongStatusRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ResumePhysicalCardSuccessPayload']: AliasType<{
        /** The physicalCard to resume */
        physicalCard?: ValueTypes['PhysicalCard'];
        /** The consent required to resume a physical card */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Percentage over a number of business days, that is applied to all funds collected to compute a Reserved amount
  This amount cannot be used over the corresponding business days */
    ['RollingReserve']: AliasType<{
        /** Percentage of the funding amount to be reserved */
        percentage?: boolean | `@${string}`;
        /** Number of business days the computed amount is reserved */
        rollingDays?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ScheduleStandingOrderInput']: {
        /** Fix Amount that will be periodically transferred
         *the value must be empty when `targetAvailableBalance` is defined* */
        amount?: ValueTypes['AmountInput'] | undefined | null | Variable<any, string>;
        /** Target available balance that will be used for periodically clipping the account
         *the value must be empty when `amount` is defined* */
        targetAvailableBalance?: ValueTypes['AmountInput'] | undefined | null | Variable<any, string>;
        /** Scheduled period of Standing Order */
        period: ValueTypes['StandingOrderPeriod'] | Variable<any, string>;
        /** Earlier date the Standing Order will be executed */
        firstExecutionDate?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** Latest date the Standing Order will be executed */
        lastExecutionDate?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** SEPA beneficiary of the Standing ORder */
        sepaBeneficiary?: ValueTypes['SepaBeneficiaryInput'] | undefined | null | Variable<any, string>;
        /** Account the Standing Order will be attached to */
        accountId: string | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined | null | Variable<any, string>;
        /** label (max 140 characters) */
        label?: string | undefined | null | Variable<any, string>;
        /** Transfer mode of the Standing Order */
        creditTransferMode?: ValueTypes['CreditTransferMode'] | undefined | null | Variable<any, string>;
    };
    ['ScheduleStandingOrderPayload']: AliasType<{
        ['...on ScheduleStandingOrderSuccessPayload']: ValueTypes['ScheduleStandingOrderSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on InvalidArgumentRejection']: ValueTypes['InvalidArgumentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ScheduleStandingOrderSuccessPayload']: AliasType<{
        standingOrder?: ValueTypes['StandingOrder'];
        __typename?: boolean | `@${string}`;
    }>;
    ['Scheme']: AliasType<{
        fields?: ValueTypes['Field'];
        title?: boolean | `@${string}`;
        type?: boolean | `@${string}`;
        remainingFieldsToRefreshCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when adding a B2B mandate with an Individual debtor */
    ['SchemeWrongRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SelectField']: AliasType<{
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        refreshDynamicFieldsOnChange?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        allowedValues?: ValueTypes['AllowedValue'];
        __typename?: boolean | `@${string}`;
    }>;
    /** External Beneficiary type SEPA */
    ['SEPABeneficiary']: AliasType<{
        /** unique identifier of a beneficiary
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        id?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** `true` if this new beneficiary is the account holder himself in an other financial institution.
    *SOON TO BE DEPRECATED*
    Not used. It will be removed soon. */
        isMyOwnIban?: boolean | `@${string}`;
        /** beneficiary address */
        address?: ValueTypes['Address'];
        /** maskedIBAN if the beneficiary is a an account in an other financial institution */
        maskedIBAN?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa beneficiary account */
    ['SepaBeneficiaryInput']: {
        /** International Bank Account Number */
        iban: ValueTypes['IBAN'] | Variable<any, string>;
        /** Full name of the beneficiary (min 2 characters, max 70 characters). The name should not include any special characters. */
        name: string | Variable<any, string>;
        /** beneficiary address */
        address?: ValueTypes['AddressInput'] | undefined | null | Variable<any, string>;
        /** `true` if this new beneficiary is the account holder himself in another financial institution. */
        isMyOwnIban: boolean | Variable<any, string>;
        /** `true` if this new beneficiary will be saved to the beneficiary list of the debited account. */
        save: boolean | Variable<any, string>;
    };
    /** SEPA Creditor Identifier
  format :
      1 – 2: ISO Country Code
      3 – 4: Check Digit
      5 – 7: Creditor Business Code – you (Creditor) choose this. The default is ZZZ
      8 - 35: Creditor National Identifier – a consecutive number that will be assigned by country
  example:
      FR11ABC123456 */
    ['SepaCreditorIdentifier']: unknown;
    /** Sepa Credit Transfer Creditor */
    ['SEPACreditTransferCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        ['...on SEPACreditTransferInCreditor']?: Omit<ValueTypes['SEPACreditTransferInCreditor'], keyof ValueTypes['SEPACreditTransferCreditor']>;
        ['...on SEPACreditTransferInternalOutCreditor']?: Omit<ValueTypes['SEPACreditTransferInternalOutCreditor'], keyof ValueTypes['SEPACreditTransferCreditor']>;
        ['...on SEPACreditTransferOutCreditor']?: Omit<ValueTypes['SEPACreditTransferOutCreditor'], keyof ValueTypes['SEPACreditTransferCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Debtor */
    ['SEPACreditTransferDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        ['...on SEPACreditTransferInDebtor']?: Omit<ValueTypes['SEPACreditTransferInDebtor'], keyof ValueTypes['SEPACreditTransferDebtor']>;
        ['...on SEPACreditTransferInternalInDebtor']?: Omit<ValueTypes['SEPACreditTransferInternalInDebtor'], keyof ValueTypes['SEPACreditTransferDebtor']>;
        ['...on SEPACreditTransferOutDebtor']?: Omit<ValueTypes['SEPACreditTransferOutDebtor'], keyof ValueTypes['SEPACreditTransferDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Creditor for Incoming transaction */
    ['SEPACreditTransferInCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Debtor for Incoming transaction */
    ['SEPACreditTransferInDebtor']: AliasType<{
        /** full name of the debtor (max 70 characters) */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** *SOON TO BE DEPRECATED*
  Sepa Credit Transfer Debtor for Incoming transaction */
    ['SEPACreditTransferInternalInDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** *SOON TO BE DEPRECATED*
  Sepa Credit Transfer Creditor for internal transaction */
    ['SEPACreditTransferInternalOutCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ValueTypes['InternalBeneficiary'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Creditor for Outgoing transaction */
    ['SEPACreditTransferOutCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ValueTypes['SEPABeneficiary'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Debtor for internal transaction */
    ['SEPACreditTransferOutDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer transaction */
    ['SEPACreditTransferTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ValueTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ValueTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ValueTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ValueTypes['SEPACreditTransferCreditor'];
        /** debtor information */
        debtor?: ValueTypes['SEPACreditTransferDebtor'];
        /** matching account for the transaction */
        account?: ValueTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ValueTypes['Transaction'];
        /** r-transaction reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** SepaDirectDebitB2BMerchantPaymentMethod */
    ['SepaDirectDebitB2BMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ValueTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ValueTypes['RollingReserve'];
        /** Whether this payment method uses the Swan Sepa Creditor Identifier */
        useSwanSepaCreditorIdentifier?: boolean | `@${string}`;
        /** When the above is false, the value of the Sepa Creditor Identifier used */
        sepaCreditorIdentifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SepaDirectDebitB2BPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Enabled */
        activate?: boolean | undefined | null | Variable<any, string>;
        /** If `true`, the transaction will be created with the Swan Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean | Variable<any, string>;
        /** Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty) */
        sepaCreditorIdentifier?: string | undefined | null | Variable<any, string>;
    };
    /** SepaDirectDebitCoreMerchantPaymentMethod */
    ['SepaDirectDebitCoreMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ValueTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ValueTypes['RollingReserve'];
        /** Whether this payment method uses the Swan Sepa Creditor Identifier */
        useSwanSepaCreditorIdentifier?: boolean | `@${string}`;
        /** When the above is false, the value of the Sepa Creditor Identifier used */
        sepaCreditorIdentifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SepaDirectDebitCorePaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined | null | Variable<any, string>;
        /** If `true`, the transaction will be created with the Swan Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean | Variable<any, string>;
        /** Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty) */
        sepaCreditorIdentifier?: string | undefined | null | Variable<any, string>;
    };
    /** Sepa Direct Debit Creditor */
    ['SEPADirectDebitCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        ['...on SEPADirectDebitInCreditor']?: Omit<ValueTypes['SEPADirectDebitInCreditor'], keyof ValueTypes['SEPADirectDebitCreditor']>;
        ['...on SEPADirectDebitOutCreditor']?: Omit<ValueTypes['SEPADirectDebitOutCreditor'], keyof ValueTypes['SEPADirectDebitCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debit Debtor */
    ['SEPADirectDebitDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        ['...on SEPADirectDebitInDebtor']?: Omit<ValueTypes['SEPADirectDebitInDebtor'], keyof ValueTypes['SEPADirectDebitDebtor']>;
        ['...on SEPADirectDebitOutDebtor']?: Omit<ValueTypes['SEPADirectDebitOutDebtor'], keyof ValueTypes['SEPADirectDebitDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debit Creditor for Input transaction */
    ['SEPADirectDebitInCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debtor for Input transaction */
    ['SEPADirectDebitInDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ValueTypes['SEPABeneficiary'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SEPADirectDebitMandate']: AliasType<{
        /** Unique identifier of the received direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        ['...on SEPAPaymentDirectDebitMandate']?: Omit<ValueTypes['SEPAPaymentDirectDebitMandate'], keyof ValueTypes['SEPADirectDebitMandate']>;
        ['...on SEPAReceivedDirectDebitMandate']?: Omit<ValueTypes['SEPAReceivedDirectDebitMandate'], keyof ValueTypes['SEPADirectDebitMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debit Creditor for Outgoing transaction */
    ['SEPADirectDebitOutCreditor']: AliasType<{
        /** full name of the creditor (max 70 characters) */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ValueTypes['SEPABeneficiary'];
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debtor for Outgoing transaction */
    ['SEPADirectDebitOutDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SepaDirectDebitPaymentCollectionInput']: {
        /** Payment Mandate ID generated by Swan */
        mandateId: string | Variable<any, string>;
        /** Date at which the Swan merchant wishes the payment to be executed */
        requestedExecutionAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
    };
    /** Scheme that will be used to create the underlying payment mandate for this funding source */
    ['SEPADirectDebitScheme']: SEPADirectDebitScheme;
    /** Sepa Direct Debit transaction */
    ['SEPADirectDebitTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ValueTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ValueTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ValueTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ValueTypes['SEPADirectDebitCreditor'];
        /** debtor information */
        debtor?: ValueTypes['SEPADirectDebitDebtor'];
        /** matching account for the transaction */
        account?: ValueTypes['Account'];
        /** matching SEPA mandate for the transaction */
        mandate?: ValueTypes['SEPADirectDebitMandate'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ValueTypes['Transaction'];
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: ValueTypes['Amount'];
        /** date on which reserved funds become available. */
        reservedAmountReleasedAt?: boolean | `@${string}`;
        /** r-transaction reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment direct debit mandate for SEPA */
    ['SEPAPaymentDirectDebitMandate']: AliasType<{
        /** Unique identifier of the SEPA Direct Debit Payment Mandate */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['TransactionsOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['TransactionsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TransactionConnection']
        ];
        /** Unique reference of the SEPA Direct Debit Payment Mandate */
        reference?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate scheme */
        scheme?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate status information */
        statusInfo?: ValueTypes['PaymentMandateStatusInfo'];
        /** SEPA Direct Debit Payment Mandate sequence */
        sequence?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate PDF document URL */
        mandateDocumentUrl?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor information */
        debtor?: ValueTypes['SEPAPaymentMandateDebtor'];
        /** SEPA direct debit ultimate creditor name */
        ultimateCreditorName?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate creditor information */
        creditor?: ValueTypes['SEPAPaymentMandateCreditor'];
        /** Signature date of the SEPA Direct Debit Payment Mandate */
        signatureDate?: boolean | `@${string}`;
        /** Creation date of the SEPA Direct Debit Payment Mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the SEPA Direct Debit Payment Mandate */
        updatedAt?: boolean | `@${string}`;
        /** Date of the the last transaction executed for the concerned SEPA Direct Debit Payment Mandate */
        executedAt?: boolean | `@${string}`;
        /** Expiry date of the SEPA Direct Debit Payment Mandate */
        expiredAt?: boolean | `@${string}`;
        /** Account Holder information */
        accountHolder?: ValueTypes['AccountHolder'];
        /** Custom name of the mandate */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SEPAPaymentMandateCreditor']: AliasType<{
        /** SEPA Direct Debit Payment Mandate creditor UUID */
        id?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate Sepa Creditor Idenfier (SCI) */
        identifier?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate creditor name */
        name?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate creditor address */
        address?: ValueTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SEPAPaymentMandateDebtor']: AliasType<{
        /** SEPA Direct Debit Payment Mandate debtor name */
        name?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor IBAN */
        iban?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor e-mail */
        email?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor country */
        country?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        address?: ValueTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SepaPaymentMandateDebtorInput']: {
        /** SEPA Direct Debit Payment Mandate debtor name */
        name: string | Variable<any, string>;
        /** SEPA Direct Debit Payment Mandate debtor IBAN */
        IBAN: string | Variable<any, string>;
        address: ValueTypes['AddressInput'] | Variable<any, string>;
    };
    ['SEPAPaymentMandateScheme']: SEPAPaymentMandateScheme;
    /** SEPA Direct Debit Payment Mandate Sequence */
    ['SEPAPaymentMandateSequence']: SEPAPaymentMandateSequence;
    /** Received direct debit mandate for SEPA */
    ['SEPAReceivedDirectDebitMandate']: AliasType<{
        /** Unique identifier of the received SEPA direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['TransactionsOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['TransactionsFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['TransactionConnection']
        ];
        /** Version of the received SEPA direct debit mandate */
        version?: boolean | `@${string}`;
        /** Creation date of the received SEPA direct debit mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the received SEPA direct debit mandate */
        updatedAt?: boolean | `@${string}`;
        /** Received SEPA direct debit Unique Mandate Reference (UMR) */
        reference?: boolean | `@${string}`;
        /** Received SEPA direct debit mandate scheme */
        scheme?: boolean | `@${string}`;
        /** Received SEPA direct debit mandate sequence */
        sequence?: boolean | `@${string}`;
        /** Received SEPA direct debit creditor */
        creditor?: ValueTypes['SEPAReceivedDirectDebitMandateCreditor'];
        /** Received SEPA direct debit ultimate creditor name */
        ultimateCreditorName?: boolean | `@${string}`;
        /** Date of the last SEPA direct debit transaction executed for the concerned received SEPA direct debit mandate */
        executedAt?: boolean | `@${string}`;
        /** Date of signature of the received SEPA direct debit mandate */
        signatureDate?: boolean | `@${string}`;
        /** Expiry date of the received SEPA direct debit mandate, computed automatically (36 months from the executedAt date) */
        expiredAt?: boolean | `@${string}`;
        /** Mandate status information of the received SEPA direct debit mandate */
        statusInfo?: ValueTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Account of the received SEPA direct debit mandate debtor */
        account?: ValueTypes['Account'];
        /** Iban of the received SEPA direct debit mandate debtor */
        iban?: boolean | `@${string}`;
        /** Mandate name */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** SEPA received direct debit mandate creditor */
    ['SEPAReceivedDirectDebitMandateCreditor']: AliasType<{
        /** SEPA Creditor identifier (SCI) */
        identifier?: boolean | `@${string}`;
        /** Name of the SEPA creditor */
        name?: boolean | `@${string}`;
        /** Address of the SEPA creditor */
        address?: ValueTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Received SEPA direct debit mandate scheme */
    ['SEPAReceivedDirectDebitMandateScheme']: SEPAReceivedDirectDebitMandateScheme;
    /** SEPA received direct debit mandate sequence */
    ['SEPAReceivedDirectDebitMandateSequence']: SEPAReceivedDirectDebitMandateSequence;
    /** SEPA Identifier
  max 35 Latin characters as follow :
      a b c d e f g h i j k l m n o p q r s t u v w x y z
      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
      0 1 2 3 4 5 6 7 8 9
      / - ? : ( ) . , '  +
  with some follow extra rules :
      Content must not start or end with a ‘/’
      Content must not contain ‘//’s */
    ['SepaReference']: unknown;
    /** Rejection returned when signature is not valid or remote IP address is not allowed */
    ['ServerConsentCredentialsNotValidOrOutdatedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when server consent is not allowed on the consent */
    ['ServerConsentNotAllowedForConsentOperationRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when server consent is not allowed for the project associated with the consent */
    ['ServerConsentNotAllowedForProjectRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when there are no server consent credentials for the project */
    ['ServerConsentProjectCredentialMissingRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the server consent project credentials are not found */
    ['ServerConsentProjectCredentialNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the server consent project settings are not found */
    ['ServerConsentProjectSettingsNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the signature is not valid
  @Deprecated */
    ['ServerConsentSignatureNotValidRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Shareholder of a company creating a Capital Deposit Case */
    ['Shareholder']: AliasType<{
        /** Unique identifier of a shareholder. */
        id?: boolean | `@${string}`;
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount?: ValueTypes['Amount'];
        /** Onboarding information of the shareholder. */
        onboarding?: ValueTypes['Onboarding'];
        /** Unique identifier of the shareholder account. */
        accountId?: boolean | `@${string}`;
        /** Status of the shareholder during the process with Swan. */
        status?: boolean | `@${string}`;
        /** Extra information about the shareholder */
        info?: ValueTypes['ShareholderInfo'];
        /** Shareholder documents for the capital deposit case */
        documents?: ValueTypes['CapitalDepositDocument'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Information about capital deposit case. */
        relatedCapitalDepositCase?: ValueTypes['CapitalDepositCase'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Shareholder information. */
    ['ShareholderInfo']: AliasType<{
        ['...on IndividualShareholder']: ValueTypes['IndividualShareholder'];
        ['...on CompanyShareholder']: ValueTypes['CompanyShareholder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Status of the shareholder during the process with Swan. */
    ['ShareholderStatus']: ShareholderStatus;
    /** Shareholder type to identify individuals and companies. */
    ['ShareholderType']: ShareholderType;
    /** Signature data used during apple pay inApp provisioning */
    ['SignatureData']: {
        /** nonce */
        nonce: string | Variable<any, string>;
        /** nonce signed by the secure element */
        nonceSignature: string | Variable<any, string>;
        /** list of apple generated certificates */
        certificates: Array<ValueTypes['Certificate']> | Variable<any, string>;
    };
    ['SimulationCardType']: SimulationCardType;
    ['SingleUseVirtualCardConfigInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string | Variable<any, string>;
        /** Card name */
        name?: string | undefined | null | Variable<any, string>;
        /** Spending limit */
        spendingLimit: ValueTypes['SpendingLimitInput'] | Variable<any, string>;
    };
    /** Spending */
    ['Spending']: AliasType<{
        /** period concerned */
        period?: boolean | `@${string}`;
        /** amount spent during the period */
        amount?: ValueTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Spending limits */
    ['SpendingLimit']: AliasType<{
        /** type of limit (defined by the Partner, defined by Swan, etc.) */
        type?: boolean | `@${string}`;
        /** period concerned */
        period?: boolean | `@${string}`;
        /** sum of amount of spending authorized during the period */
        amount?: ValueTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs when editing spending limit configuration */
    ['SpendingLimitInput']: {
        /** period concerned */
        period: ValueTypes['SpendingLimitPeriodInput'] | Variable<any, string>;
        /** sum of amount of spending authorized during the period */
        amount: ValueTypes['AmountInput'] | Variable<any, string>;
    };
    /** Available period to compute spending limits */
    ['SpendingLimitPeriod']: SpendingLimitPeriod;
    /** Available period to compute spending limits */
    ['SpendingLimitPeriodInput']: SpendingLimitPeriodInput;
    /** Available type of spending limits */
    ['SpendingLimitType']: SpendingLimitType;
    ['StandingOrder']: AliasType<{
        /** Standing Order unique identifier */
        id?: boolean | `@${string}`;
        payments?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                offset?: number | undefined | null | Variable<any, string>; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ValueTypes['PaymentOrderByInput'] | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['PaymentFiltersInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['PaymentConnection']
        ];
        /** reference that will be transferred to the beneficiary throughout the entire end-to-end chain */
        reference?: boolean | `@${string}`;
        /** label that will be transferred to the beneficiary */
        label?: boolean | `@${string}`;
        /** Fixed Amount that will be regularly transferred */
        amount?: ValueTypes['Amount'];
        /** Target available balance value that will be used for periodically clipping the account */
        targetAvailableBalance?: ValueTypes['Amount'];
        /** Scheduled period of Standing Order */
        period?: boolean | `@${string}`;
        /** Earlier date the Standing Order will be executed */
        firstExecutionDate?: boolean | `@${string}`;
        /** Latest date the Standing Order will be executed */
        lastExecutionDate?: boolean | `@${string}`;
        /** SEPA beneficiary of the Standing Order */
        sepaBeneficiary?: ValueTypes['SEPABeneficiary'];
        /** Status of the Standing Order */
        statusInfo?: ValueTypes['StandingOrderStatusInfo'];
        /** Date the Standing Order has been created */
        createdAt?: boolean | `@${string}`;
        /** Last date the Standing Order has been updated */
        updatedAt?: boolean | `@${string}`;
        /** Account of the Standing Order */
        account?: ValueTypes['Account'];
        /** Identity that scheduled the Standing Order */
        createdBy?: ValueTypes['User'];
        /** Next execution date of the Standing Order, if any */
        nextExecutionDate?: boolean | `@${string}`;
        /** Transfer mode of the Standing Order */
        creditTransferMode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['StandingOrderCanceledStatusInfo']: AliasType<{
        canceledAt?: boolean | `@${string}`;
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['StandingOrderConnection']: AliasType<{
        pageInfo?: ValueTypes['PageInfo'];
        edges?: ValueTypes['StandingOrderEdge'];
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['StandingOrderConsentPendingStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['StandingOrderEdge']: AliasType<{
        node?: ValueTypes['StandingOrder'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['StandingOrderEnabledStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when Standing Order is not found */
    ['StandingOrderNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['StandingOrderPeriod']: StandingOrderPeriod;
    ['StandingOrderStatus']: StandingOrderStatus;
    ['StandingOrderStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        ['...on StandingOrderCanceledStatusInfo']?: Omit<ValueTypes['StandingOrderCanceledStatusInfo'], keyof ValueTypes['StandingOrderStatusInfo']>;
        ['...on StandingOrderConsentPendingStatusInfo']?: Omit<ValueTypes['StandingOrderConsentPendingStatusInfo'], keyof ValueTypes['StandingOrderStatusInfo']>;
        ['...on StandingOrderEnabledStatusInfo']?: Omit<ValueTypes['StandingOrderEnabledStatusInfo'], keyof ValueTypes['StandingOrderStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level that has started for the process of the current identification */
    ['StartedIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Started` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** A statement represent metadata around a banking document that list all of the BOOKED banking transactions that have happened between startDate and endDate */
    ['Statement']: AliasType<{
        /** unique identifier of the statement */
        id?: boolean | `@${string}`;
        /** account of the statement */
        account?: ValueTypes['Account'];
        /** booked balance at the start of the window */
        openingBalance?: ValueTypes['Amount'];
        /** booked balance at the end of the window */
        closingBalance?: ValueTypes['Amount'];
        /** starting date of the date window */
        openingDate?: boolean | `@${string}`;
        /** ending date of the date window */
        closingDate?: boolean | `@${string}`;
        /** status of the statement */
        status?: boolean | `@${string}`;
        /** period of statement (either custom or monthly) */
        period?: boolean | `@${string}`;
        /** the sum of credit transactions during the window */
        totalCredits?: ValueTypes['Amount'];
        /** the sum of debit transactions during the window */
        totalDebits?: ValueTypes['Amount'];
        /** the sum of fee transactions during the window */
        fees?: ValueTypes['Amount'];
        /** type of statements (ex: PDF) */
        type?: ValueTypes['StatementInfo'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)). */
    ['StatementConnection']: AliasType<{
        pageInfo?: ValueTypes['PageInfo'];
        totalCount?: boolean | `@${string}`;
        edges?: ValueTypes['StatementEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface. */
    ['StatementEdge']: AliasType<{
        node?: ValueTypes['Statement'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filter that can be given to give the statement in a specific data range */
    ['StatementFiltersInput']: {
        /** To filter after an updatedAt value */
        isAfterUpdatedAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** To filter before an updatedAt value */
        isBeforeUpdatedAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** To filter on a specific period of statement (either custom or monthly) */
        period?: ValueTypes['StatementPeriod'] | undefined | null | Variable<any, string>;
    };
    /** Custom information for a certain type of statement */
    ['StatementInfo']: AliasType<{
        type?: boolean | `@${string}`;
        ['...on CsvStatement']?: Omit<ValueTypes['CsvStatement'], keyof ValueTypes['StatementInfo']>;
        ['...on PdfStatement']?: Omit<ValueTypes['PdfStatement'], keyof ValueTypes['StatementInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** The different periods of statement */
    ['StatementPeriod']: StatementPeriod;
    /** The different statuses of statement */
    ['StatementStatus']: StatementStatus;
    /** The different type of statement actually available
  - PDF will be a PDF file with the statement information */
    ['StatementType']: StatementType;
    ['StatusText']: StatusText;
    /** Supporting document used for compliance */
    ['SupportingDocument']: AliasType<{
        /** Unique identifier of the document */
        id?: boolean | `@${string}`;
        /** Supporting document status information */
        statusInfo?: ValueTypes['SupportingDocumentStatusInfo'];
        /** Type of supporting Document */
        supportingDocumentType?: boolean | `@${string}`;
        /** Purpose of supporting document */
        supportingDocumentPurpose?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentAccountHolder']: AliasType<{
        id?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Collection of supporting documents used for compliance
  
  Fetching SupportingDocument is restricted to Project access token */
    ['SupportingDocumentCollection']: AliasType<{
        /** Unique identifier of the supporting document collection */
        id?: boolean | `@${string}`;
        /** Status of the supporting document collection */
        statusInfo?: ValueTypes['SupportingDocumentCollectionStatusInfo'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** List of supported documents contained in the supporting document collection */
        supportingDocuments?: ValueTypes['SupportingDocument'];
        /** List of required supporting document purposes for this supporting document collection */
        requiredSupportingDocumentPurposes?: ValueTypes['SupportingDocumentPurpose'];
        accountHolder?: ValueTypes['SupportingDocumentAccountHolder'];
        onboarding?: ValueTypes['SupportingDocumentOnboarding'];
        projectInfo?: ValueTypes['ProjectInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with Approved status */
    ['SupportingDocumentCollectionApprovedStatusInfo']: AliasType<{
        /** When the supporting document collection is approved */
        status?: boolean | `@${string}`;
        /** Date on which the supporting document collection has been approved */
        approvedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with Canceled status */
    ['SupportingDocumentCollectionCanceledStatusInfo']: AliasType<{
        /** When the supporting document collection is canceled */
        status?: boolean | `@${string}`;
        /** Date on which the supporting document collection has been canceled */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['SupportingDocumentCollectionConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** SupportingDocumentCollectionEdge list */
        edges?: ValueTypes['SupportingDocumentCollectionEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['SupportingDocumentCollectionEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The supporting document collection */
        node?: ValueTypes['SupportingDocumentCollection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the supporting document collection was not found */
    ['SupportingDocumentCollectionNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with PendingReview status */
    ['SupportingDocumentCollectionPendingReviewStatusInfo']: AliasType<{
        /** When the supporting document collection is completed and in compliance review */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with Rejected status */
    ['SupportingDocumentCollectionRejectedStatusInfo']: AliasType<{
        /** When the supporting document collection is rejected */
        status?: boolean | `@${string}`;
        /** Date on which the supporting document collection has been rejected */
        rejectedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Verification status of a supporting document collection */
    ['SupportingDocumentCollectionStatus']: SupportingDocumentCollectionStatus;
    /** Rejection returned if supporting document cannot be deleted because its supporting document collection status is not WaitingForDocument */
    ['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection']: AliasType<{
        message?: boolean | `@${string}`;
        supportingDocumentCollectionStatus?: boolean | `@${string}`;
        supportingDocumentCollection?: ValueTypes['SupportingDocumentCollection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if supporting document cannot be updated because its supporting document collection status is not WaitingForDocument */
    ['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection']: AliasType<{
        message?: boolean | `@${string}`;
        supportingDocumentCollectionStatus?: boolean | `@${string}`;
        supportingDocumentCollection?: ValueTypes['SupportingDocumentCollection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentCollectionStatusInfo']: AliasType<{
        /** Status of the supporting document collection */
        status?: boolean | `@${string}`;
        ['...on SupportingDocumentCollectionApprovedStatusInfo']?: Omit<ValueTypes['SupportingDocumentCollectionApprovedStatusInfo'], keyof ValueTypes['SupportingDocumentCollectionStatusInfo']>;
        ['...on SupportingDocumentCollectionCanceledStatusInfo']?: Omit<ValueTypes['SupportingDocumentCollectionCanceledStatusInfo'], keyof ValueTypes['SupportingDocumentCollectionStatusInfo']>;
        ['...on SupportingDocumentCollectionPendingReviewStatusInfo']?: Omit<ValueTypes['SupportingDocumentCollectionPendingReviewStatusInfo'], keyof ValueTypes['SupportingDocumentCollectionStatusInfo']>;
        ['...on SupportingDocumentCollectionRejectedStatusInfo']?: Omit<ValueTypes['SupportingDocumentCollectionRejectedStatusInfo'], keyof ValueTypes['SupportingDocumentCollectionStatusInfo']>;
        ['...on SupportingDocumentCollectionWaitingForDocumentStatusInfo']?: Omit<ValueTypes['SupportingDocumentCollectionWaitingForDocumentStatusInfo'], keyof ValueTypes['SupportingDocumentCollectionStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the status transition is not allowed */
    ['SupportingDocumentCollectionStatusNotAllowedRejection']: AliasType<{
        oldStatus?: boolean | `@${string}`;
        newStatus?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with WaitingForUpload status */
    ['SupportingDocumentCollectionWaitingForDocumentStatusInfo']: AliasType<{
        /** When the Supporting Document Collection is created */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentCollectMode']: SupportingDocumentCollectMode;
    ['SupportingDocumentCommunicationLanguageSettings']: SupportingDocumentCommunicationLanguageSettings;
    /** Rejection returned if the supporting document was not found */
    ['SupportingDocumentNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document with NotUploaded status. */
    ['SupportingDocumentNotUploadedStatusInfo']: AliasType<{
        /** When the document has not been updated on time. */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentOnboarding']: AliasType<{
        id?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentPostField']: AliasType<{
        key?: boolean | `@${string}`;
        value?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Details of a supporting document purpose */
    ['SupportingDocumentPurpose']: AliasType<{
        /** Technical name of the purpose */
        name?: boolean | `@${string}`;
        /** Corresponding supporting document types accepted for this supporting document purpose */
        acceptableSupportingDocumentTypes?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document purpose */
    ['SupportingDocumentPurposeEnum']: SupportingDocumentPurposeEnum;
    /** Supporting document with Refused status */
    ['SupportingDocumentRefusedStatusInfo']: AliasType<{
        /** When the document has been refused by Swan */
        status?: boolean | `@${string}`;
        /** An unique URL and one-time URL to download the Document */
        downloadUrl?: boolean | `@${string}`;
        /** Date on which the supporting document collection has been refused */
        refusedAt?: boolean | `@${string}`;
        /** Reason why the supporting document has been refused */
        reason?: boolean | `@${string}`;
        /** Original file name */
        filename?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentSettings']: AliasType<{
        collectMode?: boolean | `@${string}`;
        communicationLanguage?: boolean | `@${string}`;
        emailContact?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Verification status of a document */
    ['SupportingDocumentStatus']: SupportingDocumentStatus;
    /** Rejection returned if supporting document cannot be deleted because of its status */
    ['SupportingDocumentStatusDoesNotAllowDeletionRejection']: AliasType<{
        supportingDocument?: ValueTypes['SupportingDocument'];
        status?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if supporting document cannot be updated because of its status */
    ['SupportingDocumentStatusDoesNotAllowUpdateRejection']: AliasType<{
        supportingDocument?: ValueTypes['SupportingDocument'];
        status?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentStatusInfo']: AliasType<{
        /** Status of the supporting document */
        status?: boolean | `@${string}`;
        ['...on SupportingDocumentNotUploadedStatusInfo']?: Omit<ValueTypes['SupportingDocumentNotUploadedStatusInfo'], keyof ValueTypes['SupportingDocumentStatusInfo']>;
        ['...on SupportingDocumentRefusedStatusInfo']?: Omit<ValueTypes['SupportingDocumentRefusedStatusInfo'], keyof ValueTypes['SupportingDocumentStatusInfo']>;
        ['...on SupportingDocumentUploadedStatusInfo']?: Omit<ValueTypes['SupportingDocumentUploadedStatusInfo'], keyof ValueTypes['SupportingDocumentStatusInfo']>;
        ['...on SupportingDocumentValidatedStatusInfo']?: Omit<ValueTypes['SupportingDocumentValidatedStatusInfo'], keyof ValueTypes['SupportingDocumentStatusInfo']>;
        ['...on SupportingDocumentWaitingForUploadStatusInfo']?: Omit<ValueTypes['SupportingDocumentWaitingForUploadStatusInfo'], keyof ValueTypes['SupportingDocumentStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the status transition is not allowed */
    ['SupportingDocumentStatusNotAllowedRejection']: AliasType<{
        oldStatus?: boolean | `@${string}`;
        newStatus?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Specific type for document */
    ['SupportingDocumentType']: SupportingDocumentType;
    /** Supporting document with Uploaded status */
    ['SupportingDocumentUploadedStatusInfo']: AliasType<{
        /** When the document has been uploaded but not verified by Swan yet */
        status?: boolean | `@${string}`;
        /** An unique URL and one-time URL to download the Document */
        downloadUrl?: boolean | `@${string}`;
        /** Original file name */
        filename?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentUploadInfo']: AliasType<{
        url?: boolean | `@${string}`;
        fields?: ValueTypes['SupportingDocumentPostField'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the supporting document collection cannot receive supporting documents anymore */
    ['SupportingDocumentUploadNotAllowedRejection']: AliasType<{
        supportingDocumentCollectionStatus?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document with Validated status */
    ['SupportingDocumentValidatedStatusInfo']: AliasType<{
        /** When the document has been uploaded and verified by Swan */
        status?: boolean | `@${string}`;
        /** An unique URL and one-time URL to download the Document */
        downloadUrl?: boolean | `@${string}`;
        /** Date on which the supporting document has been validated */
        validatedAt?: boolean | `@${string}`;
        /** Original file name */
        filename?: boolean | `@${string}`;
        /** Reason why the supporting document has been validated */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document with WaitingForUpload status */
    ['SupportingDocumentWaitingForUploadStatusInfo']: AliasType<{
        /** When the document is not uploaded yet */
        status?: boolean | `@${string}`;
        /** Info to upload the document : url and fields to add along file in form (POST) */
        upload?: ValueTypes['SupportingDocumentUploadInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SuspendAccountMembershipInput']: {
        accountMembershipId: string | Variable<any, string>;
    };
    ['SuspendAccountMembershipPayload']: AliasType<{
        ['...on SuspendAccountMembershipSuccessPayload']: ValueTypes['SuspendAccountMembershipSuccessPayload'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on LegalRepresentativeAccountMembershipCannotBeSuspendedRejection']: ValueTypes['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection'];
        ['...on UserNotAllowedToManageAccountMembershipRejection']: ValueTypes['UserNotAllowedToManageAccountMembershipRejection'];
        ['...on UserNotAllowedToSuspendItsOwnAccountMembershipRejection']: ValueTypes['UserNotAllowedToSuspendItsOwnAccountMembershipRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SuspendAccountMembershipSuccessPayload']: AliasType<{
        accountMembership?: ValueTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Define a reason with a message and a specific type for suspend account action */
    ['SuspendAccountReason']: AliasType<{
        type?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input version */
    ['SuspendAccountReasonInput']: {
        type: ValueTypes['SuspendAccountReasonType'] | Variable<any, string>;
        message?: string | undefined | null | Variable<any, string>;
    };
    /** Specific type for suspend account action */
    ['SuspendAccountReasonType']: SuspendAccountReasonType;
    /** SuspendAccountStatusReason */
    ['SuspendAccountStatusReason']: AliasType<{
        ['...on SuspendAccountReason']: ValueTypes['SuspendAccountReason'];
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings has been suspended */
    ['SuspendedFundingLimitSettingsStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source Suspended status information */
    ['SuspendedFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Suspended status */
        status?: boolean | `@${string}`;
        /** Date at which the funding source was suspended */
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** SuspendedMerchantPaymentMethodStatusInfo */
    ['SuspendedMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method suspended date */
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** SuspendedMerchantProfileStatusInfo */
    ['SuspendedMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to suspend a physical card */
    ['SuspendPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
    };
    ['SuspendPhysicalCardPayload']: AliasType<{
        ['...on SuspendPhysicalCardSuccessPayload']: ValueTypes['SuspendPhysicalCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on PhysicalCardNotFoundRejection']: ValueTypes['PhysicalCardNotFoundRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SuspendPhysicalCardSuccessPayload']: AliasType<{
        /** The physicalCard suspended */
        physicalCard?: ValueTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the SuspendReceivedDirectDebitMandatedRejection mutation is rejected */
    ['SuspendReceivedDirectDebitMandatedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Enum of reasons of rejection for suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandatedRejectionReason']: SuspendReceivedDirectDebitMandatedRejectionReason;
    /** Inputs to suspend a received direct debit mandate */
    ['SuspendReceivedDirectDebitMandateInput']: {
        receivedDirectDebitMandateId: string | Variable<any, string>;
    };
    /** Union type returned by the suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandatePayload']: AliasType<{
        ['...on SuspendReceivedDirectDebitMandateSuccessPayload']: ValueTypes['SuspendReceivedDirectDebitMandateSuccessPayload'];
        ['...on SuspendReceivedDirectDebitMandatedRejection']: ValueTypes['SuspendReceivedDirectDebitMandatedRejection'];
        ['...on ReceivedDirectDebitMandateNotFoundRejection']: ValueTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ['...on ReceivedDirectDebitMandateCanceledRejection']: ValueTypes['ReceivedDirectDebitMandateCanceledRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandateSuccessPayload']: AliasType<{
        /** the received direct debit mandate is suspended */
        receivedDirectDebitMandate?: ValueTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Swan account beneficiary */
    ['SwanAccountBeneficiaryInput']: {
        /** account number to be credited */
        accountNumber: ValueTypes['AccountNumber'] | Variable<any, string>;
        /** full name of the beneficiary  (max 70 characters) */
        name: string | Variable<any, string>;
        /** `true` if this new beneficiary will be saved to the beneficiary list of the debited account. */
        save: boolean | Variable<any, string>;
    };
    /** Status values of an identification */
    ['SwanIdentificationStatus']: SwanIdentificationStatus;
    ['SwanTCUDocumentNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SwanTCUDocumentStatusNotAllowedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['TextField']: AliasType<{
        displayFormat?: boolean | `@${string}`;
        example?: boolean | `@${string}`;
        key?: boolean | `@${string}`;
        maxLength?: boolean | `@${string}`;
        minLength?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        refreshDynamicFieldsOnChange?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        validationRegex?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual ultimate beneficial owner title (Mr/Ms) */
    ['TitleEnum']: TitleEnum;
    ['TokenRequestorId']: unknown;
    /** Rejection returned when trying to create a multi consent with too many child consents */
    ['TooManyChildConsentsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if too many items are given */
    ['TooManyItemsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Transaction */
    ['Transaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** external identifier of the transaction */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ValueTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ValueTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ValueTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** matching account for this transaction */
        account?: ValueTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ValueTypes['Transaction'];
        ['...on CardTransaction']?: Omit<ValueTypes['CardTransaction'], keyof ValueTypes['Transaction']>;
        ['...on CheckTransaction']?: Omit<ValueTypes['CheckTransaction'], keyof ValueTypes['Transaction']>;
        ['...on FeeTransaction']?: Omit<ValueTypes['FeeTransaction'], keyof ValueTypes['Transaction']>;
        ['...on InternalCreditTransfer']?: Omit<ValueTypes['InternalCreditTransfer'], keyof ValueTypes['Transaction']>;
        ['...on InternalDirectDebitTransaction']?: Omit<ValueTypes['InternalDirectDebitTransaction'], keyof ValueTypes['Transaction']>;
        ['...on InternationalCreditTransferTransaction']?: Omit<ValueTypes['InternationalCreditTransferTransaction'], keyof ValueTypes['Transaction']>;
        ['...on SEPACreditTransferTransaction']?: Omit<ValueTypes['SEPACreditTransferTransaction'], keyof ValueTypes['Transaction']>;
        ['...on SEPADirectDebitTransaction']?: Omit<ValueTypes['SEPADirectDebitTransaction'], keyof ValueTypes['Transaction']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['TransactionConnection']: AliasType<{
        pageInfo?: ValueTypes['PageInfo'];
        totalCount?: boolean | `@${string}`;
        edges?: ValueTypes['TransactionEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Edge interface */
    ['TransactionEdge']: AliasType<{
        node?: ValueTypes['Transaction'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the transaction was not found */
    ['TransactionNotFoundRejection']: AliasType<{
        transactionId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The following reason codes for a r-transaction are defined: */
    ['TransactionReasonCode']: TransactionReasonCode;
    /** the criteria to filter transactions */
    ['TransactionsFiltersInput']: {
        /** To filter on some Transaction Status (all if empty) */
        status?: Array<ValueTypes['TransactionStatus']> | undefined | null | Variable<any, string>;
        /** To filter on some Payment Products (all if empty) */
        paymentProduct?: Array<ValueTypes['PaymentProduct']> | undefined | null | Variable<any, string>;
        /** To filter after an updatedAt value */
        isAfterUpdatedAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** To filter before an updatedAt value */
        isBeforeUpdatedAt?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** To filter on some text occurrences (words or ids) */
        search?: string | undefined | null | Variable<any, string>;
        /** To filter on some transaction types */
        type?: Array<ValueTypes['TransactionTypeEnum']> | undefined | null | Variable<any, string>;
        /** To filter so it includes rejected transactions that had a fallback (`true` by default) */
        includeRejectedWithFallback?: boolean | undefined | null | Variable<any, string>;
    };
    /** Transaction side */
    ['TransactionSide']: TransactionSide;
    ['TransactionsOrderByField']: TransactionsOrderByField;
    /** the criteria to sort transactions */
    ['TransactionsOrderByInput']: {
        field?: ValueTypes['TransactionsOrderByField'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** Transaction status */
    ['TransactionStatus']: TransactionStatus;
    /** Transaction Status information */
    ['TransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        ['...on BookedTransactionStatusInfo']?: Omit<ValueTypes['BookedTransactionStatusInfo'], keyof ValueTypes['TransactionStatusInfo']>;
        ['...on CanceledTransactionStatusInfo']?: Omit<ValueTypes['CanceledTransactionStatusInfo'], keyof ValueTypes['TransactionStatusInfo']>;
        ['...on PendingTransactionStatusInfo']?: Omit<ValueTypes['PendingTransactionStatusInfo'], keyof ValueTypes['TransactionStatusInfo']>;
        ['...on RejectedTransactionStatusInfo']?: Omit<ValueTypes['RejectedTransactionStatusInfo'], keyof ValueTypes['TransactionStatusInfo']>;
        ['...on ReleasedTransactionStatusInfo']?: Omit<ValueTypes['ReleasedTransactionStatusInfo'], keyof ValueTypes['TransactionStatusInfo']>;
        ['...on UpcomingTransactionStatusInfo']?: Omit<ValueTypes['UpcomingTransactionStatusInfo'], keyof ValueTypes['TransactionStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Transaction Type */
    ['TransactionTypeEnum']: TransactionTypeEnum;
    /** TrustedBeneficiary */
    ['TrustedBeneficiary']: AliasType<{
        /** unique identifier of a trusted beneficiary */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** label of the beneficiary */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type?: boolean | `@${string}`;
        ['...on TrustedInternalBeneficiary']?: Omit<ValueTypes['TrustedInternalBeneficiary'], keyof ValueTypes['TrustedBeneficiary']>;
        ['...on TrustedInternationalBeneficiary']?: Omit<ValueTypes['TrustedInternationalBeneficiary'], keyof ValueTypes['TrustedBeneficiary']>;
        ['...on TrustedSepaBeneficiary']?: Omit<ValueTypes['TrustedSepaBeneficiary'], keyof ValueTypes['TrustedBeneficiary']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['TrustedBeneficiaryConnection']: AliasType<{
        pageInfo?: ValueTypes['PageInfo'];
        edges?: ValueTypes['TrustedBeneficiaryEdge'];
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** TrustedBeneficiary status consent pending */
    ['TrustedBeneficiaryConsentPending']: AliasType<{
        /** status of the beneficiary  (set to `ConsentPending`) */
        status?: boolean | `@${string}`;
        /** The consent required to initiate this beneficiary */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Edge interface */
    ['TrustedBeneficiaryEdge']: AliasType<{
        node?: ValueTypes['TrustedBeneficiary'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryFiltersInput']: {
        status?: Array<ValueTypes['TrustedBeneficiaryStatus']> | undefined | null | Variable<any, string>;
        type?: Array<ValueTypes['BeneficiaryType']> | undefined | null | Variable<any, string>;
    };
    /** Field we can use when ordering that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryOrderByFieldInput']: TrustedBeneficiaryOrderByFieldInput;
    /** Order that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryOrderByInput']: {
        field?: ValueTypes['TrustedBeneficiaryOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** TrustedBeneficiary status */
    ['TrustedBeneficiaryStatus']: TrustedBeneficiaryStatus;
    /** TrustedBeneficiary status information */
    ['TrustedBeneficiaryStatusInfo']: AliasType<{
        /** status of the beneficiary */
        status?: boolean | `@${string}`;
        ['...on TrustedBeneficiaryConsentPending']?: Omit<ValueTypes['TrustedBeneficiaryConsentPending'], keyof ValueTypes['TrustedBeneficiaryStatusInfo']>;
        ['...on TrustedBeneficiaryStatusInfoCanceled']?: Omit<ValueTypes['TrustedBeneficiaryStatusInfoCanceled'], keyof ValueTypes['TrustedBeneficiaryStatusInfo']>;
        ['...on TrustedBeneficiaryStatusInfoEnabled']?: Omit<ValueTypes['TrustedBeneficiaryStatusInfoEnabled'], keyof ValueTypes['TrustedBeneficiaryStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** TrustedBeneficiary status canceled */
    ['TrustedBeneficiaryStatusInfoCanceled']: AliasType<{
        /** status of the beneficiary (set to `Canceled`) */
        status?: boolean | `@${string}`;
        /** canceled Date */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** TrustedBeneficiary status enabled */
    ['TrustedBeneficiaryStatusInfoEnabled']: AliasType<{
        /** status of the beneficiary (set to `Enabled`) */
        status?: boolean | `@${string}`;
        /** enabled Date */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Trusted Internal Beneficiary */
    ['TrustedInternalBeneficiary']: AliasType<{
        /** unique identifier of a trusted beneficiary */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** label of the beneficiary */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type?: boolean | `@${string}`;
        /** beneficiary account Id */
        accountId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Trusted International Beneficiary */
    ['TrustedInternationalBeneficiary']: AliasType<{
        /** unique identifier of a trusted beneficiary */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** label of the beneficiary */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type?: boolean | `@${string}`;
        /** Currency of the international beneficiary account */
        currency?: boolean | `@${string}`;
        /** Currency-specific details of the beneficiary */
        details?: ValueTypes['KeyValue'];
        /** Route that Swan will use to transfer the funds */
        route?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Trusted SEPA Beneficiary type SEPA */
    ['TrustedSepaBeneficiary']: AliasType<{
        /** unique identifier of a trusted beneficiary */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** label of the beneficiary */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ValueTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type?: boolean | `@${string}`;
        /** IBAN if the beneficiary is a an account in an other financial institution */
        iban?: boolean | `@${string}`;
        /** beneficiary address */
        address?: ValueTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Quality of the account holder doing the onboarding */
    ['TypeOfRepresentation']: TypeOfRepresentation;
    /** Ultimate beneficial Direct Owner company info. */
    ['UltimateBeneficialDirectOwnerCompanyInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier . */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial Direct Owner Company type. */
        type?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        /** Name of the company. */
        name?: boolean | `@${string}`;
        /** Registration number. */
        registrationNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Ultimate beneficial Direct Owner individual info. */
    ['UltimateBeneficialDirectOwnerIndividualInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier . */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial Direct owner Individual type . */
        type?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        /** First name. */
        firstName?: boolean | `@${string}`;
        /** Last name. */
        lastName?: boolean | `@${string}`;
        /** Birth date. */
        birthDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Ultimate beneficial owner company info. */
    ['UltimateBeneficialIndirectOwnerCompanyInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier . */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial Indirect Owner Company type. */
        type?: boolean | `@${string}`;
        /** Unique Reference of the Parent Company. */
        parentCompanyReference?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        /** Name of the company. */
        name?: boolean | `@${string}`;
        /** Registration number. */
        registrationNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Ultimate beneficial Indirect Owner individual info. */
    ['UltimateBeneficialIndirectOwnerIndividualInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier. */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial Indirect Owner Individual type . */
        type?: boolean | `@${string}`;
        /** Unique Reference of the Parent Company. */
        parentCompanyReference?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        /** First name. */
        firstName?: boolean | `@${string}`;
        /** Last name. */
        lastName?: boolean | `@${string}`;
        /** Birth date. */
        birthDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The Ultimate Beneficial Owner could be for an Individual or a Company and these can Direct or Indirect */
    ['UltimateBeneficialOwnerInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier . */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial owner type. */
        type?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        ['...on UltimateBeneficialDirectOwnerCompanyInfo']?: Omit<ValueTypes['UltimateBeneficialDirectOwnerCompanyInfo'], keyof ValueTypes['UltimateBeneficialOwnerInfo']>;
        ['...on UltimateBeneficialDirectOwnerIndividualInfo']?: Omit<ValueTypes['UltimateBeneficialDirectOwnerIndividualInfo'], keyof ValueTypes['UltimateBeneficialOwnerInfo']>;
        ['...on UltimateBeneficialIndirectOwnerCompanyInfo']?: Omit<ValueTypes['UltimateBeneficialIndirectOwnerCompanyInfo'], keyof ValueTypes['UltimateBeneficialOwnerInfo']>;
        ['...on UltimateBeneficialIndirectOwnerIndividualInfo']?: Omit<ValueTypes['UltimateBeneficialIndirectOwnerIndividualInfo'], keyof ValueTypes['UltimateBeneficialOwnerInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Ultimate Beneficial Owner type. */
    ['UltimateBeneficialOwnerType']: UltimateBeneficialOwnerType;
    /** Upcoming transaction status information */
    ['UpcomingTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The date when the transaction will be executed */
        executionDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountHolderInput']: {
        accountHolderId: string | Variable<any, string>;
        vatNumber?: string | undefined | null | Variable<any, string>;
        taxIdentificationNumber?: string | undefined | null | Variable<any, string>;
    };
    ['UpdateAccountHolderPayload']: AliasType<{
        ['...on UpdateAccountHolderSuccessPayload']: ValueTypes['UpdateAccountHolderSuccessPayload'];
        ['...on AccountHolderNotFoundRejection']: ValueTypes['AccountHolderNotFoundRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountHolderSuccessPayload']: AliasType<{
        accountHolder?: ValueTypes['AccountHolder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to update an account */
    ['UpdateAccountInput']: {
        /** Unique identifier of an account */
        accountId: string | Variable<any, string>;
        /** Name */
        name?: string | undefined | null | Variable<any, string>;
        /** Language */
        language?: ValueTypes['AccountLanguage'] | undefined | null | Variable<any, string>;
    };
    /** Inputs to update an account membership */
    ['UpdateAccountMembershipInput']: {
        /** Unique identifier of an account membership */
        accountMembershipId: string | Variable<any, string>;
        /** Email address */
        email?: string | undefined | null | Variable<any, string>;
        /** Restricted to a user if necessary */
        restrictedTo?: ValueTypes['UpdatedRestrictedToInput'] | undefined | null | Variable<any, string>;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount?: boolean | undefined | null | Variable<any, string>;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries?: boolean | undefined | null | Variable<any, string>;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments?: boolean | undefined | null | Variable<any, string>;
        /** `true` if this account membership can invite, update, suspend or resume memberships */
        canManageAccountMembership?: boolean | undefined | null | Variable<any, string>;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null | Variable<any, string>;
        /** Periodic Spending limit */
        spendingLimit?: ValueTypes['SpendingLimitInput'] | undefined | null | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** Residency address of the member to be added */
        residencyAddress?: ValueTypes['ResidencyAddressInput'] | undefined | null | Variable<any, string>;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined | null | Variable<any, string>;
    };
    ['UpdateAccountMembershipPayload']: AliasType<{
        ['...on UpdateAccountMembershipSuccessPayload']: ValueTypes['UpdateAccountMembershipSuccessPayload'];
        ['...on AccountMembershipCannotBeUpdatedRejection']: ValueTypes['AccountMembershipCannotBeUpdatedRejection'];
        ['...on AccountMembershipNotFoundRejection']: ValueTypes['AccountMembershipNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InvalidPhoneNumberRejection']: ValueTypes['InvalidPhoneNumberRejection'];
        ['...on PermissionCannotBeGrantedRejection']: ValueTypes['PermissionCannotBeGrantedRejection'];
        ['...on UserNotAllowedToManageAccountMembershipRejection']: ValueTypes['UserNotAllowedToManageAccountMembershipRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountMembershipSuccessPayload']: AliasType<{
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountPayload']: AliasType<{
        ['...on UpdateAccountSuccessPayload']: ValueTypes['UpdateAccountSuccessPayload'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on BadAccountStatusRejection']: ValueTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountSuccessPayload']: AliasType<{
        account?: ValueTypes['Account'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to Update Card */
    ['UpdateCardInput']: {
        /** Unique identifier of the card to update */
        cardId: string | Variable<any, string>;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean | Variable<any, string>;
        /** `true` if this card allows payments outside of the country */
        international: boolean | Variable<any, string>;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean | Variable<any, string>;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean | Variable<any, string>;
        /** Periodic Spending limit */
        spendingLimit?: ValueTypes['SpendingLimitInput'] | undefined | null | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
        /** Card name */
        name?: string | undefined | null | Variable<any, string>;
    };
    ['UpdateCardPayload']: AliasType<{
        ['...on UpdateCardSuccessPayload']: ValueTypes['UpdateCardSuccessPayload'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on AccountMembershipNotAllowedRejection']: ValueTypes['AccountMembershipNotAllowedRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateCardSuccessPayload']: AliasType<{
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateCompanyOnboardingInput']: {
        /** Account name of the company account holder. Length must be from 0 to 100 characters */
        accountName?: string | undefined | null | Variable<any, string>;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ValueTypes['AccountCountry'] | undefined | null | Variable<any, string>;
        /** Name of the company. Length must be from 0 to 255 characters */
        name?: string | undefined | null | Variable<any, string>;
        /** Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters */
        registrationNumber?: string | undefined | null | Variable<any, string>;
        /** Type of the company (Association ...) */
        companyType?: ValueTypes['CompanyType'] | undefined | null | Variable<any, string>;
        /** Business activity */
        businessActivity?: ValueTypes['BusinessActivity'] | undefined | null | Variable<any, string>;
        /** Business activity description. Length must be from 0 to 1024 characters */
        businessActivityDescription?: string | undefined | null | Variable<any, string>;
        /** Estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: ValueTypes['MonthlyPaymentVolume'] | undefined | null | Variable<any, string>;
        /** The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
    
    The ultimate beneficial owner is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<ValueTypes['IndividualUltimateBeneficialOwnerInput']> | undefined | null | Variable<any, string>;
        /** Residency address of the head office (Must be in a European country) */
        residencyAddress?: ValueTypes['ResidencyAddressInput'] | undefined | null | Variable<any, string>;
        /** Email of the legal representative. Length must be from 0 to 255 characters */
        email?: string | undefined | null | Variable<any, string>;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined | null | Variable<any, string>;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined | null | Variable<any, string>;
        /** Id of onboarding to be updated. Must be a valid UUID v4. Required */
        onboardingId: string | Variable<any, string>;
        /** VAT number */
        vatNumber?: string | undefined | null | Variable<any, string>;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined | null | Variable<any, string>;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ValueTypes['AddressInformationInput'] | undefined | null | Variable<any, string>;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: ValueTypes['TypeOfRepresentation'] | undefined | null | Variable<any, string>;
    };
    /** Possible results for mutation `updateCompanyOnboarding` */
    ['UpdateCompanyOnboardingPayload']: AliasType<{
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on UpdateCompanyOnboardingSuccessPayload']: ValueTypes['UpdateCompanyOnboardingSuccessPayload'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Result when updateCompanyOnboarding is a success */
    ['UpdateCompanyOnboardingSuccessPayload']: AliasType<{
        onboarding?: ValueTypes['OnboardingInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input when the account membership is restricted to a verified user */
    ['UpdatedRestrictedToInput']: {
        /** Account member first name */
        firstName?: string | undefined | null | Variable<any, string>;
        /** Account member last name */
        lastName?: string | undefined | null | Variable<any, string>;
        /** Account member birth date */
        birthDate?: ValueTypes['Date'] | undefined | null | Variable<any, string>;
        /** Account member phone number */
        phoneNumber?: string | undefined | null | Variable<any, string>;
    };
    ['UpdateIndividualOnboardingInput']: {
        /** Account name of the individual account holder. Length must be from 0 to 255 characters */
        accountName?: string | undefined | null | Variable<any, string>;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ValueTypes['AccountCountry'] | undefined | null | Variable<any, string>;
        /** Employment status of the individual account holder */
        employmentStatus?: ValueTypes['EmploymentStatus'] | undefined | null | Variable<any, string>;
        /** Monthly income of the individual account holder */
        monthlyIncome?: ValueTypes['MonthlyIncome'] | undefined | null | Variable<any, string>;
        /** Residency address of the individual account holder (must be in a European country) */
        residencyAddress?: ValueTypes['ResidencyAddressInput'] | undefined | null | Variable<any, string>;
        /** Email. Length must be from 0 to 255 characters */
        email?: string | undefined | null | Variable<any, string>;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined | null | Variable<any, string>;
        /** Id of onboarding to be updated. Must be a valid UUID v4. Required */
        onboardingId: string | Variable<any, string>;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined | null | Variable<any, string>;
    };
    /** Possible result types for `updateIndividualOnboarding` */
    ['UpdateIndividualOnboardingPayload']: AliasType<{
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on UpdateIndividualOnboardingSuccessPayload']: ValueTypes['UpdateIndividualOnboardingSuccessPayload'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Type of result when updateIndividualOnboarding is a success */
    ['UpdateIndividualOnboardingSuccessPayload']: AliasType<{
        onboarding?: ValueTypes['OnboardingInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to update a received sepa direct debit mandate B2b. */
    ['UpdateReceivedSepaDirectDebitB2bMandateInput']: {
        /** The unique mandate id */
        receivedDirectDebitMandateId: string | Variable<any, string>;
        /** The unique identifier of the received direct debit mandate */
        mandateReference?: string | undefined | null | Variable<any, string>;
        /** The Sepa Creditor Identifier of the creditor */
        creditorIdentifier?: string | undefined | null | Variable<any, string>;
        /** The name of the creditor */
        creditorName?: string | undefined | null | Variable<any, string>;
        /** The Swan Iban of the debtor */
        iban?: string | undefined | null | Variable<any, string>;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined | null | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    /** Union type returned by the updateReceivedSepaDirectDebitB2bMandate mutation */
    ['UpdateReceivedSepaDirectDebitB2bMandatePayload']: AliasType<{
        ['...on UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload']: ValueTypes['UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload'];
        ['...on ReceivedDirectDebitMandateNotFoundRejection']: ValueTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on ReceivedDirectDebitMandateAlreadyExistRejection']: ValueTypes['ReceivedDirectDebitMandateAlreadyExistRejection'];
        ['...on ReceivedDirectDebitMandateNotB2bRejection']: ValueTypes['ReceivedDirectDebitMandateNotB2bRejection'];
        ['...on AccountNotFoundRejection']: ValueTypes['AccountNotFoundRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the updateReceivedSepaDirectDebitB2bMandate mutation */
    ['UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload']: AliasType<{
        /** The received direct debit mandate updated */
        receivedDirectDebitMandate?: ValueTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateSupportingDocumentInput']: {
        supportingDocumentId: string | Variable<any, string>;
        supportingDocumentType?: ValueTypes['SupportingDocumentType'] | undefined | null | Variable<any, string>;
        supportingDocumentPurpose?: ValueTypes['SupportingDocumentPurposeEnum'] | undefined | null | Variable<any, string>;
    };
    ['UpdateSupportingDocumentPayload']: AliasType<{
        ['...on UpdateSupportingDocumentSuccessPayload']: ValueTypes['UpdateSupportingDocumentSuccessPayload'];
        ['...on ForbiddenRejection']: ValueTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on SupportingDocumentCollectionNotFoundRejection']: ValueTypes['SupportingDocumentCollectionNotFoundRejection'];
        ['...on SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection']: ValueTypes['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection'];
        ['...on SupportingDocumentNotFoundRejection']: ValueTypes['SupportingDocumentNotFoundRejection'];
        ['...on SupportingDocumentStatusDoesNotAllowUpdateRejection']: ValueTypes['SupportingDocumentStatusDoesNotAllowUpdateRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateSupportingDocumentSuccessPayload']: AliasType<{
        supportingDocument?: ValueTypes['SupportingDocument'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateUserConsentSettingsInput']: {
        /** Swan user id */
        userId: string | Variable<any, string>;
        /** Preferred consent notification channel, Sms or App */
        preferredNotificationChannel: ValueTypes['PreferredNotificationChannel'] | Variable<any, string>;
    };
    ['UpdateUserConsentSettingsPayload']: AliasType<{
        ['...on UpdateUserConsentSettingsSuccessPayload']: ValueTypes['UpdateUserConsentSettingsSuccessPayload'];
        ['...on UpdateUserConsentSettingsTokenRejection']: ValueTypes['UpdateUserConsentSettingsTokenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateUserConsentSettingsSuccessPayload']: AliasType<{
        userConsentSettings?: ValueTypes['UserConsentSettings'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateUserConsentSettingsTokenRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['Upload']: unknown;
    /** URL that follows the WHATWG URL Standard.
  
  [Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself. */
    ['URL']: unknown;
    /** The User is the unique user, natural person, of the Swan app. */
    ['User']: AliasType<{
        /** unique identifier of the user */
        id?: boolean | `@${string}`;
        accountMemberships?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null | Variable<any, string>; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null | Variable<any, string>; /** a filtering table you can apply to your list of connections */
                filters?: ValueTypes['AccountMembershipsFilterInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['AccountMembershipConnection']
        ];
        /** mobile phone number with the international format (Example: +33689788967) */
        mobilePhoneNumber?: boolean | `@${string}`;
        /** first name */
        firstName?: boolean | `@${string}`;
        /** last name */
        lastName?: boolean | `@${string}`;
        /** list of first names */
        allFirstNames?: boolean | `@${string}`;
        /** birth date */
        birthDate?: boolean | `@${string}`;
        /** nationality */
        nationalityCCA3?: boolean | `@${string}`;
        /** `true` if Swan has verified the user's identity */
        idVerified?: boolean | `@${string}`;
        /** the methods used to authenticate this user */
        authenticators?: ValueTypes['Authenticator'];
        /** Identification status
    
    Each attempt to go through our identity verification process will update this value.
    
    This field is only available for the current user. */
        identificationStatus?: boolean | `@${string}`;
        /** List of identification levels available for the user.
    
    Whenever TRUE, it means the identification was successful for the associated level. */
        identificationLevels?: ValueTypes['IdentificationLevels'];
        /** Preferred notification channel
    
    When it is "null" it means that the preferences have not been updated. Default SMS in use */
        preferredNotificationChannel?: boolean | `@${string}`;
        /** Creation date of the user */
        createdAt?: boolean | `@${string}`;
        /** Last update date of the user */
        updatedAt?: boolean | `@${string}`;
        /** Date on which the user joined the project. Joining the project is done after the first accepted OAuth login. */
        joinedAt?: boolean | `@${string}`;
        identifications?: [
            {
                /** Maximum number of elements in the list (default value 50) */
                first: number | Variable<any, string>; /** When the list of elements needs to start after an element */
                after?: string | undefined | null | Variable<any, string>; /** When the list of identifications needs to be filtered */
                filters?: ValueTypes['IdentificationFiltersInput'] | undefined | null | Variable<any, string>; /** When the list of identifications needs to be ordered, by default the list will be ordered by the latest identification (valid or not) */
                orderBy?: ValueTypes['IdentificationsOrderByInput'] | undefined | null | Variable<any, string>;
            },
            ValueTypes['IdentificationConnection']
        ];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['UserConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** UserEdge list */
        edges?: ValueTypes['UserEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UserConsentSettings']: AliasType<{
        /** Preferred notification channel */
        preferredNotificationChannel?: boolean | `@${string}`;
        /** User identifier */
        userId?: boolean | `@${string}`;
        /** Project identifier */
        projectId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['UserEdge']: AliasType<{
        /** Opaque identifier pointing to this consent node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The consent */
        node?: ValueTypes['User'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UserFilterInput']: {
        birthDate?: ValueTypes['Date'] | undefined | null | Variable<any, string>;
        firstName?: string | undefined | null | Variable<any, string>;
        identificationLevel?: ValueTypes['IdentificationLevelInput'] | undefined | null | Variable<any, string>;
        lastName?: string | undefined | null | Variable<any, string>;
        mobilePhoneNumber?: string | undefined | null | Variable<any, string>;
        nationalityCCA3?: ValueTypes['CCA3'] | undefined | null | Variable<any, string>;
        preferredNotificationChannel?: ValueTypes['PreferredNotificationChannel'] | undefined | null | Variable<any, string>;
        /** Searches first name, last name, phone number and id
    Min length : 3 characters */
        search?: string | undefined | null | Variable<any, string>;
    };
    ['UserNotAllowedToDisableItsOwnAccountMembershipRejection']: AliasType<{
        accountMembershipId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if a identity does not have enough permission to manage account membership */
    ['UserNotAllowedToManageAccountMembershipRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['UserNotAllowedToSuspendItsOwnAccountMembershipRejection']: AliasType<{
        accountMembershipId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the User is not the Card Holder */
    ['UserNotCardHolderRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing users */
    ['UserOrderByFieldInput']: UserOrderByFieldInput;
    /** Order that can be applied when listing users */
    ['UserOrderByInput']: {
        field?: ValueTypes['UserOrderByFieldInput'] | undefined | null | Variable<any, string>;
        direction?: ValueTypes['OrderByDirection'] | undefined | null | Variable<any, string>;
    };
    /** A detail of a validation error : what field is errored and why */
    ['ValidationError']: AliasType<{
        /** Onboarding property that is not matching requirements to allow a finalization */
        field?: boolean | `@${string}`;
        /** Constraints that are not matched on the Onboarding property */
        errors?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ValidationFieldError']: AliasType<{
        code?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        path?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ValidationFieldErrorCode']: ValidationFieldErrorCode;
    /** Rejection returned if an input contains invalid data */
    ['ValidationRejection']: AliasType<{
        fields?: ValueTypes['ValidationFieldError'];
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Information extracted from a valid IBAN */
    ['ValidIban']: AliasType<{
        /** Iban from input */
        iban?: boolean | `@${string}`;
        /** Account Number extracted from the IBAN */
        accountNumber?: boolean | `@${string}`;
        /** Checksum extracted from the IBAN */
        checksum?: boolean | `@${string}`;
        /** Bank that owns this IBAN */
        bank?: ValueTypes['Bank'];
        /** Reachability of this IBAN over different payment methods */
        reachability?: ValueTypes['Reachability'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes a valid identification level for the process associated to this identification, and identification documents can be accessed */
    ['ValidIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Valid` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Verification Flow. */
    ['VerificationFlow']: VerificationFlow;
    /** Verification status of an account holder */
    ['VerificationStatus']: VerificationStatus;
    /** Enabled Information */
    ['VerifiedStatusInfo']: AliasType<{
        /** Date at which the verification was verified */
        verifiedAt?: boolean | `@${string}`;
        /** Account verification status (Verified) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewCardNumbersInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    ['ViewCardNumbersPayload']: AliasType<{
        ['...on ViewCardNumbersSuccessPayload']: ValueTypes['ViewCardNumbersSuccessPayload'];
        ['...on UserNotCardHolderRejection']: ValueTypes['UserNotCardHolderRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewCardNumbersSuccessPayload']: AliasType<{
        /** The consent required to view card numbers */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewPhysicalCardNumbersInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    ['ViewPhysicalCardNumbersPayload']: AliasType<{
        ['...on ViewPhysicalCardNumbersSuccessPayload']: ValueTypes['ViewPhysicalCardNumbersSuccessPayload'];
        ['...on UserNotCardHolderRejection']: ValueTypes['UserNotCardHolderRejection'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewPhysicalCardNumbersSuccessPayload']: AliasType<{
        /** The consent required to view card numbers */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewPhysicalCardPinInput']: {
        /** Unique identifier of a card */
        cardId: string | Variable<any, string>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string | Variable<any, string>;
    };
    ['ViewPhysicalCardPinPayload']: AliasType<{
        ['...on ViewPhysicalCardPinSuccessPayload']: ValueTypes['ViewPhysicalCardPinSuccessPayload'];
        ['...on CardNotFoundRejection']: ValueTypes['CardNotFoundRejection'];
        ['...on PhysicalCardNotFoundRejection']: ValueTypes['PhysicalCardNotFoundRejection'];
        ['...on PINNotReadyRejection']: ValueTypes['PINNotReadyRejection'];
        ['...on UserNotCardHolderRejection']: ValueTypes['UserNotCardHolderRejection'];
        ['...on ValidationRejection']: ValueTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewPhysicalCardPinSuccessPayload']: AliasType<{
        /** The consent required to view card numbers */
        consent?: ValueTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Virtual IBAN can be used by the account holder to receive SCT (Sepa Credit Transfer) or to be debited by SDD (Sepa Direct Debit). */
    ['VirtualIBANEntry']: AliasType<{
        /** Unique identifier of a Virtual IBAN entry */
        id?: boolean | `@${string}`;
        /** International Bank Account Number */
        IBAN?: boolean | `@${string}`;
        /** Bank Identifier Code */
        BIC?: boolean | `@${string}`;
        /** Label (could be used to identify) */
        label?: boolean | `@${string}`;
        /** Status of the Iban */
        status?: boolean | `@${string}`;
        /** `true` if the Virtual IBAN refuses all Sepa Direct Debit received */
        blockSDD?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['VirtualIBANEntryConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ValueTypes['PageInfo'];
        /** VirtualIBANEntryEdge list */
        edges?: ValueTypes['VirtualIBANEntryEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['VirtualIBANEntryEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The virtual iban entry */
        node?: ValueTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Wallet Provider (ApplePay, GooglePay ...) */
    ['WalletProvider']: AliasType<{
        /** name of the Wallet Provider (Apple / Google / Amazon or Unknown) */
        name?: boolean | `@${string}`;
        /** id of the Wallet Provider */
        id?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Wallet Provider */
    ['WalletProviderType']: WalletProviderType;
    ['WalletToken']: unknown;
    ['WebBankingSettings']: AliasType<{
        canViewAccountDetails?: boolean | `@${string}`;
        canViewAccountStatement?: boolean | `@${string}`;
        canManageVirtualIbans?: boolean | `@${string}`;
        canInitiatePaymentsToNewBeneficiaries?: boolean | `@${string}`;
        canViewPaymentList?: boolean | `@${string}`;
        canOrderVirtualCards?: boolean | `@${string}`;
        canOrderPhysicalCards?: boolean | `@${string}`;
        canViewMembers?: boolean | `@${string}`;
        canAddNewMembers?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** A WebhookEvent Log for webhooks service.
  It describes the response and call context for webhook endpoints
  for a specific event. */
    ['WebhookEventLog']: AliasType<{
        /** Unique identifier of the EventLog */
        id?: boolean | `@${string}`;
        /** Date the EventLog has been created */
        createdAt?: boolean | `@${string}`;
        /** Unique identifier of the event that triggered this eventLog */
        eventId?: boolean | `@${string}`;
        /** Date the Event has been generated */
        eventDate?: boolean | `@${string}`;
        /** The type of the triggering event */
        eventType?: boolean | `@${string}`;
        /** Unique identifier linked of the resource carried by the Event */
        resourceId?: boolean | `@${string}`;
        /** Duration of the callback in MS */
        duration?: boolean | `@${string}`;
        /** Request payload send to callback in string format, jsonable. */
        requestPayload?: boolean | `@${string}`;
        /** Response payload get by the callback in string format, jsonable. */
        responsePayload?: boolean | `@${string}`;
        /** The callback response status in number format. */
        statusCode?: boolean | `@${string}`;
        /** The callback response status in text format. */
        statusText?: boolean | `@${string}`;
        /** The webhook that triggered the event. */
        webhookSubscription?: ValueTypes['WebhookSubscription'];
        /** Rank of this retry */
        retryCount?: boolean | `@${string}`;
        /** Label of the associated subscription (inherited)
    This holds the label value of when the log was created, whereas
    webhookSubscription.label holds the current value of the label
    (it may have changed). */
        webhookSubscriptionLabel?: boolean | `@${string}`;
        /** Endpoint of the associated subscription (inherited)
    This holds the endpoint value of when the log was created, whereas
    webhookSubscription.endpoint holds the current value of the endpoint
    (it may have changed). */
        webhookSubscriptionEndpoint?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing eventLog */
    ['WebhookEventLogFiltersInput']: {
        statusCode?: number | undefined | null | Variable<any, string>;
        statusText?: ValueTypes['StatusText'] | undefined | null | Variable<any, string>;
        startDate?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        endDate?: ValueTypes['DateTime'] | undefined | null | Variable<any, string>;
        eventType?: string | undefined | null | Variable<any, string>;
        eventId?: string | undefined | null | Variable<any, string>;
        resourceId?: string | undefined | null | Variable<any, string>;
        webhookSubscriptionId?: string | undefined | null | Variable<any, string>;
    };
    /** Rejection returned when Webhook event log id is not found */
    ['WebhookEventLogNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** A Subscription to the webhooks service.
  It describes the registration of a callback url (the endpoint)
  and a list of event types the client wants to be notified of. */
    ['WebhookSubscription']: AliasType<{
        /** Unique identifier of the Subscription */
        id?: boolean | `@${string}`;
        /** A client provided short description of the Subscription */
        label?: boolean | `@${string}`;
        /** The callback URL to be used for POSTing events */
        endpoint?: boolean | `@${string}`;
        /** The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
    (max 36 characters) */
        secret?: boolean | `@${string}`;
        /** The types of subscribed events
    A simple list of unique IDs */
        eventTypes?: boolean | `@${string}`;
        /** Date the Subscription has been created */
        createdAt?: boolean | `@${string}`;
        /**   Last date the Subscription has been updated,
    except for state changes */
        updatedAt?: boolean | `@${string}`;
        /** The current state of the Subscription */
        statusInfo?: ValueTypes['WebhookSubscriptionStatusInfo'];
        /** KPI data about the subscription (7 last days) */
        kpi?: ValueTypes['WebhookSubscriptionKpi'];
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionBrokenStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        brokenAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionCreationStatus']: WebhookSubscriptionCreationStatus;
    ['WebhookSubscriptionDisabledStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        disabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionEnabledStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionKpi']: AliasType<{
        /** Total number of eventLogs associated to this subscription */
        totalHits?: boolean | `@${string}`;
        /** Total number of eventLogs that failed associated to this subscription
    errorRate = (errorRate/totalHits) * 100, rounded */
        errorRate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when Webhook Subscription is not found */
    ['WebhookSubscriptionNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionPayload']: AliasType<{
        ['...on WebhookSubscriptionSuccessPayload']: ValueTypes['WebhookSubscriptionSuccessPayload'];
        ['...on WebhookSubscriptionNotFoundRejection']: ValueTypes['WebhookSubscriptionNotFoundRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on InvalidArgumentRejection']: ValueTypes['InvalidArgumentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** State of a Webhook Subscription
  It is either Enabled or Disabled by the owner,
  ot set to Broken when delivery fails repeatedly. */
    ['WebhookSubscriptionStatus']: WebhookSubscriptionStatus;
    ['WebhookSubscriptionStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        ['...on WebhookSubscriptionBrokenStatusInfo']?: Omit<ValueTypes['WebhookSubscriptionBrokenStatusInfo'], keyof ValueTypes['WebhookSubscriptionStatusInfo']>;
        ['...on WebhookSubscriptionDisabledStatusInfo']?: Omit<ValueTypes['WebhookSubscriptionDisabledStatusInfo'], keyof ValueTypes['WebhookSubscriptionStatusInfo']>;
        ['...on WebhookSubscriptionEnabledStatusInfo']?: Omit<ValueTypes['WebhookSubscriptionEnabledStatusInfo'], keyof ValueTypes['WebhookSubscriptionStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionSuccessPayload']: AliasType<{
        webhookSubscription?: ValueTypes['WebhookSubscription'];
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookUnsubscribePayload']: AliasType<{
        ['...on WebhookUnsubscribeSuccessPayload']: ValueTypes['WebhookUnsubscribeSuccessPayload'];
        ['...on WebhookSubscriptionNotFoundRejection']: ValueTypes['WebhookSubscriptionNotFoundRejection'];
        ['...on InternalErrorRejection']: ValueTypes['InternalErrorRejection'];
        ['...on InvalidArgumentRejection']: ValueTypes['InvalidArgumentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookUnsubscribeSuccessPayload']: AliasType<{
        unsubscribed?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when a parameter has a wrong value */
    ['WrongValueProvidedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        valueProvided?: boolean | `@${string}`;
        parameterName?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
};
export type ResolverInputTypes = {
    /** Whether you call it a wallet, monetary account, payment account or bank account, the notion of account is fundamental at Swan. All payment flows necessarily go through an account. */
    ['Account']: AliasType<{
        /** Unique identifier of an account */
        id?: boolean | `@${string}`;
        /** Unique account number */
        number?: boolean | `@${string}`;
        /** Account name */
        name?: boolean | `@${string}`;
        /** Account holder */
        holder?: ResolverInputTypes['AccountHolder'];
        /** Cash account type */
        cashAccountType?: boolean | `@${string}`;
        /** Country of the account */
        country?: boolean | `@${string}`;
        /** Payment level */
        paymentLevel?: boolean | `@${string}`;
        /** Bank Identifier Code
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        BIC?: boolean | `@${string}`;
        /** International Bank Account Number
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        IBAN?: boolean | `@${string}`;
        /** Currency */
        currency?: boolean | `@${string}`;
        /** `true` if the main IBAN refuses all Sepa Direct Debit received */
        blockSDD?: boolean | `@${string}`;
        /** Status of the account */
        statusInfo?: ResolverInputTypes['AccountStatusInfo'];
        /** Partnership status */
        partnershipStatusInfo?: ResolverInputTypes['PartnershipStatusInfo'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        virtualIbanEntries?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null;
            },
            ResolverInputTypes['VirtualIBANEntryConnection']
        ];
        memberships?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['MembershipsFilterInput'] | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['AccountMembershipOrderByInput'] | undefined | null;
            },
            ResolverInputTypes['AccountMembershipConnection']
        ];
        /** `true`if a consent is required to fetch new transactions */
        requiredConsentToFetchNewTransactions?: boolean | `@${string}`;
        /** Language used for account statements */
        language?: boolean | `@${string}`;
        /** Legal representative account membership */
        legalRepresentativeMembership?: ResolverInputTypes['AccountMembership'];
        /** Type of the account : EMoney if account holder has not finished the KYC requirements, PaymentService otherwise */
        paymentAccountType?: boolean | `@${string}`;
        /** Date of the account going from eMoney to PaymentService */
        upgradedAt?: boolean | `@${string}`;
        /** Link to the account's bank details */
        bankDetails?: boolean | `@${string}`;
        legalDocuments?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['LegalDocumentsFilterInput'] | undefined | null;
            },
            ResolverInputTypes['LegalDocumentConnection']
        ];
        /** A list of balances regarding an account. */
        balances?: ResolverInputTypes['AccountBalances'];
        statements?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['StatementFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['StatementConnection']
        ];
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['TransactionsOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['TransactionsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TransactionConnection']
        ];
        invoices?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null;
            },
            ResolverInputTypes['InvoiceConnection']
        ];
        receivedDirectDebitMandates?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value updatedAt desc) */
                orderBy?: ResolverInputTypes['AccountReceivedDirectDebitOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['AccountReceivedDirectDebitMandateFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['ReceivedDirectDebitMandateConnection']
        ];
        merchantProfiles?: [
            {
                /** number of elements in the list (default value 50) */
                first: number; /** When the list of elements needs to start after a element */
                after?: string | undefined | null; /** When the list of elements needs to be ordered */
                orderBy?: ResolverInputTypes['MerchantProfileOrderByInput'] | undefined | null; /** When the list of elements needs to be filtered */
                filters?: ResolverInputTypes['MerchantProfileFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['MerchantProfileConnection']
        ];
        standingOrders?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an offset to start at */
                offset?: number | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['AccountStandingOrderOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['AccountStandingOrderFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['StandingOrderConnection']
        ];
        fundingSources?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an offset to start at */
                offset?: number | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['FundingSourceOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['FundingSourceFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['FundingSourceConnection']
        ];
        trustedBeneficiaries?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                offset?: number | undefined | null; /** an order you can apply to your list of connections (default value label asc) */
                orderBy?: ResolverInputTypes['TrustedBeneficiaryOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['TrustedBeneficiaryFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TrustedBeneficiaryConnection']
        ];
        __typename?: boolean | `@${string}`;
    }>;
    /** A list of balances regarding an account. */
    ['AccountBalances']: AliasType<{
        /** Balance composed of booked, pending transactions and rolling reserve used known at the time of calculation. */
        available?: ResolverInputTypes['Amount'];
        /** Balance just composed of pending transactions. */
        pending?: ResolverInputTypes['Amount'];
        /** Balance just composed of booked transactions. */
        booked?: ResolverInputTypes['Amount'];
        /** Balance just composed of rolling reserve used in booked transactions. */
        reserved?: ResolverInputTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Closed status information */
    ['AccountClosedStatus']: AliasType<{
        /** Account status (always Closed for type AccountClosedStatus) */
        status?: boolean | `@${string}`;
        /** Reason why the account is suspended
    @Deprecated */
        reason?: boolean | `@${string}`;
        /** Reason why the account is currently closed */
        reasonInfo?: ResolverInputTypes['CloseAccountStatusReason'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Closing status information */
    ['AccountClosingStatus']: AliasType<{
        /** Account status (always Closing for type AccountClosingStatus) */
        status?: boolean | `@${string}`;
        /** Reason why the account is suspended
    @Deprecated */
        reason?: boolean | `@${string}`;
        /** Reason why the account is currently in closing */
        reasonInfo?: ResolverInputTypes['CloseAccountStatusReason'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['AccountConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** AccountEdge list */
        edges?: ResolverInputTypes['AccountEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Refers to the country of the account. It will determine the country code of the local IBAN of the account.
  
  Available Account Country: CCA3 */
    ['AccountCountry']: AccountCountry;
    /** Implements the Relay Edge interface */
    ['AccountEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The account */
        node?: ResolverInputTypes['Account'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountFilterInput']: {
        /** Account Status we want to filter on */
        status?: Array<ResolverInputTypes['AccountStatus']> | undefined | null;
        /** Account Payment Levels we want to filter on */
        paymentLevels?: Array<ResolverInputTypes['PaymentLevel']> | undefined | null;
        /** Searches name, account number, and IBAN */
        search?: string | undefined | null;
    };
    ['AccountFundingLimitsReachedReason']: AccountFundingLimitsReachedReason;
    /** The account holder is the person who owns the money stored in the account. The account holder can be one of your customers, whether it is a natural person or a legal person, or quite simply you. */
    ['AccountHolder']: AliasType<{
        /** Unique identifier of the account holder. */
        id?: boolean | `@${string}`;
        /** Verification status.
         *Banking regulations require financial institutions such as Swan to know and verify their customers in order to comply with their anti-money laundering and terrorist financing obligations. In banking jargon, we talk about KYC (Know Your Customers) procedure* */
        verificationStatus?: boolean | `@${string}`;
        /** Account holder type information. */
        info?: ResolverInputTypes['AccountHolderInfo'];
        /** Account holder status information. */
        statusInfo?: ResolverInputTypes['AccountHolderStatusInfo'];
        /** Residency address. */
        residencyAddress?: ResolverInputTypes['AddressInfo'];
        /** Created date. */
        createdDate?: boolean | `@${string}`;
        /** Updated date. */
        updatedDate?: boolean | `@${string}`;
        accounts?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['AccountOrderByInput'] | undefined | null;
            },
            ResolverInputTypes['AccountConnection']
        ];
        supportingDocumentCollections?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null;
            },
            ResolverInputTypes['SupportingDocumentCollectionConnection']
        ];
        fundingLimitSettingsChangeRequests?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null;
            },
            ResolverInputTypes['FundingLimitSettingsChangeRequestConnection']
        ];
        /** Account holder onboarding */
        onboarding?: ResolverInputTypes['Onboarding'];
        externalAccounts?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null;
            },
            ResolverInputTypes['ExternalAccountConnection']
        ];
        paymentMandates?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value updatedAt desc) */
                orderBy?: ResolverInputTypes['PaymentMandateOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['PaymentMandateFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['PaymentMandateConnection']
        ];
        /** Funding limit settings */
        fundingLimitSettings?: ResolverInputTypes['FundingLimitSettings'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Holder Canceled Status Information */
    ['AccountHolderCanceledStatusInfo']: AliasType<{
        /** Status of the account holder. */
        status?: boolean | `@${string}`;
        /** Reason why the account holder is suspended. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountHolderCompanyInfo']: AliasType<{
        /** Account holder type (always Company for type AccountHolderCompanyInfo) */
        type?: boolean | `@${string}`;
        /** Name of the company. */
        name?: boolean | `@${string}`;
        /** Registration number of the company (SIRET, ...). */
        registrationNumber?: boolean | `@${string}`;
        /** Registration date of the company. */
        companyRegistrationDate?: boolean | `@${string}`;
        /** Legal form of the company (SAS, SCI, SASU, ...). */
        companyType?: boolean | `@${string}`;
        /** Business activity. */
        businessActivity?: boolean | `@${string}`;
        /** Business activity description.
    This must be 1024 characters long maximum. */
        businessActivityDescription?: boolean | `@${string}`;
        /** Estimated monthly payment volume (euro). */
        monthlyPaymentVolume?: boolean | `@${string}`;
        /** The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
    
    The ultimate beneficiary is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: ResolverInputTypes['IndividualUltimateBeneficialOwner'];
        /** Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT */
        vatNumber?: boolean | `@${string}`;
        /** Tax Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ResolverInputTypes['AddressInformation'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)). */
    ['AccountHolderConnection']: AliasType<{
        /** Total number of element in the list. */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page. */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** AccountHolderEdge list. */
        edges?: ResolverInputTypes['AccountHolderEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface. */
    ['AccountHolderEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism. */
        cursor?: boolean | `@${string}`;
        /** The account holder. */
        node?: ResolverInputTypes['AccountHolder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Holder Enabled Status Information */
    ['AccountHolderEnabledStatusInfo']: AliasType<{
        /** Status of the account holder. */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountHolderFilterInput']: {
        status?: Array<ResolverInputTypes['AccountHolderStatus']> | undefined | null;
        types?: Array<ResolverInputTypes['AccountHolderType']> | undefined | null;
        verificationStatus?: Array<ResolverInputTypes['VerificationStatus']> | undefined | null;
        /** Searches company name, first name, last name */
        search?: string | undefined | null;
        firstName?: string | undefined | null;
        lastName?: string | undefined | null;
        birthDate?: string | undefined | null;
        registrationNumber?: string | undefined | null;
    };
    /** Individual account holder. */
    ['AccountHolderIndividualInfo']: AliasType<{
        /** Account holder type (always Individual for type AccountHolderIndividualInfo). */
        type?: boolean | `@${string}`;
        /** Account Holder's first name and last name. */
        name?: boolean | `@${string}`;
        /** Employment status of the account holder (regulatory questions). */
        employmentStatus?: boolean | `@${string}`;
        /** Monthly income of the account holder (regulatory questions). */
        monthlyIncome?: boolean | `@${string}`;
        /** User of the individual account holder. */
        user?: ResolverInputTypes['User'];
        /** Tax Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account holder types. */
    ['AccountHolderInfo']: AliasType<{
        /** Account holder type */
        type?: boolean | `@${string}`;
        /** Account holder name */
        name?: boolean | `@${string}`;
        ['...on AccountHolderCompanyInfo']?: Omit<ResolverInputTypes['AccountHolderCompanyInfo'], keyof ResolverInputTypes['AccountHolderInfo']>;
        ['...on AccountHolderIndividualInfo']?: Omit<ResolverInputTypes['AccountHolderIndividualInfo'], keyof ResolverInputTypes['AccountHolderInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Account Holder was not found */
    ['AccountHolderNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing account holders */
    ['AccountHolderOrderByFieldInput']: AccountHolderOrderByFieldInput;
    /** Order that can be applied when listing account holders */
    ['AccountHolderOrderByInput']: {
        field?: ResolverInputTypes['AccountHolderOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Account holder status. */
    ['AccountHolderStatus']: AccountHolderStatus;
    /** Account Holder Status Information */
    ['AccountHolderStatusInfo']: AliasType<{
        /** Status of the account holder. */
        status?: boolean | `@${string}`;
        ['...on AccountHolderCanceledStatusInfo']?: Omit<ResolverInputTypes['AccountHolderCanceledStatusInfo'], keyof ResolverInputTypes['AccountHolderStatusInfo']>;
        ['...on AccountHolderEnabledStatusInfo']?: Omit<ResolverInputTypes['AccountHolderEnabledStatusInfo'], keyof ResolverInputTypes['AccountHolderStatusInfo']>;
        ['...on AccountHolderSuspendedStatusInfo']?: Omit<ResolverInputTypes['AccountHolderSuspendedStatusInfo'], keyof ResolverInputTypes['AccountHolderStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Holder Suspended Status Information */
    ['AccountHolderSuspendedStatusInfo']: AliasType<{
        /** Status of the account holder. */
        status?: boolean | `@${string}`;
        /** Reason why the account holder is suspended. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account holder type */
    ['AccountHolderType']: AccountHolderType;
    /** Rejection returned if the account holder type is individual.
  An individual account holder can't create a b2b received direct debit mandate. */
    ['AccountHolderTypeIndividualRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Language: ISO 639-1 language code */
    ['AccountLanguage']: AccountLanguage;
    /** An account membership represents the rights of a user for a given account.
  
  *Each account is administered by an account membership having the capacity of legal representative. He has the possibility of delegating rights on this account to other users.* */
    ['AccountMembership']: AliasType<{
        /** Unique identifier of an account membership */
        id?: boolean | `@${string}`;
        /** email */
        email?: boolean | `@${string}`;
        /** user of this account membership */
        user?: ResolverInputTypes['User'];
        /** `true` if this account membership having the capacity of the legal representative of the account holder. */
        legalRepresentative?: boolean | `@${string}`;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount?: boolean | `@${string}`;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries?: boolean | `@${string}`;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments?: boolean | `@${string}`;
        /** `true` if this account membership can invite, update, suspend or resume memberships */
        canManageAccountMembership?: boolean | `@${string}`;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | `@${string}`;
        /** status of the account membership */
        statusInfo?: ResolverInputTypes['AccountMembershipStatusInfo'];
        /** account of the account membership */
        account?: ResolverInputTypes['Account'];
        /** Periodic Spending limit list */
        spendingLimits?: ResolverInputTypes['SpendingLimit'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** version of the account membership started from '1' and incremented at every updates */
        version?: boolean | `@${string}`;
        /** Residency address of the member */
        residencyAddress?: ResolverInputTypes['AddressInfo'];
        /** Tax Identification Number of the member */
        taxIdentificationNumber?: boolean | `@${string}`;
        /** List of accepted identification level */
        acceptedIdentificationLevels?: boolean | `@${string}`;
        /** Recommended identification level */
        recommendedIdentificationLevel?: boolean | `@${string}`;
        /** Indicate if the identity bound to the account membership has required identification level */
        hasRequiredIdentificationLevel?: boolean | `@${string}`;
        /** Disabled date */
        disabledAt?: boolean | `@${string}`;
        cards?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['CardOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['CardFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['CardConnection']
        ];
        /** Periodic Spending */
        spending?: ResolverInputTypes['Spending'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when a user is binded with the error to the account membership */
    ['AccountMembershipBindingUserErrorStatusInfo']: AliasType<{
        /** AccountMembership status (always BindingUserError for type AccountMembershipBindingUserErrorStatusInfo) */
        status?: boolean | `@${string}`;
        /** `true` if the first name of the user binded doesn't match with the invitation */
        firstNameMatchError?: boolean | `@${string}`;
        /** `true` if Swan hasn't verified the user's identity */
        idVerifiedMatchError?: boolean | `@${string}`;
        /** `true` if the last name of the user binded doesn't match with the invitation */
        lastNameMatchError?: boolean | `@${string}`;
        /** `true` if the phone number of the user binded doesn't match with the invitation */
        phoneNumberMatchError?: boolean | `@${string}`;
        /** `true` if the birth date of the user binded doesn't match with the invitation */
        birthDateMatchError?: boolean | `@${string}`;
        /** restricted to a user */
        restrictedTo?: ResolverInputTypes['RestrictedTo'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountMembershipCannotBeDisabledRejection']: AliasType<{
        accountMembershipId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountMembershipCannotBeUpdatedRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['AccountMembershipConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** AccountMembershipEdge list */
        edges?: ResolverInputTypes['AccountMembershipEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when the user has to consent to invite a new account membership */
    ['AccountMembershipConsentPendingStatusInfo']: AliasType<{
        /** AccountMembership status (always ConsentPending for type AccountMembershipConsentPendingStatusInfo) */
        status?: boolean | `@${string}`;
        /** The consent required to invite this account membership */
        consent?: ResolverInputTypes['Consent'];
        /** restricted to a user */
        restrictedTo?: ResolverInputTypes['RestrictedTo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when the account membership is disabled */
    ['AccountMembershipDisabledStatusInfo']: AliasType<{
        /** AccountMembership status (always Disabled for type AccountMembershipDisabledStatusInfo) */
        status?: boolean | `@${string}`;
        /** reason why the account membership is disabled */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['AccountMembershipEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The account membership */
        node?: ResolverInputTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when the account membership is enabled */
    ['AccountMembershipEnabledStatusInfo']: AliasType<{
        /** AccountMembership status (always Enabled for type AccountMembershipEnabledStatusInfo) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** when a new account membership is invited and there is no user binded yet */
    ['AccountMembershipInvitationSentStatusInfo']: AliasType<{
        /** AccountMembership status (always InvitationSent for type AccountMembershipInvitationSentStatusInfo) */
        status?: boolean | `@${string}`;
        /** restricted to a user */
        restrictedTo?: ResolverInputTypes['RestrictedTo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Account Membership is not allowed to use an operation. */
    ['AccountMembershipNotAllowedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AccountMembershipNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if invitation has not been sent to user yet */
    ['AccountMembershipNotReadyToBeBoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing account memberships */
    ['AccountMembershipOrderByFieldInput']: AccountMembershipOrderByFieldInput;
    /** Order that can be applied when listing account memberships */
    ['AccountMembershipOrderByInput']: {
        field?: ResolverInputTypes['AccountMembershipOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Filters that can be applied when listing accounts (Only applied in user context) */
    ['AccountMembershipsFilterInput']: {
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null;
        /** Can the user initiate payments on this account */
        canInitiatePayments?: boolean | undefined | null;
        /** Can the user manage account membership */
        canManageAccountMembership?: boolean | undefined | null;
        /** Can the user manage beneficiaries */
        canManageBeneficiaries?: boolean | undefined | null;
        /** Can the user view account */
        canViewAccount?: boolean | undefined | null;
        /** Account memberships status/statuses we're looking for */
        status?: Array<ResolverInputTypes['AccountMembershipStatus']> | undefined | null;
        /** Filtered by email */
        email?: string | undefined | null;
        /** Filtered by first name */
        firstName?: string | undefined | null;
        /** Filtered by last name */
        lastName?: string | undefined | null;
        /** Searches email, first name, last name, and id */
        search?: string | undefined | null;
    };
    /** List of account memberships permission */
    ['AccountMembershipsPermission']: AccountMembershipsPermission;
    /** AccountMembership enabled */
    ['AccountMembershipStatus']: AccountMembershipStatus;
    /** here are the different account membership status: */
    ['AccountMembershipStatusInfo']: AliasType<{
        /** AccountMembership status */
        status?: boolean | `@${string}`;
        ['...on AccountMembershipBindingUserErrorStatusInfo']?: Omit<ResolverInputTypes['AccountMembershipBindingUserErrorStatusInfo'], keyof ResolverInputTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipConsentPendingStatusInfo']?: Omit<ResolverInputTypes['AccountMembershipConsentPendingStatusInfo'], keyof ResolverInputTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipDisabledStatusInfo']?: Omit<ResolverInputTypes['AccountMembershipDisabledStatusInfo'], keyof ResolverInputTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipEnabledStatusInfo']?: Omit<ResolverInputTypes['AccountMembershipEnabledStatusInfo'], keyof ResolverInputTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipInvitationSentStatusInfo']?: Omit<ResolverInputTypes['AccountMembershipInvitationSentStatusInfo'], keyof ResolverInputTypes['AccountMembershipStatusInfo']>;
        ['...on AccountMembershipSuspendedStatusInfo']?: Omit<ResolverInputTypes['AccountMembershipSuspendedStatusInfo'], keyof ResolverInputTypes['AccountMembershipStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** when the account membership is suspended */
    ['AccountMembershipSuspendedStatusInfo']: AliasType<{
        /** AccountMembership status (always Suspended for type AccountMembershipSuspendedStatusInfo) */
        status?: boolean | `@${string}`;
        /** reason why the account membership is suspended */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Thrown when an related account is not eligible to the feature */
    ['AccountNotEligibleRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the account was not found or if the user does not have the rights to know that the card exists */
    ['AccountNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Swan account number */
    ['AccountNumber']: unknown;
    /** Account Opened status information */
    ['AccountOpenedStatus']: AliasType<{
        /** Account status (always Opened for type AccountOpenedStatus) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fields that can be used when ordering accounts */
    ['AccountOrderByFieldInput']: AccountOrderByFieldInput;
    /** Order that can be applied when listing accounts */
    ['AccountOrderByInput']: {
        field?: ResolverInputTypes['AccountOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Filter that can be passed to get the received direct debit mandate in a specific data range */
    ['AccountReceivedDirectDebitMandateFiltersInput']: {
        /** To filter on status values */
        status?: Array<ResolverInputTypes['ReceivedDirectDebitMandateStatus']> | undefined | null;
        /** To filter on scheme values */
        scheme?: Array<ResolverInputTypes['ReceivedDirectDebitMandateScheme']> | undefined | null;
    };
    /** Field we can use when ordering that can be applied when listing receives direct debit mandate results */
    ['AccountReceivedDirectDebitOrderByFieldInput']: AccountReceivedDirectDebitOrderByFieldInput;
    /** Order that can be applied when listing receives direct debit mandate results */
    ['AccountReceivedDirectDebitOrderByInput']: {
        field?: ResolverInputTypes['AccountReceivedDirectDebitOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Filters that can be applied when listing Standing orders */
    ['AccountStandingOrderFiltersInput']: {
        status?: Array<ResolverInputTypes['StandingOrderStatus']> | undefined | null;
    };
    /** Field we can use when ordering that can be applied when listing standing order results */
    ['AccountStandingOrderOrderByFieldInput']: AccountStandingOrderOrderByFieldInput;
    /** Order that can be applied when listing standing order results */
    ['AccountStandingOrderOrderByInput']: {
        field?: ResolverInputTypes['AccountStandingOrderOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    ['AccountStatus']: AccountStatus;
    ['AccountStatusInfo']: AliasType<{
        /** Account status */
        status?: boolean | `@${string}`;
        ['...on AccountClosedStatus']?: Omit<ResolverInputTypes['AccountClosedStatus'], keyof ResolverInputTypes['AccountStatusInfo']>;
        ['...on AccountClosingStatus']?: Omit<ResolverInputTypes['AccountClosingStatus'], keyof ResolverInputTypes['AccountStatusInfo']>;
        ['...on AccountOpenedStatus']?: Omit<ResolverInputTypes['AccountOpenedStatus'], keyof ResolverInputTypes['AccountStatusInfo']>;
        ['...on AccountSuspendedStatus']?: Omit<ResolverInputTypes['AccountSuspendedStatus'], keyof ResolverInputTypes['AccountStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Suspended status information */
    ['AccountSuspendedStatus']: AliasType<{
        /** Account status (always Suspended for type AccountSuspendedStatus) */
        status?: boolean | `@${string}`;
        /** Reason why the account is suspended
    @Deprecated */
        reason?: boolean | `@${string}`;
        /** Reason why the account is currently suspend */
        reasonInfo?: ResolverInputTypes['SuspendAccountStatusReason'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Verification */
    ['AccountVerification']: AliasType<{
        /** Creation date of the account verification */
        createdAt?: boolean | `@${string}`;
        /** Unique identifier of the Account Verification */
        id?: boolean | `@${string}`;
        /** Account Verification Status Information */
        statusInfo?: ResolverInputTypes['AccountVerificationStatusInfo'];
        /** Last update date of the account verification */
        updatedAt?: boolean | `@${string}`;
        ['...on DirectDebitAccountVerification']?: Omit<ResolverInputTypes['DirectDebitAccountVerification'], keyof ResolverInputTypes['AccountVerification']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the external account has already been rejected.
  
  In such a case, contact Swan directly to resolve the situation for this specific account holder. */
    ['AccountVerificationAlreadyRejectedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Account Verification Status */
    ['AccountVerificationStatus']: AccountVerificationStatus;
    /** Account Verification Status Information */
    ['AccountVerificationStatusInfo']: AliasType<{
        /** Account verification status */
        status?: boolean | `@${string}`;
        ['...on PendingReviewStatusInfo']?: Omit<ResolverInputTypes['PendingReviewStatusInfo'], keyof ResolverInputTypes['AccountVerificationStatusInfo']>;
        ['...on PendingVerificationStatusInfo']?: Omit<ResolverInputTypes['PendingVerificationStatusInfo'], keyof ResolverInputTypes['AccountVerificationStatusInfo']>;
        ['...on RejectedVerificationStatusInfo']?: Omit<ResolverInputTypes['RejectedVerificationStatusInfo'], keyof ResolverInputTypes['AccountVerificationStatusInfo']>;
        ['...on VerifiedStatusInfo']?: Omit<ResolverInputTypes['VerifiedStatusInfo'], keyof ResolverInputTypes['AccountVerificationStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Account Verification is not in the expected status */
    ['AccountVerificationWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ActionNotAllowedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ActivatePhysicalCardInput']: {
        /** Unique identifier present on physical card */
        identifier: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ActivatePhysicalCardPayload']: AliasType<{
        ActivatePhysicalCardSuccessPayload?: ResolverInputTypes['ActivatePhysicalCardSuccessPayload'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        PhysicalCardNotFoundRejection?: ResolverInputTypes['PhysicalCardNotFoundRejection'];
        PhysicalCardWrongStatusRejection?: ResolverInputTypes['PhysicalCardWrongStatusRejection'];
        CannotActivatePhysicalCardRejection?: ResolverInputTypes['CannotActivatePhysicalCardRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        UserNotCardHolderRejection?: ResolverInputTypes['UserNotCardHolderRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ActivatePhysicalCardSuccessPayload']: AliasType<{
        /** The consent required to activate this physical card */
        consent?: ResolverInputTypes['Consent'];
        /** The physicalCard to activate */
        physicalCard?: ResolverInputTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ActiveMerchantPaymentLinkStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** The date when the payment link expires.
    By default the payment link expires 120 days after it was created. */
        expiresAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new account membership */
    ['AddAccountMembershipInput']: {
        /** Unique identifier of a given account */
        accountId: string;
        /** Email address */
        email: string;
        /** Restricted to a user if necessary */
        restrictedTo: ResolverInputTypes['RestrictedToInput'];
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean;
        /** `true` if this account membership can invite, update, suspend or resume account membership */
        canManageAccountMembership: boolean;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Residency address of the member to be added */
        residencyAddress?: ResolverInputTypes['ResidencyAddressInput'] | undefined | null;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined | null;
    };
    ['AddAccountMembershipPayload']: AliasType<{
        AddAccountMembershipSuccessPayload?: ResolverInputTypes['AddAccountMembershipSuccessPayload'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InvalidPhoneNumberRejection?: ResolverInputTypes['InvalidPhoneNumberRejection'];
        PermissionCannotBeGrantedRejection?: ResolverInputTypes['PermissionCannotBeGrantedRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new account membership */
    ['AddAccountMembershipsInput']: {
        /** Unique identifier of a given account */
        accountId: string;
        /** Memberships to add to the account */
        memberships: Array<ResolverInputTypes['MembershipInfoInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['AddAccountMembershipsPayload']: AliasType<{
        AddAccountMembershipsSuccessPayload?: ResolverInputTypes['AddAccountMembershipsSuccessPayload'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InvalidPhoneNumberRejection?: ResolverInputTypes['InvalidPhoneNumberRejection'];
        PermissionCannotBeGrantedRejection?: ResolverInputTypes['PermissionCannotBeGrantedRejection'];
        TooManyItemsRejection?: ResolverInputTypes['TooManyItemsRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddAccountMembershipsSuccessPayload']: AliasType<{
        accountMemberships?: ResolverInputTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddAccountMembershipSuccessPayload']: AliasType<{
        accountMembership?: ResolverInputTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new card */
    ['AddCardInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ResolverInputTypes['DateTime'] | undefined | null;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Card name */
        name?: string | undefined | null;
        /** `true` to show the card confidential information in the same request */
        viewCardNumber?: boolean | undefined | null;
        /** The id of the card product to use to create the new card. */
        cardProductId?: string | undefined | null;
        /** Spending limit */
        spendingLimit?: ResolverInputTypes['SpendingLimitInput'] | undefined | null;
    };
    ['AddCardPayload']: AliasType<{
        AddCardSuccessPayload?: ResolverInputTypes['AddCardSuccessPayload'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        CardProductDisabledRejection?: ResolverInputTypes['CardProductDisabledRejection'];
        CardProductSuspendedRejection?: ResolverInputTypes['CardProductSuspendedRejection'];
        EnabledCardDesignNotFoundRejection?: ResolverInputTypes['EnabledCardDesignNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        MissingMandatoryFieldRejection?: ResolverInputTypes['MissingMandatoryFieldRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a new cards */
    ['AddCardsInput']: {
        /** The configuration of all the cards you want to add */
        cards: Array<ResolverInputTypes['CardConfigInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined | null;
    };
    ['AddCardsPayload']: AliasType<{
        AddCardsSuccessPayload?: ResolverInputTypes['AddCardsSuccessPayload'];
        AddingCardsToDifferentAccountsRejection?: ResolverInputTypes['AddingCardsToDifferentAccountsRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        TooManyItemsRejection?: ResolverInputTypes['TooManyItemsRejection'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        CardProductSuspendedRejection?: ResolverInputTypes['CardProductSuspendedRejection'];
        CardProductNotApplicableToPhysicalCardsRejection?: ResolverInputTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        CardProductDisabledRejection?: ResolverInputTypes['CardProductDisabledRejection'];
        EnabledCardDesignNotFoundRejection?: ResolverInputTypes['EnabledCardDesignNotFoundRejection'];
        MissingMandatoryFieldRejection?: ResolverInputTypes['MissingMandatoryFieldRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddCardsSuccessPayload']: AliasType<{
        /** The newly created cards */
        cards?: ResolverInputTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddCardSuccessPayload']: AliasType<{
        /** The new card added */
        card?: ResolverInputTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a new cards */
    ['AddCardsWithGroupDeliveryInput']: {
        /** Address to deliver the printed physical cards */
        groupDeliveryAddress: ResolverInputTypes['CompleteAddressWithContactInput'];
        /** The configuration of all the cards you want to add */
        cards: Array<ResolverInputTypes['CardConfigWithGroupDeliveryInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined | null;
    };
    ['AddCardsWithGroupDeliveryPayload']: AliasType<{
        AddCardsWithGroupDeliverySuccessPayload?: ResolverInputTypes['AddCardsWithGroupDeliverySuccessPayload'];
        AddingCardsToDifferentAccountsRejection?: ResolverInputTypes['AddingCardsToDifferentAccountsRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        TooManyItemsRejection?: ResolverInputTypes['TooManyItemsRejection'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        CardProductSuspendedRejection?: ResolverInputTypes['CardProductSuspendedRejection'];
        CardProductNotApplicableToPhysicalCardsRejection?: ResolverInputTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        CardProductDisabledRejection?: ResolverInputTypes['CardProductDisabledRejection'];
        EnabledCardDesignNotFoundRejection?: ResolverInputTypes['EnabledCardDesignNotFoundRejection'];
        MissingMandatoryFieldRejection?: ResolverInputTypes['MissingMandatoryFieldRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddCardsWithGroupDeliverySuccessPayload']: AliasType<{
        /** The newly created cards */
        cards?: ResolverInputTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new digital card */
    ['AddDigitalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Provider for which to generate a digitalCard */
        walletProvider: ResolverInputTypes['WalletProviderType'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** Payload returned on mutation completion */
    ['AddDigitalCardPayload']: AliasType<{
        AddDigitalCardSuccessPayload?: ResolverInputTypes['AddDigitalCardSuccessPayload'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        CardCanNotBeDigitalizedRejection?: ResolverInputTypes['CardCanNotBeDigitalizedRejection'];
        ApplePayNotAllowedForProjectRejection?: ResolverInputTypes['ApplePayNotAllowedForProjectRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        UserNotCardHolderRejection?: ResolverInputTypes['UserNotCardHolderRejection'];
        CardProductDisabledRejection?: ResolverInputTypes['CardProductDisabledRejection'];
        EnabledCardDesignNotFoundRejection?: ResolverInputTypes['EnabledCardDesignNotFoundRejection'];
        MissingMandatoryFieldRejection?: ResolverInputTypes['MissingMandatoryFieldRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddDigitalCardSuccessPayload']: AliasType<{
        /** Digital Card used for ApplePay or GooglePay
    
    The consent can be found in the digital card status information. */
        digitalCard?: ResolverInputTypes['PendingDigitalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a Direct Debit Funding Source */
    ['AddDirectDebitFundingSourceInput']: {
        /** Scheme of the underlying payment mandate */
        scheme: ResolverInputTypes['SEPADirectDebitScheme'];
        /** Id of the account on which to create a funding source.
    Money will be funded to this account when an `initiateFundingRequest` is done using this funding source */
        accountId: string;
        /** IBAN to use in the direct debit transaction that will be triggered when funding the account.
    Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source */
        iban: ResolverInputTypes['IBAN'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Name to give to this funding source */
        name?: string | undefined | null;
    };
    /** Add Direct Debit Funding Source Payload */
    ['AddDirectDebitFundingSourcePayload']: AliasType<{
        AddDirectDebitFundingSourceSuccessPayload?: ResolverInputTypes['AddDirectDebitFundingSourceSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        NotFoundRejection?: ResolverInputTypes['NotFoundRejection'];
        AccountVerificationAlreadyRejectedRejection?: ResolverInputTypes['AccountVerificationAlreadyRejectedRejection'];
        IBANNotReachableRejection?: ResolverInputTypes['IBANNotReachableRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Add Direct Debit Funding Source Success Payload */
    ['AddDirectDebitFundingSourceSuccessPayload']: AliasType<{
        /** The created funding source */
        fundingSource?: ResolverInputTypes['FundingSource'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddExternalAccountBalanceInput']: {
        /** Unique identifier of a given external account */
        externalAccountId: string;
        /** Amount of the balance */
        amount: ResolverInputTypes['AmountInput'];
        /** Type of the balance */
        type: ResolverInputTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: ResolverInputTypes['DateTime'];
    };
    ['AddExternalAccountBalancePayload']: AliasType<{
        AddExternalAccountBalanceSuccessPayload?: ResolverInputTypes['AddExternalAccountBalanceSuccessPayload'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        ExternalAccountBalanceAlreadyExistsRejection?: ResolverInputTypes['ExternalAccountBalanceAlreadyExistsRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddExternalAccountBalanceSuccessPayload']: AliasType<{
        /** The added external balance */
        externalAccountBalance?: ResolverInputTypes['ExternalAccountBalance'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddExternalAccountInput']: {
        /** Unique identifier of a given account holder */
        accountHolderId: string;
        /** External account identifier */
        externalId: string;
        /** Name of the account */
        name?: string | undefined | null;
        /** Type of account */
        cashAccountType: ResolverInputTypes['CashAccountType'];
        /** Bank Identifier Code */
        BIC: ResolverInputTypes['BIC'];
        /** International Bank Account Number */
        IBAN: ResolverInputTypes['IBAN'];
        /** Currency */
        currency: ResolverInputTypes['Currency'];
        /** Account Holder name */
        holderName: string;
        /** Country */
        country: ResolverInputTypes['CCA3'];
        /** Original Created date */
        originalCreatedAt: ResolverInputTypes['DateTime'];
        /** Usage information of the account */
        usage: ResolverInputTypes['ExternalAccountUsage'];
        /** Source of the account information */
        source: string;
        /** Balances */
        balances?: Array<ResolverInputTypes['ExternalAccountBalanceInput']> | undefined | null;
    };
    ['AddExternalAccountPayload']: AliasType<{
        AddExternalAccountSuccessPayload?: ResolverInputTypes['AddExternalAccountSuccessPayload'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        IbanValidationRejection?: ResolverInputTypes['IbanValidationRejection'];
        ExternalAccountAlreadyExistsRejection?: ResolverInputTypes['ExternalAccountAlreadyExistsRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddExternalAccountSuccessPayload']: AliasType<{
        /** The added external account */
        externalAccount?: ResolverInputTypes['ExternalAccount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new request for funding limit settings change */
    ['AddFundingLimitSettingsChangeRequestInput']: {
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit: ResolverInputTypes['FundingLimitAmountInput'];
        /** Requested amount settings for the funding limit */
        fundingLimit: ResolverInputTypes['FundingLimitAmountInput'];
        /** Unique identifier of a given account holder */
        accountHolderId: string;
    };
    /** Payload returned on mutation completion */
    ['AddFundingLimitSettingsChangeRequestPayload']: AliasType<{
        AddFundingLimitSettingsChangeRequestSuccessPayload?: ResolverInputTypes['AddFundingLimitSettingsChangeRequestSuccessPayload'];
        FundingLimitSettingsChangeRequestBadAmountRejection?: ResolverInputTypes['FundingLimitSettingsChangeRequestBadAmountRejection'];
        AccountHolderNotFoundRejection?: ResolverInputTypes['AccountHolderNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Add Funding Limit Settings Change Request Success Payload */
    ['AddFundingLimitSettingsChangeRequestSuccessPayload']: AliasType<{
        /** The new request for funding limit settings change */
        fundingLimitSettingsChangeRequest?: ResolverInputTypes['FundingLimitSettingsChangeRequest'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the attempting to add cards to different accounts. */
    ['AddingCardsToDifferentAccountsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add an Internal Direct Debit Payment Mandate */
    ['AddInternalDirectDebitPaymentMandateInput']: {
        /** The ID of the concerned merchant payment method */
        paymentMethodId: string;
        /** Determines whether the payment mandate is a one-off or recurrent */
        sequence?: ResolverInputTypes['InternalDirectDebitSequence'] | undefined | null;
        /** Reference of the payment mandate */
        reference?: string | undefined | null;
        /** Language that will be used to produce the mandate PDF document */
        language?: ResolverInputTypes['MandateLanguage'] | undefined | null;
        /** ID of the Swan account of the debtor */
        debtorAccountId: string;
        /** Signature date of the Internal Direct Debit mandate */
        signatureDate?: ResolverInputTypes['Date'] | undefined | null;
        /** Custom name of the Internal Direct Debit mandate */
        name?: string | undefined | null;
    };
    /** Union type return by the addInternalDirectDebitPaymentMandate mutation */
    ['AddInternalDirectDebitPaymentMandatePayload']: AliasType<{
        AddInternalDirectDebitPaymentMandateSuccessPayload?: ResolverInputTypes['AddInternalDirectDebitPaymentMandateSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        NotFoundRejection?: ResolverInputTypes['NotFoundRejection'];
        DebtorAccountNotAllowedRejection?: ResolverInputTypes['DebtorAccountNotAllowedRejection'];
        DebtorAccountClosedRejection?: ResolverInputTypes['DebtorAccountClosedRejection'];
        SchemeWrongRejection?: ResolverInputTypes['SchemeWrongRejection'];
        PaymentMandateReferenceAlreadyUsedRejection?: ResolverInputTypes['PaymentMandateReferenceAlreadyUsedRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the addInternalDirectDebitPaymentMandate mutation */
    ['AddInternalDirectDebitPaymentMandateSuccessPayload']: AliasType<{
        paymentMandate?: ResolverInputTypes['InternalPaymentDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a Merchant Profile */
    ['AddMerchantProfileInput']: {
        /** ID of the Swan account which the merchantProfile is associated to */
        accountId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website */
        merchantWebsite?: string | undefined | null;
        /** base64 encoded merchant's logo */
        merchantLogo?: string | undefined | null;
        /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: ResolverInputTypes['ProductType'];
        /** Expected annual activity volumes for all payment methods. */
        expectedMonthlyPaymentVolume: ResolverInputTypes['AmountInput'];
        /** expected average basket value. */
        expectedAverageBasket: ResolverInputTypes['AmountInput'];
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page. */
        accentColor?: string | undefined | null;
    };
    /** Add Merchant Profile Payload */
    ['AddMerchantProfilePayload']: AliasType<{
        AddMerchantProfileSuccessPayload?: ResolverInputTypes['AddMerchantProfileSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Add Merchant Profile Success Payload */
    ['AddMerchantProfileSuccessPayload']: AliasType<{
        /** Merchant Profile */
        merchantProfile?: ResolverInputTypes['MerchantProfile'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddOrUpdateExternalAccountBalanceInput']: {
        /** Unique identifier of a given external account */
        externalAccountId: string;
        /** Amount of the balance */
        amount: ResolverInputTypes['AmountInput'];
        /** Type of the balance */
        type: ResolverInputTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: ResolverInputTypes['DateTime'];
    };
    ['AddOrUpdateExternalAccountBalancePayload']: AliasType<{
        AddOrUpdateExternalAccountBalanceSuccessPayload?: ResolverInputTypes['AddOrUpdateExternalAccountBalanceSuccessPayload'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddOrUpdateExternalAccountBalanceSuccessPayload']: AliasType<{
        /** The added external balance */
        externalAccountBalance?: ResolverInputTypes['ExternalAccountBalance'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a received internal direct debit mandate B2b. */
    ['AddReceivedInternalDirectDebitB2bMandateInput']: {
        /** The associated Payment Mandate ID */
        paymentMandateId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined | null;
    };
    /** Union type return by the addReceivedInternalDirectDebitB2bMandate mutation */
    ['AddReceivedInternalDirectDebitB2bMandatePayload']: AliasType<{
        AddReceivedInternalDirectDebitB2bMandateSuccessPayload?: ResolverInputTypes['AddReceivedInternalDirectDebitB2bMandateSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        PaymentMandateMandateNotFoundRejection?: ResolverInputTypes['PaymentMandateMandateNotFoundRejection'];
        AccountHolderTypeIndividualRejection?: ResolverInputTypes['AccountHolderTypeIndividualRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the addReceivedInternalDirectDebitB2bMandate mutation */
    ['AddReceivedInternalDirectDebitB2bMandateSuccessPayload']: AliasType<{
        /** The received direct debit mandate is added */
        receivedDirectDebitMandate?: ResolverInputTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a received sepa direct debit mandate B2b. */
    ['AddReceivedSepaDirectDebitB2bMandateInput']: {
        /** The unique identifier of the received direct debit mandate */
        mandateReference: string;
        /** The Sepa Creditor Identifier of the creditor */
        creditorIdentifier: string;
        /** The name of the creditor */
        creditorName: string;
        /** The Swan Iban of the debtor */
        iban: string;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined | null;
        /** Sequence of the mandate */
        sequence: ResolverInputTypes['SEPAReceivedDirectDebitMandateSequence'];
        /** Date of signature of the mandate */
        signatureDate?: ResolverInputTypes['Date'] | undefined | null;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** Union type return by the addReceivedSepaDirectDebitB2bMandate mutation */
    ['AddReceivedSepaDirectDebitB2bMandatePayload']: AliasType<{
        AddReceivedSepaDirectDebitB2bMandateSuccessPayload?: ResolverInputTypes['AddReceivedSepaDirectDebitB2bMandateSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        AccountHolderTypeIndividualRejection?: ResolverInputTypes['AccountHolderTypeIndividualRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the addReceivedSepaDirectDebitB2bMandate mutation */
    ['AddReceivedSepaDirectDebitB2bMandateSuccessPayload']: AliasType<{
        /** The received direct debit mandate is added */
        receivedDirectDebitMandate?: ResolverInputTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Address Information */
    ['Address']: AliasType<{
        /** address line 1 */
        addressLine1?: boolean | `@${string}`;
        /** addressLine2 */
        addressLine2?: boolean | `@${string}`;
        /** city */
        city?: boolean | `@${string}`;
        /** postal code (max 10 characters) */
        postalCode?: boolean | `@${string}`;
        /** state */
        state?: boolean | `@${string}`;
        /** country */
        country?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Address information. */
    ['AddressInfo']: AliasType<{
        /** Address line 1. */
        addressLine1?: boolean | `@${string}`;
        /** Address line 2. */
        addressLine2?: boolean | `@${string}`;
        /** City. */
        city?: boolean | `@${string}`;
        /** Postal code. */
        postalCode?: boolean | `@${string}`;
        /** State. */
        state?: boolean | `@${string}`;
        /** Country. */
        country?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Address */
    ['AddressInformation']: AliasType<{
        /** Address */
        addressLine1?: boolean | `@${string}`;
        /** Address */
        addressLine2?: boolean | `@${string}`;
        /** City */
        city?: boolean | `@${string}`;
        /** Country */
        country?: boolean | `@${string}`;
        /** Postal code */
        postalCode?: boolean | `@${string}`;
        /** State */
        state?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Address */
    ['AddressInformationInput']: {
        /** Address */
        addressLine1: string;
        /** Address */
        addressLine2?: string | undefined | null;
        /** City */
        city: string;
        /** Country */
        country: ResolverInputTypes['CCA3'];
        /** Postal code */
        postalCode: string;
        /** State */
        state?: string | undefined | null;
    };
    /** Address Information */
    ['AddressInput']: {
        /** address line 1 (max 100 characters) */
        addressLine1?: string | undefined | null;
        /** address line 2 (max 100 characters) */
        addressLine2?: string | undefined | null;
        /** city (max 100 characters) */
        city?: string | undefined | null;
        /** postal code (max 10 characters) */
        postalCode?: string | undefined | null;
        /** state (max 100 characters) */
        state?: string | undefined | null;
        /** country code */
        country: ResolverInputTypes['CCA3'];
    };
    ['AddSepaDirectDebitPaymentMandateInput']: {
        /** Specifies payment ID of a SEPA Direct Debit CORE or B2B payment method. */
        paymentMethodId: string;
        /** Determines whether the payment mandate is a one-off or recurrent */
        sequence: ResolverInputTypes['DirectDebitSequence'];
        /** Unique reference of the SEPA Direct Debit Payment Mandate. */
        reference?: string | undefined | null;
        /** Language that will be used to produce the mandate PDF document */
        language: ResolverInputTypes['MandateLanguage'];
        /** Signature date of the SEPA Direct Debit Payment Mandate */
        signatureDate: ResolverInputTypes['Date'];
        /** Debtor of the SEPA Direct Debit Payment Mandate */
        debtor: ResolverInputTypes['SepaPaymentMandateDebtorInput'];
        /** Custom name of the SEPA Direct Debit Payment Mandate */
        name?: string | undefined | null;
    };
    /** Union type return by the addSepaDirectDebitPaymentMandate mutation */
    ['AddSepaDirectDebitPaymentMandatePayload']: AliasType<{
        AddSepaDirectDebitPaymentMandateSuccessPayload?: ResolverInputTypes['AddSepaDirectDebitPaymentMandateSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        NotFoundRejection?: ResolverInputTypes['NotFoundRejection'];
        DebtorAccountNotAllowedRejection?: ResolverInputTypes['DebtorAccountNotAllowedRejection'];
        DebtorAccountClosedRejection?: ResolverInputTypes['DebtorAccountClosedRejection'];
        SchemeWrongRejection?: ResolverInputTypes['SchemeWrongRejection'];
        PaymentMandateReferenceAlreadyUsedRejection?: ResolverInputTypes['PaymentMandateReferenceAlreadyUsedRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        PaymentMethodNotCompatibleRejection?: ResolverInputTypes['PaymentMethodNotCompatibleRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the addSepaDirectDebitPaymentMandate mutation */
    ['AddSepaDirectDebitPaymentMandateSuccessPayload']: AliasType<{
        paymentMandate?: ResolverInputTypes['SEPAPaymentDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to add a new card */
    ['AddSingleUseVirtualCardInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Spending limit */
        spendingLimit: ResolverInputTypes['SpendingLimitInput'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Card name */
        name?: string | undefined | null;
        /** `true` to show the card confidential information in the same request */
        viewCardNumber?: boolean | undefined | null;
        /** The id of the card product to use to create the new card. */
        cardProductId?: string | undefined | null;
    };
    ['AddSingleUseVirtualCardPayload']: AliasType<{
        AddSingleUseVirtualCardSuccessForUserPayload?: ResolverInputTypes['AddSingleUseVirtualCardSuccessForUserPayload'];
        AddSingleUseVirtualCardSuccessForProjectOwnerPayload?: ResolverInputTypes['AddSingleUseVirtualCardSuccessForProjectOwnerPayload'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        CardProductSuspendedRejection?: ResolverInputTypes['CardProductSuspendedRejection'];
        CardProductDisabledRejection?: ResolverInputTypes['CardProductDisabledRejection'];
        EnabledCardDesignNotFoundRejection?: ResolverInputTypes['EnabledCardDesignNotFoundRejection'];
        MissingMandatoryFieldRejection?: ResolverInputTypes['MissingMandatoryFieldRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to add a new single-use virtual cards */
    ['AddSingleUseVirtualCardsInput']: {
        /** The configuration of all the cards you want to add */
        cards: Array<ResolverInputTypes['SingleUseVirtualCardConfigInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined | null;
    };
    ['AddSingleUseVirtualCardsPayload']: AliasType<{
        AddSingleUseVirtualCardsSuccessPayload?: ResolverInputTypes['AddSingleUseVirtualCardsSuccessPayload'];
        AddingCardsToDifferentAccountsRejection?: ResolverInputTypes['AddingCardsToDifferentAccountsRejection'];
        TooManyItemsRejection?: ResolverInputTypes['TooManyItemsRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        CardProductSuspendedRejection?: ResolverInputTypes['CardProductSuspendedRejection'];
        CardProductDisabledRejection?: ResolverInputTypes['CardProductDisabledRejection'];
        EnabledCardDesignNotFoundRejection?: ResolverInputTypes['EnabledCardDesignNotFoundRejection'];
        MissingMandatoryFieldRejection?: ResolverInputTypes['MissingMandatoryFieldRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddSingleUseVirtualCardsSuccessPayload']: AliasType<{
        /** The newly created single use virtual cards */
        cards?: ResolverInputTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddSingleUseVirtualCardSuccessForProjectOwnerPayload']: AliasType<{
        /** The new card added */
        card?: ResolverInputTypes['Card'];
        /** Card confidential */
        confidential?: ResolverInputTypes['CardConfidential'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddSingleUseVirtualCardSuccessForUserPayload']: AliasType<{
        /** The new card added */
        card?: ResolverInputTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddVirtualIbanEntryPayload']: AliasType<{
        AddVirtualIbanEntrySuccessPayload?: ResolverInputTypes['AddVirtualIbanEntrySuccessPayload'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AddVirtualIbanEntrySuccessPayload']: AliasType<{
        virtualIbanEntry?: ResolverInputTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to Add a Virtual IBAN */
    ['AddVirtualIbanInput']: {
        /** Unique identifier of a given account */
        accountId: string;
    };
    /** Input values needed to add a webhook subscription */
    ['AddWebhookSubscriptionInput']: {
        /** A short descriptive label for the subscription
    (max 255 characters) */
        label: string;
        /** The endpoint URL events will be sent to
    (max 255 characters) */
        endpoint: string;
        /** The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
    (max 36 characters) */
        secret?: string | undefined | null;
        /** The types of subscribed events
    A subset of unique IDs from `webhookEventTypes` */
        eventTypes: Array<string>;
        /** Control if the subscription should be enabled on creation */
        status: ResolverInputTypes['WebhookSubscriptionCreationStatus'];
    };
    ['AllowedValue']: AliasType<{
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to Allow SDD */
    ['AllowSddInput']: {
        /** Unique identifier of a given account */
        accountId: string;
    };
    ['AllowSddPayload']: AliasType<{
        AllowSddSuccessPayload?: ResolverInputTypes['AllowSddSuccessPayload'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AllowSddSuccessPayload']: AliasType<{
        account?: ResolverInputTypes['Account'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AllowSddVirtualIbanEntryInput']: {
        ibanEntryId: string;
    };
    ['AllowSddVirtualIbanEntryPayload']: AliasType<{
        AllowSddVirtualIbanEntrySuccessPayload?: ResolverInputTypes['AllowSddVirtualIbanEntrySuccessPayload'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AllowSddVirtualIbanEntrySuccessPayload']: AliasType<{
        virtualIbanEntry?: ResolverInputTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if card already has a valid Physical Card */
    ['AlreadyValidPhysicalCardRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AmlRiskLevel']: AmlRiskLevel;
    /** Amount with its currency */
    ['Amount']: AliasType<{
        /** currency */
        currency?: boolean | `@${string}`;
        /** value of the amount */
        value?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Amount with its currency */
    ['AmountInput']: {
        /** value of the amount */
        value: ResolverInputTypes['AmountValue'];
        /** currency */
        currency: ResolverInputTypes['Currency'];
    };
    /** The amount given with fractional digits, where fractions must be compliant to the currency definition. Up to 14 significant figures. Negative amounts are signed by minus. The decimal separator is a dot.
  
  Example: Valid representations for EUR with up to two decimals are:
  
  1056
  5768.2
  -1.50
  5877.78 */
    ['AmountValue']: unknown;
    /** Rejection return if the project is not configured to allow Apple Pay */
    ['ApplePayNotAllowedForProjectRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Approved Funding Limit */
    ['ApprovedFundingLimit']: AliasType<{
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit?: ResolverInputTypes['FundingLimitAmount'];
        /** Requested amount settings for the funding limit */
        fundingLimit?: ResolverInputTypes['FundingLimitAmount'];
        __typename?: boolean | `@${string}`;
    }>;
    ['AuditId']: unknown;
    /** A method used to authenticate a user */
    ['Authenticator']: AliasType<{
        /** Operating System parsed from the user agent (eg AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, ...) */
        os?: boolean | `@${string}`;
        /** Device Brand parsed from the user agent (eg: Acer, Alcatel, Amazon, Apple, ...) */
        brand?: boolean | `@${string}`;
        /** Device Model parsed from the user agent */
        model?: boolean | `@${string}`;
        /** Type of authenticator */
        type?: boolean | `@${string}`;
        /** Raw user agent */
        userAgent?: boolean | `@${string}`;
        /** Accept-Language header used during registration */
        acceptLanguage?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['AuthenticatorType']: AuthenticatorType;
    ['AuthorizationId']: unknown;
    /** Type of the card authorization transaction */
    ['AuthorizationType']: AuthorizationType;
    /** Rejection returned if the status account is not valid */
    ['BadAccountStatusRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['BadRequestRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Balance Information */
    ['Balance']: AliasType<{
        /** Matching account for this balance */
        account?: ResolverInputTypes['Account'];
        /** A list of balances regarding an account. */
        balances?: ResolverInputTypes['AccountBalances'];
        /** Last SCT OUT transaction */
        lastSctOut?: ResolverInputTypes['SEPACreditTransferTransaction'];
        /** Last SCT IN transaction */
        lastSctIn?: ResolverInputTypes['SEPACreditTransferTransaction'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information about the banking institution */
    ['Bank']: AliasType<{
        /** Bank name */
        name?: boolean | `@${string}`;
        /** Bank Branch Code */
        branch?: boolean | `@${string}`;
        /** Bank local identifier (unique by country) */
        nationalId?: boolean | `@${string}`;
        /** Bank BIC code */
        bic?: boolean | `@${string}`;
        /** Bank address (We might only be able to fill in the country) */
        address?: ResolverInputTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Basic Physical Card Info */
    ['BasicPhysicalCardInfo']: AliasType<{
        /** Physical Card expiration date  with MM/YY string format */
        expiryDate?: boolean | `@${string}`;
        /** Offline Spending limit defined by Swan */
        offlineSpendingLimit?: ResolverInputTypes['Amount'];
        /** Masked Card Number */
        cardMaskedNumber?: boolean | `@${string}`;
        /** Custom Options */
        customOptions?: ResolverInputTypes['PhysicalCardCustomOptions'];
        __typename?: boolean | `@${string}`;
    }>;
    /** BeneficiaryAccountHolderType */
    ['BeneficiaryAccountHolderType']: BeneficiaryAccountHolderType;
    /** BeneficiaryAccountStatus */
    ['BeneficiaryAccountStatus']: BeneficiaryAccountStatus;
    /** Beneficiary name and IBAN match */
    ['BeneficiaryMatch']: AliasType<{
        accountStatus?: boolean | `@${string}`;
        accountHolderType?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Beneficiary name and IBAN did not match */
    ['BeneficiaryMismatch']: AliasType<{
        accountStatus?: boolean | `@${string}`;
        accountHolderType?: boolean | `@${string}`;
        /** Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank */
        nameSuggestion?: boolean | `@${string}`;
        /** Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank */
        accountHolderResidencyCity?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Beneficiary type */
    ['BeneficiaryType']: BeneficiaryType;
    /** Beneficiary name and IBAN did not match entirely possibly caused by a mistype */
    ['BeneficiaryTypo']: AliasType<{
        accountStatus?: boolean | `@${string}`;
        accountHolderType?: boolean | `@${string}`;
        /** Only returned if the information is provided by the beneficiary's bank */
        nameSuggestion?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** BeneficiaryVerification input */
    ['BeneficiaryVerificationInput']: {
        /** IBAN to verify */
        iban: ResolverInputTypes['IBAN'];
        /** Name to correlate */
        name: string;
        /** AccountId of the initiator of the payment */
        debtorAccountId: string;
    };
    /** BeneficiaryVerificationResult */
    ['BeneficiaryVerificationResult']: AliasType<{
        BeneficiaryMatch?: ResolverInputTypes['BeneficiaryMatch'];
        BeneficiaryTypo?: ResolverInputTypes['BeneficiaryTypo'];
        BeneficiaryMismatch?: ResolverInputTypes['BeneficiaryMismatch'];
        InvalidBeneficiaryVerification?: ResolverInputTypes['InvalidBeneficiaryVerification'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Bank Identifier Code */
    ['BIC']: unknown;
    ['BindAccountMembershipInput']: {
        accountMembershipId: string;
    };
    ['BindAccountMembershipPayload']: AliasType<{
        BindAccountMembershipSuccessPayload?: ResolverInputTypes['BindAccountMembershipSuccessPayload'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        AccountMembershipNotFoundRejection?: ResolverInputTypes['AccountMembershipNotFoundRejection'];
        AccountMembershipNotReadyToBeBoundRejection?: ResolverInputTypes['AccountMembershipNotReadyToBeBoundRejection'];
        IdentityAlreadyBindToAccountMembershipRejection?: ResolverInputTypes['IdentityAlreadyBindToAccountMembershipRejection'];
        RestrictedToUserRejection?: ResolverInputTypes['RestrictedToUserRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['BindAccountMembershipSuccessPayload']: AliasType<{
        accountMembership?: ResolverInputTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Booked transaction status information */
    ['BookedTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The Date when the transaction is posted to an account on the Swan books. */
        bookingDate?: boolean | `@${string}`;
        /** The Date when the transaction is considered effective in accounting */
        valueDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Business activity. */
    ['BusinessActivity']: BusinessActivity;
    /** Inputs to cancel a card */
    ['CancelCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
    };
    ['CancelCardPayload']: AliasType<{
        CancelCardSuccessPayload?: ResolverInputTypes['CancelCardSuccessPayload'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelCardSuccessPayload']: AliasType<{
        /** The canceled card */
        card?: ResolverInputTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input of the `cancelConsent` mutation */
    ['CancelConsentInput']: {
        consentId: string;
    };
    /** Payload of the `cancelConsent` mutation */
    ['CancelConsentPayload']: AliasType<{
        CancelConsentSuccessPayload?: ResolverInputTypes['CancelConsentSuccessPayload'];
        ConsentNotFoundRejection?: ResolverInputTypes['ConsentNotFoundRejection'];
        NotReachableConsentStatusRejection?: ResolverInputTypes['NotReachableConsentStatusRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Success payload of the `cancelConsent` mutation */
    ['CancelConsentSuccessPayload']: AliasType<{
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to cancel a digital card */
    ['CancelDigitalCardInput']: {
        /** Unique identifier of a digital card */
        digitalCardId: string;
    };
    ['CancelDigitalCardPayload']: AliasType<{
        CancelDigitalCardSuccessPayload?: ResolverInputTypes['CancelDigitalCardSuccessPayload'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        DigitalCardNotFoundRejection?: ResolverInputTypes['DigitalCardNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelDigitalCardSuccessPayload']: AliasType<{
        /** The canceled digital card */
        digitalCard?: ResolverInputTypes['DigitalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source Canceled Reason */
    ['CanceledFundingSourceReason']: CanceledFundingSourceReason;
    /** Funding Source Canceled status information */
    ['CanceledFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Canceled status */
        status?: boolean | `@${string}`;
        /** Date at which the funding source was enabled */
        enabledAt?: boolean | `@${string}`;
        /** Date at which the funding source was canceled */
        canceledAt?: boolean | `@${string}`;
        /** Reason code of the cancellation */
        reasonCode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level for the process associated to this identification that has been cancelled by the end-user */
    ['CanceledIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Cancelled` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** CanceledMerchantPaymentMethodStatusInfo */
    ['CanceledMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method canceled date */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** CanceledMerchantProfileStatusInfo */
    ['CanceledMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        canceledAt?: boolean | `@${string}`;
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Canceled transaction status information */
    ['CanceledTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The date when the transaction was canceled */
        canceledDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Cancel Funding Source Input */
    ['CancelFundingSourceInput']: {
        /** ID of the funding source to cancel */
        id: string;
    };
    /** Cancel Funding Source Payload */
    ['CancelFundingSourcePayload']: AliasType<{
        CancelFundingSourceSuccessPayload?: ResolverInputTypes['CancelFundingSourceSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        NotFoundRejection?: ResolverInputTypes['NotFoundRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Cancel Funding Source Success Payload */
    ['CancelFundingSourceSuccessPayload']: AliasType<{
        /** Canceled Funding Source */
        fundingSource?: ResolverInputTypes['FundingSource'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to cancel a physical card */
    ['CancelPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Reason why the physical card is canceled */
        reason: ResolverInputTypes['CancelPhysicalCardReason'];
    };
    ['CancelPhysicalCardPayload']: AliasType<{
        CancelPhysicalCardSuccessPayload?: ResolverInputTypes['CancelPhysicalCardSuccessPayload'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        PhysicalCardNotFoundRejection?: ResolverInputTypes['PhysicalCardNotFoundRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** reason why the physical card is canceled */
    ['CancelPhysicalCardReason']: CancelPhysicalCardReason;
    ['CancelPhysicalCardSuccessPayload']: AliasType<{
        /** The canceled physical card */
        physicalCard?: ResolverInputTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelStandingOrderInput']: {
        standingOrderId: string;
    };
    ['CancelStandingOrderPayload']: AliasType<{
        CancelStandingOrderSuccessPayload?: ResolverInputTypes['CancelStandingOrderSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        StandingOrderNotFoundRejection?: ResolverInputTypes['StandingOrderNotFoundRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelStandingOrderSuccessPayload']: AliasType<{
        standingOrder?: ResolverInputTypes['StandingOrder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Cancel transaction */
    ['CancelTransactionInput']: {
        /** transaction ID to cancel */
        transactionId: string;
    };
    ['CancelTransactionPayload']: AliasType<{
        CancelTransactionSuccessPayload?: ResolverInputTypes['CancelTransactionSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelTransactionSuccessPayload']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelVirtualIbanEntryInput']: {
        virtualIbanEntryId: string;
    };
    ['CancelVirtualIbanEntryPayload']: AliasType<{
        CancelVirtualIbanEntrySuccessPayload?: ResolverInputTypes['CancelVirtualIbanEntrySuccessPayload'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CancelVirtualIbanEntrySuccessPayload']: AliasType<{
        virtualIbanEntry?: ResolverInputTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Physical Card cannot be activated */
    ['CannotActivatePhysicalCardRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Capital deposit case for a company. */
    ['CapitalDepositCase']: AliasType<{
        /** Unique identifier of a capital deposit case. */
        id?: boolean | `@${string}`;
        /** List of the company’s shareholders. */
        shareholders?: ResolverInputTypes['Shareholder'];
        /** Amount of the capital deposit. */
        totalCapitalDepositAmount?: ResolverInputTypes['Amount'];
        /** Name of the company. */
        companyName?: boolean | `@${string}`;
        /** Onboarding information of the company. */
        companyOnboarding?: ResolverInputTypes['Onboarding'];
        /** Unique identifier of the company account. */
        companyAccountId?: boolean | `@${string}`;
        /** Status of the capital deposit case. */
        status?: boolean | `@${string}`;
        /** Documents to provide to fulfill the capital deposit case. */
        documents?: ResolverInputTypes['CapitalDepositDocument'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of elements ([Learn More](https://docs.swan.io/api/pagination)) */
    ['CapitalDepositCaseConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** CapitalDepositCaseEdge list */
        edges?: ResolverInputTypes['CapitalDepositCaseEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['CapitalDepositCaseEdge']: AliasType<{
        /** Opaque identifier pointing to this capital deposit case node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The CapitalDepositCase */
        node?: ResolverInputTypes['CapitalDepositCase'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseFiltersInput']: {
        /** Searches company shareholder name, individual shareholder first name, last name, and id */
        search?: string | undefined | null;
        /** Status we want to filter on */
        status?: Array<ResolverInputTypes['CapitalDepositCaseStatus']> | undefined | null;
    };
    /** Field we can use when ordering that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseOrderByFieldInput']: CapitalDepositCaseOrderByFieldInput;
    /** Order that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseOrderByInput']: {
        field?: ResolverInputTypes['CapitalDepositCaseOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Status of a capital deposit case. */
    ['CapitalDepositCaseStatus']: CapitalDepositCaseStatus;
    /** Document provided for a capital deposit case. */
    ['CapitalDepositDocument']: AliasType<{
        /** Unique identifier of a document. */
        id?: boolean | `@${string}`;
        /** Type of the document. */
        type?: boolean | `@${string}`;
        /** Url to download the document, null if it has not already been uploaded. */
        downloadUrl?: boolean | `@${string}`;
        /** Date when the last version of the document has been uploaded. */
        uploadedAt?: boolean | `@${string}`;
        /** Status of the document. */
        status?: boolean | `@${string}`;
        /** Status info of the document. */
        statusInfo?: ResolverInputTypes['CapitalDepositDocumentStatusInfo'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Information about capital deposit case. */
        relatedCapitalDepositCase?: ResolverInputTypes['CapitalDepositCase'];
        /** Information about shareholder. */
        relatedShareholder?: ResolverInputTypes['Shareholder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the document from a capital deposit case cannot be uploaded in its context
  @deprecated(reason: "use `CapitalDepositDocumentCanNotBeUploadedRejection` instead") */
    ['CapitalDepositDocumentCanNotBeUploaded']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the document from a capital deposit case cannot be uploaded in its context */
    ['CapitalDepositDocumentCanNotBeUploadedRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Capital Deposit Document with Pending status */
    ['CapitalDepositDocumentPendingStatusInfo']: AliasType<{
        /** Pending */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Capital Deposit Document with Refused status */
    ['CapitalDepositDocumentRefusedStatusInfo']: AliasType<{
        /** Refused */
        status?: boolean | `@${string}`;
        /** Reason for the rejection. */
        reasonCode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Status of the Capital Deposit Case */
    ['CapitalDepositDocumentStatus']: CapitalDepositDocumentStatus;
    /** Status info of the document. */
    ['CapitalDepositDocumentStatusInfo']: AliasType<{
        /** Status of the document. */
        status?: boolean | `@${string}`;
        ['...on CapitalDepositDocumentPendingStatusInfo']?: Omit<ResolverInputTypes['CapitalDepositDocumentPendingStatusInfo'], keyof ResolverInputTypes['CapitalDepositDocumentStatusInfo']>;
        ['...on CapitalDepositDocumentRefusedStatusInfo']?: Omit<ResolverInputTypes['CapitalDepositDocumentRefusedStatusInfo'], keyof ResolverInputTypes['CapitalDepositDocumentStatusInfo']>;
        ['...on CapitalDepositDocumentUploadedStatusInfo']?: Omit<ResolverInputTypes['CapitalDepositDocumentUploadedStatusInfo'], keyof ResolverInputTypes['CapitalDepositDocumentStatusInfo']>;
        ['...on CapitalDepositDocumentValidatedStatusInfo']?: Omit<ResolverInputTypes['CapitalDepositDocumentValidatedStatusInfo'], keyof ResolverInputTypes['CapitalDepositDocumentStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Type of the document. */
    ['CapitalDepositDocumentType']: CapitalDepositDocumentType;
    /** Capital Deposit Document with Uploaded status */
    ['CapitalDepositDocumentUploadedStatusInfo']: AliasType<{
        /** Uploaded */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Capital Deposit Document with Validated status */
    ['CapitalDepositDocumentValidatedStatusInfo']: AliasType<{
        /** Validated */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card */
    ['Card']: AliasType<{
        /** Unique identifier of a card */
        id?: boolean | `@${string}`;
        /** Type of a card */
        type?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Account membership to define the card holder and the account linked to the card. */
        accountMembership?: ResolverInputTypes['AccountMembership'];
        /** Main Currency */
        mainCurrency?: boolean | `@${string}`;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: boolean | `@${string}`;
        /** URL of the card design */
        cardDesignUrl?: boolean | `@${string}`;
        /** URL of the card with masked card information (like its number) and with full card information if connected user consented beforehand */
        cardUrl?: boolean | `@${string}`;
        /** Card status information */
        statusInfo?: ResolverInputTypes['CardStatusInfo'];
        /** `true` if this card allows cash withdrawals */
        withdrawal?: boolean | `@${string}`;
        /** `true` if this card allows payments outside of the country */
        international?: boolean | `@${string}`;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions?: boolean | `@${string}`;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce?: boolean | `@${string}`;
        /** Periodic Spending limit list */
        spendingLimits?: ResolverInputTypes['SpendingLimit'];
        /** Physical card if the card holder has ordered one */
        physicalCard?: ResolverInputTypes['PhysicalCard'];
        /** Masked Card Number */
        cardMaskedNumber?: boolean | `@${string}`;
        /** Card expiry date with MM/YY format */
        expiryDate?: boolean | `@${string}`;
        /** Card name */
        name?: boolean | `@${string}`;
        /** Card product */
        cardProduct?: ResolverInputTypes['CardProduct'];
        /** Issuing Country */
        issuingCountry?: boolean | `@${string}`;
        digitalCards?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['DigitalCardOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['DigitalCardFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['DigitalCardConnection']
        ];
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['TransactionsOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['TransactionsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TransactionConnection']
        ];
        /** Periodic Spending */
        spending?: ResolverInputTypes['Spending'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CardAuthorizationOutcome']: CardAuthorizationOutcome;
    ['CardAuthorizationType']: CardAuthorizationType;
    /** Card Canceled Status Information */
    ['CardCanceledStatusInfo']: AliasType<{
        /** Card status (always Canceled for type CardCanceledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is canceled */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Canceling Status Information */
    ['CardCancelingStatusInfo']: AliasType<{
        /** Card status (always Canceling for type CardCancelingStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is about to be canceled. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the card could not be digitalized */
    ['CardCanNotBeDigitalizedRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardConfidential']: AliasType<{
        /** Card number */
        pan?: boolean | `@${string}`;
        /** Card verification value */
        cvv?: boolean | `@${string}`;
        /** Expiration date */
        expiryDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardConfigInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ResolverInputTypes['DateTime'] | undefined | null;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Card name */
        name?: string | undefined | null;
        /** Spending limit */
        spendingLimit: ResolverInputTypes['SpendingLimitInput'];
        /** If used a physical card will be printed and sent to the given address */
        physicalCard?: ResolverInputTypes['PhysicalCardConfigInput'] | undefined | null;
    };
    ['CardConfigWithGroupDeliveryInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ResolverInputTypes['DateTime'] | undefined | null;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Card name */
        name?: string | undefined | null;
        /** Spending limit */
        spendingLimit: ResolverInputTypes['SpendingLimitInput'];
        /** `true` when you wish for print an associated physical card */
        printPhysicalCard: boolean;
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: ResolverInputTypes['PhysicalCardCustomOptionsForGroupDeliveryInput'] | undefined | null;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['CardConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** CardEdge list */
        edges?: ResolverInputTypes['CardEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** when the user has to consent to add this card */
    ['CardConsentPendingStatusInfo']: AliasType<{
        /** Card status (always ConsentPending for type CardConsentPendingStatusInfo) */
        status?: boolean | `@${string}`;
        /** The consent required to add this card */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CardDesignBackground']: AliasType<{
        /** Unique identifier of a project card design background */
        id?: boolean | `@${string}`;
        /** Card design background name */
        name?: boolean | `@${string}`;
        /** Card design background type */
        type?: boolean | `@${string}`;
        /** Card design background text color */
        cardTextColor?: boolean | `@${string}`;
        /** Card design background url */
        cardBackgroundUrl?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Project Card Design Background Type */
    ['CardDesignBackgroundType']: CardDesignBackgroundType;
    /** Card designs Status */
    ['CardDesignStatus']: CardDesignStatus;
    /** Implements the Relay Edge interface */
    ['CardEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The Card entry */
        node?: ResolverInputTypes['Card'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Enabled Status Information */
    ['CardEnabledStatusInfo']: AliasType<{
        /** Card status (always Enabled for type CardEnabledStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing cards */
    ['CardFiltersInput']: {
        /** The status of the card.
    
    @deprecated(reason: "use `statuses` instead") */
        status?: ResolverInputTypes['CardStatus'] | undefined | null;
        /** Statuses of the card. */
        statuses?: Array<ResolverInputTypes['CardStatus']> | undefined | null;
        /** Type of card
    
    @deprecated(reason: "use `types` instead") */
        type?: ResolverInputTypes['CardType'] | undefined | null;
        /** Types of card */
        types?: Array<ResolverInputTypes['CardType']> | undefined | null;
        /** String searched */
        search?: string | undefined | null;
        /** Account identifier
    
    This filter is only available for User Access Token, for the moment */
        accountId?: string | undefined | null;
    };
    /** COMING SOON */
    ['CardMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ResolverInputTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ResolverInputTypes['RollingReserve'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the card was not found or if the user does not have the rights to know that the account exists */
    ['CardNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing cards */
    ['CardOrderByFieldInput']: CardOrderByFieldInput;
    /** Order that can be applied when listing cards */
    ['CardOrderByInput']: {
        field?: ResolverInputTypes['CardOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    ['CardPaymentMethodInput']: {
        /** Determine whether the payment method must be activated or not */
        activate?: boolean | undefined | null;
    };
    /** when the card is in the process of being ready to use */
    ['CardProcessingStatusInfo']: AliasType<{
        /** Card status (always Processing for type CardProcessingStatusInfo) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Product */
    ['CardProduct']: AliasType<{
        id?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        projectId?: boolean | `@${string}`;
        status?: boolean | `@${string}`;
        createdAt?: boolean | `@${string}`;
        updatedAt?: boolean | `@${string}`;
        applicableToPhysicalCards?: boolean | `@${string}`;
        cardDesigns?: ResolverInputTypes['CardProductDesign'];
        defaultCardProduct?: boolean | `@${string}`;
        individualSpendingLimit?: ResolverInputTypes['SpendingLimit'];
        companySpendingLimit?: ResolverInputTypes['SpendingLimit'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Card design of a Card Product */
    ['CardProductDesign']: AliasType<{
        /** Unique identifier of a card design */
        id?: boolean | `@${string}`;
        /** Design version */
        version?: boolean | `@${string}`;
        /** Logo url svg */
        cardProjectLogoSvgUrl?: boolean | `@${string}`;
        /** Logo url 300 dpi */
        cardProjectLogo300dpiUrl?: boolean | `@${string}`;
        /** Logo url 300 dpi */
        cardProjectLogo600dpiUrl?: boolean | `@${string}`;
        /** Zoom level */
        zoomRatioProjectLogo?: boolean | `@${string}`;
        /** Card Design URL */
        cardDesignUrl?: boolean | `@${string}`;
        /** Accent color */
        accentColor?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Status of the card design */
        status?: boolean | `@${string}`;
        /** Card Background of the Card design */
        cardBackground?: ResolverInputTypes['CardDesignBackground'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the card product is disabled. */
    ['CardProductDisabledRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the card product is not applicable to physical card. */
    ['CardProductNotApplicableToPhysicalCardsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardProductNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Product Status */
    ['CardProductStatus']: CardProductStatus;
    /** Rejection returned if the card product is suspended. */
    ['CardProductSuspendedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardProductUsedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card settings for a Project */
    ['CardSettings']: AliasType<{
        /** Unique identifier of a project card settings */
        id?: boolean | `@${string}`;
        /** Flag used to indicate if ApplePay is activated for the project */
        allowsApplePay?: boolean | `@${string}`;
        /** Settings version */
        version?: boolean | `@${string}`;
        /** Logo url svg */
        cardProjectLogoSvgUrl?: boolean | `@${string}`;
        /** Logo url 300 dpi */
        cardProjectLogo300dpiUrl?: boolean | `@${string}`;
        /** Logo url 300 dpi */
        cardProjectLogo600dpiUrl?: boolean | `@${string}`;
        /** Zoom level */
        zoomRatioProjectLogo?: boolean | `@${string}`;
        /** Card Design URL */
        cardDesignUrl?: boolean | `@${string}`;
        /** Accent color */
        accentColor?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Status of the card settings */
        status?: boolean | `@${string}`;
        /** Card Background of the Card Settings */
        cardBackground?: ResolverInputTypes['CardSettingsBackground'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CardSettingsBackground']: AliasType<{
        /** Unique identifier of a project card settings */
        id?: boolean | `@${string}`;
        /** Card settings background name */
        name?: boolean | `@${string}`;
        /** Card settings background type */
        type?: boolean | `@${string}`;
        /** Card settings background text color */
        cardTextColor?: boolean | `@${string}`;
        /** Card settings background url */
        cardBackgroundUrl?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Card Settings Background Type */
    ['CardSettingsBackgroundType']: CardSettingsBackgroundType;
    /** Card Status */
    ['CardStatus']: CardStatus;
    /** Card Status Information */
    ['CardStatusInfo']: AliasType<{
        /** Status of the card. */
        status?: boolean | `@${string}`;
        ['...on CardCanceledStatusInfo']?: Omit<ResolverInputTypes['CardCanceledStatusInfo'], keyof ResolverInputTypes['CardStatusInfo']>;
        ['...on CardCancelingStatusInfo']?: Omit<ResolverInputTypes['CardCancelingStatusInfo'], keyof ResolverInputTypes['CardStatusInfo']>;
        ['...on CardConsentPendingStatusInfo']?: Omit<ResolverInputTypes['CardConsentPendingStatusInfo'], keyof ResolverInputTypes['CardStatusInfo']>;
        ['...on CardEnabledStatusInfo']?: Omit<ResolverInputTypes['CardEnabledStatusInfo'], keyof ResolverInputTypes['CardStatusInfo']>;
        ['...on CardProcessingStatusInfo']?: Omit<ResolverInputTypes['CardProcessingStatusInfo'], keyof ResolverInputTypes['CardStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['CardToken']: unknown;
    /** Card transaction */
    ['CardTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** external identifier of the transaction */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ResolverInputTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ResolverInputTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ResolverInputTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** card numbers masked (Primary Account Number) */
        maskedPan?: boolean | `@${string}`;
        /** unique identifier of the card */
        cardId?: boolean | `@${string}`;
        /** card used for this transaction */
        card?: ResolverInputTypes['Card'];
        /** unique identifier of the terminal */
        terminalId?: boolean | `@${string}`;
        /** original amount and currency of the transaction */
        originalAmount?: ResolverInputTypes['Amount'];
        /** currency exchange if any */
        currencyExchange?: ResolverInputTypes['ReportExchangeRate'];
        /** unique identifier of the merchant */
        merchantId?: boolean | `@${string}`;
        /** merchant name */
        merchantName?: boolean | `@${string}`;
        /** merchant city */
        merchantCity?: boolean | `@${string}`;
        /** merchant country */
        merchantCountry?: boolean | `@${string}`;
        /** merchant postal code */
        merchantPostalCode?: boolean | `@${string}`;
        /** merchant category code (MCC) */
        merchantCategoryCode?: boolean | `@${string}`;
        /** merchant category description
    Enum that explains what the MCC corresponds to in a more readable way */
        merchantCategoryDescription?: boolean | `@${string}`;
        /** category of the payment flow */
        category?: boolean | `@${string}`;
        /** type of the authorization.
    Only available for:
    - authorization transaction
    - debit transaction linked to a previous authorization transaction */
        authorizationType?: boolean | `@${string}`;
        /** matching account for the transaction */
        account?: ResolverInputTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ResolverInputTypes['Transaction'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CardTransactionCategory']: CardTransactionCategory;
    /** Card Type */
    ['CardType']: CardType;
    /** Rejection returned when the Card is not the expected status */
    ['CardWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        expectedStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Cash account type (Always Current) */
    ['CashAccountType']: CashAccountType;
    /** Payment flow available options */
    ['Category']: Category;
    /** Country code alpha 2 (ISO 3166) */
    ['CCA2']: unknown;
    /** Country code alpha 3 (ISO 3166) */
    ['CCA3']: unknown;
    /** Certificate */
    ['Certificate']: {
        /** CertificateType
    
    Can be either LEAF or INTERMEDIATE */
        key: string;
        /** Base64 value of the certificate */
        value: string;
    };
    /** CheckMerchantPaymentMethod */
    ['CheckMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ResolverInputTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ResolverInputTypes['RollingReserve'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CheckPaymentMethodInput']: {
        /** Determine whether the payment method must be activated or not */
        activate?: boolean | undefined | null;
    };
    ['CheckRejection']: AliasType<{
        message?: boolean | `@${string}`;
        fnciInfo?: ResolverInputTypes['FnciInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Check transaction */
    ['CheckTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction: check number */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** 31-caracter unique identifier located at the bottom of the check.
    CMC7 is composed of 3 sections (check number (7 char.), check issuing bank code (12 char.), check holder account number (12 char.)).
    Combined with RLMC key, it  allows the check traceability. */
        cmc7?: boolean | `@${string}`;
        /** 2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
    Combined with CMC7 line, it allows the check traceability. */
        rlmcKey?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ResolverInputTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ResolverInputTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ResolverInputTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** matching account for the transaction */
        account?: ResolverInputTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ResolverInputTypes['Transaction'];
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: ResolverInputTypes['Amount'];
        /** date on which reserved funds become available */
        reservedAmountReleasedAt?: boolean | `@${string}`;
        /** return reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CloseAccountInput']: {
        accountId: string;
        reason: ResolverInputTypes['PartnerCloseAccountReasonInput'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['CloseAccountPayload']: AliasType<{
        CloseAccountSuccessPayload?: ResolverInputTypes['CloseAccountSuccessPayload'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Define a reason with a message and a specific type for closing account action */
    ['CloseAccountReason']: AliasType<{
        type?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Specific type for closing account action */
    ['CloseAccountReasonType']: CloseAccountReasonType;
    /** Union between PartnerCloseAccountReasonType and InternalCloseAccountReason */
    ['CloseAccountStatusReason']: AliasType<{
        CloseAccountReason?: ResolverInputTypes['CloseAccountReason'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CloseAccountSuccessPayload']: AliasType<{
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Data provided following the search for company information by siren number */
    ['CompanyInfo']: AliasType<{
        siren?: boolean | `@${string}`;
        companyName?: boolean | `@${string}`;
        headquarters?: ResolverInputTypes['Headquarters'];
        vatNumber?: boolean | `@${string}`;
        taxIdentificationNumber?: boolean | `@${string}`;
        legalRepresentativePersonalAddress?: ResolverInputTypes['AddressInformation'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Company shareholder info. */
    ['CompanyShareholder']: AliasType<{
        /** Whether the shareholder is an individual or a company. */
        type?: boolean | `@${string}`;
        /** Company name. */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Type of company. */
    ['CompanyType']: CompanyType;
    /** Complete Address Information */
    ['CompleteAddressInput']: {
        /** address line 1 (max 38 characters) */
        addressLine1: string;
        /** address line 2 (max 38 characters) */
        addressLine2?: string | undefined | null;
        /** city (max 30 characters) */
        city: string;
        /** postal code (max 10 characters) */
        postalCode: string;
        /** state (max 30 characters) */
        state?: string | undefined | null;
        /** country code */
        country: ResolverInputTypes['CCA3'];
    };
    /** Complete Address Information with a contact */
    ['CompleteAddressWithContactInput']: {
        /** address line 1 (max 38 characters) */
        addressLine1: string;
        /** address line 2 (max 38 characters) */
        addressLine2?: string | undefined | null;
        /** city (max 30 characters) */
        city: string;
        /** postal code (max 10 characters) */
        postalCode: string;
        /** state (max 30 characters) */
        state?: string | undefined | null;
        /** country code */
        country: ResolverInputTypes['CCA3'];
        /** contact first name */
        firstName: string;
        /** contact last name */
        lastName: string;
        /** contact phone number */
        phoneNumber: ResolverInputTypes['PhoneNumber'];
        /** contact company name (max 38 characters) */
        companyName?: string | undefined | null;
    };
    /** Complete Digital Card used for ApplePay or GooglePay
  
  Once the pending phase is over, more data will be available in the response */
    ['CompleteDigitalCard']: AliasType<{
        /** Unique identifier of a digital card */
        id?: boolean | `@${string}`;
        /** The type of digitalization that created this digital card. */
        type?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider?: ResolverInputTypes['WalletProvider'];
        /** Device
    In case of a wallet application, some information about the device will be provided */
        device?: ResolverInputTypes['Device'];
        /** Id of the wallet application.
    Will not be present for Merchant */
        walletId?: boolean | `@${string}`;
        /** Masked DPAN with the last four digits visible
    
    This value is present in the user wallet application */
        cardMaskedNumber?: boolean | `@${string}`;
        /** Digital Card status information
    
    In this type the status will be either ConsentPending or Pending */
        statusInfo?: ResolverInputTypes['CompleteDigitalCardStatusInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Complete Digital Card Status */
    ['CompleteDigitalCardStatus']: CompleteDigitalCardStatus;
    /** Complete Digital Card Status Information */
    ['CompleteDigitalCardStatusInfo']: AliasType<{
        /** Status of the digital card. */
        status?: boolean | `@${string}`;
        ['...on DigitalCardCanceledStatusInfo']?: Omit<ResolverInputTypes['DigitalCardCanceledStatusInfo'], keyof ResolverInputTypes['CompleteDigitalCardStatusInfo']>;
        ['...on DigitalCardEnabledStatusInfo']?: Omit<ResolverInputTypes['DigitalCardEnabledStatusInfo'], keyof ResolverInputTypes['CompleteDigitalCardStatusInfo']>;
        ['...on DigitalCardSuspendedStatusInfo']?: Omit<ResolverInputTypes['DigitalCardSuspendedStatusInfo'], keyof ResolverInputTypes['CompleteDigitalCardStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['CompletedMerchantPaymentLinkStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** The time when the customer completed the payment. */
        completedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to confirm physical card renewal */
    ['ConfirmPhysicalCardRenewalInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Address to deliver the physical card */
        address: ResolverInputTypes['CompleteAddressInput'];
        /** Custom Options */
        customOptions?: ResolverInputTypes['PhysicalCardCustomOptionsInput'] | undefined | null;
    };
    ['ConfirmPhysicalCardRenewalPayload']: AliasType<{
        ConfirmPhysicalCardRenewalSuccessPayload?: ResolverInputTypes['ConfirmPhysicalCardRenewalSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        PhysicalCardWrongStatusRejection?: ResolverInputTypes['PhysicalCardWrongStatusRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ConfirmPhysicalCardRenewalSuccessPayload']: AliasType<{
        /** Physical card has been updated */
        physicalCard?: ResolverInputTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Relay Connection type, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['Connection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** Edge list */
        edges?: ResolverInputTypes['Edge'];
        ['...on AccountConnection']?: Omit<ResolverInputTypes['AccountConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on AccountHolderConnection']?: Omit<ResolverInputTypes['AccountHolderConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on AccountMembershipConnection']?: Omit<ResolverInputTypes['AccountMembershipConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on CapitalDepositCaseConnection']?: Omit<ResolverInputTypes['CapitalDepositCaseConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on CardConnection']?: Omit<ResolverInputTypes['CardConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on ConsentConnection']?: Omit<ResolverInputTypes['ConsentConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on DigitalCardConnection']?: Omit<ResolverInputTypes['DigitalCardConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on ExternalAccountConnection']?: Omit<ResolverInputTypes['ExternalAccountConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on ExternalBalanceConnection']?: Omit<ResolverInputTypes['ExternalBalanceConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on FundingLimitSettingsChangeRequestConnection']?: Omit<ResolverInputTypes['FundingLimitSettingsChangeRequestConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on FundingSourceConnection']?: Omit<ResolverInputTypes['FundingSourceConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on InvoiceConnection']?: Omit<ResolverInputTypes['InvoiceConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on LegalDocumentConnection']?: Omit<ResolverInputTypes['LegalDocumentConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on MerchantProfileConnection']?: Omit<ResolverInputTypes['MerchantProfileConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on OnboardingConnection']?: Omit<ResolverInputTypes['OnboardingConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on PaymentConnection']?: Omit<ResolverInputTypes['PaymentConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on PaymentMandateConnection']?: Omit<ResolverInputTypes['PaymentMandateConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on ReceivedDirectDebitMandateConnection']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on StandingOrderConnection']?: Omit<ResolverInputTypes['StandingOrderConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on StatementConnection']?: Omit<ResolverInputTypes['StatementConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on SupportingDocumentCollectionConnection']?: Omit<ResolverInputTypes['SupportingDocumentCollectionConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on TransactionConnection']?: Omit<ResolverInputTypes['TransactionConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on TrustedBeneficiaryConnection']?: Omit<ResolverInputTypes['TrustedBeneficiaryConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on UserConnection']?: Omit<ResolverInputTypes['UserConnection'], keyof ResolverInputTypes['Connection']>;
        ['...on VirtualIBANEntryConnection']?: Omit<ResolverInputTypes['VirtualIBANEntryConnection'], keyof ResolverInputTypes['Connection']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Some sensitive operation at Swan, such as initiating a payment, require consent */
    ['Consent']: AliasType<{
        /** unique identifier of the consent */
        id?: boolean | `@${string}`;
        /** `true` if the consent requires a Strong Customer Authentication */
        requireSCA?: boolean | `@${string}`;
        /** status of the consent */
        status?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** date when the `consentUrl` was request the first time */
        startedAt?: boolean | `@${string}`;
        /** date when the consent expire */
        expiredAt?: boolean | `@${string}`;
        /** purpose of the consent */
        purpose?: boolean | `@${string}`;
        /** Redirect the user to this URL to start the consent flow */
        consentUrl?: boolean | `@${string}`;
        /** When the consent flow is finished the user is redirected to this URL */
        redirectUrl?: boolean | `@${string}`;
        /** userId who initiated the consent */
        userId?: boolean | `@${string}`;
        /** user who initiated the consent */
        user?: ResolverInputTypes['User'];
        /** unique hash of the consent */
        challenge?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ConsentConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** ConsentEdge list */
        edges?: ResolverInputTypes['ConsentEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['ConsentEdge']: AliasType<{
        /** Opaque identifier pointing to this consent node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The consent */
        node?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Consent ID with related execution order */
    ['ConsentIdWithOrder']: {
        /** Execution order. Consents are granted in ascending order. Consents with the same order may be granted in parallel. */
        order: number;
        /** Consent ID */
        consentId: string;
    };
    /** Rejection returned if a consent was not found */
    ['ConsentNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        consentId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Purpose of a consent */
    ['ConsentPurpose']: ConsentPurpose;
    /** Rejection returned when a the consent is already linked to another multi consent */
    ['ConsentsAlreadyLinkedToMultiConsentRejection']: AliasType<{
        message?: boolean | `@${string}`;
        /** IDs of the consents that are already linked to another multi consent */
        consentIds?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ConsentsFiltersInput']: {
        userId?: string | undefined | null;
    };
    /** Rejection returned when all provided consents are not in created status */
    ['ConsentsNotAllInCreatedStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        /** IDs of the consents that are not in created status */
        consentIds?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when a consent ID passed as input does not exist. */
    ['ConsentsNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        ids?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Status of a consent */
    ['ConsentStatus']: ConsentStatus;
    ['ConsentTypeNotSupportedByServerConsentRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to create a capital deposit case. */
    ['CreateCapitalDepositCaseInput']: {
        /** Name ("Dénomination sociale") of the company being registered and for which the capital is being deposited. */
        companyName: string;
        /** Array of shareholders of type company ("personne morale"). */
        companyShareholders: Array<ResolverInputTypes['OnboardCompanyShareholderInput'] | undefined | null>;
        /** Array of shareholders of type individual ("personne physique"). */
        individualShareholders: Array<ResolverInputTypes['OnboardIndividualShareholderInput'] | undefined | null>;
        /** Amount of the capital deposit. */
        totalCapitalDepositAmount: ResolverInputTypes['AmountInput'];
        /** Information required for the onboarding of a company. */
        onboardingCapitalDepositCompany: ResolverInputTypes['OnboardCompanyAccountHolderInput'];
    };
    ['CreateCapitalDepositCasePayload']: AliasType<{
        CreateCapitalDepositCaseSuccessPayload?: ResolverInputTypes['CreateCapitalDepositCaseSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        BadRequestRejection?: ResolverInputTypes['BadRequestRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CreateCapitalDepositCaseSuccessPayload']: AliasType<{
        capitalDepositCase?: ResolverInputTypes['CapitalDepositCase'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CreateMerchantPaymentLinkInput']: {
        /** The Merchant Profile to link this Payment Link to */
        merchantProfileId: string;
        /** Amount to be paid to sucessfully complete the payment. */
        amount: ResolverInputTypes['AmountInput'];
        /** Merchant Website URL to redirect the user to when the payment is completed. */
        redirectUrl: ResolverInputTypes['URL'];
        /** URL to redirect the user to if they cancel their payment */
        cancelRedirectUrl: ResolverInputTypes['URL'];
        /** The customer billing Address
    These fields should be completed also to pre-fill a SEPA direct debit mandate.
    
    We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes */
        billingAddress?: ResolverInputTypes['AddressInput'] | undefined | null;
        /** The date when the payment link expires.
    If not specified, the default time will be 120 days */
        expiresAt?: ResolverInputTypes['DateTime'] | undefined | null;
        /** A date that reflects the time at which the user asked the transaction to be executed.
    For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
    For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
    
    Default value means that the execution will be as soon as possible */
        requestedExecutionAt?: ResolverInputTypes['DateTime'] | undefined | null;
        /** Controls if the payment mandate created from this payment link is for one-time use or can be reused
    This is applicable for card and SEPA Direct Debit payment methods only.
    If not specified, the default value is OneOff. */
        sequence?: ResolverInputTypes['PaymentMandateSequence'] | undefined | null;
        /** Any string that you want to be attached to this payment link.
    Usually something to help you reference the link in an external system. */
        externalReference?: string | undefined | null;
        /** Optional field intended to provide a way for you to include a reference number or code.
    The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different. */
        reference?: string | undefined | null;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page. */
        label?: string | undefined | null;
        /** The language used for the payment page.
    Default is the browser's language, or English if not available. */
        language?: ResolverInputTypes['Language'] | undefined | null;
        /** We will use the information specified here to prefill the payment link fields
    depending on the payment method the end user chooses.
    Keep in mind that your end customer will be able to edit these fields. */
        customer?: ResolverInputTypes['CustomerInput'] | undefined | null;
        /** List of payment methods enabled for this payment link.
    If the array is empty, Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit)
    If you want to make payment possible via SEPA Direct Debit, the list should be populated either by a SEPA Direct Debit CORE or B2B. */
        paymentMethodIds?: Array<string> | undefined | null;
    };
    ['CreateMerchantPaymentLinkPayload']: AliasType<{
        CreateMerchantPaymentLinkSuccessPayload?: ResolverInputTypes['CreateMerchantPaymentLinkSuccessPayload'];
        MerchantProfileWrongStatusRejection?: ResolverInputTypes['MerchantProfileWrongStatusRejection'];
        MerchantPaymentMethodNotActiveRejection?: ResolverInputTypes['MerchantPaymentMethodNotActiveRejection'];
        PaymentMethodNotCompatibleRejection?: ResolverInputTypes['PaymentMethodNotCompatibleRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['CreateMerchantPaymentLinkSuccessPayload']: AliasType<{
        merchantPaymentLink?: ResolverInputTypes['MerchantPaymentLink'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input of the `createMultiConsent` mutation */
    ['CreateMultiConsentInput']: {
        /** A list of consent IDs with their related execution orders */
        orderedConsentIds: Array<ResolverInputTypes['ConsentIdWithOrder']>;
        /** URL the user is redirected to after consent has been given */
        redirectUrl: string;
    };
    /** Payload of the `createMultiConsent` mutation */
    ['CreateMultiConsentPayload']: AliasType<{
        CreateMultiConsentSuccessPayload?: ResolverInputTypes['CreateMultiConsentSuccessPayload'];
        ConsentsNotAllInCreatedStatusRejection?: ResolverInputTypes['ConsentsNotAllInCreatedStatusRejection'];
        ConsentsNotFoundRejection?: ResolverInputTypes['ConsentsNotFoundRejection'];
        TooManyChildConsentsRejection?: ResolverInputTypes['TooManyChildConsentsRejection'];
        ConsentsAlreadyLinkedToMultiConsentRejection?: ResolverInputTypes['ConsentsAlreadyLinkedToMultiConsentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Success payload of the `createMultiConsent` mutation */
    ['CreateMultiConsentSuccessPayload']: AliasType<{
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Credit transfer */
    ['CreditTransferInput']: {
        /** if the transfer will credit a beneficiary already created */
        beneficiaryId?: string | undefined | null;
        /** if the transfer will credit a new swan account beneficiary */
        swanAccountBeneficiary?: ResolverInputTypes['SwanAccountBeneficiaryInput'] | undefined | null;
        /** if the transfer will credit a new SEPA beneficiary */
        sepaBeneficiary?: ResolverInputTypes['SepaBeneficiaryInput'] | undefined | null;
        /** amount of the transfer */
        amount: ResolverInputTypes['AmountInput'];
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined | null;
        /** label (max 140 characters) */
        label?: string | undefined | null;
        /** requested date at which the credit transfer will try to be executed, if `null` the credit transfer is executed right away */
        requestedExecutionAt?: ResolverInputTypes['DateTime'] | undefined | null;
        /** an arbitrary identifier that you can define to easily identify this transaction later */
        externalReference?: string | undefined | null;
        /** if the transfer will execute as instant and fallbacked to a regular one if an error happend during the instant transfer */
        mode?: ResolverInputTypes['CreditTransferMode'] | undefined | null;
    };
    ['CreditTransferMode']: CreditTransferMode;
    /** Custom information for a CSV statement */
    ['CsvStatement']: AliasType<{
        /** statement type */
        type?: boolean | `@${string}`;
        /** temporary public url on which the file can be accessed */
        url?: boolean | `@${string}`;
        /** date at which the link will not be useable anymore */
        expiresAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** currency code alpha 3 (ISO 4217) */
    ['Currency']: unknown;
    ['Customer']: AliasType<{
        /** A customer id present in a third-party system.
    Alows to link a customer to a payment link and by extension, to a Merchant Payment. */
        externalCustomerId?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        iban?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['CustomerInput']: {
        /** A customer ID present in a third-party system.
    Alows to link a customer to a payment link and by extension, to a merchant payment. */
        externalCustomerId?: string | undefined | null;
        /** Customer name */
        name?: string | undefined | null;
        /** Customer IBAN */
        iban?: string | undefined | null;
    };
    /** Date with YYYY-MM-DD format */
    ['Date']: unknown;
    ['DateField']: AliasType<{
        example?: boolean | `@${string}`;
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        validationRegex?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Date time (ISO 8601 with time information)
  ex: 2021-04-12T16:28:22.867Z */
    ['DateTime']: unknown;
    /** Rejection returned when the Debtor is closed */
    ['DebtorAccountClosedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Debtor does not belong to the same project as the creditor */
    ['DebtorAccountNotAllowedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['DeleteSupportingDocumentInput']: {
        /** Id of the supporting document to delete */
        id: string;
    };
    ['DeleteSupportingDocumentPayload']: AliasType<{
        DeleteSupportingDocumentSuccessPayload?: ResolverInputTypes['DeleteSupportingDocumentSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        SupportingDocumentCollectionNotFoundRejection?: ResolverInputTypes['SupportingDocumentCollectionNotFoundRejection'];
        SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection?: ResolverInputTypes['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection'];
        SupportingDocumentNotFoundRejection?: ResolverInputTypes['SupportingDocumentNotFoundRejection'];
        SupportingDocumentStatusDoesNotAllowDeletionRejection?: ResolverInputTypes['SupportingDocumentStatusDoesNotAllowDeletionRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DeleteSupportingDocumentSuccessPayload']: AliasType<{
        id?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['DenySddInput']: {
        accountId: string;
    };
    ['DenySddPayload']: AliasType<{
        DenySddSuccessPayload?: ResolverInputTypes['DenySddSuccessPayload'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        InvalidArgumentRejection?: ResolverInputTypes['InvalidArgumentRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DenySddSuccessPayload']: AliasType<{
        account?: ResolverInputTypes['Account'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DenySddVirtualIbanEntryInput']: {
        ibanEntryId: string;
    };
    ['DenySddVirtualIbanEntryPayload']: AliasType<{
        DenySddVirtualIbanEntrySuccessPayload?: ResolverInputTypes['DenySddVirtualIbanEntrySuccessPayload'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DenySddVirtualIbanEntrySuccessPayload']: AliasType<{
        virtualIbanEntry?: ResolverInputTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Device */
    ['Device']: AliasType<{
        /** The type of device. It can be a Phone, Tablet, Watch */
        type?: boolean | `@${string}`;
        /** Device name
    End user defined name of the device on which the card id provided */
        name?: boolean | `@${string}`;
        /** Secure Element ID */
        SEID?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card used for ApplePay or GooglePay */
    ['DigitalCard']: AliasType<{
        /** Unique identifier of a digital card */
        id?: boolean | `@${string}`;
        /** The type of digitalization that created this digital card. */
        type?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider?: ResolverInputTypes['WalletProvider'];
        ['...on CompleteDigitalCard']?: Omit<ResolverInputTypes['CompleteDigitalCard'], keyof ResolverInputTypes['DigitalCard']>;
        ['...on PendingDigitalCard']?: Omit<ResolverInputTypes['PendingDigitalCard'], keyof ResolverInputTypes['DigitalCard']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card Canceled Status Information */
    ['DigitalCardCanceledStatusInfo']: AliasType<{
        /** Card status (always Canceled for type DigitalCardCanceledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Enable Date */
        enabledAt?: boolean | `@${string}`;
        /** Cancel Date */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['DigitalCardConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** CardEdge list */
        edges?: ResolverInputTypes['DigitalCardEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card ConsentPending Status Information */
    ['DigitalCardConsentPendingStatusInfo']: AliasType<{
        /** Digital Card status (always ConsentPending for type DigitalCardConsentPendingStatusInfo). */
        status?: boolean | `@${string}`;
        /** A reference to the consent to validate */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card Declined Status Information */
    ['DigitalCardDeclinedStatusInfo']: AliasType<{
        /** Digital Card status (always Declined for type DigitalCardDeclinedStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['DigitalCardEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The Card entry */
        node?: ResolverInputTypes['DigitalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card Enabled Status Information */
    ['DigitalCardEnabledStatusInfo']: AliasType<{
        /** Digital Card status (always Enabled for type DigitalCardEnabledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Enable Date */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing digitalCards */
    ['DigitalCardFiltersInput']: {
        /** The id of the digitalCard */
        id?: string | undefined | null;
        /** The status of the digital card. It can be a CompleteDigitalCardStatus or a PendingDigitalCardStatus */
        status?: string | undefined | null;
        /** The Secure Element ID
    Mostly present on APple Devices */
        SEID?: string | undefined | null;
        /** The digital card masker number */
        cardMaskedNumber?: string | undefined | null;
        /** The ID of the wallet provider in the scheme system */
        walletProviderId?: string | undefined | null;
        /** Either ApplePay, GooglePay or Merchant */
        walletProviderName?: string | undefined | null;
        /** The wallet application ID in the user phone */
        walletId?: string | undefined | null;
    };
    /** Rejection returned when the Digital Card does not exist */
    ['DigitalCardNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing digital cards */
    ['DigitalCardOrderByFieldInput']: DigitalCardOrderByFieldInput;
    /** Order that can be applied when listing digital cards */
    ['DigitalCardOrderByInput']: {
        field?: ResolverInputTypes['DigitalCardOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Digital Card Pending Status Information */
    ['DigitalCardPendingStatusInfo']: AliasType<{
        /** Digital Card status (always Pending for type DigitalCardPendingStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Digital Card Suspended Status Information */
    ['DigitalCardSuspendedStatusInfo']: AliasType<{
        /** Digital Card status (always Suspended for type DigitalCardSuspendedStatusInfo). */
        status?: boolean | `@${string}`;
        /** Enable Date */
        enabledAt?: boolean | `@${string}`;
        /** Suspend Date */
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Digitalization Type */
    ['DigitalizationType']: DigitalizationType;
    /** Direct Debit Account Verification */
    ['DirectDebitAccountVerification']: AliasType<{
        /** Creation date of the account verification */
        createdAt?: boolean | `@${string}`;
        /** IBAN of the account to cross check with account holder information */
        iban?: boolean | `@${string}`;
        /** Unique identifier of the Account Verification */
        id?: boolean | `@${string}`;
        /** Account Verification Status Information */
        statusInfo?: ResolverInputTypes['AccountVerificationStatusInfo'];
        /** Last update date of the account verification */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source with Direct Debit Mandate */
    ['DirectDebitFundingSource']: AliasType<{
        /** ID of the Funding Source */
        id?: boolean | `@${string}`;
        /** Name of the Funding Source */
        name?: boolean | `@${string}`;
        /** Funding Source status information */
        statusInfo?: ResolverInputTypes['FundingSourceStatusInfo'];
        /** IBAN to use in the direct debit transaction that will be triggered when funding the account.
    Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source */
        iban?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Last updated date */
        updatedAt?: boolean | `@${string}`;
        /** Can be queried to check the status of the account verification for this funding source.
    If the account verification is PendingVerification, you should ask your account holder to wire some money from his external account to any swan account */
        accountVerification?: ResolverInputTypes['DirectDebitAccountVerification'];
        /** Can be queried to check the status of payment payment Mandate.
    If the payment mandate is ConsentPending, you should confirm it to enable this funding source */
        paymentMandate?: ResolverInputTypes['PaymentDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DirectDebitSequence']: DirectDebitSequence;
    /** Input to disable an account membership */
    ['DisableAccountMembershipInput']: {
        /** Unique identifier of the account membership to disable */
        accountMembershipId: string;
    };
    ['DisableAccountMembershipPayload']: AliasType<{
        DisableAccountMembershipSuccessPayload?: ResolverInputTypes['DisableAccountMembershipSuccessPayload'];
        AccountMembershipCannotBeDisabledRejection?: ResolverInputTypes['AccountMembershipCannotBeDisabledRejection'];
        AccountMembershipNotFoundRejection?: ResolverInputTypes['AccountMembershipNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        LegalRepresentativeAccountMembershipCannotBeDisabledRejection?: ResolverInputTypes['LegalRepresentativeAccountMembershipCannotBeDisabledRejection'];
        UserNotAllowedToDisableItsOwnAccountMembershipRejection?: ResolverInputTypes['UserNotAllowedToDisableItsOwnAccountMembershipRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['DisableAccountMembershipSuccessPayload']: AliasType<{
        accountMembership?: ResolverInputTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings has been disabled */
    ['DisabledFundingLimitSettingsStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** EnabledMerchantPaymentMethodStatusInfo */
    ['DisabledMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method disabled date */
        disabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Retrieved document extracted from the identity verification */
    ['DocumentFile']: AliasType<{
        downloadUrl?: boolean | `@${string}`;
        ['...on DriversLicenseDocumentFile']?: Omit<ResolverInputTypes['DriversLicenseDocumentFile'], keyof ResolverInputTypes['DocumentFile']>;
        ['...on IdCardDocumentFile']?: Omit<ResolverInputTypes['IdCardDocumentFile'], keyof ResolverInputTypes['DocumentFile']>;
        ['...on PassportDocumentFile']?: Omit<ResolverInputTypes['PassportDocumentFile'], keyof ResolverInputTypes['DocumentFile']>;
        ['...on ReportDocumentFile']?: Omit<ResolverInputTypes['ReportDocumentFile'], keyof ResolverInputTypes['DocumentFile']>;
        ['...on ResidencePermitDocumentFile']?: Omit<ResolverInputTypes['ResidencePermitDocumentFile'], keyof ResolverInputTypes['DocumentFile']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** From which side the document picture was taken */
    ['DocumentFileSide']: DocumentFileSide;
    /** Reason code of the document. */
    ['DocumentReasonCode']: DocumentReasonCode;
    /** The type of the document */
    ['DocumentType']: DocumentType;
    /** The document corresponding to a driver's license */
    ['DriversLicenseDocument']: AliasType<{
        /** Unique identifier of the driver's license document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ResolverInputTypes['DriversLicenseDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the driver's license document */
    ['DriversLicenseDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        /** From which side the deiver's license's picture was taken */
        side?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Edge type containing the node and cursor. The node is not defined in the interface because generic is not supported by GraphQL
  but all implementation contains its own node property according to the paginated type. */
    ['Edge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        ['...on AccountEdge']?: Omit<ResolverInputTypes['AccountEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on AccountHolderEdge']?: Omit<ResolverInputTypes['AccountHolderEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on AccountMembershipEdge']?: Omit<ResolverInputTypes['AccountMembershipEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on CapitalDepositCaseEdge']?: Omit<ResolverInputTypes['CapitalDepositCaseEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on CardEdge']?: Omit<ResolverInputTypes['CardEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on ConsentEdge']?: Omit<ResolverInputTypes['ConsentEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on DigitalCardEdge']?: Omit<ResolverInputTypes['DigitalCardEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on ExternalAccountEdge']?: Omit<ResolverInputTypes['ExternalAccountEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on ExternalBalanceEdge']?: Omit<ResolverInputTypes['ExternalBalanceEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on FundingLimitSettingsChangeRequestEdge']?: Omit<ResolverInputTypes['FundingLimitSettingsChangeRequestEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on FundingSourceEdge']?: Omit<ResolverInputTypes['FundingSourceEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on IdentificationEdge']?: Omit<ResolverInputTypes['IdentificationEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on InvoiceEdge']?: Omit<ResolverInputTypes['InvoiceEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on LegalDocumentEdge']?: Omit<ResolverInputTypes['LegalDocumentEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on MerchantProfileEdge']?: Omit<ResolverInputTypes['MerchantProfileEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on OnboardingEdge']?: Omit<ResolverInputTypes['OnboardingEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on PaymentEdge']?: Omit<ResolverInputTypes['PaymentEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on PaymentMandateEdge']?: Omit<ResolverInputTypes['PaymentMandateEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on ReceivedDirectDebitMandateEdge']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on StandingOrderEdge']?: Omit<ResolverInputTypes['StandingOrderEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on StatementEdge']?: Omit<ResolverInputTypes['StatementEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on SupportingDocumentCollectionEdge']?: Omit<ResolverInputTypes['SupportingDocumentCollectionEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on TransactionEdge']?: Omit<ResolverInputTypes['TransactionEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on TrustedBeneficiaryEdge']?: Omit<ResolverInputTypes['TrustedBeneficiaryEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on UserEdge']?: Omit<ResolverInputTypes['UserEdge'], keyof ResolverInputTypes['Edge']>;
        ['...on VirtualIBANEntryEdge']?: Omit<ResolverInputTypes['VirtualIBANEntryEdge'], keyof ResolverInputTypes['Edge']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['EmailAddress']: unknown;
    /** Employment status. */
    ['EmploymentStatus']: EmploymentStatus;
    /** Rejection returned if the card product don't have a card design enabled */
    ['EnabledCardDesignNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when the funding limit settings is enabled */
    ['EnabledFundingLimitSettingsStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source Enabled status information */
    ['EnabledFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Enabled status */
        status?: boolean | `@${string}`;
        /** Date at which the funding source was enabled */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** EnabledMerchantPaymentMethodStatusInfo */
    ['EnabledMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method enabled date */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** EnabledMerchantProfileStatusInfo */
    ['EnabledMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to enable a received direct debit mandate, i.e. to move its status back from suspended. */
    ['EnableReceivedDirectDebitMandateInput']: {
        /** The received direct debit id to enable */
        receivedDirectDebitMandateId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl?: string | undefined | null;
    };
    /** Union type return by the enableReceivedDirectDebitMandate mutation */
    ['EnableReceivedDirectDebitMandatePayload']: AliasType<{
        EnableReceivedDirectDebitMandateSuccessPayload?: ResolverInputTypes['EnableReceivedDirectDebitMandateSuccessPayload'];
        ReceivedDirectDebitMandateNotFoundRejection?: ResolverInputTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ReceivedDirectDebitMandateCanceledRejection?: ResolverInputTypes['ReceivedDirectDebitMandateCanceledRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the enableReceivedDirectDebitMandate mutation */
    ['EnableReceivedDirectDebitMandateSuccessPayload']: AliasType<{
        /** The received direct debit mandate is enable, i.e that it is moved back to from the suspended to the enabled status */
        receivedDirectDebitMandate?: ResolverInputTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    ['EnvType']: EnvType;
    /** Describes an identification level for the process associated to this identification that has expired and is no longer considered valid */
    ['ExpiredIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Expired` */
        status?: boolean | `@${string}`;
        /** When this identification level expired */
        expiredAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExpiredMerchantPaymentLinkStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** The date when the payment link expired.
    By default the payment link expires 120 days after it was created. */
        expiredAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccount']: AliasType<{
        /** Unique identifier of an external account */
        id?: boolean | `@${string}`;
        /** External account identifier following ISO-20022 standard */
        externalId?: boolean | `@${string}`;
        /** Name of the account */
        name?: boolean | `@${string}`;
        /** Type of the account */
        cashAccountType?: boolean | `@${string}`;
        /** Bank Identifier Code */
        BIC?: boolean | `@${string}`;
        /** International Bank Account Number */
        IBAN?: boolean | `@${string}`;
        /** Currency */
        currency?: boolean | `@${string}`;
        /** Account Holder name */
        holderName?: boolean | `@${string}`;
        /** Country */
        country?: boolean | `@${string}`;
        /** Original Created date */
        originalCreatedAt?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        balances?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null;
            },
            ResolverInputTypes['ExternalBalanceConnection']
        ];
        /** Source used for this account */
        source?: ResolverInputTypes['ExternalAccountDataSource'];
        /** Financial institution */
        institution?: ResolverInputTypes['FinancialInstitution'];
        /** Usage information of the account */
        usage?: boolean | `@${string}`;
        /** Account holder for the external account */
        accountHolder?: ResolverInputTypes['AccountHolder'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountAlreadyExistsRejection']: AliasType<{
        iban?: boolean | `@${string}`;
        accountHolderId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountBalance']: AliasType<{
        /** Unique identifier of an external balance */
        id?: boolean | `@${string}`;
        /** Amount with currency */
        amount?: ResolverInputTypes['Amount'];
        /** Type of Balance */
        type?: boolean | `@${string}`;
        /** Last changed Date */
        lastChangedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountBalanceAlreadyExistsRejection']: AliasType<{
        type?: boolean | `@${string}`;
        lastChangedAt?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountBalanceInput']: {
        /** Amount with currency */
        amount: ResolverInputTypes['AmountInput'];
        /** Type of Balance */
        type: ResolverInputTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: ResolverInputTypes['DateTime'];
    };
    ['ExternalAccountBalanceType']: ExternalAccountBalanceType;
    /** Implements the Relay Connection interface, used to paginate the list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ExternalAccountConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** ExternalAccountEdge list */
        edges?: ResolverInputTypes['ExternalAccountEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountDataSource']: AliasType<{
        type?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountDataSourceType']: ExternalAccountDataSourceType;
    /** Implements the Relay Edge interface */
    ['ExternalAccountEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The external account */
        node?: ResolverInputTypes['ExternalAccount'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ExternalAccountUsage']: ExternalAccountUsage;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ExternalBalanceConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** ExternalBalanceEdge list */
        edges?: ResolverInputTypes['ExternalBalanceEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['ExternalBalanceEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The external balance */
        node?: ResolverInputTypes['ExternalAccountBalance'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to a face photo */
    ['FacePhotoDocument']: AliasType<{
        /** Unique identifier of the face photo document. For privacy reasons, no temporary download url is exposed for this document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee creditor */
    ['FeeCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        ['...on FeeInCreditor']?: Omit<ResolverInputTypes['FeeInCreditor'], keyof ResolverInputTypes['FeeCreditor']>;
        ['...on FeeOutCreditor']?: Omit<ResolverInputTypes['FeeOutCreditor'], keyof ResolverInputTypes['FeeCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['FeeDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        ['...on FeeInDebtor']?: Omit<ResolverInputTypes['FeeInDebtor'], keyof ResolverInputTypes['FeeDebtor']>;
        ['...on FeeOutDebtor']?: Omit<ResolverInputTypes['FeeOutDebtor'], keyof ResolverInputTypes['FeeDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee creditor for Incoming transaction */
    ['FeeInCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee debtor for Incoming transaction */
    ['FeeInDebtor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee creditor for Outgoing transaction */
    ['FeeOutCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fee debtor for Outgoing transaction */
    ['FeeOutDebtor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['FeeSettingsNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fees type */
    ['FeesTypeEnum']: FeesTypeEnum;
    /** Fee Transaction */
    ['FeeTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ResolverInputTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** feesType */
        feesType?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ResolverInputTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ResolverInputTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ResolverInputTypes['FeeCreditor'];
        /** debtor information */
        debtor?: ResolverInputTypes['FeeDebtor'];
        /** matching account for the transaction */
        account?: ResolverInputTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ResolverInputTypes['Transaction'];
        __typename?: boolean | `@${string}`;
    }>;
    ['Field']: AliasType<{
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        ['...on DateField']?: Omit<ResolverInputTypes['DateField'], keyof ResolverInputTypes['Field']>;
        ['...on RadioField']?: Omit<ResolverInputTypes['RadioField'], keyof ResolverInputTypes['Field']>;
        ['...on SelectField']?: Omit<ResolverInputTypes['SelectField'], keyof ResolverInputTypes['Field']>;
        ['...on TextField']?: Omit<ResolverInputTypes['TextField'], keyof ResolverInputTypes['Field']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['FieldValidationError']: FieldValidationError;
    ['FinalizeOnboardingInput']: {
        onboardingId: string;
    };
    ['FinalizeOnboardingPayload']: AliasType<{
        FinalizeOnboardingSuccessPayload?: ResolverInputTypes['FinalizeOnboardingSuccessPayload'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        OnboardingNotCompletedRejection?: ResolverInputTypes['OnboardingNotCompletedRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['FinalizeOnboardingSuccessPayload']: AliasType<{
        onboarding?: ResolverInputTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    ['FinancialInstitution']: AliasType<{
        id?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        country?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['FnciInfo']: AliasType<{
        colorCode?: boolean | `@${string}`;
        cpt1?: boolean | `@${string}`;
        cpt2?: boolean | `@${string}`;
        cpt3?: boolean | `@${string}`;
        holderEstablishment?: boolean | `@${string}`;
        responseCode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ForbiddenRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['FundingLimit']: AliasType<{
        /** Maximum Funding Amount authorized */
        amount?: ResolverInputTypes['Amount'];
        /** Funding Amount that has already been used during the interval */
        funding?: ResolverInputTypes['Amount'];
        /** Interval in number of calendar days where the limit is applied */
        rollingDays?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Amount */
    ['FundingLimitAmount']: AliasType<{
        /** The amount settings */
        amount?: ResolverInputTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Amount Input */
    ['FundingLimitAmountInput']: {
        /** The amount settings */
        amount: ResolverInputTypes['AmountInput'];
    };
    /** Rejection returned when the Account Holder Funding has been exceeded */
    ['FundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['FundingLimitSettings']: AliasType<{
        /** Instant funding limit */
        instantFundingLimit?: ResolverInputTypes['InstantFundingLimit'];
        /** Periodic funding limit */
        fundingLimit?: ResolverInputTypes['FundingLimit'];
        /** Related change request */
        fundingLimitSettingsChangeRequest?: ResolverInputTypes['FundingLimitSettingsChangeRequest'];
        /** Status of the resource */
        statusInfo?: ResolverInputTypes['FundingLimitSettingsStatusInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Settings Change Request */
    ['FundingLimitSettingsChangeRequest']: AliasType<{
        /** Unique identifier of a funding limit settings change request */
        id?: boolean | `@${string}`;
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit?: ResolverInputTypes['FundingLimitAmount'];
        /** Requested amount settings for the funding limit */
        fundingLimit?: ResolverInputTypes['FundingLimitAmount'];
        /** Approved amount settings for the the instant funding limit and the funding limit */
        approved?: ResolverInputTypes['ApprovedFundingLimit'];
        /** Status of the request */
        statusInfo?: ResolverInputTypes['FundingLimitSettingsChangeRequestStatusInfo'];
        /** Date of creation */
        createdAt?: boolean | `@${string}`;
        /** Date of last update */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings change request has been approved */
    ['FundingLimitSettingsChangeRequestApprovedStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Settings Change Request Bad Amount Rejection */
    ['FundingLimitSettingsChangeRequestBadAmountRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['FundingLimitSettingsChangeRequestConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** FundingLimitSettingsChangeRequestEdge list */
        edges?: ResolverInputTypes['FundingLimitSettingsChangeRequestEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['FundingLimitSettingsChangeRequestEdge']: AliasType<{
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The FundingLimitSettingsChangeRequest */
        node?: ResolverInputTypes['FundingLimitSettingsChangeRequest'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestFiltersInput']: {
        /** The ids of the funding limit settings change requests */
        id?: Array<string> | undefined | null;
        /** Status we want to filter on */
        status?: Array<ResolverInputTypes['FundingLimitSettingsChangeRequestStatus']> | undefined | null;
    };
    /** Field we can use when ordering that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestOrderByFieldInput']: FundingLimitSettingsChangeRequestOrderByFieldInput;
    /** Order that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestOrderByInput']: {
        field?: ResolverInputTypes['FundingLimitSettingsChangeRequestOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** StatusInfo when funding limit settings change request is pending */
    ['FundingLimitSettingsChangeRequestPendingStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings change request has been rejected */
    ['FundingLimitSettingsChangeRequestRefusedStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Limit Settings Change Request Status */
    ['FundingLimitSettingsChangeRequestStatus']: FundingLimitSettingsChangeRequestStatus;
    /** Object containing details about funding limit settings change request status */
    ['FundingLimitSettingsChangeRequestStatusInfo']: AliasType<{
        /** Current limit settings change request status. */
        status?: boolean | `@${string}`;
        ['...on FundingLimitSettingsChangeRequestApprovedStatusInfo']?: Omit<ResolverInputTypes['FundingLimitSettingsChangeRequestApprovedStatusInfo'], keyof ResolverInputTypes['FundingLimitSettingsChangeRequestStatusInfo']>;
        ['...on FundingLimitSettingsChangeRequestPendingStatusInfo']?: Omit<ResolverInputTypes['FundingLimitSettingsChangeRequestPendingStatusInfo'], keyof ResolverInputTypes['FundingLimitSettingsChangeRequestStatusInfo']>;
        ['...on FundingLimitSettingsChangeRequestRefusedStatusInfo']?: Omit<ResolverInputTypes['FundingLimitSettingsChangeRequestRefusedStatusInfo'], keyof ResolverInputTypes['FundingLimitSettingsChangeRequestStatusInfo']>;
        ['...on FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo']?: Omit<ResolverInputTypes['FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo'], keyof ResolverInputTypes['FundingLimitSettingsChangeRequestStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings change request is waiting for more information */
    ['FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Possible values for funding limit settings status */
    ['FundingLimitSettingsStatus']: FundingLimitSettingsStatus;
    /** Object containing details about funding limit settings status */
    ['FundingLimitSettingsStatusInfo']: AliasType<{
        /** Current funding limit settings. */
        status?: boolean | `@${string}`;
        ['...on DisabledFundingLimitSettingsStatusInfo']?: Omit<ResolverInputTypes['DisabledFundingLimitSettingsStatusInfo'], keyof ResolverInputTypes['FundingLimitSettingsStatusInfo']>;
        ['...on EnabledFundingLimitSettingsStatusInfo']?: Omit<ResolverInputTypes['EnabledFundingLimitSettingsStatusInfo'], keyof ResolverInputTypes['FundingLimitSettingsStatusInfo']>;
        ['...on SuspendedFundingLimitSettingsStatusInfo']?: Omit<ResolverInputTypes['SuspendedFundingLimitSettingsStatusInfo'], keyof ResolverInputTypes['FundingLimitSettingsStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source */
    ['FundingSource']: AliasType<{
        /** ID of the Funding Source */
        id?: boolean | `@${string}`;
        /** Name of the Funding Source */
        name?: boolean | `@${string}`;
        /** Funding Source status information */
        statusInfo?: ResolverInputTypes['FundingSourceStatusInfo'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Last updated date */
        updatedAt?: boolean | `@${string}`;
        ['...on DirectDebitFundingSource']?: Omit<ResolverInputTypes['DirectDebitFundingSource'], keyof ResolverInputTypes['FundingSource']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['FundingSourceConnection']: AliasType<{
        pageInfo?: ResolverInputTypes['PageInfo'];
        edges?: ResolverInputTypes['FundingSourceEdge'];
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['FundingSourceEdge']: AliasType<{
        node?: ResolverInputTypes['FundingSource'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing Funding Sources */
    ['FundingSourceFiltersInput']: {
        status: Array<ResolverInputTypes['FundingSourceStatus']>;
    };
    ['FundingSourceNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing funding source results */
    ['FundingSourceOrderByFieldInput']: FundingSourceOrderByFieldInput;
    /** Order that can be applied when listing funding source results */
    ['FundingSourceOrderByInput']: {
        field?: ResolverInputTypes['FundingSourceOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Funding Source Statuses */
    ['FundingSourceStatus']: FundingSourceStatus;
    /** Funding Source status information */
    ['FundingSourceStatusInfo']: AliasType<{
        /** Funding Source Pending status */
        status?: boolean | `@${string}`;
        ['...on CanceledFundingSourceStatusInfo']?: Omit<ResolverInputTypes['CanceledFundingSourceStatusInfo'], keyof ResolverInputTypes['FundingSourceStatusInfo']>;
        ['...on EnabledFundingSourceStatusInfo']?: Omit<ResolverInputTypes['EnabledFundingSourceStatusInfo'], keyof ResolverInputTypes['FundingSourceStatusInfo']>;
        ['...on PendingFundingSourceStatusInfo']?: Omit<ResolverInputTypes['PendingFundingSourceStatusInfo'], keyof ResolverInputTypes['FundingSourceStatusInfo']>;
        ['...on RejectedFundingSourceStatusInfo']?: Omit<ResolverInputTypes['RejectedFundingSourceStatusInfo'], keyof ResolverInputTypes['FundingSourceStatusInfo']>;
        ['...on SuspendedFundingSourceStatusInfo']?: Omit<ResolverInputTypes['SuspendedFundingSourceStatusInfo'], keyof ResolverInputTypes['FundingSourceStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Funding Source is not in the expected status */
    ['FundingSourceWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        expectedStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to generate an account */
    ['GenerateAccountStatementInput']: {
        /** Unique identifier of an account */
        accountId: string;
        /** starting date of the date window */
        openingDate: ResolverInputTypes['DateTime'];
        /** ending date of the date window */
        closingDate: ResolverInputTypes['DateTime'];
        /** language to generate the statement in (default to account's language) */
        language?: ResolverInputTypes['AccountLanguage'] | undefined | null;
        /** Type of statement to generate */
        statementType?: ResolverInputTypes['StatementType'] | undefined | null;
    };
    ['GenerateCapitalDepositDocumentUploadUrlInput']: {
        /** Unique identifier of the document. */
        documentId: string;
        /** Unique identifier of the capitalDepositCase associated to the document. */
        capitalDepositCaseId: string;
        /** Filename of the document. */
        filename: string;
    };
    ['GenerateCapitalDepositDocumentUploadUrlPayload']: AliasType<{
        GenerateCapitalDepositDocumentUploadUrlSuccessPayload?: ResolverInputTypes['GenerateCapitalDepositDocumentUploadUrlSuccessPayload'];
        CapitalDepositDocumentCanNotBeUploaded?: ResolverInputTypes['CapitalDepositDocumentCanNotBeUploaded'];
        CapitalDepositDocumentCanNotBeUploadedRejection?: ResolverInputTypes['CapitalDepositDocumentCanNotBeUploadedRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        BadRequestRejection?: ResolverInputTypes['BadRequestRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['GenerateCapitalDepositDocumentUploadUrlSuccessPayload']: AliasType<{
        /** URL to be used to upload the document. */
        uploadUrl?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['GenerateSupportingDocumentUploadUrlInput']: {
        /** Unique identifier of a supporting document collection */
        supportingDocumentCollectionId: string;
        /** Type of document */
        supportingDocumentType?: ResolverInputTypes['SupportingDocumentType'] | undefined | null;
        /** Name of the document which will be sent */
        filename: string;
        /** Purpose of document */
        supportingDocumentPurpose?: ResolverInputTypes['SupportingDocumentPurposeEnum'] | undefined | null;
    };
    ['GenerateSupportingDocumentUploadUrlPayload']: AliasType<{
        GenerateSupportingDocumentUploadUrlSuccessPayload?: ResolverInputTypes['GenerateSupportingDocumentUploadUrlSuccessPayload'];
        SupportingDocumentCollectionNotFoundRejection?: ResolverInputTypes['SupportingDocumentCollectionNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        SupportingDocumentUploadNotAllowedRejection?: ResolverInputTypes['SupportingDocumentUploadNotAllowedRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['GenerateSupportingDocumentUploadUrlSuccessPayload']: AliasType<{
        /** Id of the supporting document created for this uploadUrl */
        supportingDocumentId?: boolean | `@${string}`;
        /** Info to upload the document : url and fields to add along file in form (POST) */
        upload?: ResolverInputTypes['SupportingDocumentUploadInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Global Funding has been exceeded */
    ['GlobalFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Global Instant Funding limit has been exceeded */
    ['GlobalInstantFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignatureInput']: {
        /** ID of the consent to grant */
        consentId: string;
        /** Consent challenge signed with server consent credentials */
        signature: string;
    };
    /** Payload of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignaturePayload']: AliasType<{
        GrantConsentWithServerSignatureSuccessPayload?: ResolverInputTypes['GrantConsentWithServerSignatureSuccessPayload'];
        ConsentNotFoundRejection?: ResolverInputTypes['ConsentNotFoundRejection'];
        NotReachableConsentStatusRejection?: ResolverInputTypes['NotReachableConsentStatusRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ConsentTypeNotSupportedByServerConsentRejection?: ResolverInputTypes['ConsentTypeNotSupportedByServerConsentRejection'];
        ServerConsentNotAllowedForConsentOperationRejection?: ResolverInputTypes['ServerConsentNotAllowedForConsentOperationRejection'];
        ProjectNotFoundRejection?: ResolverInputTypes['ProjectNotFoundRejection'];
        ServerConsentNotAllowedForProjectRejection?: ResolverInputTypes['ServerConsentNotAllowedForProjectRejection'];
        ServerConsentProjectSettingsNotFoundRejection?: ResolverInputTypes['ServerConsentProjectSettingsNotFoundRejection'];
        ServerConsentProjectCredentialMissingRejection?: ResolverInputTypes['ServerConsentProjectCredentialMissingRejection'];
        ServerConsentProjectCredentialNotFoundRejection?: ResolverInputTypes['ServerConsentProjectCredentialNotFoundRejection'];
        ServerConsentCredentialsNotValidOrOutdatedRejection?: ResolverInputTypes['ServerConsentCredentialsNotValidOrOutdatedRejection'];
        ServerConsentSignatureNotValidRejection?: ResolverInputTypes['ServerConsentSignatureNotValidRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Success payload of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignatureSuccessPayload']: AliasType<{
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['Headquarters']: AliasType<{
        town?: boolean | `@${string}`;
        zipCode?: boolean | `@${string}`;
        address?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['HexColorCode']: unknown;
    /** International Bank Account Number */
    ['IBAN']: unknown;
    /** Rejection returned when the IBAN is not reachable */
    ['IBANNotReachableRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the IBAN is not valid */
    ['IBANNotValidRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Virtual IBAN Status */
    ['IBANStatus']: IBANStatus;
    /** ibanValidation input */
    ['IbanValidationInput']: {
        /** IBAN to validate */
        iban: ResolverInputTypes['IBAN'];
    };
    ['IbanValidationRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** IbanValidationResult */
    ['IbanValidationResult']: AliasType<{
        ValidIban?: ResolverInputTypes['ValidIban'];
        InvalidIban?: ResolverInputTypes['InvalidIban'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to an ID card */
    ['IdCardDocument']: AliasType<{
        /** Unique identifier of the ID card document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** The date at which the ID card was issued */
        issueDate?: boolean | `@${string}`;
        /** The date at which the ID card expires */
        expiryDate?: boolean | `@${string}`;
        /** Machine-readable zone code of the ID card */
        mrz?: boolean | `@${string}`;
        /** Number of the ID card */
        number?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ResolverInputTypes['IdCardDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the ID card document */
    ['IdCardDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        /** From which side the ID card's picture was taken */
        side?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The identification represents an ongoing identification process or its result */
    ['Identification']: AliasType<{
        /** Unique identifier of the identification */
        id?: boolean | `@${string}`;
        /** Creation date of the identification */
        createdAt?: boolean | `@${string}`;
        /** Last update date of the identification */
        updatedAt?: boolean | `@${string}`;
        /** The global status of the identification */
        status?: boolean | `@${string}`;
        /** The process that was used for this identification */
        process?: boolean | `@${string}`;
        /** The status and results associated to the available identification processes */
        levels?: ResolverInputTypes['IdentificationLevelStatusesInfo'];
        /** The available documents related to the identification (id doc, selfie, report...) */
        documents?: ResolverInputTypes['IdentificationDocument'];
        /** The identity document type used for the current identification (passport, id card ...) */
        identityDocumentType?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Fields we can use when ordering that can be applied when listing identifications */
    ['IdentificationConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** IdentificationEdge list */
        edges?: ResolverInputTypes['IdentificationEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Union representing all the possible identification document types */
    ['IdentificationDocument']: AliasType<{
        IdCardDocument?: ResolverInputTypes['IdCardDocument'];
        PassportDocument?: ResolverInputTypes['PassportDocument'];
        ResidencePermitDocument?: ResolverInputTypes['ResidencePermitDocument'];
        DriversLicenseDocument?: ResolverInputTypes['DriversLicenseDocument'];
        FacePhotoDocument?: ResolverInputTypes['FacePhotoDocument'];
        ReportDocument?: ResolverInputTypes['ReportDocument'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['IdentificationEdge']: AliasType<{
        /** The identification entry */
        node?: ResolverInputTypes['Identification'];
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filter that can be passed to get the identifications in specific data ranges */
    ['IdentificationFiltersInput']: {
        /** To filter on status values */
        statuses?: Array<ResolverInputTypes['SwanIdentificationStatus']> | undefined | null;
        /** To filter on level values */
        levels?: Array<ResolverInputTypes['IdentificationLevel']> | undefined | null;
        /** To filter on process values */
        processes?: Array<ResolverInputTypes['IdentificationProcess']> | undefined | null;
    };
    /** The various reasons that can lead to an invalid identification level */
    ['IdentificationInvalidReason']: IdentificationInvalidReason;
    /** Possible value for the field IdentificationLevel */
    ['IdentificationLevel']: IdentificationLevel;
    /** User identification levels input payload. */
    ['IdentificationLevelInput']: IdentificationLevelInput;
    /** Identification levels */
    ['IdentificationLevels']: AliasType<{
        PVID?: boolean | `@${string}`;
        QES?: boolean | `@${string}`;
        expert?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The status and results associated to the available identification processes */
    ['IdentificationLevelStatusesInfo']: AliasType<{
        /** The status and results associated to the expert level */
        expert?: ResolverInputTypes['IdentificationLevelStatusInfo'];
        /** The status and results associated to the Qualified Electronic Signature level */
        qes?: ResolverInputTypes['IdentificationLevelStatusInfo'];
        /** The status and results associated to the Remote Identity Verification Service level */
        pvid?: ResolverInputTypes['IdentificationLevelStatusInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Union representing all the possible statuses: not supported, not started, pending, valid, invalid, cancelled, expired
  Each variant contains its relevant data, for example invalid contains a `reason` field, expired contains an `expiredAt` field, valid contains a `documents` field */
    ['IdentificationLevelStatusInfo']: AliasType<{
        NotSupportedIdentificationLevelStatusInfo?: ResolverInputTypes['NotSupportedIdentificationLevelStatusInfo'];
        NotStartedIdentificationLevelStatusInfo?: ResolverInputTypes['NotStartedIdentificationLevelStatusInfo'];
        StartedIdentificationLevelStatusInfo?: ResolverInputTypes['StartedIdentificationLevelStatusInfo'];
        PendingIdentificationLevelStatusInfo?: ResolverInputTypes['PendingIdentificationLevelStatusInfo'];
        ValidIdentificationLevelStatusInfo?: ResolverInputTypes['ValidIdentificationLevelStatusInfo'];
        InvalidIdentificationLevelStatusInfo?: ResolverInputTypes['InvalidIdentificationLevelStatusInfo'];
        CanceledIdentificationLevelStatusInfo?: ResolverInputTypes['CanceledIdentificationLevelStatusInfo'];
        ExpiredIdentificationLevelStatusInfo?: ResolverInputTypes['ExpiredIdentificationLevelStatusInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Process of the identification */
    ['IdentificationProcess']: IdentificationProcess;
    /** Fields we can use when ordering that can be applied when listing identifications */
    ['IdentificationsOrderByField']: IdentificationsOrderByField;
    /** Order that can be applied when listing identifications */
    ['IdentificationsOrderByInput']: {
        /** The field by which the Identification list should be ordered */
        field?: ResolverInputTypes['IdentificationsOrderByField'] | undefined | null;
        /** The order in which the Identification list should be ordered */
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Identification status */
    ['IdentificationStatus']: IdentificationStatus;
    /** Rejection returned if identity and the account memberships are already bind */
    ['IdentityAlreadyBindToAccountMembershipRejection']: AliasType<{
        accountId?: boolean | `@${string}`;
        identityId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The type of the identity document */
    ['IdentityDocumentType']: IdentityDocumentType;
    /** Data used for in app provisioning */
    ['InAppProvisioningData']: AliasType<{
        /** Cryptographic OTP used to pre-validate digitalization */
        activationData?: boolean | `@${string}`;
        /** Base64 public key used with the wallet provider public key to encrypt the card data */
        ephemeralPublicKey?: boolean | `@${string}`;
        /** Encrypted card data */
        encryptedData?: boolean | `@${string}`;
        /** IV used to encrypt the card Data (Useful for Google Pay) */
        iv?: boolean | `@${string}`;
        /** public key fingerprint of the key used to encrypt card data (Useful for Google Pay) */
        publicKeyFingerprint?: boolean | `@${string}`;
        /** hash algorithm used during encryption of the card data (Useful for Google Pay) */
        oaepHashingAlgorithm?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual shareholder info. */
    ['IndividualShareholder']: AliasType<{
        /** Whether the shareholder is an individual or a company. */
        type?: boolean | `@${string}`;
        /** First name of the shareholder. */
        firstName?: boolean | `@${string}`;
        /** Last name of the shareholder. */
        lastName?: boolean | `@${string}`;
        /** Birth date of the shareholder. */
        birthDate?: boolean | `@${string}`;
        /** CCA3 code for the country of nationality of the shareholder. */
        nationality?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual Ultimate Beneficial Owner
  You need to describe the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company.
  Please describe the company (s) that owns the company that wishes to open an account, when an individual holds in fine more than 25% */
    ['IndividualUltimateBeneficialOwner']: AliasType<{
        /** individual first name */
        firstName?: boolean | `@${string}`;
        /** individual last name */
        lastName?: boolean | `@${string}`;
        /** individual birth date */
        birthDate?: boolean | `@${string}`;
        /** individual birth city */
        birthCity?: boolean | `@${string}`;
        /** individual birth city postal code */
        birthCityPostalCode?: boolean | `@${string}`;
        /** individual birth country code */
        birthCountryCode?: boolean | `@${string}`;
        /** Information relating to the type of the UBO */
        info?: ResolverInputTypes['IndividualUltimateBeneficialOwnerInfo'];
        /** Individual beneficial owner Tax or Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        /** Individual beneficial owner residency Address */
        residencyAddress?: ResolverInputTypes['AddressInformation'];
        /** Individual beneficial owner title (Mr/Ms) */
        title?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Define the type of the UBO */
    ['IndividualUltimateBeneficialOwnerInfo']: AliasType<{
        /** Individual type */
        type?: boolean | `@${string}`;
        ['...on IndividualUltimateBeneficialOwnerTypeHasCapital']?: Omit<ResolverInputTypes['IndividualUltimateBeneficialOwnerTypeHasCapital'], keyof ResolverInputTypes['IndividualUltimateBeneficialOwnerInfo']>;
        ['...on IndividualUltimateBeneficialOwnerTypeLegalRepresentative']?: Omit<ResolverInputTypes['IndividualUltimateBeneficialOwnerTypeLegalRepresentative'], keyof ResolverInputTypes['IndividualUltimateBeneficialOwnerInfo']>;
        ['...on IndividualUltimateBeneficialOwnerTypeOther']?: Omit<ResolverInputTypes['IndividualUltimateBeneficialOwnerTypeOther'], keyof ResolverInputTypes['IndividualUltimateBeneficialOwnerInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['IndividualUltimateBeneficialOwnerInput']: {
        /** Individual beneficial owner first name. Length must be from 0 to 100 characters */
        firstName?: string | undefined | null;
        /** Individual beneficial owner last name. Length must be from 0 to 100 characters */
        lastName?: string | undefined | null;
        /** Individual birth date. Must be a valid date in the YYYY/MM/DD format */
        birthDate?: string | undefined | null;
        /** Individual birth city. Length must be from 0 to 100 characters */
        birthCity?: string | undefined | null;
        /** Individual birth city postal code. Length must be from 0 to 50 characters */
        birthCityPostalCode?: string | undefined | null;
        /** Individual birth country code */
        birthCountryCode?: ResolverInputTypes['CCA3'] | undefined | null;
        /** Define UBO is an Indirect Owner */
        indirect?: boolean | undefined | null;
        /** Define UBO is a Direct Owner */
        direct?: boolean | undefined | null;
        /** Total of capital (in percentage, ex: 50 = 50%). Must be between 1 and 100. */
        totalCapitalPercentage?: number | undefined | null;
        /** Define UBO is a Legal Representative */
        type: ResolverInputTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
        /** Individual beneficial owner Tax or Identification Number */
        taxIdentificationNumber?: string | undefined | null;
        /** Individual beneficial owner residency address */
        residencyAddress?: ResolverInputTypes['AddressInformationInput'] | undefined | null;
        /** Individual ultimate beneficial owner title (Mr/Ms) */
        title?: ResolverInputTypes['TitleEnum'] | undefined | null;
    };
    /** Individual Ultimate beneficial owner nature */
    ['IndividualUltimateBeneficialOwnerTypeEnum']: IndividualUltimateBeneficialOwnerTypeEnum;
    /** Individual Ultimate Beneficial Owner Type Has Capital */
    ['IndividualUltimateBeneficialOwnerTypeHasCapital']: AliasType<{
        /** Individual type */
        type?: boolean | `@${string}`;
        /** Define UBO is an Indirect Owner */
        indirect?: boolean | `@${string}`;
        /** Define UBO is an Direct Owner */
        direct?: boolean | `@${string}`;
        /** Total of capital (in percentage, ex: 50 = 50%) */
        totalCapitalPercentage?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual Ultimate Beneficial Owner Type Legal Representative */
    ['IndividualUltimateBeneficialOwnerTypeLegalRepresentative']: AliasType<{
        /** Individual type */
        type?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual Ultimate Beneficial Owner Type Other */
    ['IndividualUltimateBeneficialOwnerTypeOther']: AliasType<{
        /** Individual type */
        type?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateCheckMerchantPaymentInput']: {
        /** Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€. */
        amount: ResolverInputTypes['AmountInput'];
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement.
    If empty, default label will be set as "Check N° [1st 7 characters of CMC7] */
        label?: string | undefined | null;
        /** End-to-end reference of the concerned payment collection. */
        reference?: string | undefined | null;
        /** ID of the merchant profile associated to the Swan creditor account. */
        merchantProfileId: string;
        /** 31-character unique identifier located at the bottom of the check.
    CMC7 is composed of 3 sections (check number (7 characters), check issuing bank code (12 characters), check holder account number (12 characters)).
    Combined with RLMC key, it  allows the check to be traced. */
        cmc7: string;
        /** 2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
    Combined with CMC7 line, it allows the check to be traced. */
        rlmcKey: string;
    };
    ['InitiateCheckMerchantPaymentPayload']: AliasType<{
        InitiateCheckMerchantPaymentSuccessPayload?: ResolverInputTypes['InitiateCheckMerchantPaymentSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        NotFoundRejection?: ResolverInputTypes['NotFoundRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        CheckRejection?: ResolverInputTypes['CheckRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateCheckMerchantPaymentSuccessPayload']: AliasType<{
        merchantPayment?: ResolverInputTypes['Payment'];
        /** Details of the FNCI (Fichier national des chèques irréguliers) response */
        fnciInfo?: ResolverInputTypes['FnciInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Initiate credit transfers */
    ['InitiateCreditTransfersInput']: {
        /** account to be debited identified by number */
        accountNumber?: ResolverInputTypes['AccountNumber'] | undefined | null;
        /** account id to be debited identified by id */
        accountId?: string | undefined | null;
        /** credit transfers (max 2500 records) */
        creditTransfers: Array<ResolverInputTypes['CreditTransferInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['InitiateCreditTransfersPayload']: AliasType<{
        InitiateCreditTransfersSuccessPayload?: ResolverInputTypes['InitiateCreditTransfersSuccessPayload'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateCreditTransfersSuccessPayload']: AliasType<{
        payment?: ResolverInputTypes['Payment'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to initiate a funding request */
    ['InitiateFundingRequestInput']: {
        /** ID of the funding source to be used to fund the concerned account */
        fundingSourceId: string;
        /** Amount of the requested funding, i.e. amount that will credit the concerned Swan account and debit the external funding source. */
        amount: ResolverInputTypes['AmountInput'];
        /** Reference of the funding request that will be shown on the account holder statement and on the debtor account used. */
        reference?: string | undefined | null;
        /** Label of the funding request that will be shown on the account holder statement and on the debtor account used
    Always starts with 'Partner Name' truncated at 19 characters followed by a space.
    If empty, default label is "Partner Name - Account Holder Name". */
        label?: string | undefined | null;
        /** Url to which the authorized account member must be redirected once the consent has been finalized. */
        consentRedirectUrl: string;
        /** When the funding request should be executed. If `null`, it will be executed as soon as possible.
    It is not possible to define this value when the option `isInstant` is set to true. */
        requestedExecutionAt?: ResolverInputTypes['DateTime'] | undefined | null;
        /** *SOON TO BE DEPRECATED*
    If `true` the funds should be available immediately. If `false` or `null`, the funds will be available
    after the resolution of the credit transaction. */
        isInstant?: boolean | undefined | null;
    };
    /** Initiate A Funding Request Payload */
    ['InitiateFundingRequestPayload']: AliasType<{
        InitiateFundingRequestSuccessPayload?: ResolverInputTypes['InitiateFundingRequestSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        FundingLimitExceededRejection?: ResolverInputTypes['FundingLimitExceededRejection'];
        ProjectFundingLimitExceededRejection?: ResolverInputTypes['ProjectFundingLimitExceededRejection'];
        GlobalFundingLimitExceededRejection?: ResolverInputTypes['GlobalFundingLimitExceededRejection'];
        FundingSourceWrongStatusRejection?: ResolverInputTypes['FundingSourceWrongStatusRejection'];
        FundingSourceNotFoundRejection?: ResolverInputTypes['FundingSourceNotFoundRejection'];
        InsufficientFundsRejection?: ResolverInputTypes['InsufficientFundsRejection'];
        InstantFundingLimitExceededRejection?: ResolverInputTypes['InstantFundingLimitExceededRejection'];
        ProjectInstantFundingLimitExceededRejection?: ResolverInputTypes['ProjectInstantFundingLimitExceededRejection'];
        GlobalInstantFundingLimitExceededRejection?: ResolverInputTypes['GlobalInstantFundingLimitExceededRejection'];
        AccountVerificationWrongStatusRejection?: ResolverInputTypes['AccountVerificationWrongStatusRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Initiate A Funding Request Success Payload */
    ['InitiateFundingRequestSuccessPayload']: AliasType<{
        /** Details of the funding payment created */
        payment?: ResolverInputTypes['Payment'];
        __typename?: boolean | `@${string}`;
    }>;
    /** *COMING SOON*
  Input to create a quote and an international beneficiary */
    ['InitiateInternationalCreditTransferInput']: {
        /** Account ID of the originator of the international credit transfer */
        accountId?: string | undefined | null;
        /** Account number if the beneficiary is a swan account */
        accountNumber?: ResolverInputTypes['AccountNumber'] | undefined | null;
        /** Target amount of the international credit transfer */
        targetAmount: ResolverInputTypes['AmountInput'];
        /** Beneficiary of the international credit transfer */
        internationalBeneficiary: ResolverInputTypes['InternationalBeneficiaryInput'];
        /** Transfer details */
        internationalCreditTransferDetails: Array<ResolverInputTypes['InternationalCreditTransferDetailsInput']>;
        /** When the consent flow is finished the user is redirected to this URL */
        consentRedirectUrl: string;
        /** External reference */
        externalReference?: string | undefined | null;
        /** Language used to output errors */
        language?: ResolverInputTypes['InternationalCreditTransferDisplayLanguage'] | undefined | null;
    };
    /** Initiate International Credit Transfer Response Payload */
    ['InitiateInternationalCreditTransferResponsePayload']: AliasType<{
        InitiateInternationalCreditTransferResponseSuccessPayload?: ResolverInputTypes['InitiateInternationalCreditTransferResponseSuccessPayload'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Initiate International Credit Transfer Response Success Payload */
    ['InitiateInternationalCreditTransferResponseSuccessPayload']: AliasType<{
        /** Details of the international credit transfer created */
        payment?: ResolverInputTypes['Payment'];
        /** Details for the quote of international credit transfer */
        quote?: ResolverInputTypes['InternationalCreditTransferQuote'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateMerchantPaymentCollectionInput']: {
        /** Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€. */
        amount: ResolverInputTypes['AmountInput'];
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement -
    For checks transaction, if empty, default label will be set as "Check N° [1st part of CMC7 - 7 char.] */
        label?: string | undefined | null;
        /** end-to-end reference of the concerned payment collection */
        reference?: string | undefined | null;
        /** external reference (JSON) that can be used by the Swan merchant for reconciliation purposes */
        externalReference?: string | undefined | null;
        /** Internal direct debit type of payment collection */
        internalDirectDebit?: ResolverInputTypes['InternalDirectDebitPaymentCollectionInput'] | undefined | null;
        /** Sepa Direct Debit type of payment collection */
        sepaDirectDebit?: ResolverInputTypes['SepaDirectDebitPaymentCollectionInput'] | undefined | null;
    };
    ['InitiateMerchantPaymentCollectionPayload']: AliasType<{
        InitiateMerchantPaymentCollectionSuccessPayload?: ResolverInputTypes['InitiateMerchantPaymentCollectionSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        NotFoundRejection?: ResolverInputTypes['NotFoundRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InitiateMerchantPaymentCollectionSuccessPayload']: AliasType<{
        merchantPaymentCollection?: ResolverInputTypes['Payment'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InstantFundingLimit']: AliasType<{
        /** Maximum Instant Funding Amount authorized */
        amount?: ResolverInputTypes['Amount'];
        /** Instant Funding Amount that has already been used */
        funding?: ResolverInputTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Account Holder Instant Funding limit has been exceeded */
    ['InstantFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Available balance is insufficient */
    ['InsufficientFundsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Beneficiary */
    ['InternalBeneficiary']: AliasType<{
        /** unique identifier of a beneficiary
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        id?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** `true` if this new beneficiary is the account holder himself in an other financial institution.
    *SOON TO BE DEPRECATED*
    Not used. It will be removed soon. */
        isMyOwnIban?: boolean | `@${string}`;
        /** account number if the beneficiary is a swan account */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer transaction */
    ['InternalCreditTransfer']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ResolverInputTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ResolverInputTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ResolverInputTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ResolverInputTypes['InternalCreditTransferCreditor'];
        /** debtor information */
        debtor?: ResolverInputTypes['InternalCreditTransferDebtor'];
        /** matching account for the transaction */
        account?: ResolverInputTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ResolverInputTypes['Transaction'];
        /** r-transaction reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer creditor */
    ['InternalCreditTransferCreditor']: AliasType<{
        /** full name of the Creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        ['...on InternalCreditTransferInCreditor']?: Omit<ResolverInputTypes['InternalCreditTransferInCreditor'], keyof ResolverInputTypes['InternalCreditTransferCreditor']>;
        ['...on InternalCreditTransferOutCreditor']?: Omit<ResolverInputTypes['InternalCreditTransferOutCreditor'], keyof ResolverInputTypes['InternalCreditTransferCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer debtor */
    ['InternalCreditTransferDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        ['...on InternalCreditTransferInDebtor']?: Omit<ResolverInputTypes['InternalCreditTransferInDebtor'], keyof ResolverInputTypes['InternalCreditTransferDebtor']>;
        ['...on InternalCreditTransferOutDebtor']?: Omit<ResolverInputTypes['InternalCreditTransferOutDebtor'], keyof ResolverInputTypes['InternalCreditTransferDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer creditor for Incoming transaction */
    ['InternalCreditTransferInCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer debtor for Incoming transaction */
    ['InternalCreditTransferInDebtor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer creditor for Outgoing transaction */
    ['InternalCreditTransferOutCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Credit Transfer debtor for Outgoing transaction */
    ['InternalCreditTransferOutDebtor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** InternalDirectDebitB2BMerchantPaymentMethod */
    ['InternalDirectDebitB2BMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ResolverInputTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ResolverInputTypes['RollingReserve'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalDirectDebitB2BPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined | null;
    };
    /** Internal Direct Debit Creditor */
    ['InternalDirectDebitCreditor']: AliasType<{
        /** unique identifier of the creditor account */
        accountId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal Direct Debit Debtor */
    ['InternalDirectDebitDebtor']: AliasType<{
        /** unique identifier of the debtor account */
        accountId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalDirectDebitMandate']: AliasType<{
        /** Unique identifier of the internal direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        ['...on InternalPaymentDirectDebitMandate']?: Omit<ResolverInputTypes['InternalPaymentDirectDebitMandate'], keyof ResolverInputTypes['InternalDirectDebitMandate']>;
        ['...on InternalReceivedDirectDebitMandate']?: Omit<ResolverInputTypes['InternalReceivedDirectDebitMandate'], keyof ResolverInputTypes['InternalDirectDebitMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalDirectDebitPaymentCollectionInput']: {
        /** ID of the concerned payment mandate */
        mandateId: string;
        /** Date at which the Swan merchant wishes the payment to be executed */
        requestedExecutionAt?: ResolverInputTypes['DateTime'] | undefined | null;
    };
    ['InternalDirectDebitSequence']: InternalDirectDebitSequence;
    /** InternalDirectDebitStandardMerchantPaymentMethod */
    ['InternalDirectDebitStandardMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ResolverInputTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ResolverInputTypes['RollingReserve'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalDirectDebitStandardPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined | null;
    };
    /** Internal Direct Debit transaction */
    ['InternalDirectDebitTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction: accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ResolverInputTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ResolverInputTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ResolverInputTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ResolverInputTypes['InternalDirectDebitCreditor'];
        /** debtor information */
        debtor?: ResolverInputTypes['InternalDirectDebitDebtor'];
        /** matching account for the transaction */
        account?: ResolverInputTypes['Account'];
        /** matching Internal mandate for the transaction */
        mandate?: ResolverInputTypes['InternalDirectDebitMandate'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ResolverInputTypes['Transaction'];
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: ResolverInputTypes['Amount'];
        /** date on which reserved funds become available. */
        reservedAmountReleasedAt?: boolean | `@${string}`;
        /** r-transaction reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned on unexpected server error */
    ['InternalErrorRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment direct debit mandate for Internal */
    ['InternalPaymentDirectDebitMandate']: AliasType<{
        /** Unique identifier of the Internal Direct Debit Payment Mandate */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['TransactionsOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['TransactionsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TransactionConnection']
        ];
        /** Unique reference of the Internal Direct Debit Payment Mandate */
        reference?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate scheme */
        scheme?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate status information */
        statusInfo?: ResolverInputTypes['PaymentMandateStatusInfo'];
        /** Internal Direct Debit Payment Mandate sequence */
        sequence?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate PDF document URL */
        mandateDocumentUrl?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate debtor information */
        debtor?: ResolverInputTypes['InternalPaymentMandateDebtor'];
        /** Internal direct debit ultimate creditor name */
        ultimateCreditorName?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate creditor information */
        creditor?: ResolverInputTypes['InternalPaymentMandateCreditor'];
        /** Signature date of the Internal Direct Debit Payment Mandate */
        signatureDate?: boolean | `@${string}`;
        /** Creation date of the Internal Direct Debit Payment Mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the Internal Direct Debit Payment Mandate */
        updatedAt?: boolean | `@${string}`;
        /** Date of the the last transaction executed for the concerned Internal Direct Debit Payment Mandate */
        executedAt?: boolean | `@${string}`;
        /** Expiry date of the Internal Direct Debit Payment Mandate */
        expiredAt?: boolean | `@${string}`;
        /** Account Holder information */
        accountHolder?: ResolverInputTypes['AccountHolder'];
        /** Language that will be used to produce the mandate PDF document */
        language?: boolean | `@${string}`;
        /** Custom name of the mandate */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalPaymentMandateCreditor']: AliasType<{
        /** Internal Direct Debit Payment Mandate creditor UUID */
        id?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate Creditor Idenfier */
        identifier?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate creditor name */
        name?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate creditor address */
        address?: ResolverInputTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalPaymentMandateDebtor']: AliasType<{
        /** Internal Direct Debit Payment Mandate debtor name */
        name?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate debtor e-mail */
        email?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate debtor country */
        country?: boolean | `@${string}`;
        /** Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        address?: ResolverInputTypes['Address'];
        /** Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        accountId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternalPaymentMandateScheme']: InternalPaymentMandateScheme;
    /** Internal Direct Debit Payment Mandate Sequence */
    ['InternalPaymentMandateSequence']: InternalPaymentMandateSequence;
    /** Received direct debit mandate for SEPA */
    ['InternalReceivedDirectDebitMandate']: AliasType<{
        /** Unique identifier of the received internal direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** the list of elements needs to be filtered */
                filters?: ResolverInputTypes['TransactionsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TransactionConnection']
        ];
        /** Version of the received internal direct debit mandate */
        version?: boolean | `@${string}`;
        /** Creation date of the received internal direct debit mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the received internal direct debit mandate */
        updatedAt?: boolean | `@${string}`;
        /** Received internal direct debit Unique Mandate Reference (UMR) */
        reference?: boolean | `@${string}`;
        /** Received internal direct debit mandate scheme */
        scheme?: boolean | `@${string}`;
        /** Received internal direct debit mandate sequence */
        sequence?: boolean | `@${string}`;
        /** Received internal direct debit creditor */
        creditor?: ResolverInputTypes['InternalReceivedDirectDebitMandateCreditor'];
        /** Received internal direct debit ultimate creditor name */
        ultimateCreditorName?: boolean | `@${string}`;
        /** Date of the last internal direct debit transaction executed for the concerned received internal direct debit mandate */
        executedAt?: boolean | `@${string}`;
        /** Date of signature of the received internal direct debit mandate */
        signatureDate?: boolean | `@${string}`;
        /** Expiry date of the received internal direct debit mandate, computed automatically (36 months from the executedAt date) */
        expiredAt?: boolean | `@${string}`;
        /** Mandate status information of the received internal direct debit mandate */
        statusInfo?: ResolverInputTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Account of the received internal direct debit mandate debtor */
        account?: ResolverInputTypes['Account'];
        /** Iban of the received internal direct debit mandate debtor */
        iban?: boolean | `@${string}`;
        /** Mandate name */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Internal received direct debit mandate creditor */
    ['InternalReceivedDirectDebitMandateCreditor']: AliasType<{
        /** Creditor identifier */
        identifier?: boolean | `@${string}`;
        /** Name of the creditor */
        name?: boolean | `@${string}`;
        /** Address of the creditor */
        address?: ResolverInputTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Received internal direct debit mandate scheme */
    ['InternalReceivedDirectDebitMandateScheme']: InternalReceivedDirectDebitMandateScheme;
    /** Internal received direct debit mandate sequence */
    ['InternalReceivedDirectDebitMandateSequence']: InternalReceivedDirectDebitMandateSequence;
    /** Address of an international beneficiary */
    ['InternationalAddressInput']: {
        /** Address 1 */
        address1?: string | undefined | null;
        /** City */
        city?: string | undefined | null;
        /** Country */
        country?: string | undefined | null;
        /** Zip Code */
        zipCode?: string | undefined | null;
        /** State */
        state?: string | undefined | null;
    };
    /** International Beneficiary Details */
    ['InternationalBeneficiaryDetailsInput']: {
        /** Key */
        key: string;
        /** Value */
        value: string;
    };
    /** *COMING SOON*
  International Beneficiary Dynamic Forms */
    ['InternationalBeneficiaryDynamicForms']: AliasType<{
        /** *COMING SOON*
    Schemes */
        schemes?: ResolverInputTypes['Scheme'];
        __typename?: boolean | `@${string}`;
    }>;
    /** *COMING SOON*
  International Beneficiary */
    ['InternationalBeneficiaryInput']: {
        /** Account holder name */
        name: string;
        /** Currency of the international beneficiary account */
        currency: ResolverInputTypes['Currency'];
        /** *COMING SOON*
    Currency-specific details of the beneficiary */
        details: Array<ResolverInputTypes['InternationalBeneficiaryDetailsInput']>;
        /** *COMING SOON*
    Route that Swan will use to transfer the funds */
        route: ResolverInputTypes['InternationalCreditTransferRouteInput'];
    };
    ['InternationalCreditTransferCreditor']: AliasType<{
        InternationalCreditTransferOutCreditor?: ResolverInputTypes['InternationalCreditTransferOutCreditor'];
        InternationalCreditTransferInCreditor?: ResolverInputTypes['InternationalCreditTransferInCreditor'];
        __typename?: boolean | `@${string}`;
    }>;
    /** International Currency Exchange / Quote */
    ['InternationalCreditTransferCurrencyExchange']: AliasType<{
        /** Rate of the quote */
        exchangeRate?: boolean | `@${string}`;
        /** Fees */
        feesAmount?: ResolverInputTypes['Amount'];
        /** Source amount of the quote */
        sourceAmount?: ResolverInputTypes['Amount'];
        /** target amount of the quote */
        targetAmount?: ResolverInputTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InternationalCreditTransferDebtor']: AliasType<{
        InternationalCreditTransferOutDebtor?: ResolverInputTypes['InternationalCreditTransferOutDebtor'];
        InternationalCreditTransferInDebtor?: ResolverInputTypes['InternationalCreditTransferInDebtor'];
        __typename?: boolean | `@${string}`;
    }>;
    /** International Credit Transfer - Currency-specific details of the beneficiary */
    ['InternationalCreditTransferDetails']: AliasType<{
        /** Key */
        key?: boolean | `@${string}`;
        /** Value */
        value?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** *COMING SOON*
  International Credit Transfer Details */
    ['InternationalCreditTransferDetailsInput']: {
        /** *COMING SOON*
    Key */
        key: string;
        /** *COMING SOON*
    Value */
        value: string;
    };
    /** Language: ISO 639-1 language code */
    ['InternationalCreditTransferDisplayLanguage']: InternationalCreditTransferDisplayLanguage;
    /** *COMING SOON*
  International Credit Transfer Dynamic Form */
    ['InternationalCreditTransferDynamicForm']: AliasType<{
        /** List of international transaction fields */
        fields?: ResolverInputTypes['Field'];
        /** *COMING SOON*
    Number of fields that need to be updated to fill the form completely. Please re run the query internationalCreditTransferTransactionDetailsDynamicForm with updated refreshableFields if the value of this field is not 0 */
        remainingFieldsToRefreshCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** International Credit Transfer In - Creditor info */
    ['InternationalCreditTransferInCreditor']: AliasType<{
        /** Account holder name */
        name?: boolean | `@${string}`;
        /** Bank Identifier Code */
        BIC?: boolean | `@${string}`;
        /** International Bank Account Number
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        IBAN?: boolean | `@${string}`;
        /** maskedIBAN if the beneficiary is a an account in an other financial institution */
        maskedIBAN?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternationalCreditTransferInDebtor']: AliasType<{
        /** Account holder name */
        name?: boolean | `@${string}`;
        /** Account Number */
        accountNumber?: boolean | `@${string}`;
        /** BIC */
        bic?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** International Credit Transfer Out - Creditor info */
    ['InternationalCreditTransferOutCreditor']: AliasType<{
        /** Currency of the international beneficiary account */
        currency?: boolean | `@${string}`;
        /** Currency-specific details of the beneficiary */
        details?: ResolverInputTypes['InternationalCreditTransferDetails'];
        /** Account holder name */
        name?: boolean | `@${string}`;
        /** Route that Swan will use to transfer the funds */
        route?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['InternationalCreditTransferOutDebtor']: AliasType<{
        /** Account holder name */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** *COMING SOON*
  International Quote */
    ['InternationalCreditTransferQuote']: AliasType<{
        /** Rate of the quote */
        exchangeRate?: boolean | `@${string}`;
        /** Source amount of the quote */
        sourceAmount?: ResolverInputTypes['Amount'];
        /** target amount of the quote */
        targetAmount?: ResolverInputTypes['Amount'];
        /** Fees */
        feesAmount?: ResolverInputTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** International Credit Transfer Route */
    ['InternationalCreditTransferRoute']: InternationalCreditTransferRoute;
    /** International Credit Transfer Route */
    ['InternationalCreditTransferRouteInput']: InternationalCreditTransferRouteInput;
    ['InternationalCreditTransferTransaction']: AliasType<{
        /** matching account for this transaction */
        account?: ResolverInputTypes['Account'];
        /** amount */
        amount?: ResolverInputTypes['Amount'];
        /** booked balance after this transaction */
        bookedBalanceAfter?: ResolverInputTypes['Amount'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ResolverInputTypes['InternationalCreditTransferCreditor'];
        /** debtor information */
        debtor?: ResolverInputTypes['InternationalCreditTransferDebtor'];
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** @deprecated(reason: "use `quote.feesAmount` instead") */
        fees?: ResolverInputTypes['Amount'];
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** instructed amount */
        instructedAmount?: ResolverInputTypes['Amount'];
        /** instructed amount */
        intermediaryBankFees?: ResolverInputTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ResolverInputTypes['Transaction'];
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ResolverInputTypes['Payment'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** quote given by our international provider */
        currencyExchange?: ResolverInputTypes['InternationalCreditTransferCurrencyExchange'];
        /** external identifier of the transaction */
        reference?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** return reason */
        returnReason?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TransactionStatusInfo'];
        /** type */
        type?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned on invalid argument error */
    ['InvalidArgumentRejection']: AliasType<{
        message?: boolean | `@${string}`;
        code?: boolean | `@${string}`;
        fields?: ResolverInputTypes['InvalidArgumentRejectionField'];
        __typename?: boolean | `@${string}`;
    }>;
    ['InvalidArgumentRejectionCode']: InvalidArgumentRejectionCode;
    ['InvalidArgumentRejectionField']: AliasType<{
        name?: boolean | `@${string}`;
        errors?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** InvalidVerification */
    ['InvalidBeneficiaryVerification']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Information about the invalidity of the IBAN */
    ['InvalidIban']: AliasType<{
        /** Iban from input */
        iban?: boolean | `@${string}`;
        /** Enum that can be used to discriminate on the error */
        code?: boolean | `@${string}`;
        /** Message that give a bit of context during development */
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** InvalidIbanCode */
    ['InvalidIbanCode']: InvalidIbanCode;
    /** Describes an invalid identification level for the process associated to this identification, and the invalid reason can be accessed */
    ['InvalidIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Invalid` */
        status?: boolean | `@${string}`;
        /** The reasons why this identification level is invalid */
        reasons?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if phone number is not well formatted */
    ['InvalidPhoneNumberRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if siren number is not well formatted */
    ['InvalidSirenNumberRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Invoice */
    ['Invoice']: AliasType<{
        /** unique id */
        id?: boolean | `@${string}`;
        /** account id */
        accountId?: boolean | `@${string}`;
        /** name of the invoice */
        name?: boolean | `@${string}`;
        /** type of the invoice */
        type?: boolean | `@${string}`;
        /** status of the invoice */
        status?: boolean | `@${string}`;
        /** due amount */
        amount?: ResolverInputTypes['Amount'];
        /** temporary public url on which the file can be accessible */
        url?: boolean | `@${string}`;
        /** date at which the link will not be useable anymore */
        expiresAt?: boolean | `@${string}`;
        /** starting date of the billing window */
        openingDate?: boolean | `@${string}`;
        /** ending date of the billing window */
        closingDate?: boolean | `@${string}`;
        /** creation date */
        createdAt?: boolean | `@${string}`;
        /** last update date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['InvoiceConnection']: AliasType<{
        pageInfo?: ResolverInputTypes['PageInfo'];
        totalCount?: boolean | `@${string}`;
        edges?: ResolverInputTypes['InvoiceEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Edge interface */
    ['InvoiceEdge']: AliasType<{
        node?: ResolverInputTypes['Invoice'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The different statuses of invoice */
    ['InvoiceStatus']: InvoiceStatus;
    ['InvoiceType']: InvoiceType;
    /** Key value details */
    ['KeyValue']: AliasType<{
        /** Key */
        key?: boolean | `@${string}`;
        /** Value */
        value?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['Language']: Language;
    ['LegalDocument']: AliasType<{
        /** ID of the legal document */
        id?: boolean | `@${string}`;
        /** Type of the legal document */
        type?: boolean | `@${string}`;
        /** Status of the Legal Document */
        statusInfo?: ResolverInputTypes['LegalDocumentStatusInfo'];
        /** Language of the Legal Document */
        language?: boolean | `@${string}`;
        /** Url to download the Document */
        url?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentActiveStatusInfo']: AliasType<{
        /** LegalDocument status (always Active for type LegalDocumentActiveStatusInfo) */
        status?: boolean | `@${string}`;
        /** Creation date */
        createdAt?: boolean | `@${string}`;
        /** Activation date */
        activatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** LegalDocumentEdge list */
        edges?: ResolverInputTypes['LegalDocumentEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The account membership */
        node?: ResolverInputTypes['LegalDocument'];
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentInactiveStatusInfo']: AliasType<{
        /** LegalDocument status (always Inactive for type LegalDocumentInactiveStatusInfo) */
        status?: boolean | `@${string}`;
        /** Creation date */
        createdAt?: boolean | `@${string}`;
        /** Activation date */
        activatedAt?: boolean | `@${string}`;
        /** Deactivation date */
        deactivatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentsFilterInput']: {
        status?: ResolverInputTypes['LegalDocumentStatus'] | undefined | null;
        type?: ResolverInputTypes['LegalDocumentType'] | undefined | null;
    };
    ['LegalDocumentStatus']: LegalDocumentStatus;
    ['LegalDocumentStatusInfo']: AliasType<{
        /** LegalDocument Status */
        status?: boolean | `@${string}`;
        ['...on LegalDocumentActiveStatusInfo']?: Omit<ResolverInputTypes['LegalDocumentActiveStatusInfo'], keyof ResolverInputTypes['LegalDocumentStatusInfo']>;
        ['...on LegalDocumentInactiveStatusInfo']?: Omit<ResolverInputTypes['LegalDocumentInactiveStatusInfo'], keyof ResolverInputTypes['LegalDocumentStatusInfo']>;
        ['...on LegalDocumentUpcomingStatusInfo']?: Omit<ResolverInputTypes['LegalDocumentUpcomingStatusInfo'], keyof ResolverInputTypes['LegalDocumentStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalDocumentType']: LegalDocumentType;
    ['LegalDocumentUpcomingStatusInfo']: AliasType<{
        /** LegalDocument status (always Upcoming for type LegalDocumentUpcomingStatusInfo) */
        status?: boolean | `@${string}`;
        /** Creation date */
        createdAt?: boolean | `@${string}`;
        /** Date when the LegalDocument will be activated */
        effectiveDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalRepresentativeAccountMembershipCannotBeDisabledRejection']: AliasType<{
        accountMembershipId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Language: ISO 639-1 language code */
    ['MandateLanguage']: MandateLanguage;
    ['MembershipInfoInput']: {
        /** Email address */
        email: string;
        /** Restricted to a user if necessary */
        restrictedTo: ResolverInputTypes['RestrictedToInput'];
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean;
        /** `true` if this account membership can invite, update, suspend or resume account membership */
        canManageAccountMembership: boolean;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null;
        /** Residency address of the member to be added */
        residencyAddress?: ResolverInputTypes['ResidencyAddressInput'] | undefined | null;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined | null;
    };
    /** Filters that can be applied when listing accounts (Only applied in user context) */
    ['MembershipsFilterInput']: {
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null;
        /** Can the user initiate payments on this account */
        canInitiatePayments?: boolean | undefined | null;
        /** Can the user manage account membership */
        canManageAccountMembership?: boolean | undefined | null;
        /** Can the user manage beneficiaries */
        canManageBeneficiaries?: boolean | undefined | null;
        /** Can the user view account */
        canViewAccount?: boolean | undefined | null;
        /** Account memberships status/statuses we're looking for */
        status?: Array<ResolverInputTypes['AccountMembershipStatus']> | undefined | null;
        /** Filtered by email */
        email?: string | undefined | null;
        /** Filtered by first name */
        firstName?: string | undefined | null;
        /** Filtered by last name */
        lastName?: string | undefined | null;
        /** Searches email, first name, last name, and id */
        search?: string | undefined | null;
    };
    /** MerchantCategoryDescription */
    ['MerchantCategoryDescription']: MerchantCategoryDescription;
    ['MerchantPaymentLink']: AliasType<{
        /** Merchant payment link's unique ID. */
        id?: boolean | `@${string}`;
        /** ID of the related project */
        projectId?: boolean | `@${string}`;
        /** The URL at which the customer can complete the payment. */
        url?: boolean | `@${string}`;
        /** The merchant payment link status. */
        statusInfo?: ResolverInputTypes['MerchantPaymentLinkStatusInfo'];
        /** The Merchant Profile to link this Payment Link to */
        merchantProfile?: ResolverInputTypes['MerchantProfile'];
        /** Amount to be paid to sucessfully complete the payment. */
        amount?: ResolverInputTypes['Amount'];
        /** Merchant Website URL to redirect the user to when the payment is completed. */
        redirectUrl?: boolean | `@${string}`;
        /** URL to redirect the user to if they cancel their payment */
        cancelRedirectUrl?: boolean | `@${string}`;
        /** Controls if the payment mandate created from this payment link is for one-time use or can be reused
    This is applicable for card and SEPA Direct Debit payment methods only. */
        sequence?: boolean | `@${string}`;
        /** The customer billing Address
    These fields should be completed also to pre-fill a SEPA direct debit mandate.
    
    We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes */
        billingAddress?: ResolverInputTypes['Address'];
        /**   A date that reflects the time at which the user asked the transaction to be executed.
    For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
    For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
    
    Default value means that the execution will be as soon as possible */
        requestedExecutionAt?: boolean | `@${string}`;
        /** Any string that you want to be attached to this payment link.
    Usually something to help you reference the link in an external system. */
        externalReference?: boolean | `@${string}`;
        /** Optional field intended to provide a way for you to include a reference number or code.
    The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different. */
        reference?: boolean | `@${string}`;
        /** The language used for the payment page.
    Default is the browser's language, or English if not available. */
        language?: boolean | `@${string}`;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page. */
        label?: boolean | `@${string}`;
        /**  We will use the information specified here to prefill the payment link fields
    depending on the payment method the end user chooses.
    Keep in mind that your end customer will be able to edit these fields. */
        customer?: ResolverInputTypes['Customer'];
        /** List of payment methods IDs enabled for this payment link.
    If the array is empty Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit) */
        paymentMethods?: ResolverInputTypes['MerchantPaymentMethod'];
        __typename?: boolean | `@${string}`;
    }>;
    ['MerchantPaymentLinkStatus']: MerchantPaymentLinkStatus;
    ['MerchantPaymentLinkStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        ['...on ActiveMerchantPaymentLinkStatusInfo']?: Omit<ResolverInputTypes['ActiveMerchantPaymentLinkStatusInfo'], keyof ResolverInputTypes['MerchantPaymentLinkStatusInfo']>;
        ['...on CompletedMerchantPaymentLinkStatusInfo']?: Omit<ResolverInputTypes['CompletedMerchantPaymentLinkStatusInfo'], keyof ResolverInputTypes['MerchantPaymentLinkStatusInfo']>;
        ['...on ExpiredMerchantPaymentLinkStatusInfo']?: Omit<ResolverInputTypes['ExpiredMerchantPaymentLinkStatusInfo'], keyof ResolverInputTypes['MerchantPaymentLinkStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Base object for the different Payment Methods available */
    ['MerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ResolverInputTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ResolverInputTypes['RollingReserve'];
        ['...on CardMerchantPaymentMethod']?: Omit<ResolverInputTypes['CardMerchantPaymentMethod'], keyof ResolverInputTypes['MerchantPaymentMethod']>;
        ['...on CheckMerchantPaymentMethod']?: Omit<ResolverInputTypes['CheckMerchantPaymentMethod'], keyof ResolverInputTypes['MerchantPaymentMethod']>;
        ['...on InternalDirectDebitB2BMerchantPaymentMethod']?: Omit<ResolverInputTypes['InternalDirectDebitB2BMerchantPaymentMethod'], keyof ResolverInputTypes['MerchantPaymentMethod']>;
        ['...on InternalDirectDebitStandardMerchantPaymentMethod']?: Omit<ResolverInputTypes['InternalDirectDebitStandardMerchantPaymentMethod'], keyof ResolverInputTypes['MerchantPaymentMethod']>;
        ['...on SepaDirectDebitB2BMerchantPaymentMethod']?: Omit<ResolverInputTypes['SepaDirectDebitB2BMerchantPaymentMethod'], keyof ResolverInputTypes['MerchantPaymentMethod']>;
        ['...on SepaDirectDebitCoreMerchantPaymentMethod']?: Omit<ResolverInputTypes['SepaDirectDebitCoreMerchantPaymentMethod'], keyof ResolverInputTypes['MerchantPaymentMethod']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Merchant Payment Method is not active */
    ['MerchantPaymentMethodNotActiveRejection']: AliasType<{
        paymentMethodIds?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The different statuses a MerchantPaymentMethod can have */
    ['MerchantPaymentMethodStatus']: MerchantPaymentMethodStatus;
    /** The payment method status information */
    ['MerchantPaymentMethodStatusInfo']: AliasType<{
        /** Merchant Payment Method Status */
        status?: boolean | `@${string}`;
        ['...on CanceledMerchantPaymentMethodStatusInfo']?: Omit<ResolverInputTypes['CanceledMerchantPaymentMethodStatusInfo'], keyof ResolverInputTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on DisabledMerchantPaymentMethodStatusInfo']?: Omit<ResolverInputTypes['DisabledMerchantPaymentMethodStatusInfo'], keyof ResolverInputTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on EnabledMerchantPaymentMethodStatusInfo']?: Omit<ResolverInputTypes['EnabledMerchantPaymentMethodStatusInfo'], keyof ResolverInputTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on PendingMerchantPaymentMethodStatusInfo']?: Omit<ResolverInputTypes['PendingMerchantPaymentMethodStatusInfo'], keyof ResolverInputTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on RejectedMerchantPaymentMethodStatusInfo']?: Omit<ResolverInputTypes['RejectedMerchantPaymentMethodStatusInfo'], keyof ResolverInputTypes['MerchantPaymentMethodStatusInfo']>;
        ['...on SuspendedMerchantPaymentMethodStatusInfo']?: Omit<ResolverInputTypes['SuspendedMerchantPaymentMethodStatusInfo'], keyof ResolverInputTypes['MerchantPaymentMethodStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** The different statuses a MerchantPaymentMethod can have */
    ['MerchantPaymentMethodType']: MerchantPaymentMethodType;
    /** Merchant Profile */
    ['MerchantProfile']: AliasType<{
        /** The Merchant Profile ID */
        id?: boolean | `@${string}`;
        /** The Account ID this Merchant Profile is linked to */
        accountId?: boolean | `@${string}`;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName?: boolean | `@${string}`;
        /** Url of the merchant's website */
        merchantWebsite?: boolean | `@${string}`;
        /** Url of the merchant's logo */
        merchantLogoUrl?: boolean | `@${string}`;
        /** The status of the merchant profile */
        statusInfo?: ResolverInputTypes['MerchantProfileStatusInfo'];
        /** Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType?: boolean | `@${string}`;
        /** Expected annual activity volumes for all payment method */
        expectedMonthlyPaymentVolume?: ResolverInputTypes['Amount'];
        /** Payment Methods associated */
        merchantPaymentMethods?: ResolverInputTypes['MerchantPaymentMethod'];
        /** Updates Requested associated */
        requestedMerchantProfileUpdates?: ResolverInputTypes['RequestMerchantProfileUpdate'];
        /** expected average basket value. */
        expectedAverageBasket?: ResolverInputTypes['Amount'];
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page. */
        accentColor?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['MerchantProfileConnection']: AliasType<{
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** Edge list */
        edges?: ResolverInputTypes['MerchantProfileEdge'];
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['MerchantProfileEdge']: AliasType<{
        node?: ResolverInputTypes['MerchantProfile'];
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing Funding Sources */
    ['MerchantProfileFiltersInput']: {
        status: Array<ResolverInputTypes['MerchantProfileStatus']>;
    };
    ['MerchantProfileOrderByFieldInput']: MerchantProfileOrderByFieldInput;
    ['MerchantProfileOrderByInput']: {
        field?: ResolverInputTypes['MerchantProfileOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Merchant Profile Statuses */
    ['MerchantProfileStatus']: MerchantProfileStatus;
    /** Merchant Profile Status Information */
    ['MerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        ['...on CanceledMerchantProfileStatusInfo']?: Omit<ResolverInputTypes['CanceledMerchantProfileStatusInfo'], keyof ResolverInputTypes['MerchantProfileStatusInfo']>;
        ['...on EnabledMerchantProfileStatusInfo']?: Omit<ResolverInputTypes['EnabledMerchantProfileStatusInfo'], keyof ResolverInputTypes['MerchantProfileStatusInfo']>;
        ['...on PendingReviewMerchantProfileStatusInfo']?: Omit<ResolverInputTypes['PendingReviewMerchantProfileStatusInfo'], keyof ResolverInputTypes['MerchantProfileStatusInfo']>;
        ['...on RejectedMerchantProfileStatusInfo']?: Omit<ResolverInputTypes['RejectedMerchantProfileStatusInfo'], keyof ResolverInputTypes['MerchantProfileStatusInfo']>;
        ['...on SuspendedMerchantProfileStatusInfo']?: Omit<ResolverInputTypes['SuspendedMerchantProfileStatusInfo'], keyof ResolverInputTypes['MerchantProfileStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Merchant Profile is not in the expected status */
    ['MerchantProfileWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        expectedStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when mandatory fields are missing from the call. */
    ['MissingMandatoryFieldRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Monthly income. */
    ['MonthlyIncome']: MonthlyIncome;
    /** Monthly payment volume. */
    ['MonthlyPaymentVolume']: MonthlyPaymentVolume;
    ['Mutation']: AliasType<{
        activatePhysicalCard?: [
            {
                input: ResolverInputTypes['ActivatePhysicalCardInput'];
            },
            ResolverInputTypes['ActivatePhysicalCardPayload']
        ];
        addAccountMembership?: [
            {
                input: ResolverInputTypes['AddAccountMembershipInput'];
            },
            ResolverInputTypes['AddAccountMembershipPayload']
        ];
        addAccountMemberships?: [
            {
                input: ResolverInputTypes['AddAccountMembershipsInput'];
            },
            ResolverInputTypes['AddAccountMembershipsPayload']
        ];
        addCard?: [{
            input: ResolverInputTypes['AddCardInput'];
        }, ResolverInputTypes['AddCardPayload']];
        addCardsWithGroupDelivery?: [
            {
                input: ResolverInputTypes['AddCardsWithGroupDeliveryInput'];
            },
            ResolverInputTypes['AddCardsWithGroupDeliveryPayload']
        ];
        addCards?: [
            {
                input: ResolverInputTypes['AddCardsInput'];
            },
            ResolverInputTypes['AddCardsPayload']
        ];
        addDigitalCard?: [
            {
                input?: ResolverInputTypes['AddDigitalCardInput'] | undefined | null;
            },
            ResolverInputTypes['AddDigitalCardPayload']
        ];
        addExternalAccountBalance?: [
            {
                input: ResolverInputTypes['AddExternalAccountBalanceInput'];
            },
            ResolverInputTypes['AddExternalAccountBalancePayload']
        ];
        addExternalAccount?: [
            {
                input: ResolverInputTypes['AddExternalAccountInput'];
            },
            ResolverInputTypes['AddExternalAccountPayload']
        ];
        addFundingLimitSettingsChangeRequest?: [
            {
                input: ResolverInputTypes['AddFundingLimitSettingsChangeRequestInput'];
            },
            ResolverInputTypes['AddFundingLimitSettingsChangeRequestPayload']
        ];
        addOrUpdateExternalAccountBalance?: [
            {
                input: ResolverInputTypes['AddOrUpdateExternalAccountBalanceInput'];
            },
            ResolverInputTypes['AddOrUpdateExternalAccountBalancePayload']
        ];
        addSingleUseVirtualCard?: [
            {
                input: ResolverInputTypes['AddSingleUseVirtualCardInput'];
            },
            ResolverInputTypes['AddSingleUseVirtualCardPayload']
        ];
        addSingleUseVirtualCards?: [
            {
                input: ResolverInputTypes['AddSingleUseVirtualCardsInput'];
            },
            ResolverInputTypes['AddSingleUseVirtualCardsPayload']
        ];
        addVirtualIbanEntry?: [
            {
                input?: ResolverInputTypes['AddVirtualIbanInput'] | undefined | null;
            },
            ResolverInputTypes['AddVirtualIbanEntryPayload']
        ];
        allowSddVirtualIbanEntry?: [
            {
                input: ResolverInputTypes['AllowSddVirtualIbanEntryInput'];
            },
            ResolverInputTypes['AllowSddVirtualIbanEntryPayload']
        ];
        allowSdd?: [
            {
                input: ResolverInputTypes['AllowSddInput'];
            },
            ResolverInputTypes['AllowSddPayload']
        ];
        bindAccountMembership?: [
            {
                input: ResolverInputTypes['BindAccountMembershipInput'];
            },
            ResolverInputTypes['BindAccountMembershipPayload']
        ];
        cancelCard?: [
            {
                input?: ResolverInputTypes['CancelCardInput'] | undefined | null;
            },
            ResolverInputTypes['CancelCardPayload']
        ];
        cancelDigitalCard?: [
            {
                input?: ResolverInputTypes['CancelDigitalCardInput'] | undefined | null;
            },
            ResolverInputTypes['CancelDigitalCardPayload']
        ];
        cancelPhysicalCard?: [
            {
                input?: ResolverInputTypes['CancelPhysicalCardInput'] | undefined | null;
            },
            ResolverInputTypes['CancelPhysicalCardPayload']
        ];
        cancelVirtualIbanEntry?: [
            {
                input: ResolverInputTypes['CancelVirtualIbanEntryInput'];
            },
            ResolverInputTypes['CancelVirtualIbanEntryPayload']
        ];
        closeAccount?: [
            {
                input: ResolverInputTypes['CloseAccountInput'];
            },
            ResolverInputTypes['CloseAccountPayload']
        ];
        confirmPhysicalCardRenewal?: [
            {
                input: ResolverInputTypes['ConfirmPhysicalCardRenewalInput'];
            },
            ResolverInputTypes['ConfirmPhysicalCardRenewalPayload']
        ];
        deleteSupportingDocument?: [
            {
                input: ResolverInputTypes['DeleteSupportingDocumentInput'];
            },
            ResolverInputTypes['DeleteSupportingDocumentPayload']
        ];
        denySddVirtualIbanEntry?: [
            {
                input: ResolverInputTypes['DenySddVirtualIbanEntryInput'];
            },
            ResolverInputTypes['DenySddVirtualIbanEntryPayload']
        ];
        denySdd?: [
            {
                input?: ResolverInputTypes['DenySddInput'] | undefined | null;
            },
            ResolverInputTypes['DenySddPayload']
        ];
        disableAccountMembership?: [
            {
                input?: ResolverInputTypes['DisableAccountMembershipInput'] | undefined | null;
            },
            ResolverInputTypes['DisableAccountMembershipPayload']
        ];
        finalizeOnboarding?: [
            {
                input: ResolverInputTypes['FinalizeOnboardingInput'];
            },
            ResolverInputTypes['FinalizeOnboardingPayload']
        ];
        onboardCompanyAccountHolder?: [
            {
                input?: ResolverInputTypes['OnboardCompanyAccountHolderInput'] | undefined | null;
            },
            ResolverInputTypes['OnboardCompanyAccountHolderPayload']
        ];
        onboardIndividualAccountHolder?: [
            {
                input?: ResolverInputTypes['OnboardIndividualAccountHolderInput'] | undefined | null;
            },
            ResolverInputTypes['OnboardIndividualAccountHolderPayload']
        ];
        printPhysicalCard?: [
            {
                input: ResolverInputTypes['PrintPhysicalCardInput'];
            },
            ResolverInputTypes['PrintPhysicalCardPayload']
        ];
        resumeAccountMembership?: [
            {
                input?: ResolverInputTypes['ResumeAccountMembershipInput'] | undefined | null;
            },
            ResolverInputTypes['ResumeAccountMembershipPayload']
        ];
        resumePhysicalCard?: [
            {
                input?: ResolverInputTypes['ResumePhysicalCardInput'] | undefined | null;
            },
            ResolverInputTypes['ResumePhysicalCardPayload']
        ];
        suspendAccountMembership?: [
            {
                input: ResolverInputTypes['SuspendAccountMembershipInput'];
            },
            ResolverInputTypes['SuspendAccountMembershipPayload']
        ];
        suspendPhysicalCard?: [
            {
                input?: ResolverInputTypes['SuspendPhysicalCardInput'] | undefined | null;
            },
            ResolverInputTypes['SuspendPhysicalCardPayload']
        ];
        updateAccountHolder?: [
            {
                input: ResolverInputTypes['UpdateAccountHolderInput'];
            },
            ResolverInputTypes['UpdateAccountHolderPayload']
        ];
        updateAccountMembership?: [
            {
                input: ResolverInputTypes['UpdateAccountMembershipInput'];
            },
            ResolverInputTypes['UpdateAccountMembershipPayload']
        ];
        updateAccount?: [
            {
                input: ResolverInputTypes['UpdateAccountInput'];
            },
            ResolverInputTypes['UpdateAccountPayload']
        ];
        updateCard?: [
            {
                input?: ResolverInputTypes['UpdateCardInput'] | undefined | null;
            },
            ResolverInputTypes['UpdateCardPayload']
        ];
        updateCompanyOnboarding?: [
            {
                input?: ResolverInputTypes['UpdateCompanyOnboardingInput'] | undefined | null;
            },
            ResolverInputTypes['UpdateCompanyOnboardingPayload']
        ];
        updateIndividualOnboarding?: [
            {
                input: ResolverInputTypes['UpdateIndividualOnboardingInput'];
            },
            ResolverInputTypes['UpdateIndividualOnboardingPayload']
        ];
        updateSupportingDocument?: [
            {
                input: ResolverInputTypes['UpdateSupportingDocumentInput'];
            },
            ResolverInputTypes['UpdateSupportingDocumentPayload']
        ];
        viewCardNumbers?: [
            {
                input: ResolverInputTypes['ViewCardNumbersInput'];
            },
            ResolverInputTypes['ViewCardNumbersPayload']
        ];
        viewPhysicalCardNumbers?: [
            {
                input: ResolverInputTypes['ViewPhysicalCardNumbersInput'];
            },
            ResolverInputTypes['ViewPhysicalCardNumbersPayload']
        ];
        viewPhysicalCardPin?: [
            {
                input: ResolverInputTypes['ViewPhysicalCardPinInput'];
            },
            ResolverInputTypes['ViewPhysicalCardPinPayload']
        ];
        generateSupportingDocumentUploadUrl?: [
            {
                input: ResolverInputTypes['GenerateSupportingDocumentUploadUrlInput'];
            },
            ResolverInputTypes['GenerateSupportingDocumentUploadUrlPayload']
        ];
        requestSupportingDocumentCollectionReview?: [
            {
                input?: ResolverInputTypes['RequestSupportingDocumentCollectionReviewInput'] | undefined | null;
            },
            ResolverInputTypes['RequestSupportingDocumentCollectionReviewPayload']
        ];
        generateAccountStatement?: [
            {
                input: ResolverInputTypes['GenerateAccountStatementInput'];
            },
            ResolverInputTypes['Statement']
        ];
        createCapitalDepositCase?: [
            {
                input: ResolverInputTypes['CreateCapitalDepositCaseInput'];
            },
            ResolverInputTypes['CreateCapitalDepositCasePayload']
        ];
        generateCapitalDepositDocumentUploadUrl?: [
            {
                input: ResolverInputTypes['GenerateCapitalDepositDocumentUploadUrlInput'];
            },
            ResolverInputTypes['GenerateCapitalDepositDocumentUploadUrlPayload']
        ];
        cancelConsent?: [
            {
                input: ResolverInputTypes['CancelConsentInput'];
            },
            ResolverInputTypes['CancelConsentPayload']
        ];
        createMultiConsent?: [
            {
                input: ResolverInputTypes['CreateMultiConsentInput'];
            },
            ResolverInputTypes['CreateMultiConsentPayload']
        ];
        grantConsentWithServerSignature?: [
            {
                input: ResolverInputTypes['GrantConsentWithServerSignatureInput'];
            },
            ResolverInputTypes['GrantConsentWithServerSignaturePayload']
        ];
        updateUserConsentSettings?: [
            {
                input: ResolverInputTypes['UpdateUserConsentSettingsInput'];
            },
            ResolverInputTypes['UpdateUserConsentSettingsPayload']
        ];
        addReceivedInternalDirectDebitB2bMandate?: [
            {
                input: ResolverInputTypes['AddReceivedInternalDirectDebitB2bMandateInput'];
            },
            ResolverInputTypes['AddReceivedInternalDirectDebitB2bMandatePayload']
        ];
        addReceivedSepaDirectDebitB2bMandate?: [
            {
                input: ResolverInputTypes['AddReceivedSepaDirectDebitB2bMandateInput'];
            },
            ResolverInputTypes['AddReceivedSepaDirectDebitB2bMandatePayload']
        ];
        enableReceivedDirectDebitMandate?: [
            {
                input: ResolverInputTypes['EnableReceivedDirectDebitMandateInput'];
            },
            ResolverInputTypes['EnableReceivedDirectDebitMandatePayload']
        ];
        suspendReceivedDirectDebitMandate?: [
            {
                input: ResolverInputTypes['SuspendReceivedDirectDebitMandateInput'];
            },
            ResolverInputTypes['SuspendReceivedDirectDebitMandatePayload']
        ];
        updateReceivedSepaDirectDebitB2bMandate?: [
            {
                input: ResolverInputTypes['UpdateReceivedSepaDirectDebitB2bMandateInput'];
            },
            ResolverInputTypes['UpdateReceivedSepaDirectDebitB2bMandatePayload']
        ];
        addInternalDirectDebitPaymentMandate?: [
            {
                input: ResolverInputTypes['AddInternalDirectDebitPaymentMandateInput'];
            },
            ResolverInputTypes['AddInternalDirectDebitPaymentMandatePayload']
        ];
        addMerchantProfile?: [
            {
                input: ResolverInputTypes['AddMerchantProfileInput'];
            },
            ResolverInputTypes['AddMerchantProfilePayload']
        ];
        addSepaDirectDebitPaymentMandate?: [
            {
                input: ResolverInputTypes['AddSepaDirectDebitPaymentMandateInput'];
            },
            ResolverInputTypes['AddSepaDirectDebitPaymentMandatePayload']
        ];
        initiateCheckMerchantPayment?: [
            {
                input: ResolverInputTypes['InitiateCheckMerchantPaymentInput'];
            },
            ResolverInputTypes['InitiateCheckMerchantPaymentPayload']
        ];
        createMerchantPaymentLink?: [
            {
                input: ResolverInputTypes['CreateMerchantPaymentLinkInput'];
            },
            ResolverInputTypes['CreateMerchantPaymentLinkPayload']
        ];
        initiateMerchantPaymentCollection?: [
            {
                input: ResolverInputTypes['InitiateMerchantPaymentCollectionInput'];
            },
            ResolverInputTypes['InitiateMerchantPaymentCollectionPayload']
        ];
        requestMerchantPaymentMethods?: [
            {
                input: ResolverInputTypes['RequestMerchantPaymentMethodsInput'];
            },
            ResolverInputTypes['RequestMerchantPaymentMethodsPayload']
        ];
        requestMerchantProfileUpdate?: [
            {
                input: ResolverInputTypes['RequestMerchantProfileUpdateInput'];
            },
            ResolverInputTypes['RequestMerchantProfileUpdatePayload']
        ];
        cancelTransaction?: [
            {
                input: ResolverInputTypes['CancelTransactionInput'];
            },
            ResolverInputTypes['CancelTransactionPayload']
        ];
        initiateCreditTransfers?: [
            {
                input: ResolverInputTypes['InitiateCreditTransfersInput'];
            },
            ResolverInputTypes['InitiateCreditTransfersPayload']
        ];
        refund?: [{
            input: ResolverInputTypes['RefundInput'];
        }, ResolverInputTypes['RefundPayload']];
        addDirectDebitFundingSource?: [
            {
                input: ResolverInputTypes['AddDirectDebitFundingSourceInput'];
            },
            ResolverInputTypes['AddDirectDebitFundingSourcePayload']
        ];
        cancelFundingSource?: [
            {
                input: ResolverInputTypes['CancelFundingSourceInput'];
            },
            ResolverInputTypes['CancelFundingSourcePayload']
        ];
        cancelStandingOrder?: [
            {
                input: ResolverInputTypes['CancelStandingOrderInput'];
            },
            ResolverInputTypes['CancelStandingOrderPayload']
        ];
        initiateFundingRequest?: [
            {
                input: ResolverInputTypes['InitiateFundingRequestInput'];
            },
            ResolverInputTypes['InitiateFundingRequestPayload']
        ];
        initiateInternationalCreditTransfer?: [
            {
                input: ResolverInputTypes['InitiateInternationalCreditTransferInput'];
            },
            ResolverInputTypes['InitiateInternationalCreditTransferResponsePayload']
        ];
        scheduleStandingOrder?: [
            {
                input: ResolverInputTypes['ScheduleStandingOrderInput'];
            },
            ResolverInputTypes['ScheduleStandingOrderPayload']
        ];
        replayWebhookEvent?: [
            {
                input: ResolverInputTypes['ReplayWebhookEventInput'];
            },
            ResolverInputTypes['ReplayWebhookEventPayload']
        ];
        addWebhookSubscription?: [
            {
                input: ResolverInputTypes['AddWebhookSubscriptionInput'];
            },
            ResolverInputTypes['WebhookSubscriptionPayload']
        ];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the entity was not found or if the user does not have the rights to know that the account exists */
    ['NotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when consent status couldn't change */
    ['NotReachableConsentStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        unreachableStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level that hasn't started for the process of the current identification */
    ['NotStartedIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `NotStarted` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the queried service doesn't support the country code */
    ['NotSupportedCountryRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level that's not supported for the process of the current identification */
    ['NotSupportedIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `NotSupported` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Extra parameters provided by partner */
    ['OAuthRedirectParameters']: AliasType<{
        /** Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. */
        state?: boolean | `@${string}`;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['OAuthRedirectParametersInput']: {
        /** Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. Length must be from 0 to 255 characters */
        state?: string | undefined | null;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined | null;
    };
    /** Inputs to onboard a new company account holder */
    ['OnboardCompanyAccountHolderInput']: {
        /** Account name of the company account holder.
    Length must be from 0 to 100 characters */
        accountName?: string | undefined | null;
        /** Name of the company. Length must be from 0 to 255 characters */
        name?: string | undefined | null;
        /** Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters */
        registrationNumber?: string | undefined | null;
        /** Type of the company (Association ...) */
        companyType?: ResolverInputTypes['CompanyType'] | undefined | null;
        /** Business activity */
        businessActivity?: ResolverInputTypes['BusinessActivity'] | undefined | null;
        /** Business activity description. Length must be from 0 to 1024 characters */
        businessActivityDescription?: string | undefined | null;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ResolverInputTypes['AccountCountry'] | undefined | null;
        /** Estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: ResolverInputTypes['MonthlyPaymentVolume'] | undefined | null;
        /** The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
    
    The ultimate beneficial owner is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<ResolverInputTypes['IndividualUltimateBeneficialOwnerInput']> | undefined | null;
        /** Residency address of the head office (Must be in a European country) */
        residencyAddress?: ResolverInputTypes['ResidencyAddressInput'] | undefined | null;
        /** Email of the legal representative. Length must be from 0 to 255 characters */
        email?: string | undefined | null;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined | null;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
    Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined | null;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined | null;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ResolverInputTypes['OAuthRedirectParametersInput'] | undefined | null;
        /** VAT number */
        vatNumber?: string | undefined | null;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined | null;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ResolverInputTypes['AddressInformationInput'] | undefined | null;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: ResolverInputTypes['TypeOfRepresentation'] | undefined | null;
    };
    ['OnboardCompanyAccountHolderPayload']: AliasType<{
        OnboardCompanyAccountHolderSuccessPayload?: ResolverInputTypes['OnboardCompanyAccountHolderSuccessPayload'];
        BadRequestRejection?: ResolverInputTypes['BadRequestRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['OnboardCompanyAccountHolderSuccessPayload']: AliasType<{
        onboarding?: ResolverInputTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information on the shareholder. */
    ['OnboardCompanyShareholderInput']: {
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: ResolverInputTypes['AmountInput'];
        /** Name ("Dénomination sociale") of the shareholder. */
        name: string;
        /** Information required for the onboarding of a company shareholder. */
        onboardingInfo: ResolverInputTypes['OnboardCompanyAccountHolderInput'];
    };
    /** Inputs to onboard a new individual account holder */
    ['OnboardIndividualAccountHolderInput']: {
        /** Account name of the individual account holder. Length must be from 0 to 255 characters */
        accountName?: string | undefined | null;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ResolverInputTypes['AccountCountry'] | undefined | null;
        /** Employment status of the individual account holder */
        employmentStatus?: ResolverInputTypes['EmploymentStatus'] | undefined | null;
        /** Monthly income of the individual account holder */
        monthlyIncome?: ResolverInputTypes['MonthlyIncome'] | undefined | null;
        /** Residency address of the individual account holder (must be in a European country) */
        residencyAddress?: ResolverInputTypes['ResidencyAddressInput'] | undefined | null;
        /** Email. Length must be from 0 to 255 characters */
        email?: string | undefined | null;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined | null;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined | null;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ResolverInputTypes['OAuthRedirectParametersInput'] | undefined | null;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined | null;
    };
    ['OnboardIndividualAccountHolderPayload']: AliasType<{
        OnboardIndividualAccountHolderSuccessPayload?: ResolverInputTypes['OnboardIndividualAccountHolderSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['OnboardIndividualAccountHolderSuccessPayload']: AliasType<{
        onboarding?: ResolverInputTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information on the shareholder. */
    ['OnboardIndividualShareholderInput']: {
        /** First name of the shareholder. */
        firstName: string;
        /** Last name of the shareholder. */
        lastName: string;
        /** Birthdate of the shareholder in the YYYY/MM/DD format. */
        birthDate: string;
        /** CCA3 code for the country of nationality of the shareholder. */
        nationality: ResolverInputTypes['CCA3'];
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: ResolverInputTypes['AmountInput'];
        /** Information required for the onboarding of a individual shareholder. */
        onboardingInfo: ResolverInputTypes['OnboardIndividualAccountHolderInput'];
    };
    /** Information provided during the onboarding process of an individual or a company */
    ['Onboarding']: AliasType<{
        /** Unique identifier of an onboarding */
        id?: boolean | `@${string}`;
        /** Account name */
        accountName?: boolean | `@${string}`;
        /** Account Country */
        accountCountry?: boolean | `@${string}`;
        /** Creation date */
        createdAt?: boolean | `@${string}`;
        /** Email */
        email?: boolean | `@${string}`;
        /** Finalization date */
        finalizedAt?: boolean | `@${string}`;
        /** Language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
        language?: boolean | `@${string}`;
        /** Information regarding the Individual or the company to onboard */
        info?: ResolverInputTypes['OnboardingAccountHolderInfo'];
        /** Account holder created at the end of the onboarding process */
        accountHolder?: ResolverInputTypes['AccountHolder'];
        /** Redirect the legal representative of a new account holder to this URL to start the onboarding process */
        onboardingUrl?: boolean | `@${string}`;
        /** Current computed state of onboarding */
        onboardingState?: boolean | `@${string}`;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl?: boolean | `@${string}`;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ResolverInputTypes['OAuthRedirectParameters'];
        /** Status (valid/invalid/finalized) and details of errors on fields */
        statusInfo?: ResolverInputTypes['OnboardingStatusInfo'];
        /** Swan TCU URL */
        tcuUrl?: boolean | `@${string}`;
        /** List of supporting document collection owned by the account holder. */
        supportingDocumentCollection?: ResolverInputTypes['SupportingDocumentCollection'];
        /** Creation date */
        updatedAt?: boolean | `@${string}`;
        /** Account opened after the onboarding finalization */
        account?: ResolverInputTypes['Account'];
        /** List of accepted identification level for the legal representative */
        legalRepresentativeAcceptedIdentificationLevels?: boolean | `@${string}`;
        /** Recommended identification level for the legal representative */
        legalRepresentativeRecommendedIdentificationLevel?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The onboarding could be for an Individual or a company */
    ['OnboardingAccountHolderInfo']: AliasType<{
        /** Account holder type */
        type?: boolean | `@${string}`;
        ['...on OnboardingCompanyAccountHolderInfo']?: Omit<ResolverInputTypes['OnboardingCompanyAccountHolderInfo'], keyof ResolverInputTypes['OnboardingAccountHolderInfo']>;
        ['...on OnboardingIndividualAccountHolderInfo']?: Omit<ResolverInputTypes['OnboardingIndividualAccountHolderInfo'], keyof ResolverInputTypes['OnboardingAccountHolderInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Company Account Holder Information */
    ['OnboardingCompanyAccountHolderInfo']: AliasType<{
        /** Account holder type (always Company for type OnboardingCompanyAccountHolderInfo) */
        type?: boolean | `@${string}`;
        /** name of the company */
        name?: boolean | `@${string}`;
        /** registration number of the company (SIRET, ...) */
        registrationNumber?: boolean | `@${string}`;
        /** legal form of the company (SAS, SCI, SASU, ...) */
        companyType?: boolean | `@${string}`;
        /** business activity */
        businessActivity?: boolean | `@${string}`;
        /** business activity description
    This must be 1024 characters long maximum. */
        businessActivityDescription?: boolean | `@${string}`;
        /** estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: boolean | `@${string}`;
        /** The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
    
    The ultimate beneficiary is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: ResolverInputTypes['IndividualUltimateBeneficialOwner'];
        /** residency address of the head office (Must be in a European country) */
        residencyAddress?: ResolverInputTypes['AddressInfo'];
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | `@${string}`;
        /** Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT */
        vatNumber?: boolean | `@${string}`;
        /** Tax Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ResolverInputTypes['AddressInformation'];
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['OnboardingConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** OnboardingEdge list */
        edges?: ResolverInputTypes['OnboardingEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['OnboardingEdge']: AliasType<{
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The Onboarding */
        node?: ResolverInputTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing onboardings */
    ['OnboardingFiltersInput']: {
        /** Type/Types we want to filter on */
        types?: Array<ResolverInputTypes['AccountHolderType']> | undefined | null;
        /** Email we want to filter on */
        email?: string | undefined | null;
        /** Searches company name, first name, last name */
        search?: string | undefined | null;
        /** Status we want to filter on */
        status?: Array<ResolverInputTypes['OnboardingStatus']> | undefined | null;
    };
    /** StatusInfo when onboarding has been finalized */
    ['OnboardingFinalizedStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual Account Holder Information */
    ['OnboardingIndividualAccountHolderInfo']: AliasType<{
        /** Account holder type (always Individual for type OnboardingIndividualAccountHolderInfo) */
        type?: boolean | `@${string}`;
        /** employment status of the individual account holder */
        employmentStatus?: boolean | `@${string}`;
        /** monthly income of the individual account holder */
        monthlyIncome?: boolean | `@${string}`;
        /** residency address of the individual account holder (must be in a European country) */
        residencyAddress?: ResolverInputTypes['AddressInfo'];
        /** Tax Identification Number */
        taxIdentificationNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['OnboardingInfo']: AliasType<{
        /** Unique identifier of an onboarding */
        id?: boolean | `@${string}`;
        /** Account name */
        accountName?: boolean | `@${string}`;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: boolean | `@${string}`;
        /** email */
        email?: boolean | `@${string}`;
        /** language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
        language?: boolean | `@${string}`;
        /** Information regarding the Individual or the company to onboard */
        info?: ResolverInputTypes['OnboardingAccountHolderInfo'];
        /** Redirect the legal representative of a new account holder to this URL to start the onboarding process */
        onboardingUrl?: boolean | `@${string}`;
        /** Current computed state of onboarding */
        onboardingState?: boolean | `@${string}`;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl?: boolean | `@${string}`;
        /** Project infos you set in the dashboard */
        projectInfo?: ResolverInputTypes['ProjectInfo'];
        /** Verification Flow */
        verificationFlow?: boolean | `@${string}`;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ResolverInputTypes['OAuthRedirectParameters'];
        /** Status (valid/invalid/finalized) and details of errors on fields */
        statusInfo?: ResolverInputTypes['OnboardingStatusInfo'];
        /** Supporting document collection related to onboarding. */
        supportingDocumentCollection?: ResolverInputTypes['SupportingDocumentCollection'];
        /** List of accepted identification level for the legal representative */
        legalRepresentativeAcceptedIdentificationLevels?: boolean | `@${string}`;
        /** Recommended identification level for the legal representative */
        legalRepresentativeRecommendedIdentificationLevel?: boolean | `@${string}`;
        /** Swan TCU URL */
        tcuUrl?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when onboarding has still at least one incorrect field */
    ['OnboardingInvalidStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        errors?: ResolverInputTypes['ValidationError'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if an onboarding is not completed */
    ['OnboardingNotCompletedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        /** @deprecated(reason: "use `onboarding.id` instead") */
        onboardingId?: boolean | `@${string}`;
        onboarding?: ResolverInputTypes['Onboarding'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing onboardings */
    ['OnboardingOrderByFieldInput']: OnboardingOrderByFieldInput;
    /** Order that can be applied when listing onboardings */
    ['OnboardingOrderByInput']: {
        field?: ResolverInputTypes['OnboardingOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Onboarding process state */
    ['OnboardingState']: OnboardingState;
    /** Possible values for onboarding status */
    ['OnboardingStatus']: OnboardingStatus;
    /** Object containing details about onboarding status (valid/invalid and why it is invalid/already finalized) */
    ['OnboardingStatusInfo']: AliasType<{
        /** Current onboarding status. Onboarding can only be finalized if status is "valid" */
        status?: boolean | `@${string}`;
        ['...on OnboardingFinalizedStatusInfo']?: Omit<ResolverInputTypes['OnboardingFinalizedStatusInfo'], keyof ResolverInputTypes['OnboardingStatusInfo']>;
        ['...on OnboardingInvalidStatusInfo']?: Omit<ResolverInputTypes['OnboardingInvalidStatusInfo'], keyof ResolverInputTypes['OnboardingStatusInfo']>;
        ['...on OnboardingValidStatusInfo']?: Omit<ResolverInputTypes['OnboardingValidStatusInfo'], keyof ResolverInputTypes['OnboardingStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when onboarding has all onboarding fields are correctly filled */
    ['OnboardingValidStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['OrderByDirection']: OrderByDirection;
    /** Implements PageInfo from the Relay Connections Specification - information about a page in the pagination mechanism */
    ['PageInfo']: AliasType<{
        /** Indicates whether more edges exist following this page */
        hasNextPage?: boolean | `@${string}`;
        /** Indicates whether more edges exist preceding this page */
        hasPreviousPage?: boolean | `@${string}`;
        /** Opaque identifier pointing to the first node of the page */
        startCursor?: boolean | `@${string}`;
        /** Opaque identifier pointing to the last node of the page */
        endCursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input version */
    ['PartnerCloseAccountReasonInput']: {
        type: ResolverInputTypes['PartnerCloseAccountReasonType'];
        message?: string | undefined | null;
    };
    /** Specific type for closing account action */
    ['PartnerCloseAccountReasonType']: PartnerCloseAccountReasonType;
    /** Partnership Status Accepted */
    ['PartnershipAcceptedStatusInfo']: AliasType<{
        /** Partnership status (always Accepted for type PartnershipAcceptedStatusInfo) */
        status?: boolean | `@${string}`;
        /** Accepted date of the partnership for this account */
        acceptedDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Partnership Status canceled */
    ['PartnershipCanceledStatusInfo']: AliasType<{
        /** Partnership status (always Canceled for type PartnershipCanceledStatusInfo) */
        status?: boolean | `@${string}`;
        /** Accepted date of the partnership for this account */
        acceptedDate?: boolean | `@${string}`;
        /** Canceled date of the partnership for this account */
        canceledDate?: boolean | `@${string}`;
        /** Reason of the cancelation */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Partnership Status currently cancelling */
    ['PartnershipCancelingStatusInfo']: AliasType<{
        /** Partnership status (always Canceling for type PartnershipCancelingStatusInfo) */
        status?: boolean | `@${string}`;
        /** Accepted date of the partnership for this account */
        acceptedDate?: boolean | `@${string}`;
        /** Canceled date of the partnership for this account */
        canceledAfter?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PartnershipStatus']: PartnershipStatus;
    /** Partnership Status information */
    ['PartnershipStatusInfo']: AliasType<{
        /** Status of the partnership for this account */
        status?: boolean | `@${string}`;
        ['...on PartnershipAcceptedStatusInfo']?: Omit<ResolverInputTypes['PartnershipAcceptedStatusInfo'], keyof ResolverInputTypes['PartnershipStatusInfo']>;
        ['...on PartnershipCanceledStatusInfo']?: Omit<ResolverInputTypes['PartnershipCanceledStatusInfo'], keyof ResolverInputTypes['PartnershipStatusInfo']>;
        ['...on PartnershipCancelingStatusInfo']?: Omit<ResolverInputTypes['PartnershipCancelingStatusInfo'], keyof ResolverInputTypes['PartnershipStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to a passport */
    ['PassportDocument']: AliasType<{
        /** Unique identifier of the passport document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** The date at which the passport was issued */
        issueDate?: boolean | `@${string}`;
        /** The date at which the passport expires */
        expiryDate?: boolean | `@${string}`;
        /** Machine-readable zone code of the passport */
        mrz?: boolean | `@${string}`;
        /** Number of the passport */
        number?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ResolverInputTypes['PassportDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the passport document */
    ['PassportDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        /** From which side the passport's picture was taken */
        side?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** A Payment represents a set of transactions linked to the same payment act.
  
  This payment act can be initiated:
  - either from a user
  - either from a merchant
  - either from you
  - either from Swan */
    ['Payment']: AliasType<{
        /** unique identifier of a payment */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['PaymentStatusInfo'];
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['TransactionsOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['TransactionsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TransactionConnection']
        ];
        /** standing order that has initiated this payment */
        standingOrder?: ResolverInputTypes['StandingOrder'];
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentAccountType']: PaymentAccountType;
    /** Please see the Connection interface */
    ['PaymentConnection']: AliasType<{
        pageInfo?: ResolverInputTypes['PageInfo'];
        edges?: ResolverInputTypes['PaymentEdge'];
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment status consent pending */
    ['PaymentConsentPending']: AliasType<{
        /** status of the payment */
        status?: boolean | `@${string}`;
        /** The consent required to initiate this payment */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentDirectDebitMandate']: AliasType<{
        /** Unique identifier of the Direct Debit Payment Mandate */
        id?: boolean | `@${string}`;
        ['...on InternalPaymentDirectDebitMandate']?: Omit<ResolverInputTypes['InternalPaymentDirectDebitMandate'], keyof ResolverInputTypes['PaymentDirectDebitMandate']>;
        ['...on SEPAPaymentDirectDebitMandate']?: Omit<ResolverInputTypes['SEPAPaymentDirectDebitMandate'], keyof ResolverInputTypes['PaymentDirectDebitMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['PaymentEdge']: AliasType<{
        node?: ResolverInputTypes['Payment'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing payments */
    ['PaymentFiltersInput']: {
        status?: Array<ResolverInputTypes['PaymentStatus']> | undefined | null;
    };
    /** Payment status initiated */
    ['PaymentInitiated']: AliasType<{
        /** status of the payment */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment Level of the account */
    ['PaymentLevel']: PaymentLevel;
    ['PaymentLinkSequenceType']: PaymentLinkSequenceType;
    ['PaymentMandate']: AliasType<{
        /** Unique identifier of the Payment Mandate */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** number of elements in the list (default value 50) */
                first: number; /** When the list of elements needs to start after a element */
                after?: string | undefined | null; /** When the list of elements needs to be filtered */
                filters?: ResolverInputTypes['TransactionsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TransactionConnection']
        ];
        /** Custom name of the mandate */
        name?: boolean | `@${string}`;
        /** Account Holder information */
        accountHolder?: ResolverInputTypes['AccountHolder'];
        /** Creation date of the Payment Mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the Payment Mandate */
        updatedAt?: boolean | `@${string}`;
        /** Date of the the last transaction executed for the concerned Payment Mandate */
        executedAt?: boolean | `@${string}`;
        /** Expiry date of the Payment Mandate */
        expiredAt?: boolean | `@${string}`;
        /** Payment Mandate status information */
        statusInfo?: ResolverInputTypes['PaymentMandateStatusInfo'];
        ['...on InternalPaymentDirectDebitMandate']?: Omit<ResolverInputTypes['InternalPaymentDirectDebitMandate'], keyof ResolverInputTypes['PaymentMandate']>;
        ['...on SEPAPaymentDirectDebitMandate']?: Omit<ResolverInputTypes['SEPAPaymentDirectDebitMandate'], keyof ResolverInputTypes['PaymentMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentMandateCanceledReason']: PaymentMandateCanceledReason;
    /** Payment Mandate Canceled status information */
    ['PaymentMandateCanceledStatusInfo']: AliasType<{
        /** Payment Mandate status (always Canceled for type PaymentMandateCanceledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason behind the Payment Mandate Canceled status */
        reason?: boolean | `@${string}`;
        /** Date of Cancellation of the mandate. */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['PaymentMandateConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** PaymentMandateEdge list */
        edges?: ResolverInputTypes['PaymentMandateEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment Mandate Consent Pending status information */
    ['PaymentMandateConsentPendingStatusInfo']: AliasType<{
        /** Payment Mandate status (always Enabled for type PaymentMandateEnableedStatusInfo). */
        status?: boolean | `@${string}`;
        /** Consent information required to enable the concerned Payment Mandate */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentMandateCreditor']: AliasType<{
        /** Creditor UUID */
        id?: boolean | `@${string}`;
        /** Creditor name */
        name?: boolean | `@${string}`;
        /** Creditor address */
        address?: ResolverInputTypes['Address'];
        ['...on InternalPaymentMandateCreditor']?: Omit<ResolverInputTypes['InternalPaymentMandateCreditor'], keyof ResolverInputTypes['PaymentMandateCreditor']>;
        ['...on SEPAPaymentMandateCreditor']?: Omit<ResolverInputTypes['SEPAPaymentMandateCreditor'], keyof ResolverInputTypes['PaymentMandateCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentMandateDebtor']: AliasType<{
        /** Debtor name */
        name?: boolean | `@${string}`;
        /** Debtor e-mail */
        email?: boolean | `@${string}`;
        /** Debtor country */
        country?: boolean | `@${string}`;
        ['...on InternalPaymentMandateDebtor']?: Omit<ResolverInputTypes['InternalPaymentMandateDebtor'], keyof ResolverInputTypes['PaymentMandateDebtor']>;
        ['...on SEPAPaymentMandateDebtor']?: Omit<ResolverInputTypes['SEPAPaymentMandateDebtor'], keyof ResolverInputTypes['PaymentMandateDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['PaymentMandateEdge']: AliasType<{
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The payment mandate */
        node?: ResolverInputTypes['PaymentMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment Mandate Enabled status information */
    ['PaymentMandateEnabledStatusInfo']: AliasType<{
        /** Payment Mandate status (always Enabled for type PaymentMandateEnabledStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filter that can be passed to get the payment mandate in a specific data range */
    ['PaymentMandateFiltersInput']: {
        /** To filter on status values */
        status?: Array<ResolverInputTypes['PaymentMandateStatus']> | undefined | null;
        /** To filter on scheme values */
        scheme?: Array<ResolverInputTypes['PaymentMandateScheme']> | undefined | null;
    };
    /** Error returned if the payment mandate was not found */
    ['PaymentMandateMandateNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing payment mandate results */
    ['PaymentMandateOrderByFieldInput']: PaymentMandateOrderByFieldInput;
    /** Order that can be applied when listing payment mandate results */
    ['PaymentMandateOrderByInput']: {
        field?: ResolverInputTypes['PaymentMandateOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Rejection returned if the payment mandate reference is already used for the same creditor */
    ['PaymentMandateReferenceAlreadyUsedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment Mandate Rejected status information */
    ['PaymentMandateRejectedStatusInfo']: AliasType<{
        /** Payment Mandate status (always Rejected for type PaymentMandateSuspendedStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PaymentMandateScheme']: PaymentMandateScheme;
    /** Payment Mandate Sequence */
    ['PaymentMandateSequence']: PaymentMandateSequence;
    /** Payment Mandate status */
    ['PaymentMandateStatus']: PaymentMandateStatus;
    /** Payment Mandate status information */
    ['PaymentMandateStatusInfo']: AliasType<{
        /** Status of the payment mandate. */
        status?: boolean | `@${string}`;
        ['...on PaymentMandateCanceledStatusInfo']?: Omit<ResolverInputTypes['PaymentMandateCanceledStatusInfo'], keyof ResolverInputTypes['PaymentMandateStatusInfo']>;
        ['...on PaymentMandateConsentPendingStatusInfo']?: Omit<ResolverInputTypes['PaymentMandateConsentPendingStatusInfo'], keyof ResolverInputTypes['PaymentMandateStatusInfo']>;
        ['...on PaymentMandateEnabledStatusInfo']?: Omit<ResolverInputTypes['PaymentMandateEnabledStatusInfo'], keyof ResolverInputTypes['PaymentMandateStatusInfo']>;
        ['...on PaymentMandateRejectedStatusInfo']?: Omit<ResolverInputTypes['PaymentMandateRejectedStatusInfo'], keyof ResolverInputTypes['PaymentMandateStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when a payment method is not compatible for the requested mutation */
    ['PaymentMethodNotCompatibleRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing payment */
    ['PaymentOrderByFieldInput']: PaymentOrderByFieldInput;
    /** Order that can be applied when listing payments */
    ['PaymentOrderByInput']: {
        field?: ResolverInputTypes['PaymentOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Payment product */
    ['PaymentProduct']: PaymentProduct;
    /** Payment status rejected */
    ['PaymentRejected']: AliasType<{
        /** status of the payment */
        status?: boolean | `@${string}`;
        /** rejected reason */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment status */
    ['PaymentStatus']: PaymentStatus;
    /** Payment Status Information */
    ['PaymentStatusInfo']: AliasType<{
        /** status of the payment */
        status?: boolean | `@${string}`;
        ['...on PaymentConsentPending']?: Omit<ResolverInputTypes['PaymentConsentPending'], keyof ResolverInputTypes['PaymentStatusInfo']>;
        ['...on PaymentInitiated']?: Omit<ResolverInputTypes['PaymentInitiated'], keyof ResolverInputTypes['PaymentStatusInfo']>;
        ['...on PaymentRejected']?: Omit<ResolverInputTypes['PaymentRejected'], keyof ResolverInputTypes['PaymentStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Custom information for a PDF statement */
    ['PdfStatement']: AliasType<{
        /** statement type */
        type?: boolean | `@${string}`;
        /** temporary public url on which the file can be accessed */
        url?: boolean | `@${string}`;
        /** date at which the link will not be useable anymore */
        expiresAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Consent when the account membership will be updated */
    ['PendingConsentAccountMembershipUpdate']: AliasType<{
        /** New account membership version waiting for consent */
        accountMembershipId?: ResolverInputTypes['AccountMembership'];
        /** The consent required to update the account membership */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Digital Card used for ApplePay or GooglePay */
    ['PendingDigitalCard']: AliasType<{
        /** Unique identifier of a digital card */
        id?: boolean | `@${string}`;
        /** The type of digitalization that created this digital card. */
        type?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider?: ResolverInputTypes['WalletProvider'];
        /** Digital Card status information
    
    In this type the status will be either ConsentPending or Pending */
        statusInfo?: ResolverInputTypes['PendingDigitalCardStatusInfo'];
        inAppProvisioningData?: [
            {
                signatureData?: ResolverInputTypes['SignatureData'] | undefined | null;
            },
            ResolverInputTypes['InAppProvisioningData']
        ];
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Digital Card Status */
    ['PendingDigitalCardStatus']: PendingDigitalCardStatus;
    /** Pending Digital Card Status Information */
    ['PendingDigitalCardStatusInfo']: AliasType<{
        /** Status of the digital card. */
        status?: boolean | `@${string}`;
        ['...on DigitalCardConsentPendingStatusInfo']?: Omit<ResolverInputTypes['DigitalCardConsentPendingStatusInfo'], keyof ResolverInputTypes['PendingDigitalCardStatusInfo']>;
        ['...on DigitalCardDeclinedStatusInfo']?: Omit<ResolverInputTypes['DigitalCardDeclinedStatusInfo'], keyof ResolverInputTypes['PendingDigitalCardStatusInfo']>;
        ['...on DigitalCardPendingStatusInfo']?: Omit<ResolverInputTypes['DigitalCardPendingStatusInfo'], keyof ResolverInputTypes['PendingDigitalCardStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source Pending status information */
    ['PendingFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Pending status */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level that is pending for the process of the current identification, requiring an operation not related to the end-user to progress */
    ['PendingIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Pending` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** PendingMerchantPaymentMethodStatusInfo */
    ['PendingMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** PendingReviewMerchantProfileStatusInfo */
    ['PendingReviewMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Verification Information */
    ['PendingReviewStatusInfo']: AliasType<{
        /** Account verification status (PendingReview) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending transaction status information */
    ['PendingTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The date when the pending amount of this transaction is released on the available balance of this account if not booked */
        pendingEndDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Pending Verification Information */
    ['PendingVerificationStatusInfo']: AliasType<{
        /** Account verification status (PendingVerification) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PermissionCannotBeGrantedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** E.164 standard format phone number
  
  Examples
  +551155256325
  +44207183875 */
    ['PhoneNumber']: unknown;
    /** Physical Card */
    ['PhysicalCard']: AliasType<{
        /** Physical Card status information */
        statusInfo?: ResolverInputTypes['PhysicalCardStatusInfo'];
        /** Physical Card expiration date  with MM/YY string format */
        expiryDate?: boolean | `@${string}`;
        /** Unique identifier present on physical card, such identifier is null if the status is ToActivate or Canceled. This identifier is updated when a renewed card is activated */
        identifier?: boolean | `@${string}`;
        /** Offline Spending limit defined by Swan */
        offlineSpendingLimit?: ResolverInputTypes['Amount'];
        /** Masked Card Number */
        cardMaskedNumber?: boolean | `@${string}`;
        /** Custom Options */
        customOptions?: ResolverInputTypes['PhysicalCardCustomOptions'];
        /** every previous Physical Card information */
        previousPhysicalCards?: ResolverInputTypes['BasicPhysicalCardInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Activated Status Information */
    ['PhysicalCardActivatedStatusInfo']: AliasType<{
        /** Physical Card status (always Activated for type PhysicalCardEnabledStatusInfo). */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Canceled Status Information */
    ['PhysicalCardCanceledStatusInfo']: AliasType<{
        /** Physical Card status (always Canceled for type PhysicalCardCanceledStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is canceled. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Canceling Status Information */
    ['PhysicalCardCancelingStatusInfo']: AliasType<{
        /** Physical Card status (always Canceling for type PhysicalCardCancelingStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is canceled. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PhysicalCardConfigInput']: {
        /** Address to deliver the physical card */
        deliveryAddress: ResolverInputTypes['CompleteAddressInput'];
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: ResolverInputTypes['PhysicalCardCustomOptionsInput'] | undefined | null;
        /** `true` if the user must choose their PIN */
        choosePin?: boolean | undefined | null;
    };
    /** when the user has to authorize production of the physical card */
    ['PhysicalCardConsentPendingStatusInfo']: AliasType<{
        /** Physical Card status (always ConsentPending for type PhysicalCardConsentPendingStatusInfo) */
        status?: boolean | `@${string}`;
        /** The consent required to authorize production of the physical card */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Custom options for physical card. */
    ['PhysicalCardCustomOptions']: AliasType<{
        /** Additional line embossed on the card. */
        additionalPrintedLine?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PhysicalCardCustomOptionsForGroupDeliveryInput']: {
        /** Additional line to be embossed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined | null;
    };
    ['PhysicalCardCustomOptionsForPrintInput']: {
        /** Additional line to be printed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined | null;
    };
    ['PhysicalCardCustomOptionsInput']: {
        /** Additional line to be embossed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined | null;
    };
    /** Rejection returned when the Physical Card does not exist */
    ['PhysicalCardNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** when the physical card is in the process of being ready to use */
    ['PhysicalCardProcessingStatusInfo']: AliasType<{
        /** Physical card status (always Processing for type PhysicalCardProcessingStatusInfo) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Renewed Status Information */
    ['PhysicalCardRenewedStatusInfo']: AliasType<{
        /** Physical Card status (always Renewed for type PhysicalCardRenewedStatusInfo). */
        status?: boolean | `@${string}`;
        /** address to deliver the physical card */
        address?: ResolverInputTypes['Address'];
        /** Estimated delivery date */
        estimatedDeliveryDate?: boolean | `@${string}`;
        /** Shipping tracking number */
        trackingNumber?: boolean | `@${string}`;
        /** Name of the shipping provider (Ex: LaPoste, DHL ...) */
        shippingProvider?: boolean | `@${string}`;
        /** `true` if PIN Code is available. */
        isPINReady?: boolean | `@${string}`;
        /** New physical Card info */
        newPhysicalCard?: ResolverInputTypes['BasicPhysicalCardInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Status */
    ['PhysicalCardStatus']: PhysicalCardStatus;
    /** Physical Card Status Information */
    ['PhysicalCardStatusInfo']: AliasType<{
        /** Status of the physical card. */
        status?: boolean | `@${string}`;
        ['...on PhysicalCardActivatedStatusInfo']?: Omit<ResolverInputTypes['PhysicalCardActivatedStatusInfo'], keyof ResolverInputTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardCanceledStatusInfo']?: Omit<ResolverInputTypes['PhysicalCardCanceledStatusInfo'], keyof ResolverInputTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardCancelingStatusInfo']?: Omit<ResolverInputTypes['PhysicalCardCancelingStatusInfo'], keyof ResolverInputTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardConsentPendingStatusInfo']?: Omit<ResolverInputTypes['PhysicalCardConsentPendingStatusInfo'], keyof ResolverInputTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardProcessingStatusInfo']?: Omit<ResolverInputTypes['PhysicalCardProcessingStatusInfo'], keyof ResolverInputTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardRenewedStatusInfo']?: Omit<ResolverInputTypes['PhysicalCardRenewedStatusInfo'], keyof ResolverInputTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardSuspendedStatusInfo']?: Omit<ResolverInputTypes['PhysicalCardSuspendedStatusInfo'], keyof ResolverInputTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardToActivateStatusInfo']?: Omit<ResolverInputTypes['PhysicalCardToActivateStatusInfo'], keyof ResolverInputTypes['PhysicalCardStatusInfo']>;
        ['...on PhysicalCardToRenewStatusInfo']?: Omit<ResolverInputTypes['PhysicalCardToRenewStatusInfo'], keyof ResolverInputTypes['PhysicalCardStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card Suspended Status Information */
    ['PhysicalCardSuspendedStatusInfo']: AliasType<{
        /** Physical Card status (always Suspended for type PhysicalCardSuspendedStatusInfo). */
        status?: boolean | `@${string}`;
        /** Reason why the card is suspended. */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Physical Card To Activate Status Information */
    ['PhysicalCardToActivateStatusInfo']: AliasType<{
        /** Physical Card status (always ToActivate for type PhysicalCardToActivateStatusInfo). */
        status?: boolean | `@${string}`;
        /** address to deliver the physical card */
        address?: ResolverInputTypes['Address'];
        /** Estimated delivery date */
        estimatedDeliveryDate?: boolean | `@${string}`;
        /** Shipping tracking number */
        trackingNumber?: boolean | `@${string}`;
        /** Name of the shipping provider (Ex: LaPoste, DHL ...) */
        shippingProvider?: boolean | `@${string}`;
        /** `true` if PIN Code is available. */
        isPINReady?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** when the physical card is in the process of being renewed */
    ['PhysicalCardToRenewStatusInfo']: AliasType<{
        /** Physical card status (always ToRenew for type PhysicalCardToRenewStatusInfo) */
        status?: boolean | `@${string}`;
        /** registered address to deliver the new physical card */
        address?: ResolverInputTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Physical Card is not the expected status */
    ['PhysicalCardWrongStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        identifier?: boolean | `@${string}`;
        currentStatus?: boolean | `@${string}`;
        expectedStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** 6 digits numeric passcode */
    ['PIN']: unknown;
    ['PINNotReadyRejection']: AliasType<{
        physicalCardIdentifier?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['PreferredNotificationChannel']: PreferredNotificationChannel;
    ['PreProvisioningSUVCardSettings']: AliasType<{
        preProvisioningSUVCards?: boolean | `@${string}`;
        preProvisioningSUVNumberOfCards?: boolean | `@${string}`;
        ownerProvisioningSUVCards?: boolean | `@${string}`;
        preProvisioningSUVCardsAvailablePercentage?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to print a physical card */
    ['PrintPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Address to deliver the physical card */
        address: ResolverInputTypes['CompleteAddressInput'];
        /** `true` if the user must choose their PIN Code (will be deprecated/removed) */
        choosePINCode: boolean;
        /** `true` if the user must choose their PIN */
        choosePin?: boolean | undefined | null;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: ResolverInputTypes['PhysicalCardCustomOptionsForPrintInput'] | undefined | null;
    };
    ['PrintPhysicalCardPayload']: AliasType<{
        PrintPhysicalCardSuccessPayload?: ResolverInputTypes['PrintPhysicalCardSuccessPayload'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        AlreadyValidPhysicalCardRejection?: ResolverInputTypes['AlreadyValidPhysicalCardRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        BadRequestRejection?: ResolverInputTypes['BadRequestRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        CardProductNotApplicableToPhysicalCardsRejection?: ResolverInputTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        CardProductDisabledRejection?: ResolverInputTypes['CardProductDisabledRejection'];
        MissingMandatoryFieldRejection?: ResolverInputTypes['MissingMandatoryFieldRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['PrintPhysicalCardSuccessPayload']: AliasType<{
        /** The physicalCard created */
        physicalCard?: ResolverInputTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
    ['ProductType']: ProductType;
    ['ProjectCardDesigns']: AliasType<{
        /** Unique identifier of a project */
        id?: boolean | `@${string}`;
        /** Visual Id from the issuing card processor (Monext) */
        issuingProcessorVisualId?: boolean | `@${string}`;
        /** Specific card product for companies */
        specificCardProductCodeForCompanies?: boolean | `@${string}`;
        /** Project name */
        name?: boolean | `@${string}`;
        /** Project card product designs */
        cardDesigns?: ResolverInputTypes['CardProductDesign'];
        /** Project's pre provisioning suv card settings */
        preProvisioningSUVCardSettings?: ResolverInputTypes['PreProvisioningSUVCardSettings'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectCardSettings']: AliasType<{
        /** Unique identifier of a project */
        id?: boolean | `@${string}`;
        /** Visual Id from the issuing card processor (Monext) */
        issuingProcessorVisualId?: boolean | `@${string}`;
        /** Specific card product for companies */
        specificCardProductCodeForCompanies?: boolean | `@${string}`;
        /** Project name */
        name?: boolean | `@${string}`;
        /** Project's card settings */
        cardSettings?: ResolverInputTypes['CardSettings'];
        /** Project's pre provisioning suv card settings */
        preProvisioningSUVCardSettings?: ResolverInputTypes['PreProvisioningSUVCardSettings'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Project Card Settings Background Type */
    ['ProjectCardSettingsBackgroundType']: ProjectCardSettingsBackgroundType;
    /** Card Status */
    ['ProjectCardStatus']: ProjectCardStatus;
    ['ProjectForbiddenRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Project Funding has been exceeded */
    ['ProjectFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Public information of a `Project` */
    ['ProjectInfo']: AliasType<{
        /** The card products associated with this project. */
        cardProducts?: ResolverInputTypes['CardProduct'];
        /** the currently active card settings */
        activeCardSettings?: ResolverInputTypes['CardSettings'];
        /** Unique identifier of the project */
        id?: boolean | `@${string}`;
        B2BMembershipIDVerification?: boolean | `@${string}`;
        supportingDocumentSettings?: ResolverInputTypes['SupportingDocumentSettings'];
        /** Your project name displayed in white label interfaces and in the terms and conditions */
        name?: boolean | `@${string}`;
        /** The type of your project */
        type?: boolean | `@${string}`;
        /** URL of your logo */
        logoUri?: boolean | `@${string}`;
        /** Your accent color, used in white label interfaces. Most of the time for call to actions */
        accentColor?: boolean | `@${string}`;
        /** Your custom subdomain used in consents */
        customConsentSubdomain?: boolean | `@${string}`;
        /** Your OAuth client id */
        oAuthClientId?: boolean | `@${string}`;
        tcuDocumentUri?: [
            {
                /** this consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
                language: string;
            },
            boolean | `@${string}`
        ];
        /** Unique id of your current Terms and Conditions of Use */
        tcuDocumentId?: boolean | `@${string}`;
        /** Web banking settings */
        webBankingSettings?: ResolverInputTypes['WebBankingSettings'];
        /** Project status */
        status?: boolean | `@${string}`;
        /** Flag that determines if desktop authentication is enabled for this project */
        allowsDesktopAuthentication?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the Project Instant Funding limit has been exceeded */
    ['ProjectInstantFundingLimitExceededRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectInvalidStatusRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectNotFound']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the project is not found */
    ['ProjectNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectSettingsForbiddenError']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectSettingsNotFound']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectSettingsStatusNotReachable']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ProjectStatus']: ProjectStatus;
    ['ProjectType']: ProjectType;
    /** Rejection returned when the public onboarding is disabled */
    ['PublicOnboardingDisabledRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['Query']: AliasType<{
        fundingLimitSettingsChangeRequest?: [
            {
                fundingLimitSettingsChangeRequestId: string;
            },
            ResolverInputTypes['FundingLimitSettingsChangeRequest']
        ];
        ibanValidation?: [
            {
                input?: ResolverInputTypes['IbanValidationInput'] | undefined | null;
            },
            ResolverInputTypes['IbanValidationResult']
        ];
        accountHolder?: [{
            id: string;
        }, ResolverInputTypes['AccountHolder']];
        accountHolders?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['AccountHolderFilterInput'] | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['AccountHolderOrderByInput'] | undefined | null;
            },
            ResolverInputTypes['AccountHolderConnection']
        ];
        accountMembership?: [{
            id: string;
        }, ResolverInputTypes['AccountMembership']];
        accountMemberships?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['AccountMembershipsFilterInput'] | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['AccountMembershipOrderByInput'] | undefined | null;
            },
            ResolverInputTypes['AccountMembershipConnection']
        ];
        account?: [{
            accountId: string;
        }, ResolverInputTypes['Account']];
        accounts?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['AccountFilterInput'] | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['AccountOrderByInput'] | undefined | null;
            },
            ResolverInputTypes['AccountConnection']
        ];
        beneficiaryVerification?: [
            {
                input?: ResolverInputTypes['BeneficiaryVerificationInput'] | undefined | null;
            },
            ResolverInputTypes['BeneficiaryVerificationResult']
        ];
        card?: [{
            cardId: string;
        }, ResolverInputTypes['Card']];
        cards?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['CardOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['CardFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['CardConnection']
        ];
        onboarding?: [{
            id: string;
        }, ResolverInputTypes['Onboarding']];
        onboardings?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['OnboardingFiltersInput'] | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['OnboardingOrderByInput'] | undefined | null;
            },
            ResolverInputTypes['OnboardingConnection']
        ];
        supportingDocumentCollection?: [
            {
                id: string;
            },
            ResolverInputTypes['SupportingDocumentCollection']
        ];
        accountStatement?: [{
            id: string;
        }, ResolverInputTypes['Statement']];
        payment?: [{
            id: string;
        }, ResolverInputTypes['Payment']];
        payments?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['PaymentOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['PaymentFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['PaymentConnection']
        ];
        transaction?: [{
            id: string;
        }, ResolverInputTypes['Transaction']];
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['TransactionsOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['TransactionsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TransactionConnection']
        ];
        accountInvoice?: [{
            invoiceId: string;
        }, ResolverInputTypes['Invoice']];
        capitalDepositCase?: [{
            id: string;
        }, ResolverInputTypes['CapitalDepositCase']];
        capitalDepositCases?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['CapitalDepositCaseFiltersInput'] | undefined | null; /** an order you can apply to your list of connections */
                orderBy?: ResolverInputTypes['CapitalDepositCaseOrderByInput'] | undefined | null;
            },
            ResolverInputTypes['CapitalDepositCaseConnection']
        ];
        capitalDepositDocument?: [{
            id: string;
        }, ResolverInputTypes['CapitalDepositDocument']];
        shareholder?: [{
            id: string;
        }, ResolverInputTypes['Shareholder']];
        /** Returns the project infos you set in the dashboard. */
        projectInfo?: ResolverInputTypes['ProjectInfo'];
        consent?: [{
            id: string;
        }, ResolverInputTypes['Consent']];
        consents?: [
            {
                first: number;
                after?: string | undefined | null;
                filters?: ResolverInputTypes['ConsentsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['ConsentConnection']
        ];
        user?: [{
            id?: string | undefined | null;
        }, ResolverInputTypes['User']];
        users?: [
            {
                after?: string | undefined | null;
                before?: string | undefined | null;
                filters?: ResolverInputTypes['UserFilterInput'] | undefined | null;
                first: number; /** @deprecated(reason: "use the `search` field in `UserFilterInput`") */
                search?: string | undefined | null;
            },
            ResolverInputTypes['UserConnection']
        ];
        receivedDirectDebitMandate?: [
            {
                receivedDirectDebitMandateId: string;
            },
            ResolverInputTypes['ReceivedDirectDebitMandate']
        ];
        merchantProfile?: [{
            id: string;
        }, ResolverInputTypes['MerchantProfile']];
        fundingSource?: [{
            id: string;
        }, ResolverInputTypes['FundingSource']];
        internationalBeneficiaryDynamicForms?: [
            {
                amount: ResolverInputTypes['AmountInput'];
                language?: ResolverInputTypes['InternationalCreditTransferDisplayLanguage'] | undefined | null;
                dynamicFields?: Array<ResolverInputTypes['InternationalBeneficiaryDetailsInput']> | undefined | null;
            },
            ResolverInputTypes['InternationalBeneficiaryDynamicForms']
        ];
        internationalCreditTransferTransactionDetailsDynamicForm?: [
            {
                targetAmount: ResolverInputTypes['AmountInput'];
                language?: ResolverInputTypes['InternationalCreditTransferDisplayLanguage'] | undefined | null;
                internationalBeneficiary: ResolverInputTypes['InternationalBeneficiaryInput'];
                refreshableFields?: Array<ResolverInputTypes['InternationalCreditTransferDetailsInput']> | undefined | null;
            },
            ResolverInputTypes['InternationalCreditTransferDynamicForm']
        ];
        internationalCreditTransferQuote?: [
            {
                accountId: string;
                targetAmount: ResolverInputTypes['AmountInput'];
                language?: ResolverInputTypes['InternationalCreditTransferDisplayLanguage'] | undefined | null;
            },
            ResolverInputTypes['InternationalCreditTransferQuote']
        ];
        standingOrder?: [{
            standingOrderId: string;
        }, ResolverInputTypes['StandingOrder']];
        webhookEventLog?: [{
            id: string;
        }, ResolverInputTypes['WebhookEventLog']];
        __typename?: boolean | `@${string}`;
    }>;
    ['RadioField']: AliasType<{
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        refreshDynamicFieldsOnChange?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        allowedValues?: ResolverInputTypes['AllowedValue'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information that can be used to determine where the iban can be used */
    ['Reachability']: AliasType<{
        /** Can be used for instant transfer over SEPA */
        sepaCreditTransferInst?: boolean | `@${string}`;
        /** Can be used for direct debit over SEPA */
        sepaDirectDebitCore?: boolean | `@${string}`;
        /** Can be used for B2B direct debit over SEPA */
        sepaDirectDebitB2b?: boolean | `@${string}`;
        /** Can be used for transfer over SEPA (can be used in initiateCreditTransfer mutation) */
        sepaCreditTransfer?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Define a reason with a message */
    ['Reason']: AliasType<{
        message?: boolean | `@${string}`;
        ['...on CloseAccountReason']?: Omit<ResolverInputTypes['CloseAccountReason'], keyof ResolverInputTypes['Reason']>;
        ['...on SuspendAccountReason']?: Omit<ResolverInputTypes['SuspendAccountReason'], keyof ResolverInputTypes['Reason']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input version */
    ['ReasonInput']: {
        message?: string | undefined | null;
    };
    /** Interface for Received Direct Debit Mandate */
    ['ReceivedDirectDebitMandate']: AliasType<{
        /** Unique identifier of the received direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        /** Version of the received direct debit mandate */
        version?: boolean | `@${string}`;
        /** Creation date of the received direct debit mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the received direct debit mandate */
        updatedAt?: boolean | `@${string}`;
        /** Date of signature of the received direct debit mandate */
        signatureDate?: boolean | `@${string}`;
        /** Date of the last direct debit transaction executed for the concerned received direct debit mandate */
        executedAt?: boolean | `@${string}`;
        /** Expiry date of the received direct debit mandate */
        expiredAt?: boolean | `@${string}`;
        /** Mandate status information of the received direct debit mandate */
        statusInfo?: ResolverInputTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Mandate name */
        name?: boolean | `@${string}`;
        ['...on InternalReceivedDirectDebitMandate']?: Omit<ResolverInputTypes['InternalReceivedDirectDebitMandate'], keyof ResolverInputTypes['ReceivedDirectDebitMandate']>;
        ['...on SEPAReceivedDirectDebitMandate']?: Omit<ResolverInputTypes['SEPAReceivedDirectDebitMandate'], keyof ResolverInputTypes['ReceivedDirectDebitMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the received direct debit mandate already exist */
    ['ReceivedDirectDebitMandateAlreadyExistRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received direct debit mandate is canceled and therefore can't be enabled/suspended or updated */
    ['ReceivedDirectDebitMandateCanceledRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ReceivedDirectDebitMandateConnection']: AliasType<{
        /** Total number of elements in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** ReceivedDirectDebitMandateEdge list */
        edges?: ResolverInputTypes['ReceivedDirectDebitMandateEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['ReceivedDirectDebitMandateEdge']: AliasType<{
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The received direct debit mandate */
        node?: ResolverInputTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the received direct debit mandate is not a B2b mandate */
    ['ReceivedDirectDebitMandateNotB2bRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Error returned if the received direct debit mandate was not found or if the user does not have the rights to receive information abo
  ut the existence of the received direct debit mandate */
    ['ReceivedDirectDebitMandateNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate Scheme */
    ['ReceivedDirectDebitMandateScheme']: ReceivedDirectDebitMandateScheme;
    /** Received Direct Debit Mandate Statuses */
    ['ReceivedDirectDebitMandateStatus']: ReceivedDirectDebitMandateStatus;
    /** Received Direct Debit Mandate status information */
    ['ReceivedDirectDebitMandateStatusInfo']: AliasType<{
        /** Received Direct Debit Mandate status */
        status?: boolean | `@${string}`;
        ['...on ReceivedDirectDebitMandateStatusInfoCanceled']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateStatusInfoCanceled'], keyof ResolverInputTypes['ReceivedDirectDebitMandateStatusInfo']>;
        ['...on ReceivedDirectDebitMandateStatusInfoConsentInitiationPending']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateStatusInfoConsentInitiationPending'], keyof ResolverInputTypes['ReceivedDirectDebitMandateStatusInfo']>;
        ['...on ReceivedDirectDebitMandateStatusInfoConsentPending']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateStatusInfoConsentPending'], keyof ResolverInputTypes['ReceivedDirectDebitMandateStatusInfo']>;
        ['...on ReceivedDirectDebitMandateStatusInfoEnabled']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateStatusInfoEnabled'], keyof ResolverInputTypes['ReceivedDirectDebitMandateStatusInfo']>;
        ['...on ReceivedDirectDebitMandateStatusInfoSuspended']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateStatusInfoSuspended'], keyof ResolverInputTypes['ReceivedDirectDebitMandateStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate Canceled status information */
    ['ReceivedDirectDebitMandateStatusInfoCanceled']: AliasType<{
        /** Received Direct Debit Mandate status (always Canceled for type ReceivedDirectDebitMandateStatusInfoCanceled) */
        status?: boolean | `@${string}`;
        /** Date of cancellation */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate ConsentInitiationPending status information */
    ['ReceivedDirectDebitMandateStatusInfoConsentInitiationPending']: AliasType<{
        /** Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate ConsentPending status information */
    ['ReceivedDirectDebitMandateStatusInfoConsentPending']: AliasType<{
        /** Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentPending) */
        status?: boolean | `@${string}`;
        /** The consent required to consent to a received direct debit mandate */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate Enabled status information */
    ['ReceivedDirectDebitMandateStatusInfoEnabled']: AliasType<{
        /** Received Direct Debit Mandate status (always Enabled for type ReceivedDirectDebitMandateStatusInfoEnabled) */
        status?: boolean | `@${string}`;
        /** Date at which the received direct debit mandate has been moved to the enabled status */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Received Direct Debit Mandate Suspended status information */
    ['ReceivedDirectDebitMandateStatusInfoSuspended']: AliasType<{
        /** Received Direct Debit Mandate status (always Suspended for type ReceivedDirectDebitMandateStatusInfoSuspended) */
        status?: boolean | `@${string}`;
        /** Date of the last time the received direct debit mandate has been moved to the suspended status */
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to select the beneficiary and the originator to perform a refund */
    ['RefundInput']: {
        /** transactions to refund */
        refundTransactions: Array<ResolverInputTypes['RefundTransaction']>;
        /** url the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** The respond body to a refund mutation */
    ['RefundPayload']: AliasType<{
        RefundSuccessPayload?: ResolverInputTypes['RefundSuccessPayload'];
        RefundRejection?: ResolverInputTypes['RefundRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the transaction status is not correct for the desired action */
    ['RefundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        code?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Reason code that explains why we can't refund the transactions */
    ['RefundRejectionCode']: RefundRejectionCode;
    /** Consent generated by the refund mutation */
    ['RefundSuccessPayload']: AliasType<{
        /** optional consent that need to be validated for the refund to go through */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Information about the transaction to refund */
    ['RefundTransaction']: {
        /** id of the transaction to refund */
        originTransactionId: string;
        /** amount to refund in the same currency as the account */
        amount: ResolverInputTypes['AmountInput'];
        /** reference assigned by the initiating party, to unambiguously identify the transaction.
    This reference is passed on, unchanged, throughout the entire end-to-end chain for credit transfers. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined | null;
        /** label for the refund transaction (max 140 characters) */
        label?: string | undefined | null;
        /** only used when the transaction was a credit transfer
    
    date when the credit transfer will be executed, if `null` the credit transfer is executed today */
        executionDate?: ResolverInputTypes['DateTime'] | undefined | null;
    };
    /** Funding Source Rejected Reason */
    ['RejectedFundingSourceReason']: RejectedFundingSourceReason;
    /** Funding Source Rejected status information */
    ['RejectedFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Rejected status */
        status?: boolean | `@${string}`;
        /** Date at which the funding source was rejected */
        rejectedAt?: boolean | `@${string}`;
        /** Reason code of the rejection */
        reasonCode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** RejectedMerchantPaymentMethodStatusInfo */
    ['RejectedMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method rejected date */
        rejectedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** RejectedMerchantProfileStatusInfo */
    ['RejectedMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        rejectedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The following reason code for a rejected transaction are defined: */
    ['RejectedReasonCode']: RejectedReasonCode;
    /** Rejected transaction status information */
    ['RejectedTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** reason code */
        reason?: boolean | `@${string}`;
        /** `true` if the transaction had a fallback */
        hasFallback?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejected Verification Reason */
    ['RejectedVerificationReason']: RejectedVerificationReason;
    /** Rejected Information */
    ['RejectedVerificationStatusInfo']: AliasType<{
        /** Rejected Reason */
        reason?: boolean | `@${string}`;
        /** Date at which the verification was rejected */
        rejectedAt?: boolean | `@${string}`;
        /** Account verification status (Rejected) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['Rejection']: AliasType<{
        message?: boolean | `@${string}`;
        ['...on AccountHolderNotFoundRejection']?: Omit<ResolverInputTypes['AccountHolderNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountHolderTypeIndividualRejection']?: Omit<ResolverInputTypes['AccountHolderTypeIndividualRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountMembershipCannotBeDisabledRejection']?: Omit<ResolverInputTypes['AccountMembershipCannotBeDisabledRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountMembershipCannotBeUpdatedRejection']?: Omit<ResolverInputTypes['AccountMembershipCannotBeUpdatedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountMembershipNotAllowedRejection']?: Omit<ResolverInputTypes['AccountMembershipNotAllowedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountMembershipNotFoundRejection']?: Omit<ResolverInputTypes['AccountMembershipNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountMembershipNotReadyToBeBoundRejection']?: Omit<ResolverInputTypes['AccountMembershipNotReadyToBeBoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountNotEligibleRejection']?: Omit<ResolverInputTypes['AccountNotEligibleRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountNotFoundRejection']?: Omit<ResolverInputTypes['AccountNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountVerificationAlreadyRejectedRejection']?: Omit<ResolverInputTypes['AccountVerificationAlreadyRejectedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AccountVerificationWrongStatusRejection']?: Omit<ResolverInputTypes['AccountVerificationWrongStatusRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ActionNotAllowedRejection']?: Omit<ResolverInputTypes['ActionNotAllowedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AddingCardsToDifferentAccountsRejection']?: Omit<ResolverInputTypes['AddingCardsToDifferentAccountsRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on AlreadyValidPhysicalCardRejection']?: Omit<ResolverInputTypes['AlreadyValidPhysicalCardRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ApplePayNotAllowedForProjectRejection']?: Omit<ResolverInputTypes['ApplePayNotAllowedForProjectRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on BadAccountStatusRejection']?: Omit<ResolverInputTypes['BadAccountStatusRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on BadRequestRejection']?: Omit<ResolverInputTypes['BadRequestRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CannotActivatePhysicalCardRejection']?: Omit<ResolverInputTypes['CannotActivatePhysicalCardRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CapitalDepositDocumentCanNotBeUploaded']?: Omit<ResolverInputTypes['CapitalDepositDocumentCanNotBeUploaded'], keyof ResolverInputTypes['Rejection']>;
        ['...on CapitalDepositDocumentCanNotBeUploadedRejection']?: Omit<ResolverInputTypes['CapitalDepositDocumentCanNotBeUploadedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CardCanNotBeDigitalizedRejection']?: Omit<ResolverInputTypes['CardCanNotBeDigitalizedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CardNotFoundRejection']?: Omit<ResolverInputTypes['CardNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CardProductDisabledRejection']?: Omit<ResolverInputTypes['CardProductDisabledRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CardProductNotApplicableToPhysicalCardsRejection']?: Omit<ResolverInputTypes['CardProductNotApplicableToPhysicalCardsRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CardProductNotFoundRejection']?: Omit<ResolverInputTypes['CardProductNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CardProductSuspendedRejection']?: Omit<ResolverInputTypes['CardProductSuspendedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CardProductUsedRejection']?: Omit<ResolverInputTypes['CardProductUsedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CardWrongStatusRejection']?: Omit<ResolverInputTypes['CardWrongStatusRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on CheckRejection']?: Omit<ResolverInputTypes['CheckRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ConsentNotFoundRejection']?: Omit<ResolverInputTypes['ConsentNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ConsentsAlreadyLinkedToMultiConsentRejection']?: Omit<ResolverInputTypes['ConsentsAlreadyLinkedToMultiConsentRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ConsentsNotAllInCreatedStatusRejection']?: Omit<ResolverInputTypes['ConsentsNotAllInCreatedStatusRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ConsentsNotFoundRejection']?: Omit<ResolverInputTypes['ConsentsNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ConsentTypeNotSupportedByServerConsentRejection']?: Omit<ResolverInputTypes['ConsentTypeNotSupportedByServerConsentRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on DebtorAccountClosedRejection']?: Omit<ResolverInputTypes['DebtorAccountClosedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on DebtorAccountNotAllowedRejection']?: Omit<ResolverInputTypes['DebtorAccountNotAllowedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on DigitalCardNotFoundRejection']?: Omit<ResolverInputTypes['DigitalCardNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on EnabledCardDesignNotFoundRejection']?: Omit<ResolverInputTypes['EnabledCardDesignNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ExternalAccountAlreadyExistsRejection']?: Omit<ResolverInputTypes['ExternalAccountAlreadyExistsRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ExternalAccountBalanceAlreadyExistsRejection']?: Omit<ResolverInputTypes['ExternalAccountBalanceAlreadyExistsRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on FeeSettingsNotFoundRejection']?: Omit<ResolverInputTypes['FeeSettingsNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ForbiddenRejection']?: Omit<ResolverInputTypes['ForbiddenRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on FundingLimitExceededRejection']?: Omit<ResolverInputTypes['FundingLimitExceededRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on FundingLimitSettingsChangeRequestBadAmountRejection']?: Omit<ResolverInputTypes['FundingLimitSettingsChangeRequestBadAmountRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on FundingSourceNotFoundRejection']?: Omit<ResolverInputTypes['FundingSourceNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on FundingSourceWrongStatusRejection']?: Omit<ResolverInputTypes['FundingSourceWrongStatusRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on GlobalFundingLimitExceededRejection']?: Omit<ResolverInputTypes['GlobalFundingLimitExceededRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on GlobalInstantFundingLimitExceededRejection']?: Omit<ResolverInputTypes['GlobalInstantFundingLimitExceededRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on IBANNotReachableRejection']?: Omit<ResolverInputTypes['IBANNotReachableRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on IBANNotValidRejection']?: Omit<ResolverInputTypes['IBANNotValidRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on IbanValidationRejection']?: Omit<ResolverInputTypes['IbanValidationRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on IdentityAlreadyBindToAccountMembershipRejection']?: Omit<ResolverInputTypes['IdentityAlreadyBindToAccountMembershipRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on InstantFundingLimitExceededRejection']?: Omit<ResolverInputTypes['InstantFundingLimitExceededRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on InsufficientFundsRejection']?: Omit<ResolverInputTypes['InsufficientFundsRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on InternalErrorRejection']?: Omit<ResolverInputTypes['InternalErrorRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on InvalidArgumentRejection']?: Omit<ResolverInputTypes['InvalidArgumentRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on InvalidPhoneNumberRejection']?: Omit<ResolverInputTypes['InvalidPhoneNumberRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on InvalidSirenNumberRejection']?: Omit<ResolverInputTypes['InvalidSirenNumberRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on LegalRepresentativeAccountMembershipCannotBeDisabledRejection']?: Omit<ResolverInputTypes['LegalRepresentativeAccountMembershipCannotBeDisabledRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on LegalRepresentativeAccountMembershipCannotBeSuspendedRejection']?: Omit<ResolverInputTypes['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on MerchantPaymentMethodNotActiveRejection']?: Omit<ResolverInputTypes['MerchantPaymentMethodNotActiveRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on MerchantProfileWrongStatusRejection']?: Omit<ResolverInputTypes['MerchantProfileWrongStatusRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on MissingMandatoryFieldRejection']?: Omit<ResolverInputTypes['MissingMandatoryFieldRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on NotFoundRejection']?: Omit<ResolverInputTypes['NotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on NotReachableConsentStatusRejection']?: Omit<ResolverInputTypes['NotReachableConsentStatusRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on NotSupportedCountryRejection']?: Omit<ResolverInputTypes['NotSupportedCountryRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on OnboardingNotCompletedRejection']?: Omit<ResolverInputTypes['OnboardingNotCompletedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on PaymentMandateMandateNotFoundRejection']?: Omit<ResolverInputTypes['PaymentMandateMandateNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on PaymentMandateReferenceAlreadyUsedRejection']?: Omit<ResolverInputTypes['PaymentMandateReferenceAlreadyUsedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on PaymentMethodNotCompatibleRejection']?: Omit<ResolverInputTypes['PaymentMethodNotCompatibleRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on PermissionCannotBeGrantedRejection']?: Omit<ResolverInputTypes['PermissionCannotBeGrantedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on PhysicalCardNotFoundRejection']?: Omit<ResolverInputTypes['PhysicalCardNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on PhysicalCardWrongStatusRejection']?: Omit<ResolverInputTypes['PhysicalCardWrongStatusRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on PINNotReadyRejection']?: Omit<ResolverInputTypes['PINNotReadyRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ProjectForbiddenRejection']?: Omit<ResolverInputTypes['ProjectForbiddenRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ProjectFundingLimitExceededRejection']?: Omit<ResolverInputTypes['ProjectFundingLimitExceededRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ProjectInstantFundingLimitExceededRejection']?: Omit<ResolverInputTypes['ProjectInstantFundingLimitExceededRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ProjectInvalidStatusRejection']?: Omit<ResolverInputTypes['ProjectInvalidStatusRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ProjectNotFound']?: Omit<ResolverInputTypes['ProjectNotFound'], keyof ResolverInputTypes['Rejection']>;
        ['...on ProjectNotFoundRejection']?: Omit<ResolverInputTypes['ProjectNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ProjectSettingsForbiddenError']?: Omit<ResolverInputTypes['ProjectSettingsForbiddenError'], keyof ResolverInputTypes['Rejection']>;
        ['...on ProjectSettingsNotFound']?: Omit<ResolverInputTypes['ProjectSettingsNotFound'], keyof ResolverInputTypes['Rejection']>;
        ['...on ProjectSettingsStatusNotReachable']?: Omit<ResolverInputTypes['ProjectSettingsStatusNotReachable'], keyof ResolverInputTypes['Rejection']>;
        ['...on PublicOnboardingDisabledRejection']?: Omit<ResolverInputTypes['PublicOnboardingDisabledRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ReceivedDirectDebitMandateAlreadyExistRejection']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateAlreadyExistRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ReceivedDirectDebitMandateCanceledRejection']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateCanceledRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ReceivedDirectDebitMandateNotB2bRejection']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateNotB2bRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ReceivedDirectDebitMandateNotFoundRejection']?: Omit<ResolverInputTypes['ReceivedDirectDebitMandateNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on RefundRejection']?: Omit<ResolverInputTypes['RefundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on RestrictedToUserRejection']?: Omit<ResolverInputTypes['RestrictedToUserRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SchemeWrongRejection']?: Omit<ResolverInputTypes['SchemeWrongRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ServerConsentCredentialsNotValidOrOutdatedRejection']?: Omit<ResolverInputTypes['ServerConsentCredentialsNotValidOrOutdatedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ServerConsentNotAllowedForConsentOperationRejection']?: Omit<ResolverInputTypes['ServerConsentNotAllowedForConsentOperationRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ServerConsentNotAllowedForProjectRejection']?: Omit<ResolverInputTypes['ServerConsentNotAllowedForProjectRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ServerConsentProjectCredentialMissingRejection']?: Omit<ResolverInputTypes['ServerConsentProjectCredentialMissingRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ServerConsentProjectCredentialNotFoundRejection']?: Omit<ResolverInputTypes['ServerConsentProjectCredentialNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ServerConsentProjectSettingsNotFoundRejection']?: Omit<ResolverInputTypes['ServerConsentProjectSettingsNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ServerConsentSignatureNotValidRejection']?: Omit<ResolverInputTypes['ServerConsentSignatureNotValidRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on StandingOrderNotFoundRejection']?: Omit<ResolverInputTypes['StandingOrderNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SupportingDocumentCollectionNotFoundRejection']?: Omit<ResolverInputTypes['SupportingDocumentCollectionNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection']?: Omit<ResolverInputTypes['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection']?: Omit<ResolverInputTypes['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SupportingDocumentCollectionStatusNotAllowedRejection']?: Omit<ResolverInputTypes['SupportingDocumentCollectionStatusNotAllowedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SupportingDocumentNotFoundRejection']?: Omit<ResolverInputTypes['SupportingDocumentNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SupportingDocumentStatusDoesNotAllowDeletionRejection']?: Omit<ResolverInputTypes['SupportingDocumentStatusDoesNotAllowDeletionRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SupportingDocumentStatusDoesNotAllowUpdateRejection']?: Omit<ResolverInputTypes['SupportingDocumentStatusDoesNotAllowUpdateRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SupportingDocumentStatusNotAllowedRejection']?: Omit<ResolverInputTypes['SupportingDocumentStatusNotAllowedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SupportingDocumentUploadNotAllowedRejection']?: Omit<ResolverInputTypes['SupportingDocumentUploadNotAllowedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SuspendReceivedDirectDebitMandatedRejection']?: Omit<ResolverInputTypes['SuspendReceivedDirectDebitMandatedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SwanTCUDocumentNotFoundRejection']?: Omit<ResolverInputTypes['SwanTCUDocumentNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on SwanTCUDocumentStatusNotAllowedRejection']?: Omit<ResolverInputTypes['SwanTCUDocumentStatusNotAllowedRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on TooManyChildConsentsRejection']?: Omit<ResolverInputTypes['TooManyChildConsentsRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on TooManyItemsRejection']?: Omit<ResolverInputTypes['TooManyItemsRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on TransactionNotFoundRejection']?: Omit<ResolverInputTypes['TransactionNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on UpdateUserConsentSettingsTokenRejection']?: Omit<ResolverInputTypes['UpdateUserConsentSettingsTokenRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on UserNotAllowedToDisableItsOwnAccountMembershipRejection']?: Omit<ResolverInputTypes['UserNotAllowedToDisableItsOwnAccountMembershipRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on UserNotAllowedToManageAccountMembershipRejection']?: Omit<ResolverInputTypes['UserNotAllowedToManageAccountMembershipRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on UserNotAllowedToSuspendItsOwnAccountMembershipRejection']?: Omit<ResolverInputTypes['UserNotAllowedToSuspendItsOwnAccountMembershipRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on UserNotCardHolderRejection']?: Omit<ResolverInputTypes['UserNotCardHolderRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on ValidationRejection']?: Omit<ResolverInputTypes['ValidationRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on WebhookEventLogNotFoundRejection']?: Omit<ResolverInputTypes['WebhookEventLogNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on WebhookSubscriptionNotFoundRejection']?: Omit<ResolverInputTypes['WebhookSubscriptionNotFoundRejection'], keyof ResolverInputTypes['Rejection']>;
        ['...on WrongValueProvidedRejection']?: Omit<ResolverInputTypes['WrongValueProvidedRejection'], keyof ResolverInputTypes['Rejection']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['ReleasedReason']: ReleasedReason;
    /** Released card transaction status information */
    ['ReleasedTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The date when the transaction was released */
        releaseDate?: boolean | `@${string}`;
        /** reason of the released transaction */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to replay a Webhook event */
    ['ReplayWebhookEventInput']: {
        /** The ID of a webhook Event */
        webhookEventId: string;
    };
    /** Invoke Webhook Endpoint Payload */
    ['ReplayWebhookEventPayload']: AliasType<{
        ReplayWebhookEventSuccessPayload?: ResolverInputTypes['ReplayWebhookEventSuccessPayload'];
        WebhookEventLogNotFoundRejection?: ResolverInputTypes['WebhookEventLogNotFoundRejection'];
        WebhookSubscriptionNotFoundRejection?: ResolverInputTypes['WebhookSubscriptionNotFoundRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        InvalidArgumentRejection?: ResolverInputTypes['InvalidArgumentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Invoke Webhook Endpoint Success Payload */
    ['ReplayWebhookEventSuccessPayload']: AliasType<{
        webhookEventLogEntryId?: boolean | `@${string}`;
        endpointStatus?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to a identification report */
    ['ReportDocument']: AliasType<{
        /** Unique identifier of the report document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ResolverInputTypes['ReportDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the report document */
    ['ReportDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** here is the exchange rate detail */
    ['ReportExchangeRate']: AliasType<{
        sourceCurrency?: boolean | `@${string}`;
        exchangeRate?: boolean | `@${string}`;
        unitCurrency?: boolean | `@${string}`;
        targetCurrency?: boolean | `@${string}`;
        quotationDate?: boolean | `@${string}`;
        contractIdentification?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['RequestMerchantPaymentMethodsInput']: {
        /** ID of the Merchant Profile */
        merchantProfileId: string;
        /** Input for the Internal Direct Debit Standard payment method */
        internalDirectDebitStandard?: ResolverInputTypes['InternalDirectDebitStandardPaymentMethodInput'] | undefined | null;
        /** Input for the Internal Direct Debit B2B payment method */
        internalDirectDebitB2B?: ResolverInputTypes['InternalDirectDebitB2BPaymentMethodInput'] | undefined | null;
        /** Input for the Sepa Direct Debit Core payment method */
        sepaDirectDebitCore?: ResolverInputTypes['SepaDirectDebitCorePaymentMethodInput'] | undefined | null;
        /** Input for the Sepa Direct Debit B2B payment method */
        sepaDirectDebitB2B?: ResolverInputTypes['SepaDirectDebitB2BPaymentMethodInput'] | undefined | null;
        /** Input for Check payment method */
        check?: ResolverInputTypes['CheckPaymentMethodInput'] | undefined | null;
        /** Input for Card payment method */
        card?: ResolverInputTypes['CardPaymentMethodInput'] | undefined | null;
    };
    ['RequestMerchantPaymentMethodsPayload']: AliasType<{
        RequestMerchantPaymentMethodsSuccessPayload?: ResolverInputTypes['RequestMerchantPaymentMethodsSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        NotFoundRejection?: ResolverInputTypes['NotFoundRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['RequestMerchantPaymentMethodsSuccessPayload']: AliasType<{
        merchantProfile?: ResolverInputTypes['MerchantProfile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Request Update Merchant Profile */
    ['RequestMerchantProfileUpdate']: AliasType<{
        /** The Request ID */
        id?: boolean | `@${string}`;
        /** The Merchant Profile ID to update */
        merchantProfileId?: boolean | `@${string}`;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName?: boolean | `@${string}`;
        /** Url of the merchant's website */
        merchantWebsite?: boolean | `@${string}`;
        /** Url of the merchant's logo */
        merchantLogoUrl?: boolean | `@${string}`;
        /** The status of the request */
        status?: boolean | `@${string}`;
        /** Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType?: boolean | `@${string}`;
        /** Expected annual activity volumes for all payment method */
        expectedMonthlyPaymentVolume?: ResolverInputTypes['Amount'];
        /** expected average basket value. */
        expectedAverageBasket?: ResolverInputTypes['Amount'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to update a Merchant Profile */
    ['RequestMerchantProfileUpdateInput']: {
        /** ID of the MerchantProfile to update */
        merchantProfileId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website.
    Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value. */
        merchantWebsite?: string | undefined | null;
        /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: ResolverInputTypes['ProductType'];
        /** Expected annual activity volumes for all payment methods. */
        expectedMonthlyPaymentVolume: ResolverInputTypes['AmountInput'];
        /** expected average basket value. */
        expectedAverageBasket: ResolverInputTypes['AmountInput'];
        /** base64 encoded merchant's logo.
    Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value. */
        merchantLogo?: string | undefined | null;
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page.
    Unlike the other fields in this mutation, the value specified here updates the merchant profile's accent color immediately. */
        accentColor?: string | undefined | null;
    };
    /** Add Merchant Profile Payload */
    ['RequestMerchantProfileUpdatePayload']: AliasType<{
        RequestMerchantProfileUpdateSuccessPayload?: ResolverInputTypes['RequestMerchantProfileUpdateSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Request Merchant Profile Update Statuses */
    ['RequestMerchantProfileUpdateStatus']: RequestMerchantProfileUpdateStatus;
    /** Add Merchant Profile Success Payload */
    ['RequestMerchantProfileUpdateSuccessPayload']: AliasType<{
        /** Request Update Merchant Profile */
        requestMerchantProfileUpdate?: ResolverInputTypes['RequestMerchantProfileUpdate'];
        __typename?: boolean | `@${string}`;
    }>;
    ['RequestSupportingDocumentCollectionReviewInput']: {
        /** Id of the supporting document collection to review. */
        supportingDocumentCollectionId: string;
    };
    ['RequestSupportingDocumentCollectionReviewPayload']: AliasType<{
        RequestSupportingDocumentCollectionReviewSuccessPayload?: ResolverInputTypes['RequestSupportingDocumentCollectionReviewSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        SupportingDocumentCollectionNotFoundRejection?: ResolverInputTypes['SupportingDocumentCollectionNotFoundRejection'];
        SupportingDocumentCollectionStatusNotAllowedRejection?: ResolverInputTypes['SupportingDocumentCollectionStatusNotAllowedRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['RequestSupportingDocumentCollectionReviewSuccessPayload']: AliasType<{
        supportingDocumentCollection?: ResolverInputTypes['SupportingDocumentCollection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The document corresponding to a residence permit */
    ['ResidencePermitDocument']: AliasType<{
        /** Unique identifier of the residence permit document */
        id?: boolean | `@${string}`;
        /** The type of the document */
        type?: boolean | `@${string}`;
        /** The date at which the residence permit was issued */
        issueDate?: boolean | `@${string}`;
        /** The date at which the residence permit expires */
        expiryDate?: boolean | `@${string}`;
        /** Machine-readable zone code of the residence permit */
        mrz?: boolean | `@${string}`;
        /** Number of the residence permit */
        number?: boolean | `@${string}`;
        /** List of the associated files */
        files?: ResolverInputTypes['ResidencePermitDocumentFile'];
        __typename?: boolean | `@${string}`;
    }>;
    /** The file associated to the resident permit document */
    ['ResidencePermitDocumentFile']: AliasType<{
        /** The file's temporary download url */
        downloadUrl?: boolean | `@${string}`;
        /** From which side the residence permit's picture was taken */
        side?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ResidencyAddressInput']: {
        /** Address line 1. Length must be from 0 to 255 characters */
        addressLine1?: string | undefined | null;
        /** AddressLine2. Length must be from 0 to 255 characters */
        addressLine2?: string | undefined | null;
        /** City. Length must be from 0 to 100 characters */
        city?: string | undefined | null;
        /** Postal code. Length must be from 0 to 50 characters */
        postalCode?: string | undefined | null;
        /** State of residency. Length must be from 0 to 100 characters */
        state?: string | undefined | null;
        /** Country */
        country?: ResolverInputTypes['CCA3'] | undefined | null;
    };
    /** Account membership restricted to */
    ['RestrictedTo']: AliasType<{
        /** first name */
        firstName?: boolean | `@${string}`;
        /** last name */
        lastName?: boolean | `@${string}`;
        /** birth date */
        birthDate?: boolean | `@${string}`;
        /** phone number */
        phoneNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input when the account membership is restricted to a verified user */
    ['RestrictedToInput']: {
        /** Account member first name */
        firstName: string;
        /** Account member last name */
        lastName: string;
        /** Account member birth date */
        birthDate?: ResolverInputTypes['Date'] | undefined | null;
        /** Account member phone number */
        phoneNumber: ResolverInputTypes['PhoneNumber'];
    };
    /** Rejection returned if the mutation cannot be executed in another context than user */
    ['RestrictedToUserRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ResumeAccountMembershipInput']: {
        /** Unique identifier of a given account membership to resume */
        accountMembershipId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ResumeAccountMembershipPayload']: AliasType<{
        ResumeAccountMembershipSuccessPayload?: ResolverInputTypes['ResumeAccountMembershipSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        UserNotAllowedToManageAccountMembershipRejection?: ResolverInputTypes['UserNotAllowedToManageAccountMembershipRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ResumeAccountMembershipSuccessPayload']: AliasType<{
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to resume a physical card */
    ['ResumePhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ResumePhysicalCardPayload']: AliasType<{
        ResumePhysicalCardSuccessPayload?: ResolverInputTypes['ResumePhysicalCardSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        UserNotCardHolderRejection?: ResolverInputTypes['UserNotCardHolderRejection'];
        PhysicalCardNotFoundRejection?: ResolverInputTypes['PhysicalCardNotFoundRejection'];
        PhysicalCardWrongStatusRejection?: ResolverInputTypes['PhysicalCardWrongStatusRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ResumePhysicalCardSuccessPayload']: AliasType<{
        /** The physicalCard to resume */
        physicalCard?: ResolverInputTypes['PhysicalCard'];
        /** The consent required to resume a physical card */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Percentage over a number of business days, that is applied to all funds collected to compute a Reserved amount
  This amount cannot be used over the corresponding business days */
    ['RollingReserve']: AliasType<{
        /** Percentage of the funding amount to be reserved */
        percentage?: boolean | `@${string}`;
        /** Number of business days the computed amount is reserved */
        rollingDays?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ScheduleStandingOrderInput']: {
        /** Fix Amount that will be periodically transferred
         *the value must be empty when `targetAvailableBalance` is defined* */
        amount?: ResolverInputTypes['AmountInput'] | undefined | null;
        /** Target available balance that will be used for periodically clipping the account
         *the value must be empty when `amount` is defined* */
        targetAvailableBalance?: ResolverInputTypes['AmountInput'] | undefined | null;
        /** Scheduled period of Standing Order */
        period: ResolverInputTypes['StandingOrderPeriod'];
        /** Earlier date the Standing Order will be executed */
        firstExecutionDate?: ResolverInputTypes['DateTime'] | undefined | null;
        /** Latest date the Standing Order will be executed */
        lastExecutionDate?: ResolverInputTypes['DateTime'] | undefined | null;
        /** SEPA beneficiary of the Standing ORder */
        sepaBeneficiary?: ResolverInputTypes['SepaBeneficiaryInput'] | undefined | null;
        /** Account the Standing Order will be attached to */
        accountId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined | null;
        /** label (max 140 characters) */
        label?: string | undefined | null;
        /** Transfer mode of the Standing Order */
        creditTransferMode?: ResolverInputTypes['CreditTransferMode'] | undefined | null;
    };
    ['ScheduleStandingOrderPayload']: AliasType<{
        ScheduleStandingOrderSuccessPayload?: ResolverInputTypes['ScheduleStandingOrderSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        InvalidArgumentRejection?: ResolverInputTypes['InvalidArgumentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ScheduleStandingOrderSuccessPayload']: AliasType<{
        standingOrder?: ResolverInputTypes['StandingOrder'];
        __typename?: boolean | `@${string}`;
    }>;
    ['Scheme']: AliasType<{
        fields?: ResolverInputTypes['Field'];
        title?: boolean | `@${string}`;
        type?: boolean | `@${string}`;
        remainingFieldsToRefreshCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when adding a B2B mandate with an Individual debtor */
    ['SchemeWrongRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SelectField']: AliasType<{
        key?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        refreshDynamicFieldsOnChange?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        allowedValues?: ResolverInputTypes['AllowedValue'];
        __typename?: boolean | `@${string}`;
    }>;
    /** External Beneficiary type SEPA */
    ['SEPABeneficiary']: AliasType<{
        /** unique identifier of a beneficiary
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        id?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** `true` if this new beneficiary is the account holder himself in an other financial institution.
    *SOON TO BE DEPRECATED*
    Not used. It will be removed soon. */
        isMyOwnIban?: boolean | `@${string}`;
        /** beneficiary address */
        address?: ResolverInputTypes['Address'];
        /** maskedIBAN if the beneficiary is a an account in an other financial institution */
        maskedIBAN?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa beneficiary account */
    ['SepaBeneficiaryInput']: {
        /** International Bank Account Number */
        iban: ResolverInputTypes['IBAN'];
        /** Full name of the beneficiary (min 2 characters, max 70 characters). The name should not include any special characters. */
        name: string;
        /** beneficiary address */
        address?: ResolverInputTypes['AddressInput'] | undefined | null;
        /** `true` if this new beneficiary is the account holder himself in another financial institution. */
        isMyOwnIban: boolean;
        /** `true` if this new beneficiary will be saved to the beneficiary list of the debited account. */
        save: boolean;
    };
    /** SEPA Creditor Identifier
  format :
      1 – 2: ISO Country Code
      3 – 4: Check Digit
      5 – 7: Creditor Business Code – you (Creditor) choose this. The default is ZZZ
      8 - 35: Creditor National Identifier – a consecutive number that will be assigned by country
  example:
      FR11ABC123456 */
    ['SepaCreditorIdentifier']: unknown;
    /** Sepa Credit Transfer Creditor */
    ['SEPACreditTransferCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        ['...on SEPACreditTransferInCreditor']?: Omit<ResolverInputTypes['SEPACreditTransferInCreditor'], keyof ResolverInputTypes['SEPACreditTransferCreditor']>;
        ['...on SEPACreditTransferInternalOutCreditor']?: Omit<ResolverInputTypes['SEPACreditTransferInternalOutCreditor'], keyof ResolverInputTypes['SEPACreditTransferCreditor']>;
        ['...on SEPACreditTransferOutCreditor']?: Omit<ResolverInputTypes['SEPACreditTransferOutCreditor'], keyof ResolverInputTypes['SEPACreditTransferCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Debtor */
    ['SEPACreditTransferDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        ['...on SEPACreditTransferInDebtor']?: Omit<ResolverInputTypes['SEPACreditTransferInDebtor'], keyof ResolverInputTypes['SEPACreditTransferDebtor']>;
        ['...on SEPACreditTransferInternalInDebtor']?: Omit<ResolverInputTypes['SEPACreditTransferInternalInDebtor'], keyof ResolverInputTypes['SEPACreditTransferDebtor']>;
        ['...on SEPACreditTransferOutDebtor']?: Omit<ResolverInputTypes['SEPACreditTransferOutDebtor'], keyof ResolverInputTypes['SEPACreditTransferDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Creditor for Incoming transaction */
    ['SEPACreditTransferInCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Debtor for Incoming transaction */
    ['SEPACreditTransferInDebtor']: AliasType<{
        /** full name of the debtor (max 70 characters) */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** *SOON TO BE DEPRECATED*
  Sepa Credit Transfer Debtor for Incoming transaction */
    ['SEPACreditTransferInternalInDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** *SOON TO BE DEPRECATED*
  Sepa Credit Transfer Creditor for internal transaction */
    ['SEPACreditTransferInternalOutCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ResolverInputTypes['InternalBeneficiary'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Creditor for Outgoing transaction */
    ['SEPACreditTransferOutCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ResolverInputTypes['SEPABeneficiary'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer Debtor for internal transaction */
    ['SEPACreditTransferOutDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Credit Transfer transaction */
    ['SEPACreditTransferTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ResolverInputTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ResolverInputTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ResolverInputTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ResolverInputTypes['SEPACreditTransferCreditor'];
        /** debtor information */
        debtor?: ResolverInputTypes['SEPACreditTransferDebtor'];
        /** matching account for the transaction */
        account?: ResolverInputTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ResolverInputTypes['Transaction'];
        /** r-transaction reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** SepaDirectDebitB2BMerchantPaymentMethod */
    ['SepaDirectDebitB2BMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ResolverInputTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ResolverInputTypes['RollingReserve'];
        /** Whether this payment method uses the Swan Sepa Creditor Identifier */
        useSwanSepaCreditorIdentifier?: boolean | `@${string}`;
        /** When the above is false, the value of the Sepa Creditor Identifier used */
        sepaCreditorIdentifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SepaDirectDebitB2BPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Enabled */
        activate?: boolean | undefined | null;
        /** If `true`, the transaction will be created with the Swan Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty) */
        sepaCreditorIdentifier?: string | undefined | null;
    };
    /** SepaDirectDebitCoreMerchantPaymentMethod */
    ['SepaDirectDebitCoreMerchantPaymentMethod']: AliasType<{
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id?: boolean | `@${string}`;
        /** The Merchant Payment Method Type */
        type?: boolean | `@${string}`;
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId?: boolean | `@${string}`;
        /** Status of the Merchant Payment Method */
        statusInfo?: ResolverInputTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version?: boolean | `@${string}`;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt?: boolean | `@${string}`;
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ResolverInputTypes['RollingReserve'];
        /** Whether this payment method uses the Swan Sepa Creditor Identifier */
        useSwanSepaCreditorIdentifier?: boolean | `@${string}`;
        /** When the above is false, the value of the Sepa Creditor Identifier used */
        sepaCreditorIdentifier?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SepaDirectDebitCorePaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined | null;
        /** If `true`, the transaction will be created with the Swan Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty) */
        sepaCreditorIdentifier?: string | undefined | null;
    };
    /** Sepa Direct Debit Creditor */
    ['SEPADirectDebitCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        ['...on SEPADirectDebitInCreditor']?: Omit<ResolverInputTypes['SEPADirectDebitInCreditor'], keyof ResolverInputTypes['SEPADirectDebitCreditor']>;
        ['...on SEPADirectDebitOutCreditor']?: Omit<ResolverInputTypes['SEPADirectDebitOutCreditor'], keyof ResolverInputTypes['SEPADirectDebitCreditor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debit Debtor */
    ['SEPADirectDebitDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        ['...on SEPADirectDebitInDebtor']?: Omit<ResolverInputTypes['SEPADirectDebitInDebtor'], keyof ResolverInputTypes['SEPADirectDebitDebtor']>;
        ['...on SEPADirectDebitOutDebtor']?: Omit<ResolverInputTypes['SEPADirectDebitOutDebtor'], keyof ResolverInputTypes['SEPADirectDebitDebtor']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debit Creditor for Input transaction */
    ['SEPADirectDebitInCreditor']: AliasType<{
        /** full name of the creditor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debtor for Input transaction */
    ['SEPADirectDebitInDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ResolverInputTypes['SEPABeneficiary'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SEPADirectDebitMandate']: AliasType<{
        /** Unique identifier of the received direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        ['...on SEPAPaymentDirectDebitMandate']?: Omit<ResolverInputTypes['SEPAPaymentDirectDebitMandate'], keyof ResolverInputTypes['SEPADirectDebitMandate']>;
        ['...on SEPAReceivedDirectDebitMandate']?: Omit<ResolverInputTypes['SEPAReceivedDirectDebitMandate'], keyof ResolverInputTypes['SEPADirectDebitMandate']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debit Creditor for Outgoing transaction */
    ['SEPADirectDebitOutCreditor']: AliasType<{
        /** full name of the creditor (max 70 characters) */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ResolverInputTypes['SEPABeneficiary'];
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Sepa Direct Debtor for Outgoing transaction */
    ['SEPADirectDebitOutDebtor']: AliasType<{
        /** full name of the debtor */
        name?: boolean | `@${string}`;
        /** maskedIBAN */
        maskedIBAN?: boolean | `@${string}`;
        /** IBAN */
        IBAN?: boolean | `@${string}`;
        /** BIC */
        BIC?: boolean | `@${string}`;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: boolean | `@${string}`;
        /** account number */
        accountNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SepaDirectDebitPaymentCollectionInput']: {
        /** Payment Mandate ID generated by Swan */
        mandateId: string;
        /** Date at which the Swan merchant wishes the payment to be executed */
        requestedExecutionAt?: ResolverInputTypes['DateTime'] | undefined | null;
    };
    /** Scheme that will be used to create the underlying payment mandate for this funding source */
    ['SEPADirectDebitScheme']: SEPADirectDebitScheme;
    /** Sepa Direct Debit transaction */
    ['SEPADirectDebitTransaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ResolverInputTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ResolverInputTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ResolverInputTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** creditor information */
        creditor?: ResolverInputTypes['SEPADirectDebitCreditor'];
        /** debtor information */
        debtor?: ResolverInputTypes['SEPADirectDebitDebtor'];
        /** matching account for the transaction */
        account?: ResolverInputTypes['Account'];
        /** matching SEPA mandate for the transaction */
        mandate?: ResolverInputTypes['SEPADirectDebitMandate'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ResolverInputTypes['Transaction'];
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: ResolverInputTypes['Amount'];
        /** date on which reserved funds become available. */
        reservedAmountReleasedAt?: boolean | `@${string}`;
        /** r-transaction reason */
        returnReason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Payment direct debit mandate for SEPA */
    ['SEPAPaymentDirectDebitMandate']: AliasType<{
        /** Unique identifier of the SEPA Direct Debit Payment Mandate */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['TransactionsOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['TransactionsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TransactionConnection']
        ];
        /** Unique reference of the SEPA Direct Debit Payment Mandate */
        reference?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate scheme */
        scheme?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate status information */
        statusInfo?: ResolverInputTypes['PaymentMandateStatusInfo'];
        /** SEPA Direct Debit Payment Mandate sequence */
        sequence?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate PDF document URL */
        mandateDocumentUrl?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor information */
        debtor?: ResolverInputTypes['SEPAPaymentMandateDebtor'];
        /** SEPA direct debit ultimate creditor name */
        ultimateCreditorName?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate creditor information */
        creditor?: ResolverInputTypes['SEPAPaymentMandateCreditor'];
        /** Signature date of the SEPA Direct Debit Payment Mandate */
        signatureDate?: boolean | `@${string}`;
        /** Creation date of the SEPA Direct Debit Payment Mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the SEPA Direct Debit Payment Mandate */
        updatedAt?: boolean | `@${string}`;
        /** Date of the the last transaction executed for the concerned SEPA Direct Debit Payment Mandate */
        executedAt?: boolean | `@${string}`;
        /** Expiry date of the SEPA Direct Debit Payment Mandate */
        expiredAt?: boolean | `@${string}`;
        /** Account Holder information */
        accountHolder?: ResolverInputTypes['AccountHolder'];
        /** Custom name of the mandate */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SEPAPaymentMandateCreditor']: AliasType<{
        /** SEPA Direct Debit Payment Mandate creditor UUID */
        id?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate Sepa Creditor Idenfier (SCI) */
        identifier?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate creditor name */
        name?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate creditor address */
        address?: ResolverInputTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SEPAPaymentMandateDebtor']: AliasType<{
        /** SEPA Direct Debit Payment Mandate debtor name */
        name?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor IBAN */
        iban?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor e-mail */
        email?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor country */
        country?: boolean | `@${string}`;
        /** SEPA Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        address?: ResolverInputTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SepaPaymentMandateDebtorInput']: {
        /** SEPA Direct Debit Payment Mandate debtor name */
        name: string;
        /** SEPA Direct Debit Payment Mandate debtor IBAN */
        IBAN: string;
        address: ResolverInputTypes['AddressInput'];
    };
    ['SEPAPaymentMandateScheme']: SEPAPaymentMandateScheme;
    /** SEPA Direct Debit Payment Mandate Sequence */
    ['SEPAPaymentMandateSequence']: SEPAPaymentMandateSequence;
    /** Received direct debit mandate for SEPA */
    ['SEPAReceivedDirectDebitMandate']: AliasType<{
        /** Unique identifier of the received SEPA direct debit mandate, generated by Swan */
        id?: boolean | `@${string}`;
        transactions?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['TransactionsOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['TransactionsFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['TransactionConnection']
        ];
        /** Version of the received SEPA direct debit mandate */
        version?: boolean | `@${string}`;
        /** Creation date of the received SEPA direct debit mandate */
        createdAt?: boolean | `@${string}`;
        /** Last Update date of the received SEPA direct debit mandate */
        updatedAt?: boolean | `@${string}`;
        /** Received SEPA direct debit Unique Mandate Reference (UMR) */
        reference?: boolean | `@${string}`;
        /** Received SEPA direct debit mandate scheme */
        scheme?: boolean | `@${string}`;
        /** Received SEPA direct debit mandate sequence */
        sequence?: boolean | `@${string}`;
        /** Received SEPA direct debit creditor */
        creditor?: ResolverInputTypes['SEPAReceivedDirectDebitMandateCreditor'];
        /** Received SEPA direct debit ultimate creditor name */
        ultimateCreditorName?: boolean | `@${string}`;
        /** Date of the last SEPA direct debit transaction executed for the concerned received SEPA direct debit mandate */
        executedAt?: boolean | `@${string}`;
        /** Date of signature of the received SEPA direct debit mandate */
        signatureDate?: boolean | `@${string}`;
        /** Expiry date of the received SEPA direct debit mandate, computed automatically (36 months from the executedAt date) */
        expiredAt?: boolean | `@${string}`;
        /** Mandate status information of the received SEPA direct debit mandate */
        statusInfo?: ResolverInputTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Account of the received SEPA direct debit mandate debtor */
        account?: ResolverInputTypes['Account'];
        /** Iban of the received SEPA direct debit mandate debtor */
        iban?: boolean | `@${string}`;
        /** Mandate name */
        name?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** SEPA received direct debit mandate creditor */
    ['SEPAReceivedDirectDebitMandateCreditor']: AliasType<{
        /** SEPA Creditor identifier (SCI) */
        identifier?: boolean | `@${string}`;
        /** Name of the SEPA creditor */
        name?: boolean | `@${string}`;
        /** Address of the SEPA creditor */
        address?: ResolverInputTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Received SEPA direct debit mandate scheme */
    ['SEPAReceivedDirectDebitMandateScheme']: SEPAReceivedDirectDebitMandateScheme;
    /** SEPA received direct debit mandate sequence */
    ['SEPAReceivedDirectDebitMandateSequence']: SEPAReceivedDirectDebitMandateSequence;
    /** SEPA Identifier
  max 35 Latin characters as follow :
      a b c d e f g h i j k l m n o p q r s t u v w x y z
      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
      0 1 2 3 4 5 6 7 8 9
      / - ? : ( ) . , '  +
  with some follow extra rules :
      Content must not start or end with a ‘/’
      Content must not contain ‘//’s */
    ['SepaReference']: unknown;
    /** Rejection returned when signature is not valid or remote IP address is not allowed */
    ['ServerConsentCredentialsNotValidOrOutdatedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when server consent is not allowed on the consent */
    ['ServerConsentNotAllowedForConsentOperationRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when server consent is not allowed for the project associated with the consent */
    ['ServerConsentNotAllowedForProjectRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when there are no server consent credentials for the project */
    ['ServerConsentProjectCredentialMissingRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the server consent project credentials are not found */
    ['ServerConsentProjectCredentialNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the server consent project settings are not found */
    ['ServerConsentProjectSettingsNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the signature is not valid
  @Deprecated */
    ['ServerConsentSignatureNotValidRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Shareholder of a company creating a Capital Deposit Case */
    ['Shareholder']: AliasType<{
        /** Unique identifier of a shareholder. */
        id?: boolean | `@${string}`;
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount?: ResolverInputTypes['Amount'];
        /** Onboarding information of the shareholder. */
        onboarding?: ResolverInputTypes['Onboarding'];
        /** Unique identifier of the shareholder account. */
        accountId?: boolean | `@${string}`;
        /** Status of the shareholder during the process with Swan. */
        status?: boolean | `@${string}`;
        /** Extra information about the shareholder */
        info?: ResolverInputTypes['ShareholderInfo'];
        /** Shareholder documents for the capital deposit case */
        documents?: ResolverInputTypes['CapitalDepositDocument'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** Information about capital deposit case. */
        relatedCapitalDepositCase?: ResolverInputTypes['CapitalDepositCase'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Shareholder information. */
    ['ShareholderInfo']: AliasType<{
        IndividualShareholder?: ResolverInputTypes['IndividualShareholder'];
        CompanyShareholder?: ResolverInputTypes['CompanyShareholder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Status of the shareholder during the process with Swan. */
    ['ShareholderStatus']: ShareholderStatus;
    /** Shareholder type to identify individuals and companies. */
    ['ShareholderType']: ShareholderType;
    /** Signature data used during apple pay inApp provisioning */
    ['SignatureData']: {
        /** nonce */
        nonce: string;
        /** nonce signed by the secure element */
        nonceSignature: string;
        /** list of apple generated certificates */
        certificates: Array<ResolverInputTypes['Certificate']>;
    };
    ['SimulationCardType']: SimulationCardType;
    ['SingleUseVirtualCardConfigInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card name */
        name?: string | undefined | null;
        /** Spending limit */
        spendingLimit: ResolverInputTypes['SpendingLimitInput'];
    };
    /** Spending */
    ['Spending']: AliasType<{
        /** period concerned */
        period?: boolean | `@${string}`;
        /** amount spent during the period */
        amount?: ResolverInputTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Spending limits */
    ['SpendingLimit']: AliasType<{
        /** type of limit (defined by the Partner, defined by Swan, etc.) */
        type?: boolean | `@${string}`;
        /** period concerned */
        period?: boolean | `@${string}`;
        /** sum of amount of spending authorized during the period */
        amount?: ResolverInputTypes['Amount'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs when editing spending limit configuration */
    ['SpendingLimitInput']: {
        /** period concerned */
        period: ResolverInputTypes['SpendingLimitPeriodInput'];
        /** sum of amount of spending authorized during the period */
        amount: ResolverInputTypes['AmountInput'];
    };
    /** Available period to compute spending limits */
    ['SpendingLimitPeriod']: SpendingLimitPeriod;
    /** Available period to compute spending limits */
    ['SpendingLimitPeriodInput']: SpendingLimitPeriodInput;
    /** Available type of spending limits */
    ['SpendingLimitType']: SpendingLimitType;
    ['StandingOrder']: AliasType<{
        /** Standing Order unique identifier */
        id?: boolean | `@${string}`;
        payments?: [
            {
                /** the number of elements to load (default value 50, maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                offset?: number | undefined | null; /** an order you can apply to your list of connections (default value UpdatedAt desc) */
                orderBy?: ResolverInputTypes['PaymentOrderByInput'] | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['PaymentFiltersInput'] | undefined | null;
            },
            ResolverInputTypes['PaymentConnection']
        ];
        /** reference that will be transferred to the beneficiary throughout the entire end-to-end chain */
        reference?: boolean | `@${string}`;
        /** label that will be transferred to the beneficiary */
        label?: boolean | `@${string}`;
        /** Fixed Amount that will be regularly transferred */
        amount?: ResolverInputTypes['Amount'];
        /** Target available balance value that will be used for periodically clipping the account */
        targetAvailableBalance?: ResolverInputTypes['Amount'];
        /** Scheduled period of Standing Order */
        period?: boolean | `@${string}`;
        /** Earlier date the Standing Order will be executed */
        firstExecutionDate?: boolean | `@${string}`;
        /** Latest date the Standing Order will be executed */
        lastExecutionDate?: boolean | `@${string}`;
        /** SEPA beneficiary of the Standing Order */
        sepaBeneficiary?: ResolverInputTypes['SEPABeneficiary'];
        /** Status of the Standing Order */
        statusInfo?: ResolverInputTypes['StandingOrderStatusInfo'];
        /** Date the Standing Order has been created */
        createdAt?: boolean | `@${string}`;
        /** Last date the Standing Order has been updated */
        updatedAt?: boolean | `@${string}`;
        /** Account of the Standing Order */
        account?: ResolverInputTypes['Account'];
        /** Identity that scheduled the Standing Order */
        createdBy?: ResolverInputTypes['User'];
        /** Next execution date of the Standing Order, if any */
        nextExecutionDate?: boolean | `@${string}`;
        /** Transfer mode of the Standing Order */
        creditTransferMode?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['StandingOrderCanceledStatusInfo']: AliasType<{
        canceledAt?: boolean | `@${string}`;
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['StandingOrderConnection']: AliasType<{
        pageInfo?: ResolverInputTypes['PageInfo'];
        edges?: ResolverInputTypes['StandingOrderEdge'];
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['StandingOrderConsentPendingStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['StandingOrderEdge']: AliasType<{
        node?: ResolverInputTypes['StandingOrder'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['StandingOrderEnabledStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when Standing Order is not found */
    ['StandingOrderNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['StandingOrderPeriod']: StandingOrderPeriod;
    ['StandingOrderStatus']: StandingOrderStatus;
    ['StandingOrderStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        ['...on StandingOrderCanceledStatusInfo']?: Omit<ResolverInputTypes['StandingOrderCanceledStatusInfo'], keyof ResolverInputTypes['StandingOrderStatusInfo']>;
        ['...on StandingOrderConsentPendingStatusInfo']?: Omit<ResolverInputTypes['StandingOrderConsentPendingStatusInfo'], keyof ResolverInputTypes['StandingOrderStatusInfo']>;
        ['...on StandingOrderEnabledStatusInfo']?: Omit<ResolverInputTypes['StandingOrderEnabledStatusInfo'], keyof ResolverInputTypes['StandingOrderStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes an identification level that has started for the process of the current identification */
    ['StartedIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Started` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** A statement represent metadata around a banking document that list all of the BOOKED banking transactions that have happened between startDate and endDate */
    ['Statement']: AliasType<{
        /** unique identifier of the statement */
        id?: boolean | `@${string}`;
        /** account of the statement */
        account?: ResolverInputTypes['Account'];
        /** booked balance at the start of the window */
        openingBalance?: ResolverInputTypes['Amount'];
        /** booked balance at the end of the window */
        closingBalance?: ResolverInputTypes['Amount'];
        /** starting date of the date window */
        openingDate?: boolean | `@${string}`;
        /** ending date of the date window */
        closingDate?: boolean | `@${string}`;
        /** status of the statement */
        status?: boolean | `@${string}`;
        /** period of statement (either custom or monthly) */
        period?: boolean | `@${string}`;
        /** the sum of credit transactions during the window */
        totalCredits?: ResolverInputTypes['Amount'];
        /** the sum of debit transactions during the window */
        totalDebits?: ResolverInputTypes['Amount'];
        /** the sum of fee transactions during the window */
        fees?: ResolverInputTypes['Amount'];
        /** type of statements (ex: PDF) */
        type?: ResolverInputTypes['StatementInfo'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)). */
    ['StatementConnection']: AliasType<{
        pageInfo?: ResolverInputTypes['PageInfo'];
        totalCount?: boolean | `@${string}`;
        edges?: ResolverInputTypes['StatementEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface. */
    ['StatementEdge']: AliasType<{
        node?: ResolverInputTypes['Statement'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filter that can be given to give the statement in a specific data range */
    ['StatementFiltersInput']: {
        /** To filter after an updatedAt value */
        isAfterUpdatedAt?: ResolverInputTypes['DateTime'] | undefined | null;
        /** To filter before an updatedAt value */
        isBeforeUpdatedAt?: ResolverInputTypes['DateTime'] | undefined | null;
        /** To filter on a specific period of statement (either custom or monthly) */
        period?: ResolverInputTypes['StatementPeriod'] | undefined | null;
    };
    /** Custom information for a certain type of statement */
    ['StatementInfo']: AliasType<{
        type?: boolean | `@${string}`;
        ['...on CsvStatement']?: Omit<ResolverInputTypes['CsvStatement'], keyof ResolverInputTypes['StatementInfo']>;
        ['...on PdfStatement']?: Omit<ResolverInputTypes['PdfStatement'], keyof ResolverInputTypes['StatementInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** The different periods of statement */
    ['StatementPeriod']: StatementPeriod;
    /** The different statuses of statement */
    ['StatementStatus']: StatementStatus;
    /** The different type of statement actually available
  - PDF will be a PDF file with the statement information */
    ['StatementType']: StatementType;
    ['StatusText']: StatusText;
    /** Supporting document used for compliance */
    ['SupportingDocument']: AliasType<{
        /** Unique identifier of the document */
        id?: boolean | `@${string}`;
        /** Supporting document status information */
        statusInfo?: ResolverInputTypes['SupportingDocumentStatusInfo'];
        /** Type of supporting Document */
        supportingDocumentType?: boolean | `@${string}`;
        /** Purpose of supporting document */
        supportingDocumentPurpose?: boolean | `@${string}`;
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentAccountHolder']: AliasType<{
        id?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Collection of supporting documents used for compliance
  
  Fetching SupportingDocument is restricted to Project access token */
    ['SupportingDocumentCollection']: AliasType<{
        /** Unique identifier of the supporting document collection */
        id?: boolean | `@${string}`;
        /** Status of the supporting document collection */
        statusInfo?: ResolverInputTypes['SupportingDocumentCollectionStatusInfo'];
        /** Created date */
        createdAt?: boolean | `@${string}`;
        /** Updated date */
        updatedAt?: boolean | `@${string}`;
        /** List of supported documents contained in the supporting document collection */
        supportingDocuments?: ResolverInputTypes['SupportingDocument'];
        /** List of required supporting document purposes for this supporting document collection */
        requiredSupportingDocumentPurposes?: ResolverInputTypes['SupportingDocumentPurpose'];
        accountHolder?: ResolverInputTypes['SupportingDocumentAccountHolder'];
        onboarding?: ResolverInputTypes['SupportingDocumentOnboarding'];
        projectInfo?: ResolverInputTypes['ProjectInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with Approved status */
    ['SupportingDocumentCollectionApprovedStatusInfo']: AliasType<{
        /** When the supporting document collection is approved */
        status?: boolean | `@${string}`;
        /** Date on which the supporting document collection has been approved */
        approvedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with Canceled status */
    ['SupportingDocumentCollectionCanceledStatusInfo']: AliasType<{
        /** When the supporting document collection is canceled */
        status?: boolean | `@${string}`;
        /** Date on which the supporting document collection has been canceled */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['SupportingDocumentCollectionConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** SupportingDocumentCollectionEdge list */
        edges?: ResolverInputTypes['SupportingDocumentCollectionEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['SupportingDocumentCollectionEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The supporting document collection */
        node?: ResolverInputTypes['SupportingDocumentCollection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the supporting document collection was not found */
    ['SupportingDocumentCollectionNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with PendingReview status */
    ['SupportingDocumentCollectionPendingReviewStatusInfo']: AliasType<{
        /** When the supporting document collection is completed and in compliance review */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with Rejected status */
    ['SupportingDocumentCollectionRejectedStatusInfo']: AliasType<{
        /** When the supporting document collection is rejected */
        status?: boolean | `@${string}`;
        /** Date on which the supporting document collection has been rejected */
        rejectedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Verification status of a supporting document collection */
    ['SupportingDocumentCollectionStatus']: SupportingDocumentCollectionStatus;
    /** Rejection returned if supporting document cannot be deleted because its supporting document collection status is not WaitingForDocument */
    ['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection']: AliasType<{
        message?: boolean | `@${string}`;
        supportingDocumentCollectionStatus?: boolean | `@${string}`;
        supportingDocumentCollection?: ResolverInputTypes['SupportingDocumentCollection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if supporting document cannot be updated because its supporting document collection status is not WaitingForDocument */
    ['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection']: AliasType<{
        message?: boolean | `@${string}`;
        supportingDocumentCollectionStatus?: boolean | `@${string}`;
        supportingDocumentCollection?: ResolverInputTypes['SupportingDocumentCollection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentCollectionStatusInfo']: AliasType<{
        /** Status of the supporting document collection */
        status?: boolean | `@${string}`;
        ['...on SupportingDocumentCollectionApprovedStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentCollectionApprovedStatusInfo'], keyof ResolverInputTypes['SupportingDocumentCollectionStatusInfo']>;
        ['...on SupportingDocumentCollectionCanceledStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentCollectionCanceledStatusInfo'], keyof ResolverInputTypes['SupportingDocumentCollectionStatusInfo']>;
        ['...on SupportingDocumentCollectionPendingReviewStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentCollectionPendingReviewStatusInfo'], keyof ResolverInputTypes['SupportingDocumentCollectionStatusInfo']>;
        ['...on SupportingDocumentCollectionRejectedStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentCollectionRejectedStatusInfo'], keyof ResolverInputTypes['SupportingDocumentCollectionStatusInfo']>;
        ['...on SupportingDocumentCollectionWaitingForDocumentStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentCollectionWaitingForDocumentStatusInfo'], keyof ResolverInputTypes['SupportingDocumentCollectionStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the status transition is not allowed */
    ['SupportingDocumentCollectionStatusNotAllowedRejection']: AliasType<{
        oldStatus?: boolean | `@${string}`;
        newStatus?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document collection with WaitingForUpload status */
    ['SupportingDocumentCollectionWaitingForDocumentStatusInfo']: AliasType<{
        /** When the Supporting Document Collection is created */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentCollectMode']: SupportingDocumentCollectMode;
    ['SupportingDocumentCommunicationLanguageSettings']: SupportingDocumentCommunicationLanguageSettings;
    /** Rejection returned if the supporting document was not found */
    ['SupportingDocumentNotFoundRejection']: AliasType<{
        id?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document with NotUploaded status. */
    ['SupportingDocumentNotUploadedStatusInfo']: AliasType<{
        /** When the document has not been updated on time. */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentOnboarding']: AliasType<{
        id?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentPostField']: AliasType<{
        key?: boolean | `@${string}`;
        value?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Details of a supporting document purpose */
    ['SupportingDocumentPurpose']: AliasType<{
        /** Technical name of the purpose */
        name?: boolean | `@${string}`;
        /** Corresponding supporting document types accepted for this supporting document purpose */
        acceptableSupportingDocumentTypes?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document purpose */
    ['SupportingDocumentPurposeEnum']: SupportingDocumentPurposeEnum;
    /** Supporting document with Refused status */
    ['SupportingDocumentRefusedStatusInfo']: AliasType<{
        /** When the document has been refused by Swan */
        status?: boolean | `@${string}`;
        /** An unique URL and one-time URL to download the Document */
        downloadUrl?: boolean | `@${string}`;
        /** Date on which the supporting document collection has been refused */
        refusedAt?: boolean | `@${string}`;
        /** Reason why the supporting document has been refused */
        reason?: boolean | `@${string}`;
        /** Original file name */
        filename?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentSettings']: AliasType<{
        collectMode?: boolean | `@${string}`;
        communicationLanguage?: boolean | `@${string}`;
        emailContact?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Verification status of a document */
    ['SupportingDocumentStatus']: SupportingDocumentStatus;
    /** Rejection returned if supporting document cannot be deleted because of its status */
    ['SupportingDocumentStatusDoesNotAllowDeletionRejection']: AliasType<{
        supportingDocument?: ResolverInputTypes['SupportingDocument'];
        status?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if supporting document cannot be updated because of its status */
    ['SupportingDocumentStatusDoesNotAllowUpdateRejection']: AliasType<{
        supportingDocument?: ResolverInputTypes['SupportingDocument'];
        status?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentStatusInfo']: AliasType<{
        /** Status of the supporting document */
        status?: boolean | `@${string}`;
        ['...on SupportingDocumentNotUploadedStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentNotUploadedStatusInfo'], keyof ResolverInputTypes['SupportingDocumentStatusInfo']>;
        ['...on SupportingDocumentRefusedStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentRefusedStatusInfo'], keyof ResolverInputTypes['SupportingDocumentStatusInfo']>;
        ['...on SupportingDocumentUploadedStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentUploadedStatusInfo'], keyof ResolverInputTypes['SupportingDocumentStatusInfo']>;
        ['...on SupportingDocumentValidatedStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentValidatedStatusInfo'], keyof ResolverInputTypes['SupportingDocumentStatusInfo']>;
        ['...on SupportingDocumentWaitingForUploadStatusInfo']?: Omit<ResolverInputTypes['SupportingDocumentWaitingForUploadStatusInfo'], keyof ResolverInputTypes['SupportingDocumentStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the status transition is not allowed */
    ['SupportingDocumentStatusNotAllowedRejection']: AliasType<{
        oldStatus?: boolean | `@${string}`;
        newStatus?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Specific type for document */
    ['SupportingDocumentType']: SupportingDocumentType;
    /** Supporting document with Uploaded status */
    ['SupportingDocumentUploadedStatusInfo']: AliasType<{
        /** When the document has been uploaded but not verified by Swan yet */
        status?: boolean | `@${string}`;
        /** An unique URL and one-time URL to download the Document */
        downloadUrl?: boolean | `@${string}`;
        /** Original file name */
        filename?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SupportingDocumentUploadInfo']: AliasType<{
        url?: boolean | `@${string}`;
        fields?: ResolverInputTypes['SupportingDocumentPostField'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the supporting document collection cannot receive supporting documents anymore */
    ['SupportingDocumentUploadNotAllowedRejection']: AliasType<{
        supportingDocumentCollectionStatus?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document with Validated status */
    ['SupportingDocumentValidatedStatusInfo']: AliasType<{
        /** When the document has been uploaded and verified by Swan */
        status?: boolean | `@${string}`;
        /** An unique URL and one-time URL to download the Document */
        downloadUrl?: boolean | `@${string}`;
        /** Date on which the supporting document has been validated */
        validatedAt?: boolean | `@${string}`;
        /** Original file name */
        filename?: boolean | `@${string}`;
        /** Reason why the supporting document has been validated */
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Supporting document with WaitingForUpload status */
    ['SupportingDocumentWaitingForUploadStatusInfo']: AliasType<{
        /** When the document is not uploaded yet */
        status?: boolean | `@${string}`;
        /** Info to upload the document : url and fields to add along file in form (POST) */
        upload?: ResolverInputTypes['SupportingDocumentUploadInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SuspendAccountMembershipInput']: {
        accountMembershipId: string;
    };
    ['SuspendAccountMembershipPayload']: AliasType<{
        SuspendAccountMembershipSuccessPayload?: ResolverInputTypes['SuspendAccountMembershipSuccessPayload'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        LegalRepresentativeAccountMembershipCannotBeSuspendedRejection?: ResolverInputTypes['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection'];
        UserNotAllowedToManageAccountMembershipRejection?: ResolverInputTypes['UserNotAllowedToManageAccountMembershipRejection'];
        UserNotAllowedToSuspendItsOwnAccountMembershipRejection?: ResolverInputTypes['UserNotAllowedToSuspendItsOwnAccountMembershipRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SuspendAccountMembershipSuccessPayload']: AliasType<{
        accountMembership?: ResolverInputTypes['AccountMembership'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Define a reason with a message and a specific type for suspend account action */
    ['SuspendAccountReason']: AliasType<{
        type?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Input version */
    ['SuspendAccountReasonInput']: {
        type: ResolverInputTypes['SuspendAccountReasonType'];
        message?: string | undefined | null;
    };
    /** Specific type for suspend account action */
    ['SuspendAccountReasonType']: SuspendAccountReasonType;
    /** SuspendAccountStatusReason */
    ['SuspendAccountStatusReason']: AliasType<{
        SuspendAccountReason?: ResolverInputTypes['SuspendAccountReason'];
        __typename?: boolean | `@${string}`;
    }>;
    /** StatusInfo when funding limit settings has been suspended */
    ['SuspendedFundingLimitSettingsStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Funding Source Suspended status information */
    ['SuspendedFundingSourceStatusInfo']: AliasType<{
        /** Funding Source Suspended status */
        status?: boolean | `@${string}`;
        /** Date at which the funding source was suspended */
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** SuspendedMerchantPaymentMethodStatusInfo */
    ['SuspendedMerchantPaymentMethodStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        /** Merchant Payment Method suspended date */
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** SuspendedMerchantProfileStatusInfo */
    ['SuspendedMerchantProfileStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        suspendedAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to suspend a physical card */
    ['SuspendPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
    };
    ['SuspendPhysicalCardPayload']: AliasType<{
        SuspendPhysicalCardSuccessPayload?: ResolverInputTypes['SuspendPhysicalCardSuccessPayload'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        PhysicalCardNotFoundRejection?: ResolverInputTypes['PhysicalCardNotFoundRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['SuspendPhysicalCardSuccessPayload']: AliasType<{
        /** The physicalCard suspended */
        physicalCard?: ResolverInputTypes['PhysicalCard'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the SuspendReceivedDirectDebitMandatedRejection mutation is rejected */
    ['SuspendReceivedDirectDebitMandatedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        reason?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Enum of reasons of rejection for suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandatedRejectionReason']: SuspendReceivedDirectDebitMandatedRejectionReason;
    /** Inputs to suspend a received direct debit mandate */
    ['SuspendReceivedDirectDebitMandateInput']: {
        receivedDirectDebitMandateId: string;
    };
    /** Union type returned by the suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandatePayload']: AliasType<{
        SuspendReceivedDirectDebitMandateSuccessPayload?: ResolverInputTypes['SuspendReceivedDirectDebitMandateSuccessPayload'];
        SuspendReceivedDirectDebitMandatedRejection?: ResolverInputTypes['SuspendReceivedDirectDebitMandatedRejection'];
        ReceivedDirectDebitMandateNotFoundRejection?: ResolverInputTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ReceivedDirectDebitMandateCanceledRejection?: ResolverInputTypes['ReceivedDirectDebitMandateCanceledRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandateSuccessPayload']: AliasType<{
        /** the received direct debit mandate is suspended */
        receivedDirectDebitMandate?: ResolverInputTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Swan account beneficiary */
    ['SwanAccountBeneficiaryInput']: {
        /** account number to be credited */
        accountNumber: ResolverInputTypes['AccountNumber'];
        /** full name of the beneficiary  (max 70 characters) */
        name: string;
        /** `true` if this new beneficiary will be saved to the beneficiary list of the debited account. */
        save: boolean;
    };
    /** Status values of an identification */
    ['SwanIdentificationStatus']: SwanIdentificationStatus;
    ['SwanTCUDocumentNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['SwanTCUDocumentStatusNotAllowedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['TextField']: AliasType<{
        displayFormat?: boolean | `@${string}`;
        example?: boolean | `@${string}`;
        key?: boolean | `@${string}`;
        maxLength?: boolean | `@${string}`;
        minLength?: boolean | `@${string}`;
        name?: boolean | `@${string}`;
        refreshDynamicFieldsOnChange?: boolean | `@${string}`;
        required?: boolean | `@${string}`;
        validationRegex?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Individual ultimate beneficial owner title (Mr/Ms) */
    ['TitleEnum']: TitleEnum;
    ['TokenRequestorId']: unknown;
    /** Rejection returned when trying to create a multi consent with too many child consents */
    ['TooManyChildConsentsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if too many items are given */
    ['TooManyItemsRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Transaction */
    ['Transaction']: AliasType<{
        /** unique identifier of the transaction */
        id?: boolean | `@${string}`;
        /** external identifier of the transaction */
        reference?: boolean | `@${string}`;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier?: boolean | `@${string}`;
        /** side (Credit or Debit) */
        side?: boolean | `@${string}`;
        /** type */
        type?: boolean | `@${string}`;
        /** amount */
        amount?: ResolverInputTypes['Amount'];
        /** label */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: boolean | `@${string}`;
        /** payment associated to this transaction */
        payment?: ResolverInputTypes['Payment'];
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty?: boolean | `@${string}`;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ResolverInputTypes['Amount'];
        /** payment product used for this transaction */
        paymentProduct?: boolean | `@${string}`;
        /** matching account for this transaction */
        account?: ResolverInputTypes['Account'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: boolean | `@${string}`;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate?: boolean | `@${string}`;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: boolean | `@${string}`;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: boolean | `@${string}`;
        /** origin transaction associated to this transaction */
        originTransaction?: ResolverInputTypes['Transaction'];
        ['...on CardTransaction']?: Omit<ResolverInputTypes['CardTransaction'], keyof ResolverInputTypes['Transaction']>;
        ['...on CheckTransaction']?: Omit<ResolverInputTypes['CheckTransaction'], keyof ResolverInputTypes['Transaction']>;
        ['...on FeeTransaction']?: Omit<ResolverInputTypes['FeeTransaction'], keyof ResolverInputTypes['Transaction']>;
        ['...on InternalCreditTransfer']?: Omit<ResolverInputTypes['InternalCreditTransfer'], keyof ResolverInputTypes['Transaction']>;
        ['...on InternalDirectDebitTransaction']?: Omit<ResolverInputTypes['InternalDirectDebitTransaction'], keyof ResolverInputTypes['Transaction']>;
        ['...on InternationalCreditTransferTransaction']?: Omit<ResolverInputTypes['InternationalCreditTransferTransaction'], keyof ResolverInputTypes['Transaction']>;
        ['...on SEPACreditTransferTransaction']?: Omit<ResolverInputTypes['SEPACreditTransferTransaction'], keyof ResolverInputTypes['Transaction']>;
        ['...on SEPADirectDebitTransaction']?: Omit<ResolverInputTypes['SEPADirectDebitTransaction'], keyof ResolverInputTypes['Transaction']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['TransactionConnection']: AliasType<{
        pageInfo?: ResolverInputTypes['PageInfo'];
        totalCount?: boolean | `@${string}`;
        edges?: ResolverInputTypes['TransactionEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Edge interface */
    ['TransactionEdge']: AliasType<{
        node?: ResolverInputTypes['Transaction'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if the transaction was not found */
    ['TransactionNotFoundRejection']: AliasType<{
        transactionId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The following reason codes for a r-transaction are defined: */
    ['TransactionReasonCode']: TransactionReasonCode;
    /** the criteria to filter transactions */
    ['TransactionsFiltersInput']: {
        /** To filter on some Transaction Status (all if empty) */
        status?: Array<ResolverInputTypes['TransactionStatus']> | undefined | null;
        /** To filter on some Payment Products (all if empty) */
        paymentProduct?: Array<ResolverInputTypes['PaymentProduct']> | undefined | null;
        /** To filter after an updatedAt value */
        isAfterUpdatedAt?: ResolverInputTypes['DateTime'] | undefined | null;
        /** To filter before an updatedAt value */
        isBeforeUpdatedAt?: ResolverInputTypes['DateTime'] | undefined | null;
        /** To filter on some text occurrences (words or ids) */
        search?: string | undefined | null;
        /** To filter on some transaction types */
        type?: Array<ResolverInputTypes['TransactionTypeEnum']> | undefined | null;
        /** To filter so it includes rejected transactions that had a fallback (`true` by default) */
        includeRejectedWithFallback?: boolean | undefined | null;
    };
    /** Transaction side */
    ['TransactionSide']: TransactionSide;
    ['TransactionsOrderByField']: TransactionsOrderByField;
    /** the criteria to sort transactions */
    ['TransactionsOrderByInput']: {
        field?: ResolverInputTypes['TransactionsOrderByField'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** Transaction status */
    ['TransactionStatus']: TransactionStatus;
    /** Transaction Status information */
    ['TransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        ['...on BookedTransactionStatusInfo']?: Omit<ResolverInputTypes['BookedTransactionStatusInfo'], keyof ResolverInputTypes['TransactionStatusInfo']>;
        ['...on CanceledTransactionStatusInfo']?: Omit<ResolverInputTypes['CanceledTransactionStatusInfo'], keyof ResolverInputTypes['TransactionStatusInfo']>;
        ['...on PendingTransactionStatusInfo']?: Omit<ResolverInputTypes['PendingTransactionStatusInfo'], keyof ResolverInputTypes['TransactionStatusInfo']>;
        ['...on RejectedTransactionStatusInfo']?: Omit<ResolverInputTypes['RejectedTransactionStatusInfo'], keyof ResolverInputTypes['TransactionStatusInfo']>;
        ['...on ReleasedTransactionStatusInfo']?: Omit<ResolverInputTypes['ReleasedTransactionStatusInfo'], keyof ResolverInputTypes['TransactionStatusInfo']>;
        ['...on UpcomingTransactionStatusInfo']?: Omit<ResolverInputTypes['UpcomingTransactionStatusInfo'], keyof ResolverInputTypes['TransactionStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Transaction Type */
    ['TransactionTypeEnum']: TransactionTypeEnum;
    /** TrustedBeneficiary */
    ['TrustedBeneficiary']: AliasType<{
        /** unique identifier of a trusted beneficiary */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** label of the beneficiary */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type?: boolean | `@${string}`;
        ['...on TrustedInternalBeneficiary']?: Omit<ResolverInputTypes['TrustedInternalBeneficiary'], keyof ResolverInputTypes['TrustedBeneficiary']>;
        ['...on TrustedInternationalBeneficiary']?: Omit<ResolverInputTypes['TrustedInternationalBeneficiary'], keyof ResolverInputTypes['TrustedBeneficiary']>;
        ['...on TrustedSepaBeneficiary']?: Omit<ResolverInputTypes['TrustedSepaBeneficiary'], keyof ResolverInputTypes['TrustedBeneficiary']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Connection interface */
    ['TrustedBeneficiaryConnection']: AliasType<{
        pageInfo?: ResolverInputTypes['PageInfo'];
        edges?: ResolverInputTypes['TrustedBeneficiaryEdge'];
        totalCount?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** TrustedBeneficiary status consent pending */
    ['TrustedBeneficiaryConsentPending']: AliasType<{
        /** status of the beneficiary  (set to `ConsentPending`) */
        status?: boolean | `@${string}`;
        /** The consent required to initiate this beneficiary */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Please see the Edge interface */
    ['TrustedBeneficiaryEdge']: AliasType<{
        node?: ResolverInputTypes['TrustedBeneficiary'];
        cursor?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryFiltersInput']: {
        status?: Array<ResolverInputTypes['TrustedBeneficiaryStatus']> | undefined | null;
        type?: Array<ResolverInputTypes['BeneficiaryType']> | undefined | null;
    };
    /** Field we can use when ordering that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryOrderByFieldInput']: TrustedBeneficiaryOrderByFieldInput;
    /** Order that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryOrderByInput']: {
        field?: ResolverInputTypes['TrustedBeneficiaryOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** TrustedBeneficiary status */
    ['TrustedBeneficiaryStatus']: TrustedBeneficiaryStatus;
    /** TrustedBeneficiary status information */
    ['TrustedBeneficiaryStatusInfo']: AliasType<{
        /** status of the beneficiary */
        status?: boolean | `@${string}`;
        ['...on TrustedBeneficiaryConsentPending']?: Omit<ResolverInputTypes['TrustedBeneficiaryConsentPending'], keyof ResolverInputTypes['TrustedBeneficiaryStatusInfo']>;
        ['...on TrustedBeneficiaryStatusInfoCanceled']?: Omit<ResolverInputTypes['TrustedBeneficiaryStatusInfoCanceled'], keyof ResolverInputTypes['TrustedBeneficiaryStatusInfo']>;
        ['...on TrustedBeneficiaryStatusInfoEnabled']?: Omit<ResolverInputTypes['TrustedBeneficiaryStatusInfoEnabled'], keyof ResolverInputTypes['TrustedBeneficiaryStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** TrustedBeneficiary status canceled */
    ['TrustedBeneficiaryStatusInfoCanceled']: AliasType<{
        /** status of the beneficiary (set to `Canceled`) */
        status?: boolean | `@${string}`;
        /** canceled Date */
        canceledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** TrustedBeneficiary status enabled */
    ['TrustedBeneficiaryStatusInfoEnabled']: AliasType<{
        /** status of the beneficiary (set to `Enabled`) */
        status?: boolean | `@${string}`;
        /** enabled Date */
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Trusted Internal Beneficiary */
    ['TrustedInternalBeneficiary']: AliasType<{
        /** unique identifier of a trusted beneficiary */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** label of the beneficiary */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type?: boolean | `@${string}`;
        /** beneficiary account Id */
        accountId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Trusted International Beneficiary */
    ['TrustedInternationalBeneficiary']: AliasType<{
        /** unique identifier of a trusted beneficiary */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** label of the beneficiary */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type?: boolean | `@${string}`;
        /** Currency of the international beneficiary account */
        currency?: boolean | `@${string}`;
        /** Currency-specific details of the beneficiary */
        details?: ResolverInputTypes['KeyValue'];
        /** Route that Swan will use to transfer the funds */
        route?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Trusted SEPA Beneficiary type SEPA */
    ['TrustedSepaBeneficiary']: AliasType<{
        /** unique identifier of a trusted beneficiary */
        id?: boolean | `@${string}`;
        /** created date */
        createdAt?: boolean | `@${string}`;
        /** updated date */
        updatedAt?: boolean | `@${string}`;
        /** full name of the beneficiary */
        name?: boolean | `@${string}`;
        /** label of the beneficiary */
        label?: boolean | `@${string}`;
        /** status information */
        statusInfo?: ResolverInputTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type?: boolean | `@${string}`;
        /** IBAN if the beneficiary is a an account in an other financial institution */
        iban?: boolean | `@${string}`;
        /** beneficiary address */
        address?: ResolverInputTypes['Address'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Quality of the account holder doing the onboarding */
    ['TypeOfRepresentation']: TypeOfRepresentation;
    /** Ultimate beneficial Direct Owner company info. */
    ['UltimateBeneficialDirectOwnerCompanyInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier . */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial Direct Owner Company type. */
        type?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        /** Name of the company. */
        name?: boolean | `@${string}`;
        /** Registration number. */
        registrationNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Ultimate beneficial Direct Owner individual info. */
    ['UltimateBeneficialDirectOwnerIndividualInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier . */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial Direct owner Individual type . */
        type?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        /** First name. */
        firstName?: boolean | `@${string}`;
        /** Last name. */
        lastName?: boolean | `@${string}`;
        /** Birth date. */
        birthDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Ultimate beneficial owner company info. */
    ['UltimateBeneficialIndirectOwnerCompanyInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier . */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial Indirect Owner Company type. */
        type?: boolean | `@${string}`;
        /** Unique Reference of the Parent Company. */
        parentCompanyReference?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        /** Name of the company. */
        name?: boolean | `@${string}`;
        /** Registration number. */
        registrationNumber?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Ultimate beneficial Indirect Owner individual info. */
    ['UltimateBeneficialIndirectOwnerIndividualInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier. */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial Indirect Owner Individual type . */
        type?: boolean | `@${string}`;
        /** Unique Reference of the Parent Company. */
        parentCompanyReference?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        /** First name. */
        firstName?: boolean | `@${string}`;
        /** Last name. */
        lastName?: boolean | `@${string}`;
        /** Birth date. */
        birthDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** The Ultimate Beneficial Owner could be for an Individual or a Company and these can Direct or Indirect */
    ['UltimateBeneficialOwnerInfo']: AliasType<{
        /** Ultimate Beneficial Owner Unique Identifier . */
        id?: boolean | `@${string}`;
        /** Ultimate beneficial owner type. */
        type?: boolean | `@${string}`;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio?: boolean | `@${string}`;
        ['...on UltimateBeneficialDirectOwnerCompanyInfo']?: Omit<ResolverInputTypes['UltimateBeneficialDirectOwnerCompanyInfo'], keyof ResolverInputTypes['UltimateBeneficialOwnerInfo']>;
        ['...on UltimateBeneficialDirectOwnerIndividualInfo']?: Omit<ResolverInputTypes['UltimateBeneficialDirectOwnerIndividualInfo'], keyof ResolverInputTypes['UltimateBeneficialOwnerInfo']>;
        ['...on UltimateBeneficialIndirectOwnerCompanyInfo']?: Omit<ResolverInputTypes['UltimateBeneficialIndirectOwnerCompanyInfo'], keyof ResolverInputTypes['UltimateBeneficialOwnerInfo']>;
        ['...on UltimateBeneficialIndirectOwnerIndividualInfo']?: Omit<ResolverInputTypes['UltimateBeneficialIndirectOwnerIndividualInfo'], keyof ResolverInputTypes['UltimateBeneficialOwnerInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    /** Ultimate Beneficial Owner type. */
    ['UltimateBeneficialOwnerType']: UltimateBeneficialOwnerType;
    /** Upcoming transaction status information */
    ['UpcomingTransactionStatusInfo']: AliasType<{
        /** status of the transaction */
        status?: boolean | `@${string}`;
        /** The date when the transaction will be executed */
        executionDate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountHolderInput']: {
        accountHolderId: string;
        vatNumber?: string | undefined | null;
        taxIdentificationNumber?: string | undefined | null;
    };
    ['UpdateAccountHolderPayload']: AliasType<{
        UpdateAccountHolderSuccessPayload?: ResolverInputTypes['UpdateAccountHolderSuccessPayload'];
        AccountHolderNotFoundRejection?: ResolverInputTypes['AccountHolderNotFoundRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountHolderSuccessPayload']: AliasType<{
        accountHolder?: ResolverInputTypes['AccountHolder'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to update an account */
    ['UpdateAccountInput']: {
        /** Unique identifier of an account */
        accountId: string;
        /** Name */
        name?: string | undefined | null;
        /** Language */
        language?: ResolverInputTypes['AccountLanguage'] | undefined | null;
    };
    /** Inputs to update an account membership */
    ['UpdateAccountMembershipInput']: {
        /** Unique identifier of an account membership */
        accountMembershipId: string;
        /** Email address */
        email?: string | undefined | null;
        /** Restricted to a user if necessary */
        restrictedTo?: ResolverInputTypes['UpdatedRestrictedToInput'] | undefined | null;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount?: boolean | undefined | null;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries?: boolean | undefined | null;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments?: boolean | undefined | null;
        /** `true` if this account membership can invite, update, suspend or resume memberships */
        canManageAccountMembership?: boolean | undefined | null;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined | null;
        /** Periodic Spending limit */
        spendingLimit?: ResolverInputTypes['SpendingLimitInput'] | undefined | null;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Residency address of the member to be added */
        residencyAddress?: ResolverInputTypes['ResidencyAddressInput'] | undefined | null;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined | null;
    };
    ['UpdateAccountMembershipPayload']: AliasType<{
        UpdateAccountMembershipSuccessPayload?: ResolverInputTypes['UpdateAccountMembershipSuccessPayload'];
        AccountMembershipCannotBeUpdatedRejection?: ResolverInputTypes['AccountMembershipCannotBeUpdatedRejection'];
        AccountMembershipNotFoundRejection?: ResolverInputTypes['AccountMembershipNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InvalidPhoneNumberRejection?: ResolverInputTypes['InvalidPhoneNumberRejection'];
        PermissionCannotBeGrantedRejection?: ResolverInputTypes['PermissionCannotBeGrantedRejection'];
        UserNotAllowedToManageAccountMembershipRejection?: ResolverInputTypes['UserNotAllowedToManageAccountMembershipRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountMembershipSuccessPayload']: AliasType<{
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountPayload']: AliasType<{
        UpdateAccountSuccessPayload?: ResolverInputTypes['UpdateAccountSuccessPayload'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        BadAccountStatusRejection?: ResolverInputTypes['BadAccountStatusRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateAccountSuccessPayload']: AliasType<{
        account?: ResolverInputTypes['Account'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input to Update Card */
    ['UpdateCardInput']: {
        /** Unique identifier of the card to update */
        cardId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ResolverInputTypes['DateTime'] | undefined | null;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Periodic Spending limit */
        spendingLimit?: ResolverInputTypes['SpendingLimitInput'] | undefined | null;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Card name */
        name?: string | undefined | null;
    };
    ['UpdateCardPayload']: AliasType<{
        UpdateCardSuccessPayload?: ResolverInputTypes['UpdateCardSuccessPayload'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        AccountMembershipNotAllowedRejection?: ResolverInputTypes['AccountMembershipNotAllowedRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateCardSuccessPayload']: AliasType<{
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateCompanyOnboardingInput']: {
        /** Account name of the company account holder. Length must be from 0 to 100 characters */
        accountName?: string | undefined | null;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ResolverInputTypes['AccountCountry'] | undefined | null;
        /** Name of the company. Length must be from 0 to 255 characters */
        name?: string | undefined | null;
        /** Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters */
        registrationNumber?: string | undefined | null;
        /** Type of the company (Association ...) */
        companyType?: ResolverInputTypes['CompanyType'] | undefined | null;
        /** Business activity */
        businessActivity?: ResolverInputTypes['BusinessActivity'] | undefined | null;
        /** Business activity description. Length must be from 0 to 1024 characters */
        businessActivityDescription?: string | undefined | null;
        /** Estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: ResolverInputTypes['MonthlyPaymentVolume'] | undefined | null;
        /** The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
    
    The ultimate beneficial owner is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<ResolverInputTypes['IndividualUltimateBeneficialOwnerInput']> | undefined | null;
        /** Residency address of the head office (Must be in a European country) */
        residencyAddress?: ResolverInputTypes['ResidencyAddressInput'] | undefined | null;
        /** Email of the legal representative. Length must be from 0 to 255 characters */
        email?: string | undefined | null;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined | null;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined | null;
        /** Id of onboarding to be updated. Must be a valid UUID v4. Required */
        onboardingId: string;
        /** VAT number */
        vatNumber?: string | undefined | null;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined | null;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ResolverInputTypes['AddressInformationInput'] | undefined | null;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: ResolverInputTypes['TypeOfRepresentation'] | undefined | null;
    };
    /** Possible results for mutation `updateCompanyOnboarding` */
    ['UpdateCompanyOnboardingPayload']: AliasType<{
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        UpdateCompanyOnboardingSuccessPayload?: ResolverInputTypes['UpdateCompanyOnboardingSuccessPayload'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Result when updateCompanyOnboarding is a success */
    ['UpdateCompanyOnboardingSuccessPayload']: AliasType<{
        onboarding?: ResolverInputTypes['OnboardingInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Input when the account membership is restricted to a verified user */
    ['UpdatedRestrictedToInput']: {
        /** Account member first name */
        firstName?: string | undefined | null;
        /** Account member last name */
        lastName?: string | undefined | null;
        /** Account member birth date */
        birthDate?: ResolverInputTypes['Date'] | undefined | null;
        /** Account member phone number */
        phoneNumber?: string | undefined | null;
    };
    ['UpdateIndividualOnboardingInput']: {
        /** Account name of the individual account holder. Length must be from 0 to 255 characters */
        accountName?: string | undefined | null;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ResolverInputTypes['AccountCountry'] | undefined | null;
        /** Employment status of the individual account holder */
        employmentStatus?: ResolverInputTypes['EmploymentStatus'] | undefined | null;
        /** Monthly income of the individual account holder */
        monthlyIncome?: ResolverInputTypes['MonthlyIncome'] | undefined | null;
        /** Residency address of the individual account holder (must be in a European country) */
        residencyAddress?: ResolverInputTypes['ResidencyAddressInput'] | undefined | null;
        /** Email. Length must be from 0 to 255 characters */
        email?: string | undefined | null;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined | null;
        /** Id of onboarding to be updated. Must be a valid UUID v4. Required */
        onboardingId: string;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined | null;
    };
    /** Possible result types for `updateIndividualOnboarding` */
    ['UpdateIndividualOnboardingPayload']: AliasType<{
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        UpdateIndividualOnboardingSuccessPayload?: ResolverInputTypes['UpdateIndividualOnboardingSuccessPayload'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Type of result when updateIndividualOnboarding is a success */
    ['UpdateIndividualOnboardingSuccessPayload']: AliasType<{
        onboarding?: ResolverInputTypes['OnboardingInfo'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Inputs to update a received sepa direct debit mandate B2b. */
    ['UpdateReceivedSepaDirectDebitB2bMandateInput']: {
        /** The unique mandate id */
        receivedDirectDebitMandateId: string;
        /** The unique identifier of the received direct debit mandate */
        mandateReference?: string | undefined | null;
        /** The Sepa Creditor Identifier of the creditor */
        creditorIdentifier?: string | undefined | null;
        /** The name of the creditor */
        creditorName?: string | undefined | null;
        /** The Swan Iban of the debtor */
        iban?: string | undefined | null;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined | null;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** Union type returned by the updateReceivedSepaDirectDebitB2bMandate mutation */
    ['UpdateReceivedSepaDirectDebitB2bMandatePayload']: AliasType<{
        UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload?: ResolverInputTypes['UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload'];
        ReceivedDirectDebitMandateNotFoundRejection?: ResolverInputTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        ReceivedDirectDebitMandateAlreadyExistRejection?: ResolverInputTypes['ReceivedDirectDebitMandateAlreadyExistRejection'];
        ReceivedDirectDebitMandateNotB2bRejection?: ResolverInputTypes['ReceivedDirectDebitMandateNotB2bRejection'];
        AccountNotFoundRejection?: ResolverInputTypes['AccountNotFoundRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Return type in case of a successful response of the updateReceivedSepaDirectDebitB2bMandate mutation */
    ['UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload']: AliasType<{
        /** The received direct debit mandate updated */
        receivedDirectDebitMandate?: ResolverInputTypes['ReceivedDirectDebitMandate'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateSupportingDocumentInput']: {
        supportingDocumentId: string;
        supportingDocumentType?: ResolverInputTypes['SupportingDocumentType'] | undefined | null;
        supportingDocumentPurpose?: ResolverInputTypes['SupportingDocumentPurposeEnum'] | undefined | null;
    };
    ['UpdateSupportingDocumentPayload']: AliasType<{
        UpdateSupportingDocumentSuccessPayload?: ResolverInputTypes['UpdateSupportingDocumentSuccessPayload'];
        ForbiddenRejection?: ResolverInputTypes['ForbiddenRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        SupportingDocumentCollectionNotFoundRejection?: ResolverInputTypes['SupportingDocumentCollectionNotFoundRejection'];
        SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection?: ResolverInputTypes['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection'];
        SupportingDocumentNotFoundRejection?: ResolverInputTypes['SupportingDocumentNotFoundRejection'];
        SupportingDocumentStatusDoesNotAllowUpdateRejection?: ResolverInputTypes['SupportingDocumentStatusDoesNotAllowUpdateRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateSupportingDocumentSuccessPayload']: AliasType<{
        supportingDocument?: ResolverInputTypes['SupportingDocument'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateUserConsentSettingsInput']: {
        /** Swan user id */
        userId: string;
        /** Preferred consent notification channel, Sms or App */
        preferredNotificationChannel: ResolverInputTypes['PreferredNotificationChannel'];
    };
    ['UpdateUserConsentSettingsPayload']: AliasType<{
        UpdateUserConsentSettingsSuccessPayload?: ResolverInputTypes['UpdateUserConsentSettingsSuccessPayload'];
        UpdateUserConsentSettingsTokenRejection?: ResolverInputTypes['UpdateUserConsentSettingsTokenRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateUserConsentSettingsSuccessPayload']: AliasType<{
        userConsentSettings?: ResolverInputTypes['UserConsentSettings'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UpdateUserConsentSettingsTokenRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['Upload']: unknown;
    /** URL that follows the WHATWG URL Standard.
  
  [Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself. */
    ['URL']: unknown;
    /** The User is the unique user, natural person, of the Swan app. */
    ['User']: AliasType<{
        /** unique identifier of the user */
        id?: boolean | `@${string}`;
        accountMemberships?: [
            {
                /** the number of elements to load (maximum: 100) */
                first: number; /** the index (a unique reference in string form) from which you will load the preceding elements */
                before?: string | undefined | null; /** the index (a unique reference in string form) from which you will load the following elements */
                after?: string | undefined | null; /** a filtering table you can apply to your list of connections */
                filters?: ResolverInputTypes['AccountMembershipsFilterInput'] | undefined | null;
            },
            ResolverInputTypes['AccountMembershipConnection']
        ];
        /** mobile phone number with the international format (Example: +33689788967) */
        mobilePhoneNumber?: boolean | `@${string}`;
        /** first name */
        firstName?: boolean | `@${string}`;
        /** last name */
        lastName?: boolean | `@${string}`;
        /** list of first names */
        allFirstNames?: boolean | `@${string}`;
        /** birth date */
        birthDate?: boolean | `@${string}`;
        /** nationality */
        nationalityCCA3?: boolean | `@${string}`;
        /** `true` if Swan has verified the user's identity */
        idVerified?: boolean | `@${string}`;
        /** the methods used to authenticate this user */
        authenticators?: ResolverInputTypes['Authenticator'];
        /** Identification status
    
    Each attempt to go through our identity verification process will update this value.
    
    This field is only available for the current user. */
        identificationStatus?: boolean | `@${string}`;
        /** List of identification levels available for the user.
    
    Whenever TRUE, it means the identification was successful for the associated level. */
        identificationLevels?: ResolverInputTypes['IdentificationLevels'];
        /** Preferred notification channel
    
    When it is "null" it means that the preferences have not been updated. Default SMS in use */
        preferredNotificationChannel?: boolean | `@${string}`;
        /** Creation date of the user */
        createdAt?: boolean | `@${string}`;
        /** Last update date of the user */
        updatedAt?: boolean | `@${string}`;
        /** Date on which the user joined the project. Joining the project is done after the first accepted OAuth login. */
        joinedAt?: boolean | `@${string}`;
        identifications?: [
            {
                /** Maximum number of elements in the list (default value 50) */
                first: number; /** When the list of elements needs to start after an element */
                after?: string | undefined | null; /** When the list of identifications needs to be filtered */
                filters?: ResolverInputTypes['IdentificationFiltersInput'] | undefined | null; /** When the list of identifications needs to be ordered, by default the list will be ordered by the latest identification (valid or not) */
                orderBy?: ResolverInputTypes['IdentificationsOrderByInput'] | undefined | null;
            },
            ResolverInputTypes['IdentificationConnection']
        ];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['UserConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** UserEdge list */
        edges?: ResolverInputTypes['UserEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UserConsentSettings']: AliasType<{
        /** Preferred notification channel */
        preferredNotificationChannel?: boolean | `@${string}`;
        /** User identifier */
        userId?: boolean | `@${string}`;
        /** Project identifier */
        projectId?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['UserEdge']: AliasType<{
        /** Opaque identifier pointing to this consent node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The consent */
        node?: ResolverInputTypes['User'];
        __typename?: boolean | `@${string}`;
    }>;
    ['UserFilterInput']: {
        birthDate?: ResolverInputTypes['Date'] | undefined | null;
        firstName?: string | undefined | null;
        identificationLevel?: ResolverInputTypes['IdentificationLevelInput'] | undefined | null;
        lastName?: string | undefined | null;
        mobilePhoneNumber?: string | undefined | null;
        nationalityCCA3?: ResolverInputTypes['CCA3'] | undefined | null;
        preferredNotificationChannel?: ResolverInputTypes['PreferredNotificationChannel'] | undefined | null;
        /** Searches first name, last name, phone number and id
    Min length : 3 characters */
        search?: string | undefined | null;
    };
    ['UserNotAllowedToDisableItsOwnAccountMembershipRejection']: AliasType<{
        accountMembershipId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned if a identity does not have enough permission to manage account membership */
    ['UserNotAllowedToManageAccountMembershipRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['UserNotAllowedToSuspendItsOwnAccountMembershipRejection']: AliasType<{
        accountMembershipId?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when the User is not the Card Holder */
    ['UserNotCardHolderRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Field we can use when ordering that can be applied when listing users */
    ['UserOrderByFieldInput']: UserOrderByFieldInput;
    /** Order that can be applied when listing users */
    ['UserOrderByInput']: {
        field?: ResolverInputTypes['UserOrderByFieldInput'] | undefined | null;
        direction?: ResolverInputTypes['OrderByDirection'] | undefined | null;
    };
    /** A detail of a validation error : what field is errored and why */
    ['ValidationError']: AliasType<{
        /** Onboarding property that is not matching requirements to allow a finalization */
        field?: boolean | `@${string}`;
        /** Constraints that are not matched on the Onboarding property */
        errors?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ValidationFieldError']: AliasType<{
        code?: boolean | `@${string}`;
        message?: boolean | `@${string}`;
        path?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ValidationFieldErrorCode']: ValidationFieldErrorCode;
    /** Rejection returned if an input contains invalid data */
    ['ValidationRejection']: AliasType<{
        fields?: ResolverInputTypes['ValidationFieldError'];
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Information extracted from a valid IBAN */
    ['ValidIban']: AliasType<{
        /** Iban from input */
        iban?: boolean | `@${string}`;
        /** Account Number extracted from the IBAN */
        accountNumber?: boolean | `@${string}`;
        /** Checksum extracted from the IBAN */
        checksum?: boolean | `@${string}`;
        /** Bank that owns this IBAN */
        bank?: ResolverInputTypes['Bank'];
        /** Reachability of this IBAN over different payment methods */
        reachability?: ResolverInputTypes['Reachability'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Describes a valid identification level for the process associated to this identification, and identification documents can be accessed */
    ['ValidIdentificationLevelStatusInfo']: AliasType<{
        /** Always set to `Valid` */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Verification Flow. */
    ['VerificationFlow']: VerificationFlow;
    /** Verification status of an account holder */
    ['VerificationStatus']: VerificationStatus;
    /** Enabled Information */
    ['VerifiedStatusInfo']: AliasType<{
        /** Date at which the verification was verified */
        verifiedAt?: boolean | `@${string}`;
        /** Account verification status (Verified) */
        status?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewCardNumbersInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ViewCardNumbersPayload']: AliasType<{
        ViewCardNumbersSuccessPayload?: ResolverInputTypes['ViewCardNumbersSuccessPayload'];
        UserNotCardHolderRejection?: ResolverInputTypes['UserNotCardHolderRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewCardNumbersSuccessPayload']: AliasType<{
        /** The consent required to view card numbers */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewPhysicalCardNumbersInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ViewPhysicalCardNumbersPayload']: AliasType<{
        ViewPhysicalCardNumbersSuccessPayload?: ResolverInputTypes['ViewPhysicalCardNumbersSuccessPayload'];
        UserNotCardHolderRejection?: ResolverInputTypes['UserNotCardHolderRejection'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewPhysicalCardNumbersSuccessPayload']: AliasType<{
        /** The consent required to view card numbers */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewPhysicalCardPinInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ViewPhysicalCardPinPayload']: AliasType<{
        ViewPhysicalCardPinSuccessPayload?: ResolverInputTypes['ViewPhysicalCardPinSuccessPayload'];
        CardNotFoundRejection?: ResolverInputTypes['CardNotFoundRejection'];
        PhysicalCardNotFoundRejection?: ResolverInputTypes['PhysicalCardNotFoundRejection'];
        PINNotReadyRejection?: ResolverInputTypes['PINNotReadyRejection'];
        UserNotCardHolderRejection?: ResolverInputTypes['UserNotCardHolderRejection'];
        ValidationRejection?: ResolverInputTypes['ValidationRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['ViewPhysicalCardPinSuccessPayload']: AliasType<{
        /** The consent required to view card numbers */
        consent?: ResolverInputTypes['Consent'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Virtual IBAN can be used by the account holder to receive SCT (Sepa Credit Transfer) or to be debited by SDD (Sepa Direct Debit). */
    ['VirtualIBANEntry']: AliasType<{
        /** Unique identifier of a Virtual IBAN entry */
        id?: boolean | `@${string}`;
        /** International Bank Account Number */
        IBAN?: boolean | `@${string}`;
        /** Bank Identifier Code */
        BIC?: boolean | `@${string}`;
        /** Label (could be used to identify) */
        label?: boolean | `@${string}`;
        /** Status of the Iban */
        status?: boolean | `@${string}`;
        /** `true` if the Virtual IBAN refuses all Sepa Direct Debit received */
        blockSDD?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['VirtualIBANEntryConnection']: AliasType<{
        /** Total number of element in the list */
        totalCount?: boolean | `@${string}`;
        /** Information about the current, the previous and the next page */
        pageInfo?: ResolverInputTypes['PageInfo'];
        /** VirtualIBANEntryEdge list */
        edges?: ResolverInputTypes['VirtualIBANEntryEdge'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Implements the Relay Edge interface */
    ['VirtualIBANEntryEdge']: AliasType<{
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor?: boolean | `@${string}`;
        /** The virtual iban entry */
        node?: ResolverInputTypes['VirtualIBANEntry'];
        __typename?: boolean | `@${string}`;
    }>;
    /** Wallet Provider (ApplePay, GooglePay ...) */
    ['WalletProvider']: AliasType<{
        /** name of the Wallet Provider (Apple / Google / Amazon or Unknown) */
        name?: boolean | `@${string}`;
        /** id of the Wallet Provider */
        id?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Wallet Provider */
    ['WalletProviderType']: WalletProviderType;
    ['WalletToken']: unknown;
    ['WebBankingSettings']: AliasType<{
        canViewAccountDetails?: boolean | `@${string}`;
        canViewAccountStatement?: boolean | `@${string}`;
        canManageVirtualIbans?: boolean | `@${string}`;
        canInitiatePaymentsToNewBeneficiaries?: boolean | `@${string}`;
        canViewPaymentList?: boolean | `@${string}`;
        canOrderVirtualCards?: boolean | `@${string}`;
        canOrderPhysicalCards?: boolean | `@${string}`;
        canViewMembers?: boolean | `@${string}`;
        canAddNewMembers?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** A WebhookEvent Log for webhooks service.
  It describes the response and call context for webhook endpoints
  for a specific event. */
    ['WebhookEventLog']: AliasType<{
        /** Unique identifier of the EventLog */
        id?: boolean | `@${string}`;
        /** Date the EventLog has been created */
        createdAt?: boolean | `@${string}`;
        /** Unique identifier of the event that triggered this eventLog */
        eventId?: boolean | `@${string}`;
        /** Date the Event has been generated */
        eventDate?: boolean | `@${string}`;
        /** The type of the triggering event */
        eventType?: boolean | `@${string}`;
        /** Unique identifier linked of the resource carried by the Event */
        resourceId?: boolean | `@${string}`;
        /** Duration of the callback in MS */
        duration?: boolean | `@${string}`;
        /** Request payload send to callback in string format, jsonable. */
        requestPayload?: boolean | `@${string}`;
        /** Response payload get by the callback in string format, jsonable. */
        responsePayload?: boolean | `@${string}`;
        /** The callback response status in number format. */
        statusCode?: boolean | `@${string}`;
        /** The callback response status in text format. */
        statusText?: boolean | `@${string}`;
        /** The webhook that triggered the event. */
        webhookSubscription?: ResolverInputTypes['WebhookSubscription'];
        /** Rank of this retry */
        retryCount?: boolean | `@${string}`;
        /** Label of the associated subscription (inherited)
    This holds the label value of when the log was created, whereas
    webhookSubscription.label holds the current value of the label
    (it may have changed). */
        webhookSubscriptionLabel?: boolean | `@${string}`;
        /** Endpoint of the associated subscription (inherited)
    This holds the endpoint value of when the log was created, whereas
    webhookSubscription.endpoint holds the current value of the endpoint
    (it may have changed). */
        webhookSubscriptionEndpoint?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Filters that can be applied when listing eventLog */
    ['WebhookEventLogFiltersInput']: {
        statusCode?: number | undefined | null;
        statusText?: ResolverInputTypes['StatusText'] | undefined | null;
        startDate?: ResolverInputTypes['DateTime'] | undefined | null;
        endDate?: ResolverInputTypes['DateTime'] | undefined | null;
        eventType?: string | undefined | null;
        eventId?: string | undefined | null;
        resourceId?: string | undefined | null;
        webhookSubscriptionId?: string | undefined | null;
    };
    /** Rejection returned when Webhook event log id is not found */
    ['WebhookEventLogNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** A Subscription to the webhooks service.
  It describes the registration of a callback url (the endpoint)
  and a list of event types the client wants to be notified of. */
    ['WebhookSubscription']: AliasType<{
        /** Unique identifier of the Subscription */
        id?: boolean | `@${string}`;
        /** A client provided short description of the Subscription */
        label?: boolean | `@${string}`;
        /** The callback URL to be used for POSTing events */
        endpoint?: boolean | `@${string}`;
        /** The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
    (max 36 characters) */
        secret?: boolean | `@${string}`;
        /** The types of subscribed events
    A simple list of unique IDs */
        eventTypes?: boolean | `@${string}`;
        /** Date the Subscription has been created */
        createdAt?: boolean | `@${string}`;
        /**   Last date the Subscription has been updated,
    except for state changes */
        updatedAt?: boolean | `@${string}`;
        /** The current state of the Subscription */
        statusInfo?: ResolverInputTypes['WebhookSubscriptionStatusInfo'];
        /** KPI data about the subscription (7 last days) */
        kpi?: ResolverInputTypes['WebhookSubscriptionKpi'];
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionBrokenStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        brokenAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionCreationStatus']: WebhookSubscriptionCreationStatus;
    ['WebhookSubscriptionDisabledStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        disabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionEnabledStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        enabledAt?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionKpi']: AliasType<{
        /** Total number of eventLogs associated to this subscription */
        totalHits?: boolean | `@${string}`;
        /** Total number of eventLogs that failed associated to this subscription
    errorRate = (errorRate/totalHits) * 100, rounded */
        errorRate?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when Webhook Subscription is not found */
    ['WebhookSubscriptionNotFoundRejection']: AliasType<{
        message?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionPayload']: AliasType<{
        WebhookSubscriptionSuccessPayload?: ResolverInputTypes['WebhookSubscriptionSuccessPayload'];
        WebhookSubscriptionNotFoundRejection?: ResolverInputTypes['WebhookSubscriptionNotFoundRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        InvalidArgumentRejection?: ResolverInputTypes['InvalidArgumentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    /** State of a Webhook Subscription
  It is either Enabled or Disabled by the owner,
  ot set to Broken when delivery fails repeatedly. */
    ['WebhookSubscriptionStatus']: WebhookSubscriptionStatus;
    ['WebhookSubscriptionStatusInfo']: AliasType<{
        status?: boolean | `@${string}`;
        ['...on WebhookSubscriptionBrokenStatusInfo']?: Omit<ResolverInputTypes['WebhookSubscriptionBrokenStatusInfo'], keyof ResolverInputTypes['WebhookSubscriptionStatusInfo']>;
        ['...on WebhookSubscriptionDisabledStatusInfo']?: Omit<ResolverInputTypes['WebhookSubscriptionDisabledStatusInfo'], keyof ResolverInputTypes['WebhookSubscriptionStatusInfo']>;
        ['...on WebhookSubscriptionEnabledStatusInfo']?: Omit<ResolverInputTypes['WebhookSubscriptionEnabledStatusInfo'], keyof ResolverInputTypes['WebhookSubscriptionStatusInfo']>;
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookSubscriptionSuccessPayload']: AliasType<{
        webhookSubscription?: ResolverInputTypes['WebhookSubscription'];
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookUnsubscribePayload']: AliasType<{
        WebhookUnsubscribeSuccessPayload?: ResolverInputTypes['WebhookUnsubscribeSuccessPayload'];
        WebhookSubscriptionNotFoundRejection?: ResolverInputTypes['WebhookSubscriptionNotFoundRejection'];
        InternalErrorRejection?: ResolverInputTypes['InternalErrorRejection'];
        InvalidArgumentRejection?: ResolverInputTypes['InvalidArgumentRejection'];
        __typename?: boolean | `@${string}`;
    }>;
    ['WebhookUnsubscribeSuccessPayload']: AliasType<{
        unsubscribed?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    /** Rejection returned when a parameter has a wrong value */
    ['WrongValueProvidedRejection']: AliasType<{
        message?: boolean | `@${string}`;
        valueProvided?: boolean | `@${string}`;
        parameterName?: boolean | `@${string}`;
        __typename?: boolean | `@${string}`;
    }>;
    ['schema']: AliasType<{
        query?: ResolverInputTypes['Query'];
        mutation?: ResolverInputTypes['Mutation'];
        __typename?: boolean | `@${string}`;
    }>;
};
export type ModelTypes = {
    /** Whether you call it a wallet, monetary account, payment account or bank account, the notion of account is fundamental at Swan. All payment flows necessarily go through an account. */
    ['Account']: {
        /** Unique identifier of an account */
        id: string;
        /** Unique account number */
        number: ModelTypes['AccountNumber'];
        /** Account name */
        name: string;
        /** Account holder */
        holder: ModelTypes['AccountHolder'];
        /** Cash account type */
        cashAccountType: ModelTypes['CashAccountType'];
        /** Country of the account */
        country: ModelTypes['AccountCountry'];
        /** Payment level */
        paymentLevel: ModelTypes['PaymentLevel'];
        /** Bank Identifier Code
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        BIC: ModelTypes['BIC'];
        /** International Bank Account Number
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        IBAN?: ModelTypes['IBAN'] | undefined;
        /** Currency */
        currency: ModelTypes['Currency'];
        /** `true` if the main IBAN refuses all Sepa Direct Debit received */
        blockSDD?: boolean | undefined;
        /** Status of the account */
        statusInfo: ModelTypes['AccountStatusInfo'];
        /** Partnership status */
        partnershipStatusInfo?: ModelTypes['PartnershipStatusInfo'] | undefined;
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** List of Virtual IBAN
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        virtualIbanEntries: ModelTypes['VirtualIBANEntryConnection'];
        /** List of account membership for this account
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        memberships: ModelTypes['AccountMembershipConnection'];
        /** `true`if a consent is required to fetch new transactions */
        requiredConsentToFetchNewTransactions: boolean;
        /** Language used for account statements */
        language: ModelTypes['AccountLanguage'];
        /** Legal representative account membership */
        legalRepresentativeMembership: ModelTypes['AccountMembership'];
        /** Type of the account : EMoney if account holder has not finished the KYC requirements, PaymentService otherwise */
        paymentAccountType: ModelTypes['PaymentAccountType'];
        /** Date of the account going from eMoney to PaymentService */
        upgradedAt?: ModelTypes['DateTime'] | undefined;
        /** Link to the account's bank details */
        bankDetails?: string | undefined;
        /** Legal Documents linked to the account
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        legalDocuments?: ModelTypes['LegalDocumentConnection'] | undefined;
        /** A list of balances regarding an account. */
        balances?: ModelTypes['AccountBalances'] | undefined;
        /** List of statements of an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    *For a Project access token, this is all the transactions of the project (only available with project access token)* */
        statements?: ModelTypes['StatementConnection'] | undefined;
        /** A list of transactions of an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: ModelTypes['TransactionConnection'] | undefined;
        /** A list of invoices of an account.
    The list is ordered by creation date (from newest to oldest)
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        invoices?: ModelTypes['InvoiceConnection'] | undefined;
        /** A list of receive Direct Mandates of an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        receivedDirectDebitMandates?: ModelTypes['ReceivedDirectDebitMandateConnection'] | undefined;
        /** List of merchant profiles created on the account */
        merchantProfiles?: ModelTypes['MerchantProfileConnection'] | undefined;
        /** A list of standing orders regarding an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        standingOrders: ModelTypes['StandingOrderConnection'];
        /** List of funding source created on the account
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        fundingSources?: ModelTypes['FundingSourceConnection'] | undefined;
        /** List of trusted beneficiaries of an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        trustedBeneficiaries: ModelTypes['TrustedBeneficiaryConnection'];
    };
    /** A list of balances regarding an account. */
    ['AccountBalances']: {
        /** Balance composed of booked, pending transactions and rolling reserve used known at the time of calculation. */
        available: ModelTypes['Amount'];
        /** Balance just composed of pending transactions. */
        pending: ModelTypes['Amount'];
        /** Balance just composed of booked transactions. */
        booked: ModelTypes['Amount'];
        /** Balance just composed of rolling reserve used in booked transactions. */
        reserved: ModelTypes['Amount'];
    };
    /** Account Closed status information */
    ['AccountClosedStatus']: {
        /** Account status (always Closed for type AccountClosedStatus) */
        status: ModelTypes['AccountStatus'];
        /** Reason why the account is suspended
    @Deprecated */
        reason: string;
        /** Reason why the account is currently closed */
        reasonInfo: ModelTypes['CloseAccountStatusReason'];
    };
    /** Account Closing status information */
    ['AccountClosingStatus']: {
        /** Account status (always Closing for type AccountClosingStatus) */
        status: ModelTypes['AccountStatus'];
        /** Reason why the account is suspended
    @Deprecated */
        reason: string;
        /** Reason why the account is currently in closing */
        reasonInfo: ModelTypes['CloseAccountStatusReason'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['AccountConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** AccountEdge list */
        edges: Array<ModelTypes['AccountEdge']>;
    };
    ['AccountCountry']: AccountCountry;
    /** Implements the Relay Edge interface */
    ['AccountEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The account */
        node: ModelTypes['Account'];
    };
    ['AccountFilterInput']: {
        /** Account Status we want to filter on */
        status?: Array<ModelTypes['AccountStatus']> | undefined;
        /** Account Payment Levels we want to filter on */
        paymentLevels?: Array<ModelTypes['PaymentLevel']> | undefined;
        /** Searches name, account number, and IBAN */
        search?: string | undefined;
    };
    ['AccountFundingLimitsReachedReason']: AccountFundingLimitsReachedReason;
    /** The account holder is the person who owns the money stored in the account. The account holder can be one of your customers, whether it is a natural person or a legal person, or quite simply you. */
    ['AccountHolder']: {
        /** Unique identifier of the account holder. */
        id: string;
        /** Verification status.
         *Banking regulations require financial institutions such as Swan to know and verify their customers in order to comply with their anti-money laundering and terrorist financing obligations. In banking jargon, we talk about KYC (Know Your Customers) procedure* */
        verificationStatus: ModelTypes['VerificationStatus'];
        /** Account holder type information. */
        info: ModelTypes['AccountHolderInfo'];
        /** Account holder status information. */
        statusInfo?: ModelTypes['AccountHolderStatusInfo'] | undefined;
        /** Residency address. */
        residencyAddress: ModelTypes['AddressInfo'];
        /** Created date. */
        createdDate: ModelTypes['DateTime'];
        /** Updated date. */
        updatedDate: ModelTypes['DateTime'];
        /** List of accounts owned by the account holder.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        accounts: ModelTypes['AccountConnection'];
        /** List of supporting document collection for an account holder
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        supportingDocumentCollections: ModelTypes['SupportingDocumentCollectionConnection'];
        /** List of funding limit settings change request for an account holder
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        fundingLimitSettingsChangeRequests: ModelTypes['FundingLimitSettingsChangeRequestConnection'];
        /** Account holder onboarding */
        onboarding?: ModelTypes['Onboarding'] | undefined;
        /** List of external account owned by the account holder
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        externalAccounts: ModelTypes['ExternalAccountConnection'];
        /** A list of Payment Mandates for an account holder.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        paymentMandates?: ModelTypes['PaymentMandateConnection'] | undefined;
        /** Funding limit settings */
        fundingLimitSettings?: ModelTypes['FundingLimitSettings'] | undefined;
    };
    /** Account Holder Canceled Status Information */
    ['AccountHolderCanceledStatusInfo']: {
        /** Status of the account holder. */
        status: ModelTypes['AccountHolderStatus'];
        /** Reason why the account holder is suspended. */
        reason: string;
    };
    ['AccountHolderCompanyInfo']: {
        /** Account holder type (always Company for type AccountHolderCompanyInfo) */
        type: ModelTypes['AccountHolderType'];
        /** Name of the company. */
        name: string;
        /** Registration number of the company (SIRET, ...). */
        registrationNumber?: string | undefined;
        /** Registration date of the company. */
        companyRegistrationDate?: ModelTypes['Date'] | undefined;
        /** Legal form of the company (SAS, SCI, SASU, ...). */
        companyType?: ModelTypes['CompanyType'] | undefined;
        /** Business activity. */
        businessActivity: ModelTypes['BusinessActivity'];
        /** Business activity description.
    This must be 1024 characters long maximum. */
        businessActivityDescription: string;
        /** Estimated monthly payment volume (euro). */
        monthlyPaymentVolume: ModelTypes['MonthlyPaymentVolume'];
        /** The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
    
    The ultimate beneficiary is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners: Array<ModelTypes['IndividualUltimateBeneficialOwner']>;
        /** Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT */
        vatNumber?: string | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ModelTypes['AddressInformation'] | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)). */
    ['AccountHolderConnection']: {
        /** Total number of element in the list. */
        totalCount: number;
        /** Information about the current, the previous and the next page. */
        pageInfo: ModelTypes['PageInfo'];
        /** AccountHolderEdge list. */
        edges: Array<ModelTypes['AccountHolderEdge']>;
    };
    /** Implements the Relay Edge interface. */
    ['AccountHolderEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism. */
        cursor: string;
        /** The account holder. */
        node: ModelTypes['AccountHolder'];
    };
    /** Account Holder Enabled Status Information */
    ['AccountHolderEnabledStatusInfo']: {
        /** Status of the account holder. */
        status: ModelTypes['AccountHolderStatus'];
    };
    ['AccountHolderFilterInput']: {
        status?: Array<ModelTypes['AccountHolderStatus']> | undefined;
        types?: Array<ModelTypes['AccountHolderType']> | undefined;
        verificationStatus?: Array<ModelTypes['VerificationStatus']> | undefined;
        /** Searches company name, first name, last name */
        search?: string | undefined;
        firstName?: string | undefined;
        lastName?: string | undefined;
        birthDate?: string | undefined;
        registrationNumber?: string | undefined;
    };
    /** Individual account holder. */
    ['AccountHolderIndividualInfo']: {
        /** Account holder type (always Individual for type AccountHolderIndividualInfo). */
        type: ModelTypes['AccountHolderType'];
        /** Account Holder's first name and last name. */
        name: string;
        /** Employment status of the account holder (regulatory questions). */
        employmentStatus: ModelTypes['EmploymentStatus'];
        /** Monthly income of the account holder (regulatory questions). */
        monthlyIncome: ModelTypes['MonthlyIncome'];
        /** User of the individual account holder. */
        user: ModelTypes['User'];
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
    };
    /** Account holder types. */
    ['AccountHolderInfo']: ModelTypes['AccountHolderCompanyInfo'] | ModelTypes['AccountHolderIndividualInfo'];
    /** Rejection returned when the Account Holder was not found */
    ['AccountHolderNotFoundRejection']: {
        message: string;
    };
    ['AccountHolderOrderByFieldInput']: AccountHolderOrderByFieldInput;
    /** Order that can be applied when listing account holders */
    ['AccountHolderOrderByInput']: {
        field?: ModelTypes['AccountHolderOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['AccountHolderStatus']: AccountHolderStatus;
    /** Account Holder Status Information */
    ['AccountHolderStatusInfo']: ModelTypes['AccountHolderCanceledStatusInfo'] | ModelTypes['AccountHolderEnabledStatusInfo'] | ModelTypes['AccountHolderSuspendedStatusInfo'];
    /** Account Holder Suspended Status Information */
    ['AccountHolderSuspendedStatusInfo']: {
        /** Status of the account holder. */
        status: ModelTypes['AccountHolderStatus'];
        /** Reason why the account holder is suspended. */
        reason: string;
    };
    ['AccountHolderType']: AccountHolderType;
    /** Rejection returned if the account holder type is individual.
  An individual account holder can't create a b2b received direct debit mandate. */
    ['AccountHolderTypeIndividualRejection']: {
        message: string;
    };
    ['AccountLanguage']: AccountLanguage;
    /** An account membership represents the rights of a user for a given account.
  
  *Each account is administered by an account membership having the capacity of legal representative. He has the possibility of delegating rights on this account to other users.* */
    ['AccountMembership']: {
        /** Unique identifier of an account membership */
        id: string;
        /** email */
        email: string;
        /** user of this account membership */
        user?: ModelTypes['User'] | undefined;
        /** `true` if this account membership having the capacity of the legal representative of the account holder. */
        legalRepresentative: boolean;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean;
        /** `true` if this account membership can invite, update, suspend or resume memberships */
        canManageAccountMembership: boolean;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards: boolean;
        /** status of the account membership */
        statusInfo: ModelTypes['AccountMembershipStatusInfo'];
        /** account of the account membership */
        account?: ModelTypes['Account'] | undefined;
        /** Periodic Spending limit list */
        spendingLimits?: Array<ModelTypes['SpendingLimit']> | undefined;
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** version of the account membership started from '1' and incremented at every updates */
        version: string;
        /** Residency address of the member */
        residencyAddress?: ModelTypes['AddressInfo'] | undefined;
        /** Tax Identification Number of the member */
        taxIdentificationNumber?: string | undefined;
        /** List of accepted identification level */
        acceptedIdentificationLevels: Array<ModelTypes['IdentificationLevel'] | undefined>;
        /** Recommended identification level */
        recommendedIdentificationLevel: ModelTypes['IdentificationLevel'];
        /** Indicate if the identity bound to the account membership has required identification level */
        hasRequiredIdentificationLevel?: boolean | undefined;
        /** Disabled date */
        disabledAt?: ModelTypes['DateTime'] | undefined;
        /** account membership's cards
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        cards: ModelTypes['CardConnection'];
        /** Periodic Spending */
        spending?: ModelTypes['Spending'] | undefined;
    };
    /** when a user is binded with the error to the account membership */
    ['AccountMembershipBindingUserErrorStatusInfo']: {
        /** AccountMembership status (always BindingUserError for type AccountMembershipBindingUserErrorStatusInfo) */
        status: ModelTypes['AccountMembershipStatus'];
        /** `true` if the first name of the user binded doesn't match with the invitation */
        firstNameMatchError: boolean;
        /** `true` if Swan hasn't verified the user's identity */
        idVerifiedMatchError: boolean;
        /** `true` if the last name of the user binded doesn't match with the invitation */
        lastNameMatchError: boolean;
        /** `true` if the phone number of the user binded doesn't match with the invitation */
        phoneNumberMatchError: boolean;
        /** `true` if the birth date of the user binded doesn't match with the invitation */
        birthDateMatchError: boolean;
        /** restricted to a user */
        restrictedTo: ModelTypes['RestrictedTo'];
    };
    ['AccountMembershipCannotBeDisabledRejection']: {
        accountMembershipId: string;
        message: string;
    };
    ['AccountMembershipCannotBeUpdatedRejection']: {
        id: string;
        message: string;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['AccountMembershipConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** AccountMembershipEdge list */
        edges: Array<ModelTypes['AccountMembershipEdge']>;
    };
    /** when the user has to consent to invite a new account membership */
    ['AccountMembershipConsentPendingStatusInfo']: {
        /** AccountMembership status (always ConsentPending for type AccountMembershipConsentPendingStatusInfo) */
        status: ModelTypes['AccountMembershipStatus'];
        /** The consent required to invite this account membership */
        consent: ModelTypes['Consent'];
        /** restricted to a user */
        restrictedTo: ModelTypes['RestrictedTo'];
    };
    /** when the account membership is disabled */
    ['AccountMembershipDisabledStatusInfo']: {
        /** AccountMembership status (always Disabled for type AccountMembershipDisabledStatusInfo) */
        status: ModelTypes['AccountMembershipStatus'];
        /** reason why the account membership is disabled */
        reason: string;
    };
    /** Implements the Relay Edge interface */
    ['AccountMembershipEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The account membership */
        node: ModelTypes['AccountMembership'];
    };
    /** when the account membership is enabled */
    ['AccountMembershipEnabledStatusInfo']: {
        /** AccountMembership status (always Enabled for type AccountMembershipEnabledStatusInfo) */
        status: ModelTypes['AccountMembershipStatus'];
    };
    /** when a new account membership is invited and there is no user binded yet */
    ['AccountMembershipInvitationSentStatusInfo']: {
        /** AccountMembership status (always InvitationSent for type AccountMembershipInvitationSentStatusInfo) */
        status: ModelTypes['AccountMembershipStatus'];
        /** restricted to a user */
        restrictedTo: ModelTypes['RestrictedTo'];
    };
    /** Rejection returned when the Account Membership is not allowed to use an operation. */
    ['AccountMembershipNotAllowedRejection']: {
        message: string;
    };
    ['AccountMembershipNotFoundRejection']: {
        id: string;
        message: string;
    };
    /** Rejection returned if invitation has not been sent to user yet */
    ['AccountMembershipNotReadyToBeBoundRejection']: {
        id: string;
        message: string;
    };
    ['AccountMembershipOrderByFieldInput']: AccountMembershipOrderByFieldInput;
    /** Order that can be applied when listing account memberships */
    ['AccountMembershipOrderByInput']: {
        field?: ModelTypes['AccountMembershipOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    /** Filters that can be applied when listing accounts (Only applied in user context) */
    ['AccountMembershipsFilterInput']: {
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** Can the user initiate payments on this account */
        canInitiatePayments?: boolean | undefined;
        /** Can the user manage account membership */
        canManageAccountMembership?: boolean | undefined;
        /** Can the user manage beneficiaries */
        canManageBeneficiaries?: boolean | undefined;
        /** Can the user view account */
        canViewAccount?: boolean | undefined;
        /** Account memberships status/statuses we're looking for */
        status?: Array<ModelTypes['AccountMembershipStatus']> | undefined;
        /** Filtered by email */
        email?: string | undefined;
        /** Filtered by first name */
        firstName?: string | undefined;
        /** Filtered by last name */
        lastName?: string | undefined;
        /** Searches email, first name, last name, and id */
        search?: string | undefined;
    };
    ['AccountMembershipsPermission']: AccountMembershipsPermission;
    ['AccountMembershipStatus']: AccountMembershipStatus;
    /** here are the different account membership status: */
    ['AccountMembershipStatusInfo']: ModelTypes['AccountMembershipBindingUserErrorStatusInfo'] | ModelTypes['AccountMembershipConsentPendingStatusInfo'] | ModelTypes['AccountMembershipDisabledStatusInfo'] | ModelTypes['AccountMembershipEnabledStatusInfo'] | ModelTypes['AccountMembershipInvitationSentStatusInfo'] | ModelTypes['AccountMembershipSuspendedStatusInfo'];
    /** when the account membership is suspended */
    ['AccountMembershipSuspendedStatusInfo']: {
        /** AccountMembership status (always Suspended for type AccountMembershipSuspendedStatusInfo) */
        status: ModelTypes['AccountMembershipStatus'];
        /** reason why the account membership is suspended */
        reason: string;
    };
    /** Thrown when an related account is not eligible to the feature */
    ['AccountNotEligibleRejection']: {
        message: string;
    };
    /** Rejection returned if the account was not found or if the user does not have the rights to know that the card exists */
    ['AccountNotFoundRejection']: {
        id: string;
        message: string;
    };
    /** Swan account number */
    ['AccountNumber']: any;
    /** Account Opened status information */
    ['AccountOpenedStatus']: {
        /** Account status (always Opened for type AccountOpenedStatus) */
        status: ModelTypes['AccountStatus'];
    };
    ['AccountOrderByFieldInput']: AccountOrderByFieldInput;
    /** Order that can be applied when listing accounts */
    ['AccountOrderByInput']: {
        field?: ModelTypes['AccountOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    /** Filter that can be passed to get the received direct debit mandate in a specific data range */
    ['AccountReceivedDirectDebitMandateFiltersInput']: {
        /** To filter on status values */
        status?: Array<ModelTypes['ReceivedDirectDebitMandateStatus']> | undefined;
        /** To filter on scheme values */
        scheme?: Array<ModelTypes['ReceivedDirectDebitMandateScheme']> | undefined;
    };
    ['AccountReceivedDirectDebitOrderByFieldInput']: AccountReceivedDirectDebitOrderByFieldInput;
    /** Order that can be applied when listing receives direct debit mandate results */
    ['AccountReceivedDirectDebitOrderByInput']: {
        field?: ModelTypes['AccountReceivedDirectDebitOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    /** Filters that can be applied when listing Standing orders */
    ['AccountStandingOrderFiltersInput']: {
        status?: Array<ModelTypes['StandingOrderStatus']> | undefined;
    };
    ['AccountStandingOrderOrderByFieldInput']: AccountStandingOrderOrderByFieldInput;
    /** Order that can be applied when listing standing order results */
    ['AccountStandingOrderOrderByInput']: {
        field?: ModelTypes['AccountStandingOrderOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['AccountStatus']: AccountStatus;
    ['AccountStatusInfo']: ModelTypes['AccountClosedStatus'] | ModelTypes['AccountClosingStatus'] | ModelTypes['AccountOpenedStatus'] | ModelTypes['AccountSuspendedStatus'];
    /** Account Suspended status information */
    ['AccountSuspendedStatus']: {
        /** Account status (always Suspended for type AccountSuspendedStatus) */
        status: ModelTypes['AccountStatus'];
        /** Reason why the account is suspended
    @Deprecated */
        reason: string;
        /** Reason why the account is currently suspend */
        reasonInfo: ModelTypes['SuspendAccountStatusReason'];
    };
    /** Account Verification */
    ['AccountVerification']: ModelTypes['DirectDebitAccountVerification'];
    /** Rejection returned when the external account has already been rejected.
  
  In such a case, contact Swan directly to resolve the situation for this specific account holder. */
    ['AccountVerificationAlreadyRejectedRejection']: {
        message: string;
    };
    ['AccountVerificationStatus']: AccountVerificationStatus;
    /** Account Verification Status Information */
    ['AccountVerificationStatusInfo']: ModelTypes['PendingReviewStatusInfo'] | ModelTypes['PendingVerificationStatusInfo'] | ModelTypes['RejectedVerificationStatusInfo'] | ModelTypes['VerifiedStatusInfo'];
    /** Rejection returned when the Account Verification is not in the expected status */
    ['AccountVerificationWrongStatusRejection']: {
        message: string;
    };
    ['ActionNotAllowedRejection']: {
        message: string;
    };
    ['ActivatePhysicalCardInput']: {
        /** Unique identifier present on physical card */
        identifier: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ActivatePhysicalCardPayload']: ModelTypes['ActivatePhysicalCardSuccessPayload'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['PhysicalCardNotFoundRejection'] | ModelTypes['PhysicalCardWrongStatusRejection'] | ModelTypes['CannotActivatePhysicalCardRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['UserNotCardHolderRejection'] | ModelTypes['ValidationRejection'];
    ['ActivatePhysicalCardSuccessPayload']: {
        /** The consent required to activate this physical card */
        consent: ModelTypes['Consent'];
        /** The physicalCard to activate */
        physicalCard: ModelTypes['PhysicalCard'];
    };
    ['ActiveMerchantPaymentLinkStatusInfo']: {
        status: ModelTypes['MerchantPaymentLinkStatus'];
        /** The date when the payment link expires.
    By default the payment link expires 120 days after it was created. */
        expiresAt: ModelTypes['DateTime'];
    };
    /** Inputs to add a new account membership */
    ['AddAccountMembershipInput']: {
        /** Unique identifier of a given account */
        accountId: string;
        /** Email address */
        email: string;
        /** Restricted to a user if necessary */
        restrictedTo: ModelTypes['RestrictedToInput'];
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean;
        /** `true` if this account membership can invite, update, suspend or resume account membership */
        canManageAccountMembership: boolean;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Residency address of the member to be added */
        residencyAddress?: ModelTypes['ResidencyAddressInput'] | undefined;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined;
    };
    ['AddAccountMembershipPayload']: ModelTypes['AddAccountMembershipSuccessPayload'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InvalidPhoneNumberRejection'] | ModelTypes['PermissionCannotBeGrantedRejection'] | ModelTypes['ValidationRejection'];
    /** Inputs to add a new account membership */
    ['AddAccountMembershipsInput']: {
        /** Unique identifier of a given account */
        accountId: string;
        /** Memberships to add to the account */
        memberships: Array<ModelTypes['MembershipInfoInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['AddAccountMembershipsPayload']: ModelTypes['AddAccountMembershipsSuccessPayload'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InvalidPhoneNumberRejection'] | ModelTypes['PermissionCannotBeGrantedRejection'] | ModelTypes['TooManyItemsRejection'] | ModelTypes['ValidationRejection'];
    ['AddAccountMembershipsSuccessPayload']: {
        accountMemberships: Array<ModelTypes['AccountMembership']>;
    };
    ['AddAccountMembershipSuccessPayload']: {
        accountMembership: ModelTypes['AccountMembership'];
    };
    /** Inputs to add a new card */
    ['AddCardInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ModelTypes['DateTime'] | undefined;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Card name */
        name?: string | undefined;
        /** `true` to show the card confidential information in the same request */
        viewCardNumber?: boolean | undefined;
        /** The id of the card product to use to create the new card. */
        cardProductId?: string | undefined;
        /** Spending limit */
        spendingLimit?: ModelTypes['SpendingLimitInput'] | undefined;
    };
    ['AddCardPayload']: ModelTypes['AddCardSuccessPayload'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['CardProductDisabledRejection'] | ModelTypes['CardProductSuspendedRejection'] | ModelTypes['EnabledCardDesignNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['MissingMandatoryFieldRejection'] | ModelTypes['ValidationRejection'];
    /** Input to add a new cards */
    ['AddCardsInput']: {
        /** The configuration of all the cards you want to add */
        cards: Array<ModelTypes['CardConfigInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined;
    };
    ['AddCardsPayload']: ModelTypes['AddCardsSuccessPayload'] | ModelTypes['AddingCardsToDifferentAccountsRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['TooManyItemsRejection'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['CardProductSuspendedRejection'] | ModelTypes['CardProductNotApplicableToPhysicalCardsRejection'] | ModelTypes['CardProductDisabledRejection'] | ModelTypes['EnabledCardDesignNotFoundRejection'] | ModelTypes['MissingMandatoryFieldRejection'] | ModelTypes['ValidationRejection'];
    ['AddCardsSuccessPayload']: {
        /** The newly created cards */
        cards: Array<ModelTypes['Card']>;
    };
    ['AddCardSuccessPayload']: {
        /** The new card added */
        card: ModelTypes['Card'];
    };
    /** Input to add a new cards */
    ['AddCardsWithGroupDeliveryInput']: {
        /** Address to deliver the printed physical cards */
        groupDeliveryAddress: ModelTypes['CompleteAddressWithContactInput'];
        /** The configuration of all the cards you want to add */
        cards: Array<ModelTypes['CardConfigWithGroupDeliveryInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined;
    };
    ['AddCardsWithGroupDeliveryPayload']: ModelTypes['AddCardsWithGroupDeliverySuccessPayload'] | ModelTypes['AddingCardsToDifferentAccountsRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['TooManyItemsRejection'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['CardProductSuspendedRejection'] | ModelTypes['CardProductNotApplicableToPhysicalCardsRejection'] | ModelTypes['CardProductDisabledRejection'] | ModelTypes['EnabledCardDesignNotFoundRejection'] | ModelTypes['MissingMandatoryFieldRejection'] | ModelTypes['ValidationRejection'];
    ['AddCardsWithGroupDeliverySuccessPayload']: {
        /** The newly created cards */
        cards: Array<ModelTypes['Card']>;
    };
    /** Inputs to add a new digital card */
    ['AddDigitalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Provider for which to generate a digitalCard */
        walletProvider: ModelTypes['WalletProviderType'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** Payload returned on mutation completion */
    ['AddDigitalCardPayload']: ModelTypes['AddDigitalCardSuccessPayload'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['CardCanNotBeDigitalizedRejection'] | ModelTypes['ApplePayNotAllowedForProjectRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['UserNotCardHolderRejection'] | ModelTypes['CardProductDisabledRejection'] | ModelTypes['EnabledCardDesignNotFoundRejection'] | ModelTypes['MissingMandatoryFieldRejection'] | ModelTypes['ValidationRejection'];
    ['AddDigitalCardSuccessPayload']: {
        /** Digital Card used for ApplePay or GooglePay
    
    The consent can be found in the digital card status information. */
        digitalCard: ModelTypes['PendingDigitalCard'];
    };
    /** Input to add a Direct Debit Funding Source */
    ['AddDirectDebitFundingSourceInput']: {
        /** Scheme of the underlying payment mandate */
        scheme: ModelTypes['SEPADirectDebitScheme'];
        /** Id of the account on which to create a funding source.
    Money will be funded to this account when an `initiateFundingRequest` is done using this funding source */
        accountId: string;
        /** IBAN to use in the direct debit transaction that will be triggered when funding the account.
    Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source */
        iban: ModelTypes['IBAN'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Name to give to this funding source */
        name?: string | undefined;
    };
    /** Add Direct Debit Funding Source Payload */
    ['AddDirectDebitFundingSourcePayload']: ModelTypes['AddDirectDebitFundingSourceSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['NotFoundRejection'] | ModelTypes['AccountVerificationAlreadyRejectedRejection'] | ModelTypes['IBANNotReachableRejection'] | ModelTypes['ValidationRejection'];
    /** Add Direct Debit Funding Source Success Payload */
    ['AddDirectDebitFundingSourceSuccessPayload']: {
        /** The created funding source */
        fundingSource: ModelTypes['FundingSource'];
    };
    ['AddExternalAccountBalanceInput']: {
        /** Unique identifier of a given external account */
        externalAccountId: string;
        /** Amount of the balance */
        amount: ModelTypes['AmountInput'];
        /** Type of the balance */
        type: ModelTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: ModelTypes['DateTime'];
    };
    ['AddExternalAccountBalancePayload']: ModelTypes['AddExternalAccountBalanceSuccessPayload'] | ModelTypes['ValidationRejection'] | ModelTypes['ExternalAccountBalanceAlreadyExistsRejection'] | ModelTypes['ForbiddenRejection'];
    ['AddExternalAccountBalanceSuccessPayload']: {
        /** The added external balance */
        externalAccountBalance: ModelTypes['ExternalAccountBalance'];
    };
    ['AddExternalAccountInput']: {
        /** Unique identifier of a given account holder */
        accountHolderId: string;
        /** External account identifier */
        externalId: string;
        /** Name of the account */
        name?: string | undefined;
        /** Type of account */
        cashAccountType: ModelTypes['CashAccountType'];
        /** Bank Identifier Code */
        BIC: ModelTypes['BIC'];
        /** International Bank Account Number */
        IBAN: ModelTypes['IBAN'];
        /** Currency */
        currency: ModelTypes['Currency'];
        /** Account Holder name */
        holderName: string;
        /** Country */
        country: ModelTypes['CCA3'];
        /** Original Created date */
        originalCreatedAt: ModelTypes['DateTime'];
        /** Usage information of the account */
        usage: ModelTypes['ExternalAccountUsage'];
        /** Source of the account information */
        source: string;
        /** Balances */
        balances?: Array<ModelTypes['ExternalAccountBalanceInput']> | undefined;
    };
    ['AddExternalAccountPayload']: ModelTypes['AddExternalAccountSuccessPayload'] | ModelTypes['ValidationRejection'] | ModelTypes['IbanValidationRejection'] | ModelTypes['ExternalAccountAlreadyExistsRejection'] | ModelTypes['ForbiddenRejection'];
    ['AddExternalAccountSuccessPayload']: {
        /** The added external account */
        externalAccount: ModelTypes['ExternalAccount'];
    };
    /** Inputs to add a new request for funding limit settings change */
    ['AddFundingLimitSettingsChangeRequestInput']: {
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit: ModelTypes['FundingLimitAmountInput'];
        /** Requested amount settings for the funding limit */
        fundingLimit: ModelTypes['FundingLimitAmountInput'];
        /** Unique identifier of a given account holder */
        accountHolderId: string;
    };
    /** Payload returned on mutation completion */
    ['AddFundingLimitSettingsChangeRequestPayload']: ModelTypes['AddFundingLimitSettingsChangeRequestSuccessPayload'] | ModelTypes['FundingLimitSettingsChangeRequestBadAmountRejection'] | ModelTypes['AccountHolderNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ValidationRejection'];
    /** Add Funding Limit Settings Change Request Success Payload */
    ['AddFundingLimitSettingsChangeRequestSuccessPayload']: {
        /** The new request for funding limit settings change */
        fundingLimitSettingsChangeRequest: ModelTypes['FundingLimitSettingsChangeRequest'];
    };
    /** Rejection returned if the attempting to add cards to different accounts. */
    ['AddingCardsToDifferentAccountsRejection']: {
        message: string;
    };
    /** Inputs to add an Internal Direct Debit Payment Mandate */
    ['AddInternalDirectDebitPaymentMandateInput']: {
        /** The ID of the concerned merchant payment method */
        paymentMethodId: string;
        /** Determines whether the payment mandate is a one-off or recurrent */
        sequence?: ModelTypes['InternalDirectDebitSequence'] | undefined;
        /** Reference of the payment mandate */
        reference?: string | undefined;
        /** Language that will be used to produce the mandate PDF document */
        language?: ModelTypes['MandateLanguage'] | undefined;
        /** ID of the Swan account of the debtor */
        debtorAccountId: string;
        /** Signature date of the Internal Direct Debit mandate */
        signatureDate?: ModelTypes['Date'] | undefined;
        /** Custom name of the Internal Direct Debit mandate */
        name?: string | undefined;
    };
    /** Union type return by the addInternalDirectDebitPaymentMandate mutation */
    ['AddInternalDirectDebitPaymentMandatePayload']: ModelTypes['AddInternalDirectDebitPaymentMandateSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['NotFoundRejection'] | ModelTypes['DebtorAccountNotAllowedRejection'] | ModelTypes['DebtorAccountClosedRejection'] | ModelTypes['SchemeWrongRejection'] | ModelTypes['PaymentMandateReferenceAlreadyUsedRejection'] | ModelTypes['InternalErrorRejection'];
    /** Return type in case of a successful response of the addInternalDirectDebitPaymentMandate mutation */
    ['AddInternalDirectDebitPaymentMandateSuccessPayload']: {
        paymentMandate: ModelTypes['InternalPaymentDirectDebitMandate'];
    };
    /** Input to add a Merchant Profile */
    ['AddMerchantProfileInput']: {
        /** ID of the Swan account which the merchantProfile is associated to */
        accountId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website */
        merchantWebsite?: string | undefined;
        /** base64 encoded merchant's logo */
        merchantLogo?: string | undefined;
        /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: ModelTypes['ProductType'];
        /** Expected annual activity volumes for all payment methods. */
        expectedMonthlyPaymentVolume: ModelTypes['AmountInput'];
        /** expected average basket value. */
        expectedAverageBasket: ModelTypes['AmountInput'];
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page. */
        accentColor?: string | undefined;
    };
    /** Add Merchant Profile Payload */
    ['AddMerchantProfilePayload']: ModelTypes['AddMerchantProfileSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ValidationRejection'];
    /** Add Merchant Profile Success Payload */
    ['AddMerchantProfileSuccessPayload']: {
        /** Merchant Profile */
        merchantProfile: ModelTypes['MerchantProfile'];
    };
    ['AddOrUpdateExternalAccountBalanceInput']: {
        /** Unique identifier of a given external account */
        externalAccountId: string;
        /** Amount of the balance */
        amount: ModelTypes['AmountInput'];
        /** Type of the balance */
        type: ModelTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: ModelTypes['DateTime'];
    };
    ['AddOrUpdateExternalAccountBalancePayload']: ModelTypes['AddOrUpdateExternalAccountBalanceSuccessPayload'] | ModelTypes['ValidationRejection'] | ModelTypes['ForbiddenRejection'];
    ['AddOrUpdateExternalAccountBalanceSuccessPayload']: {
        /** The added external balance */
        externalAccountBalance: ModelTypes['ExternalAccountBalance'];
    };
    /** Inputs to add a received internal direct debit mandate B2b. */
    ['AddReceivedInternalDirectDebitB2bMandateInput']: {
        /** The associated Payment Mandate ID */
        paymentMandateId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined;
    };
    /** Union type return by the addReceivedInternalDirectDebitB2bMandate mutation */
    ['AddReceivedInternalDirectDebitB2bMandatePayload']: ModelTypes['AddReceivedInternalDirectDebitB2bMandateSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['PaymentMandateMandateNotFoundRejection'] | ModelTypes['AccountHolderTypeIndividualRejection'];
    /** Return type in case of a successful response of the addReceivedInternalDirectDebitB2bMandate mutation */
    ['AddReceivedInternalDirectDebitB2bMandateSuccessPayload']: {
        /** The received direct debit mandate is added */
        receivedDirectDebitMandate: ModelTypes['ReceivedDirectDebitMandate'];
    };
    /** Inputs to add a received sepa direct debit mandate B2b. */
    ['AddReceivedSepaDirectDebitB2bMandateInput']: {
        /** The unique identifier of the received direct debit mandate */
        mandateReference: string;
        /** The Sepa Creditor Identifier of the creditor */
        creditorIdentifier: string;
        /** The name of the creditor */
        creditorName: string;
        /** The Swan Iban of the debtor */
        iban: string;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined;
        /** Sequence of the mandate */
        sequence: ModelTypes['SEPAReceivedDirectDebitMandateSequence'];
        /** Date of signature of the mandate */
        signatureDate?: ModelTypes['Date'] | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** Union type return by the addReceivedSepaDirectDebitB2bMandate mutation */
    ['AddReceivedSepaDirectDebitB2bMandatePayload']: ModelTypes['AddReceivedSepaDirectDebitB2bMandateSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['AccountHolderTypeIndividualRejection'];
    /** Return type in case of a successful response of the addReceivedSepaDirectDebitB2bMandate mutation */
    ['AddReceivedSepaDirectDebitB2bMandateSuccessPayload']: {
        /** The received direct debit mandate is added */
        receivedDirectDebitMandate: ModelTypes['ReceivedDirectDebitMandate'];
    };
    /** Address Information */
    ['Address']: {
        /** address line 1 */
        addressLine1?: string | undefined;
        /** addressLine2 */
        addressLine2?: string | undefined;
        /** city */
        city?: string | undefined;
        /** postal code (max 10 characters) */
        postalCode?: string | undefined;
        /** state */
        state?: string | undefined;
        /** country */
        country?: ModelTypes['CCA3'] | undefined;
    };
    /** Address information. */
    ['AddressInfo']: {
        /** Address line 1. */
        addressLine1?: string | undefined;
        /** Address line 2. */
        addressLine2?: string | undefined;
        /** City. */
        city?: string | undefined;
        /** Postal code. */
        postalCode?: string | undefined;
        /** State. */
        state?: string | undefined;
        /** Country. */
        country?: ModelTypes['CCA3'] | undefined;
    };
    /** Address */
    ['AddressInformation']: {
        /** Address */
        addressLine1: string;
        /** Address */
        addressLine2?: string | undefined;
        /** City */
        city: string;
        /** Country */
        country: ModelTypes['CCA3'];
        /** Postal code */
        postalCode: string;
        /** State */
        state?: string | undefined;
    };
    /** Address */
    ['AddressInformationInput']: {
        /** Address */
        addressLine1: string;
        /** Address */
        addressLine2?: string | undefined;
        /** City */
        city: string;
        /** Country */
        country: ModelTypes['CCA3'];
        /** Postal code */
        postalCode: string;
        /** State */
        state?: string | undefined;
    };
    /** Address Information */
    ['AddressInput']: {
        /** address line 1 (max 100 characters) */
        addressLine1?: string | undefined;
        /** address line 2 (max 100 characters) */
        addressLine2?: string | undefined;
        /** city (max 100 characters) */
        city?: string | undefined;
        /** postal code (max 10 characters) */
        postalCode?: string | undefined;
        /** state (max 100 characters) */
        state?: string | undefined;
        /** country code */
        country: ModelTypes['CCA3'];
    };
    ['AddSepaDirectDebitPaymentMandateInput']: {
        /** Specifies payment ID of a SEPA Direct Debit CORE or B2B payment method. */
        paymentMethodId: string;
        /** Determines whether the payment mandate is a one-off or recurrent */
        sequence: ModelTypes['DirectDebitSequence'];
        /** Unique reference of the SEPA Direct Debit Payment Mandate. */
        reference?: string | undefined;
        /** Language that will be used to produce the mandate PDF document */
        language: ModelTypes['MandateLanguage'];
        /** Signature date of the SEPA Direct Debit Payment Mandate */
        signatureDate: ModelTypes['Date'];
        /** Debtor of the SEPA Direct Debit Payment Mandate */
        debtor: ModelTypes['SepaPaymentMandateDebtorInput'];
        /** Custom name of the SEPA Direct Debit Payment Mandate */
        name?: string | undefined;
    };
    /** Union type return by the addSepaDirectDebitPaymentMandate mutation */
    ['AddSepaDirectDebitPaymentMandatePayload']: ModelTypes['AddSepaDirectDebitPaymentMandateSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['NotFoundRejection'] | ModelTypes['DebtorAccountNotAllowedRejection'] | ModelTypes['DebtorAccountClosedRejection'] | ModelTypes['SchemeWrongRejection'] | ModelTypes['PaymentMandateReferenceAlreadyUsedRejection'] | ModelTypes['ValidationRejection'] | ModelTypes['PaymentMethodNotCompatibleRejection'] | ModelTypes['InternalErrorRejection'];
    /** Return type in case of a successful response of the addSepaDirectDebitPaymentMandate mutation */
    ['AddSepaDirectDebitPaymentMandateSuccessPayload']: {
        paymentMandate: ModelTypes['SEPAPaymentDirectDebitMandate'];
    };
    /** Inputs to add a new card */
    ['AddSingleUseVirtualCardInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Spending limit */
        spendingLimit: ModelTypes['SpendingLimitInput'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Card name */
        name?: string | undefined;
        /** `true` to show the card confidential information in the same request */
        viewCardNumber?: boolean | undefined;
        /** The id of the card product to use to create the new card. */
        cardProductId?: string | undefined;
    };
    ['AddSingleUseVirtualCardPayload']: ModelTypes['AddSingleUseVirtualCardSuccessForUserPayload'] | ModelTypes['AddSingleUseVirtualCardSuccessForProjectOwnerPayload'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['CardProductSuspendedRejection'] | ModelTypes['CardProductDisabledRejection'] | ModelTypes['EnabledCardDesignNotFoundRejection'] | ModelTypes['MissingMandatoryFieldRejection'] | ModelTypes['ValidationRejection'];
    /** Input to add a new single-use virtual cards */
    ['AddSingleUseVirtualCardsInput']: {
        /** The configuration of all the cards you want to add */
        cards: Array<ModelTypes['SingleUseVirtualCardConfigInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined;
    };
    ['AddSingleUseVirtualCardsPayload']: ModelTypes['AddSingleUseVirtualCardsSuccessPayload'] | ModelTypes['AddingCardsToDifferentAccountsRejection'] | ModelTypes['TooManyItemsRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['CardProductSuspendedRejection'] | ModelTypes['CardProductDisabledRejection'] | ModelTypes['EnabledCardDesignNotFoundRejection'] | ModelTypes['MissingMandatoryFieldRejection'] | ModelTypes['ValidationRejection'];
    ['AddSingleUseVirtualCardsSuccessPayload']: {
        /** The newly created single use virtual cards */
        cards: Array<ModelTypes['Card']>;
    };
    ['AddSingleUseVirtualCardSuccessForProjectOwnerPayload']: {
        /** The new card added */
        card: ModelTypes['Card'];
        /** Card confidential */
        confidential: ModelTypes['CardConfidential'];
    };
    ['AddSingleUseVirtualCardSuccessForUserPayload']: {
        /** The new card added */
        card: ModelTypes['Card'];
    };
    ['AddVirtualIbanEntryPayload']: ModelTypes['AddVirtualIbanEntrySuccessPayload'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ValidationRejection'];
    ['AddVirtualIbanEntrySuccessPayload']: {
        virtualIbanEntry: ModelTypes['VirtualIBANEntry'];
    };
    /** Input to Add a Virtual IBAN */
    ['AddVirtualIbanInput']: {
        /** Unique identifier of a given account */
        accountId: string;
    };
    /** Input values needed to add a webhook subscription */
    ['AddWebhookSubscriptionInput']: {
        /** A short descriptive label for the subscription
    (max 255 characters) */
        label: string;
        /** The endpoint URL events will be sent to
    (max 255 characters) */
        endpoint: string;
        /** The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
    (max 36 characters) */
        secret?: string | undefined;
        /** The types of subscribed events
    A subset of unique IDs from `webhookEventTypes` */
        eventTypes: Array<string>;
        /** Control if the subscription should be enabled on creation */
        status: ModelTypes['WebhookSubscriptionCreationStatus'];
    };
    ['AllowedValue']: {
        key: string;
        name: string;
    };
    /** Input to Allow SDD */
    ['AllowSddInput']: {
        /** Unique identifier of a given account */
        accountId: string;
    };
    ['AllowSddPayload']: ModelTypes['AllowSddSuccessPayload'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['ValidationRejection'];
    ['AllowSddSuccessPayload']: {
        account: ModelTypes['Account'];
    };
    ['AllowSddVirtualIbanEntryInput']: {
        ibanEntryId: string;
    };
    ['AllowSddVirtualIbanEntryPayload']: ModelTypes['AllowSddVirtualIbanEntrySuccessPayload'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['ValidationRejection'];
    ['AllowSddVirtualIbanEntrySuccessPayload']: {
        virtualIbanEntry: ModelTypes['VirtualIBANEntry'];
    };
    /** Rejection returned if card already has a valid Physical Card */
    ['AlreadyValidPhysicalCardRejection']: {
        message: string;
    };
    ['AmlRiskLevel']: AmlRiskLevel;
    /** Amount with its currency */
    ['Amount']: {
        /** currency */
        currency: ModelTypes['Currency'];
        /** value of the amount */
        value: ModelTypes['AmountValue'];
    };
    /** Amount with its currency */
    ['AmountInput']: {
        /** value of the amount */
        value: ModelTypes['AmountValue'];
        /** currency */
        currency: ModelTypes['Currency'];
    };
    /** The amount given with fractional digits, where fractions must be compliant to the currency definition. Up to 14 significant figures. Negative amounts are signed by minus. The decimal separator is a dot.
  
  Example: Valid representations for EUR with up to two decimals are:
  
  1056
  5768.2
  -1.50
  5877.78 */
    ['AmountValue']: any;
    /** Rejection return if the project is not configured to allow Apple Pay */
    ['ApplePayNotAllowedForProjectRejection']: {
        id: string;
        message: string;
    };
    /** Approved Funding Limit */
    ['ApprovedFundingLimit']: {
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit: ModelTypes['FundingLimitAmount'];
        /** Requested amount settings for the funding limit */
        fundingLimit: ModelTypes['FundingLimitAmount'];
    };
    ['AuditId']: any;
    /** A method used to authenticate a user */
    ['Authenticator']: {
        /** Operating System parsed from the user agent (eg AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, ...) */
        os?: string | undefined;
        /** Device Brand parsed from the user agent (eg: Acer, Alcatel, Amazon, Apple, ...) */
        brand?: string | undefined;
        /** Device Model parsed from the user agent */
        model?: string | undefined;
        /** Type of authenticator */
        type: ModelTypes['AuthenticatorType'];
        /** Raw user agent */
        userAgent?: string | undefined;
        /** Accept-Language header used during registration */
        acceptLanguage?: string | undefined;
    };
    ['AuthenticatorType']: AuthenticatorType;
    ['AuthorizationId']: any;
    ['AuthorizationType']: AuthorizationType;
    /** Rejection returned if the status account is not valid */
    ['BadAccountStatusRejection']: {
        id: string;
        message: string;
    };
    ['BadRequestRejection']: {
        message: string;
    };
    /** Balance Information */
    ['Balance']: {
        /** Matching account for this balance */
        account: ModelTypes['Account'];
        /** A list of balances regarding an account. */
        balances?: ModelTypes['AccountBalances'] | undefined;
        /** Last SCT OUT transaction */
        lastSctOut?: ModelTypes['SEPACreditTransferTransaction'] | undefined;
        /** Last SCT IN transaction */
        lastSctIn?: ModelTypes['SEPACreditTransferTransaction'] | undefined;
    };
    /** Information about the banking institution */
    ['Bank']: {
        /** Bank name */
        name: string;
        /** Bank Branch Code */
        branch?: string | undefined;
        /** Bank local identifier (unique by country) */
        nationalId: string;
        /** Bank BIC code */
        bic: ModelTypes['BIC'];
        /** Bank address (We might only be able to fill in the country) */
        address: ModelTypes['Address'];
    };
    /** Basic Physical Card Info */
    ['BasicPhysicalCardInfo']: {
        /** Physical Card expiration date  with MM/YY string format */
        expiryDate?: string | undefined;
        /** Offline Spending limit defined by Swan */
        offlineSpendingLimit: ModelTypes['Amount'];
        /** Masked Card Number */
        cardMaskedNumber: string;
        /** Custom Options */
        customOptions: ModelTypes['PhysicalCardCustomOptions'];
    };
    ['BeneficiaryAccountHolderType']: BeneficiaryAccountHolderType;
    ['BeneficiaryAccountStatus']: BeneficiaryAccountStatus;
    /** Beneficiary name and IBAN match */
    ['BeneficiaryMatch']: {
        accountStatus: ModelTypes['BeneficiaryAccountStatus'];
        accountHolderType: ModelTypes['BeneficiaryAccountHolderType'];
    };
    /** Beneficiary name and IBAN did not match */
    ['BeneficiaryMismatch']: {
        accountStatus: ModelTypes['BeneficiaryAccountStatus'];
        accountHolderType: ModelTypes['BeneficiaryAccountHolderType'];
        /** Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank */
        nameSuggestion?: string | undefined;
        /** Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank */
        accountHolderResidencyCity?: string | undefined;
    };
    ['BeneficiaryType']: BeneficiaryType;
    /** Beneficiary name and IBAN did not match entirely possibly caused by a mistype */
    ['BeneficiaryTypo']: {
        accountStatus: ModelTypes['BeneficiaryAccountStatus'];
        accountHolderType: ModelTypes['BeneficiaryAccountHolderType'];
        /** Only returned if the information is provided by the beneficiary's bank */
        nameSuggestion?: string | undefined;
    };
    /** BeneficiaryVerification input */
    ['BeneficiaryVerificationInput']: {
        /** IBAN to verify */
        iban: ModelTypes['IBAN'];
        /** Name to correlate */
        name: string;
        /** AccountId of the initiator of the payment */
        debtorAccountId: string;
    };
    /** BeneficiaryVerificationResult */
    ['BeneficiaryVerificationResult']: ModelTypes['BeneficiaryMatch'] | ModelTypes['BeneficiaryTypo'] | ModelTypes['BeneficiaryMismatch'] | ModelTypes['InvalidBeneficiaryVerification'];
    /** Bank Identifier Code */
    ['BIC']: any;
    ['BindAccountMembershipInput']: {
        accountMembershipId: string;
    };
    ['BindAccountMembershipPayload']: ModelTypes['BindAccountMembershipSuccessPayload'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['AccountMembershipNotFoundRejection'] | ModelTypes['AccountMembershipNotReadyToBeBoundRejection'] | ModelTypes['IdentityAlreadyBindToAccountMembershipRejection'] | ModelTypes['RestrictedToUserRejection'] | ModelTypes['ValidationRejection'];
    ['BindAccountMembershipSuccessPayload']: {
        accountMembership: ModelTypes['AccountMembership'];
    };
    /** Booked transaction status information */
    ['BookedTransactionStatusInfo']: {
        /** status of the transaction */
        status: ModelTypes['TransactionStatus'];
        /** The Date when the transaction is posted to an account on the Swan books. */
        bookingDate: ModelTypes['DateTime'];
        /** The Date when the transaction is considered effective in accounting */
        valueDate: ModelTypes['DateTime'];
    };
    ['BusinessActivity']: BusinessActivity;
    /** Inputs to cancel a card */
    ['CancelCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
    };
    ['CancelCardPayload']: ModelTypes['CancelCardSuccessPayload'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ValidationRejection'];
    ['CancelCardSuccessPayload']: {
        /** The canceled card */
        card: ModelTypes['Card'];
    };
    /** Input of the `cancelConsent` mutation */
    ['CancelConsentInput']: {
        consentId: string;
    };
    /** Payload of the `cancelConsent` mutation */
    ['CancelConsentPayload']: ModelTypes['CancelConsentSuccessPayload'] | ModelTypes['ConsentNotFoundRejection'] | ModelTypes['NotReachableConsentStatusRejection'];
    /** Success payload of the `cancelConsent` mutation */
    ['CancelConsentSuccessPayload']: {
        consent: ModelTypes['Consent'];
    };
    /** Inputs to cancel a digital card */
    ['CancelDigitalCardInput']: {
        /** Unique identifier of a digital card */
        digitalCardId: string;
    };
    ['CancelDigitalCardPayload']: ModelTypes['CancelDigitalCardSuccessPayload'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['DigitalCardNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ValidationRejection'];
    ['CancelDigitalCardSuccessPayload']: {
        /** The canceled digital card */
        digitalCard: ModelTypes['DigitalCard'];
    };
    ['CanceledFundingSourceReason']: CanceledFundingSourceReason;
    /** Funding Source Canceled status information */
    ['CanceledFundingSourceStatusInfo']: {
        /** Funding Source Canceled status */
        status: ModelTypes['FundingSourceStatus'];
        /** Date at which the funding source was enabled */
        enabledAt?: ModelTypes['Date'] | undefined;
        /** Date at which the funding source was canceled */
        canceledAt: ModelTypes['Date'];
        /** Reason code of the cancellation */
        reasonCode: ModelTypes['CanceledFundingSourceReason'];
    };
    /** Describes an identification level for the process associated to this identification that has been cancelled by the end-user */
    ['CanceledIdentificationLevelStatusInfo']: {
        /** Always set to `Cancelled` */
        status: ModelTypes['SwanIdentificationStatus'];
    };
    /** CanceledMerchantPaymentMethodStatusInfo */
    ['CanceledMerchantPaymentMethodStatusInfo']: {
        status: ModelTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method canceled date */
        canceledAt: ModelTypes['Date'];
    };
    /** CanceledMerchantProfileStatusInfo */
    ['CanceledMerchantProfileStatusInfo']: {
        status: ModelTypes['MerchantProfileStatus'];
        canceledAt: ModelTypes['Date'];
        enabledAt?: ModelTypes['Date'] | undefined;
    };
    /** Canceled transaction status information */
    ['CanceledTransactionStatusInfo']: {
        /** status of the transaction */
        status: ModelTypes['TransactionStatus'];
        /** The date when the transaction was canceled */
        canceledDate?: ModelTypes['DateTime'] | undefined;
    };
    /** Cancel Funding Source Input */
    ['CancelFundingSourceInput']: {
        /** ID of the funding source to cancel */
        id: string;
    };
    /** Cancel Funding Source Payload */
    ['CancelFundingSourcePayload']: ModelTypes['CancelFundingSourceSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['NotFoundRejection'];
    /** Cancel Funding Source Success Payload */
    ['CancelFundingSourceSuccessPayload']: {
        /** Canceled Funding Source */
        fundingSource?: ModelTypes['FundingSource'] | undefined;
    };
    /** Inputs to cancel a physical card */
    ['CancelPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Reason why the physical card is canceled */
        reason: ModelTypes['CancelPhysicalCardReason'];
    };
    ['CancelPhysicalCardPayload']: ModelTypes['CancelPhysicalCardSuccessPayload'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['PhysicalCardNotFoundRejection'] | ModelTypes['ValidationRejection'];
    ['CancelPhysicalCardReason']: CancelPhysicalCardReason;
    ['CancelPhysicalCardSuccessPayload']: {
        /** The canceled physical card */
        physicalCard: ModelTypes['PhysicalCard'];
    };
    ['CancelStandingOrderInput']: {
        standingOrderId: string;
    };
    ['CancelStandingOrderPayload']: ModelTypes['CancelStandingOrderSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['StandingOrderNotFoundRejection'];
    ['CancelStandingOrderSuccessPayload']: {
        standingOrder: ModelTypes['StandingOrder'];
    };
    /** Cancel transaction */
    ['CancelTransactionInput']: {
        /** transaction ID to cancel */
        transactionId: string;
    };
    ['CancelTransactionPayload']: ModelTypes['CancelTransactionSuccessPayload'] | ModelTypes['ForbiddenRejection'];
    ['CancelTransactionSuccessPayload']: {
        message: string;
    };
    ['CancelVirtualIbanEntryInput']: {
        virtualIbanEntryId: string;
    };
    ['CancelVirtualIbanEntryPayload']: ModelTypes['CancelVirtualIbanEntrySuccessPayload'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ValidationRejection'];
    ['CancelVirtualIbanEntrySuccessPayload']: {
        virtualIbanEntry: ModelTypes['VirtualIBANEntry'];
    };
    /** Rejection returned when the Physical Card cannot be activated */
    ['CannotActivatePhysicalCardRejection']: {
        message: string;
        identifier: string;
    };
    /** Capital deposit case for a company. */
    ['CapitalDepositCase']: {
        /** Unique identifier of a capital deposit case. */
        id: string;
        /** List of the company’s shareholders. */
        shareholders: Array<ModelTypes['Shareholder']>;
        /** Amount of the capital deposit. */
        totalCapitalDepositAmount: ModelTypes['Amount'];
        /** Name of the company. */
        companyName: string;
        /** Onboarding information of the company. */
        companyOnboarding?: ModelTypes['Onboarding'] | undefined;
        /** Unique identifier of the company account. */
        companyAccountId?: string | undefined;
        /** Status of the capital deposit case. */
        status: ModelTypes['CapitalDepositCaseStatus'];
        /** Documents to provide to fulfill the capital deposit case. */
        documents: Array<ModelTypes['CapitalDepositDocument']>;
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of elements ([Learn More](https://docs.swan.io/api/pagination)) */
    ['CapitalDepositCaseConnection']: {
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** CapitalDepositCaseEdge list */
        edges: Array<ModelTypes['CapitalDepositCaseEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['CapitalDepositCaseEdge']: {
        /** Opaque identifier pointing to this capital deposit case node in the pagination mechanism */
        cursor: string;
        /** The CapitalDepositCase */
        node: ModelTypes['CapitalDepositCase'];
    };
    /** Filters that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseFiltersInput']: {
        /** Searches company shareholder name, individual shareholder first name, last name, and id */
        search?: string | undefined;
        /** Status we want to filter on */
        status?: Array<ModelTypes['CapitalDepositCaseStatus']> | undefined;
    };
    ['CapitalDepositCaseOrderByFieldInput']: CapitalDepositCaseOrderByFieldInput;
    /** Order that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseOrderByInput']: {
        field?: ModelTypes['CapitalDepositCaseOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['CapitalDepositCaseStatus']: CapitalDepositCaseStatus;
    /** Document provided for a capital deposit case. */
    ['CapitalDepositDocument']: {
        /** Unique identifier of a document. */
        id: string;
        /** Type of the document. */
        type: ModelTypes['CapitalDepositDocumentType'];
        /** Url to download the document, null if it has not already been uploaded. */
        downloadUrl?: string | undefined;
        /** Date when the last version of the document has been uploaded. */
        uploadedAt?: ModelTypes['Date'] | undefined;
        /** Status of the document. */
        status: ModelTypes['CapitalDepositDocumentStatus'];
        /** Status info of the document. */
        statusInfo: ModelTypes['CapitalDepositDocumentStatusInfo'];
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** Information about capital deposit case. */
        relatedCapitalDepositCase?: ModelTypes['CapitalDepositCase'] | undefined;
        /** Information about shareholder. */
        relatedShareholder?: ModelTypes['Shareholder'] | undefined;
    };
    /** Rejection returned if the document from a capital deposit case cannot be uploaded in its context
  @deprecated(reason: "use `CapitalDepositDocumentCanNotBeUploadedRejection` instead") */
    ['CapitalDepositDocumentCanNotBeUploaded']: {
        id: string;
        message: string;
    };
    /** Rejection returned if the document from a capital deposit case cannot be uploaded in its context */
    ['CapitalDepositDocumentCanNotBeUploadedRejection']: {
        id: string;
        message: string;
    };
    /** Capital Deposit Document with Pending status */
    ['CapitalDepositDocumentPendingStatusInfo']: {
        /** Pending */
        status: ModelTypes['CapitalDepositDocumentStatus'];
    };
    /** Capital Deposit Document with Refused status */
    ['CapitalDepositDocumentRefusedStatusInfo']: {
        /** Refused */
        status: ModelTypes['CapitalDepositDocumentStatus'];
        /** Reason for the rejection. */
        reasonCode: ModelTypes['DocumentReasonCode'];
    };
    ['CapitalDepositDocumentStatus']: CapitalDepositDocumentStatus;
    /** Status info of the document. */
    ['CapitalDepositDocumentStatusInfo']: ModelTypes['CapitalDepositDocumentPendingStatusInfo'] | ModelTypes['CapitalDepositDocumentRefusedStatusInfo'] | ModelTypes['CapitalDepositDocumentUploadedStatusInfo'] | ModelTypes['CapitalDepositDocumentValidatedStatusInfo'];
    ['CapitalDepositDocumentType']: CapitalDepositDocumentType;
    /** Capital Deposit Document with Uploaded status */
    ['CapitalDepositDocumentUploadedStatusInfo']: {
        /** Uploaded */
        status: ModelTypes['CapitalDepositDocumentStatus'];
    };
    /** Capital Deposit Document with Validated status */
    ['CapitalDepositDocumentValidatedStatusInfo']: {
        /** Validated */
        status: ModelTypes['CapitalDepositDocumentStatus'];
    };
    /** Card */
    ['Card']: {
        /** Unique identifier of a card */
        id: string;
        /** Type of a card */
        type: ModelTypes['CardType'];
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** Account membership to define the card holder and the account linked to the card. */
        accountMembership: ModelTypes['AccountMembership'];
        /** Main Currency */
        mainCurrency: ModelTypes['Currency'];
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ModelTypes['DateTime'] | undefined;
        /** URL of the card design */
        cardDesignUrl: string;
        /** URL of the card with masked card information (like its number) and with full card information if connected user consented beforehand */
        cardUrl: string;
        /** Card status information */
        statusInfo: ModelTypes['CardStatusInfo'];
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Periodic Spending limit list */
        spendingLimits?: Array<ModelTypes['SpendingLimit']> | undefined;
        /** Physical card if the card holder has ordered one */
        physicalCard?: ModelTypes['PhysicalCard'] | undefined;
        /** Masked Card Number */
        cardMaskedNumber: string;
        /** Card expiry date with MM/YY format */
        expiryDate?: string | undefined;
        /** Card name */
        name?: string | undefined;
        /** Card product */
        cardProduct: ModelTypes['CardProduct'];
        /** Issuing Country */
        issuingCountry: ModelTypes['CCA3'];
        /** Digital Cards linked to this card
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        digitalCards: ModelTypes['DigitalCardConnection'];
        /** List of transactions of a card.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: ModelTypes['TransactionConnection'] | undefined;
        /** Periodic Spending */
        spending?: ModelTypes['Spending'] | undefined;
    };
    ['CardAuthorizationOutcome']: CardAuthorizationOutcome;
    ['CardAuthorizationType']: CardAuthorizationType;
    /** Card Canceled Status Information */
    ['CardCanceledStatusInfo']: {
        /** Card status (always Canceled for type CardCanceledStatusInfo). */
        status: ModelTypes['CardStatus'];
        /** Reason why the card is canceled */
        reason: string;
    };
    /** Card Canceling Status Information */
    ['CardCancelingStatusInfo']: {
        /** Card status (always Canceling for type CardCancelingStatusInfo). */
        status: ModelTypes['CardStatus'];
        /** Reason why the card is about to be canceled. */
        reason: string;
    };
    /** Rejection returned if the card could not be digitalized */
    ['CardCanNotBeDigitalizedRejection']: {
        id: string;
        message: string;
    };
    ['CardConfidential']: {
        /** Card number */
        pan: string;
        /** Card verification value */
        cvv: string;
        /** Expiration date */
        expiryDate: string;
    };
    ['CardConfigInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ModelTypes['DateTime'] | undefined;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Card name */
        name?: string | undefined;
        /** Spending limit */
        spendingLimit: ModelTypes['SpendingLimitInput'];
        /** If used a physical card will be printed and sent to the given address */
        physicalCard?: ModelTypes['PhysicalCardConfigInput'] | undefined;
    };
    ['CardConfigWithGroupDeliveryInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ModelTypes['DateTime'] | undefined;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Card name */
        name?: string | undefined;
        /** Spending limit */
        spendingLimit: ModelTypes['SpendingLimitInput'];
        /** `true` when you wish for print an associated physical card */
        printPhysicalCard: boolean;
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: ModelTypes['PhysicalCardCustomOptionsForGroupDeliveryInput'] | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['CardConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** CardEdge list */
        edges: Array<ModelTypes['CardEdge']>;
    };
    /** when the user has to consent to add this card */
    ['CardConsentPendingStatusInfo']: {
        /** Card status (always ConsentPending for type CardConsentPendingStatusInfo) */
        status: ModelTypes['CardStatus'];
        /** The consent required to add this card */
        consent: ModelTypes['Consent'];
    };
    ['CardDesignBackground']: {
        /** Unique identifier of a project card design background */
        id: string;
        /** Card design background name */
        name: string;
        /** Card design background type */
        type: string;
        /** Card design background text color */
        cardTextColor: string;
        /** Card design background url */
        cardBackgroundUrl: string;
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
    };
    ['CardDesignBackgroundType']: CardDesignBackgroundType;
    ['CardDesignStatus']: CardDesignStatus;
    /** Implements the Relay Edge interface */
    ['CardEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The Card entry */
        node: ModelTypes['Card'];
    };
    /** Card Enabled Status Information */
    ['CardEnabledStatusInfo']: {
        /** Card status (always Enabled for type CardEnabledStatusInfo). */
        status: ModelTypes['CardStatus'];
    };
    /** Filters that can be applied when listing cards */
    ['CardFiltersInput']: {
        /** The status of the card.
    
    @deprecated(reason: "use `statuses` instead") */
        status?: ModelTypes['CardStatus'] | undefined;
        /** Statuses of the card. */
        statuses?: Array<ModelTypes['CardStatus']> | undefined;
        /** Type of card
    
    @deprecated(reason: "use `types` instead") */
        type?: ModelTypes['CardType'] | undefined;
        /** Types of card */
        types?: Array<ModelTypes['CardType']> | undefined;
        /** String searched */
        search?: string | undefined;
        /** Account identifier
    
    This filter is only available for User Access Token, for the moment */
        accountId?: string | undefined;
    };
    /** COMING SOON */
    ['CardMerchantPaymentMethod']: {
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: ModelTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: ModelTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: ModelTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ModelTypes['RollingReserve'] | undefined;
    };
    /** Rejection returned if the card was not found or if the user does not have the rights to know that the account exists */
    ['CardNotFoundRejection']: {
        id: string;
        message: string;
    };
    ['CardOrderByFieldInput']: CardOrderByFieldInput;
    /** Order that can be applied when listing cards */
    ['CardOrderByInput']: {
        field?: ModelTypes['CardOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['CardPaymentMethodInput']: {
        /** Determine whether the payment method must be activated or not */
        activate?: boolean | undefined;
    };
    /** when the card is in the process of being ready to use */
    ['CardProcessingStatusInfo']: {
        /** Card status (always Processing for type CardProcessingStatusInfo) */
        status: ModelTypes['CardStatus'];
    };
    /** Card Product */
    ['CardProduct']: {
        id: string;
        name?: string | undefined;
        projectId: string;
        status: ModelTypes['CardProductStatus'];
        createdAt: ModelTypes['DateTime'];
        updatedAt: ModelTypes['DateTime'];
        applicableToPhysicalCards: boolean;
        cardDesigns: Array<ModelTypes['CardProductDesign']>;
        defaultCardProduct: boolean;
        individualSpendingLimit: ModelTypes['SpendingLimit'];
        companySpendingLimit: ModelTypes['SpendingLimit'];
    };
    /** Card design of a Card Product */
    ['CardProductDesign']: {
        /** Unique identifier of a card design */
        id: string;
        /** Design version */
        version: number;
        /** Logo url svg */
        cardProjectLogoSvgUrl?: string | undefined;
        /** Logo url 300 dpi */
        cardProjectLogo300dpiUrl?: string | undefined;
        /** Logo url 300 dpi */
        cardProjectLogo600dpiUrl?: string | undefined;
        /** Zoom level */
        zoomRatioProjectLogo?: number | undefined;
        /** Card Design URL */
        cardDesignUrl?: string | undefined;
        /** Accent color */
        accentColor: string;
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** Status of the card design */
        status: ModelTypes['CardDesignStatus'];
        /** Card Background of the Card design */
        cardBackground: ModelTypes['CardDesignBackground'];
    };
    /** Rejection returned if the card product is disabled. */
    ['CardProductDisabledRejection']: {
        message: string;
    };
    /** Rejection returned if the card product is not applicable to physical card. */
    ['CardProductNotApplicableToPhysicalCardsRejection']: {
        message: string;
    };
    ['CardProductNotFoundRejection']: {
        message: string;
    };
    ['CardProductStatus']: CardProductStatus;
    /** Rejection returned if the card product is suspended. */
    ['CardProductSuspendedRejection']: {
        message: string;
    };
    ['CardProductUsedRejection']: {
        message: string;
    };
    /** Card settings for a Project */
    ['CardSettings']: {
        /** Unique identifier of a project card settings */
        id: string;
        /** Flag used to indicate if ApplePay is activated for the project */
        allowsApplePay: boolean;
        /** Settings version */
        version: number;
        /** Logo url svg */
        cardProjectLogoSvgUrl?: string | undefined;
        /** Logo url 300 dpi */
        cardProjectLogo300dpiUrl?: string | undefined;
        /** Logo url 300 dpi */
        cardProjectLogo600dpiUrl?: string | undefined;
        /** Zoom level */
        zoomRatioProjectLogo?: number | undefined;
        /** Card Design URL */
        cardDesignUrl?: string | undefined;
        /** Accent color */
        accentColor: string;
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** Status of the card settings */
        status: ModelTypes['ProjectCardStatus'];
        /** Card Background of the Card Settings */
        cardBackground: ModelTypes['CardSettingsBackground'];
    };
    ['CardSettingsBackground']: {
        /** Unique identifier of a project card settings */
        id: string;
        /** Card settings background name */
        name: string;
        /** Card settings background type */
        type: string;
        /** Card settings background text color */
        cardTextColor: string;
        /** Card settings background url */
        cardBackgroundUrl: string;
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
    };
    ['CardSettingsBackgroundType']: CardSettingsBackgroundType;
    ['CardStatus']: CardStatus;
    /** Card Status Information */
    ['CardStatusInfo']: ModelTypes['CardCanceledStatusInfo'] | ModelTypes['CardCancelingStatusInfo'] | ModelTypes['CardConsentPendingStatusInfo'] | ModelTypes['CardEnabledStatusInfo'] | ModelTypes['CardProcessingStatusInfo'];
    ['CardToken']: any;
    /** Card transaction */
    ['CardTransaction']: {
        /** unique identifier of the transaction */
        id: string;
        /** external identifier of the transaction */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: ModelTypes['TransactionSide'];
        /** type */
        type: ModelTypes['TransactionTypeEnum'];
        /** amount */
        amount: ModelTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: ModelTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: ModelTypes['Payment'] | undefined;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ModelTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: ModelTypes['PaymentProduct'];
        /** card numbers masked (Primary Account Number) */
        maskedPan: string;
        /** unique identifier of the card */
        cardId: string;
        /** card used for this transaction */
        card: ModelTypes['Card'];
        /** unique identifier of the terminal */
        terminalId: string;
        /** original amount and currency of the transaction */
        originalAmount: ModelTypes['Amount'];
        /** currency exchange if any */
        currencyExchange: Array<ModelTypes['ReportExchangeRate']>;
        /** unique identifier of the merchant */
        merchantId: string;
        /** merchant name */
        merchantName: string;
        /** merchant city */
        merchantCity: string;
        /** merchant country */
        merchantCountry?: ModelTypes['CCA3'] | undefined;
        /** merchant postal code */
        merchantPostalCode?: string | undefined;
        /** merchant category code (MCC) */
        merchantCategoryCode: string;
        /** merchant category description
    Enum that explains what the MCC corresponds to in a more readable way */
        merchantCategoryDescription: ModelTypes['MerchantCategoryDescription'];
        /** category of the payment flow */
        category: ModelTypes['Category'];
        /** type of the authorization.
    Only available for:
    - authorization transaction
    - debit transaction linked to a previous authorization transaction */
        authorizationType?: ModelTypes['AuthorizationType'] | undefined;
        /** matching account for the transaction */
        account?: ModelTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: ModelTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: ModelTypes['Transaction'] | undefined;
    };
    ['CardTransactionCategory']: CardTransactionCategory;
    ['CardType']: CardType;
    /** Rejection returned when the Card is not the expected status */
    ['CardWrongStatusRejection']: {
        message: string;
        identifier: string;
        currentStatus: ModelTypes['CardStatus'];
        expectedStatus: ModelTypes['CardStatus'];
    };
    ['CashAccountType']: CashAccountType;
    ['Category']: Category;
    /** Country code alpha 2 (ISO 3166) */
    ['CCA2']: any;
    /** Country code alpha 3 (ISO 3166) */
    ['CCA3']: any;
    /** Certificate */
    ['Certificate']: {
        /** CertificateType
    
    Can be either LEAF or INTERMEDIATE */
        key: string;
        /** Base64 value of the certificate */
        value: string;
    };
    /** CheckMerchantPaymentMethod */
    ['CheckMerchantPaymentMethod']: {
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: ModelTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: ModelTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: ModelTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ModelTypes['RollingReserve'] | undefined;
    };
    ['CheckPaymentMethodInput']: {
        /** Determine whether the payment method must be activated or not */
        activate?: boolean | undefined;
    };
    ['CheckRejection']: {
        message: string;
        fnciInfo: ModelTypes['FnciInfo'];
    };
    /** Check transaction */
    ['CheckTransaction']: {
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference: string;
        /** payment method identifier used for this transaction: check number */
        paymentMethodIdentifier: string;
        /** 31-caracter unique identifier located at the bottom of the check.
    CMC7 is composed of 3 sections (check number (7 char.), check issuing bank code (12 char.), check holder account number (12 char.)).
    Combined with RLMC key, it  allows the check traceability. */
        cmc7: string;
        /** 2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
    Combined with CMC7 line, it allows the check traceability. */
        rlmcKey: string;
        /** side (Credit or Debit) */
        side: ModelTypes['TransactionSide'];
        /** type */
        type: ModelTypes['TransactionTypeEnum'];
        /** amount */
        amount: ModelTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: ModelTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: ModelTypes['Payment'] | undefined;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ModelTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: ModelTypes['PaymentProduct'];
        /** matching account for the transaction */
        account?: ModelTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: ModelTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: ModelTypes['Transaction'] | undefined;
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: ModelTypes['Amount'] | undefined;
        /** date on which reserved funds become available */
        reservedAmountReleasedAt?: ModelTypes['DateTime'] | undefined;
        /** return reason */
        returnReason?: ModelTypes['TransactionReasonCode'] | undefined;
    };
    ['CloseAccountInput']: {
        accountId: string;
        reason: ModelTypes['PartnerCloseAccountReasonInput'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['CloseAccountPayload']: ModelTypes['CloseAccountSuccessPayload'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ValidationRejection'];
    /** Define a reason with a message and a specific type for closing account action */
    ['CloseAccountReason']: {
        type: ModelTypes['CloseAccountReasonType'];
        message?: string | undefined;
    };
    ['CloseAccountReasonType']: CloseAccountReasonType;
    /** Union between PartnerCloseAccountReasonType and InternalCloseAccountReason */
    ['CloseAccountStatusReason']: ModelTypes['CloseAccountReason'];
    ['CloseAccountSuccessPayload']: {
        consent: ModelTypes['Consent'];
    };
    /** Data provided following the search for company information by siren number */
    ['CompanyInfo']: {
        siren: string;
        companyName: string;
        headquarters: ModelTypes['Headquarters'];
        vatNumber?: string | undefined;
        taxIdentificationNumber?: string | undefined;
        legalRepresentativePersonalAddress?: ModelTypes['AddressInformation'] | undefined;
    };
    /** Company shareholder info. */
    ['CompanyShareholder']: {
        /** Whether the shareholder is an individual or a company. */
        type: ModelTypes['ShareholderType'];
        /** Company name. */
        name: string;
    };
    ['CompanyType']: CompanyType;
    /** Complete Address Information */
    ['CompleteAddressInput']: {
        /** address line 1 (max 38 characters) */
        addressLine1: string;
        /** address line 2 (max 38 characters) */
        addressLine2?: string | undefined;
        /** city (max 30 characters) */
        city: string;
        /** postal code (max 10 characters) */
        postalCode: string;
        /** state (max 30 characters) */
        state?: string | undefined;
        /** country code */
        country: ModelTypes['CCA3'];
    };
    /** Complete Address Information with a contact */
    ['CompleteAddressWithContactInput']: {
        /** address line 1 (max 38 characters) */
        addressLine1: string;
        /** address line 2 (max 38 characters) */
        addressLine2?: string | undefined;
        /** city (max 30 characters) */
        city: string;
        /** postal code (max 10 characters) */
        postalCode: string;
        /** state (max 30 characters) */
        state?: string | undefined;
        /** country code */
        country: ModelTypes['CCA3'];
        /** contact first name */
        firstName: string;
        /** contact last name */
        lastName: string;
        /** contact phone number */
        phoneNumber: ModelTypes['PhoneNumber'];
        /** contact company name (max 38 characters) */
        companyName?: string | undefined;
    };
    /** Complete Digital Card used for ApplePay or GooglePay
  
  Once the pending phase is over, more data will be available in the response */
    ['CompleteDigitalCard']: {
        /** Unique identifier of a digital card */
        id: string;
        /** The type of digitalization that created this digital card. */
        type: ModelTypes['DigitalizationType'];
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider: ModelTypes['WalletProvider'];
        /** Device
    In case of a wallet application, some information about the device will be provided */
        device: ModelTypes['Device'];
        /** Id of the wallet application.
    Will not be present for Merchant */
        walletId?: string | undefined;
        /** Masked DPAN with the last four digits visible
    
    This value is present in the user wallet application */
        cardMaskedNumber: string;
        /** Digital Card status information
    
    In this type the status will be either ConsentPending or Pending */
        statusInfo: ModelTypes['CompleteDigitalCardStatusInfo'];
    };
    ['CompleteDigitalCardStatus']: CompleteDigitalCardStatus;
    /** Complete Digital Card Status Information */
    ['CompleteDigitalCardStatusInfo']: ModelTypes['DigitalCardCanceledStatusInfo'] | ModelTypes['DigitalCardEnabledStatusInfo'] | ModelTypes['DigitalCardSuspendedStatusInfo'];
    ['CompletedMerchantPaymentLinkStatusInfo']: {
        status: ModelTypes['MerchantPaymentLinkStatus'];
        /** The time when the customer completed the payment. */
        completedAt: ModelTypes['DateTime'];
    };
    /** Inputs to confirm physical card renewal */
    ['ConfirmPhysicalCardRenewalInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Address to deliver the physical card */
        address: ModelTypes['CompleteAddressInput'];
        /** Custom Options */
        customOptions?: ModelTypes['PhysicalCardCustomOptionsInput'] | undefined;
    };
    ['ConfirmPhysicalCardRenewalPayload']: ModelTypes['ConfirmPhysicalCardRenewalSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['ValidationRejection'] | ModelTypes['PhysicalCardWrongStatusRejection'];
    ['ConfirmPhysicalCardRenewalSuccessPayload']: {
        /** Physical card has been updated */
        physicalCard: ModelTypes['PhysicalCard'];
    };
    /** Relay Connection type, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['Connection']: ModelTypes['AccountConnection'] | ModelTypes['AccountHolderConnection'] | ModelTypes['AccountMembershipConnection'] | ModelTypes['CapitalDepositCaseConnection'] | ModelTypes['CardConnection'] | ModelTypes['ConsentConnection'] | ModelTypes['DigitalCardConnection'] | ModelTypes['ExternalAccountConnection'] | ModelTypes['ExternalBalanceConnection'] | ModelTypes['FundingLimitSettingsChangeRequestConnection'] | ModelTypes['FundingSourceConnection'] | ModelTypes['InvoiceConnection'] | ModelTypes['LegalDocumentConnection'] | ModelTypes['MerchantProfileConnection'] | ModelTypes['OnboardingConnection'] | ModelTypes['PaymentConnection'] | ModelTypes['PaymentMandateConnection'] | ModelTypes['ReceivedDirectDebitMandateConnection'] | ModelTypes['StandingOrderConnection'] | ModelTypes['StatementConnection'] | ModelTypes['SupportingDocumentCollectionConnection'] | ModelTypes['TransactionConnection'] | ModelTypes['TrustedBeneficiaryConnection'] | ModelTypes['UserConnection'] | ModelTypes['VirtualIBANEntryConnection'];
    /** Some sensitive operation at Swan, such as initiating a payment, require consent */
    ['Consent']: {
        /** unique identifier of the consent */
        id: string;
        /** `true` if the consent requires a Strong Customer Authentication */
        requireSCA: boolean;
        /** status of the consent */
        status: ModelTypes['ConsentStatus'];
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt?: ModelTypes['DateTime'] | undefined;
        /** date when the `consentUrl` was request the first time */
        startedAt?: ModelTypes['DateTime'] | undefined;
        /** date when the consent expire */
        expiredAt?: ModelTypes['DateTime'] | undefined;
        /** purpose of the consent */
        purpose: ModelTypes['ConsentPurpose'];
        /** Redirect the user to this URL to start the consent flow */
        consentUrl: string;
        /** When the consent flow is finished the user is redirected to this URL */
        redirectUrl: string;
        /** userId who initiated the consent */
        userId: string;
        /** user who initiated the consent */
        user?: ModelTypes['User'] | undefined;
        /** unique hash of the consent */
        challenge?: string | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ConsentConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** ConsentEdge list */
        edges: Array<ModelTypes['ConsentEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['ConsentEdge']: {
        /** Opaque identifier pointing to this consent node in the pagination mechanism */
        cursor: string;
        /** The consent */
        node: ModelTypes['Consent'];
    };
    /** Consent ID with related execution order */
    ['ConsentIdWithOrder']: {
        /** Execution order. Consents are granted in ascending order. Consents with the same order may be granted in parallel. */
        order: number;
        /** Consent ID */
        consentId: string;
    };
    /** Rejection returned if a consent was not found */
    ['ConsentNotFoundRejection']: {
        message: string;
        consentId: string;
    };
    ['ConsentPurpose']: ConsentPurpose;
    /** Rejection returned when a the consent is already linked to another multi consent */
    ['ConsentsAlreadyLinkedToMultiConsentRejection']: {
        message: string;
        /** IDs of the consents that are already linked to another multi consent */
        consentIds: Array<string>;
    };
    ['ConsentsFiltersInput']: {
        userId?: string | undefined;
    };
    /** Rejection returned when all provided consents are not in created status */
    ['ConsentsNotAllInCreatedStatusRejection']: {
        message: string;
        /** IDs of the consents that are not in created status */
        consentIds: Array<string>;
    };
    /** Rejection returned when a consent ID passed as input does not exist. */
    ['ConsentsNotFoundRejection']: {
        message: string;
        ids: Array<string>;
    };
    ['ConsentStatus']: ConsentStatus;
    ['ConsentTypeNotSupportedByServerConsentRejection']: {
        message: string;
    };
    /** Inputs to create a capital deposit case. */
    ['CreateCapitalDepositCaseInput']: {
        /** Name ("Dénomination sociale") of the company being registered and for which the capital is being deposited. */
        companyName: string;
        /** Array of shareholders of type company ("personne morale"). */
        companyShareholders: Array<ModelTypes['OnboardCompanyShareholderInput'] | undefined>;
        /** Array of shareholders of type individual ("personne physique"). */
        individualShareholders: Array<ModelTypes['OnboardIndividualShareholderInput'] | undefined>;
        /** Amount of the capital deposit. */
        totalCapitalDepositAmount: ModelTypes['AmountInput'];
        /** Information required for the onboarding of a company. */
        onboardingCapitalDepositCompany: ModelTypes['OnboardCompanyAccountHolderInput'];
    };
    ['CreateCapitalDepositCasePayload']: ModelTypes['CreateCapitalDepositCaseSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['BadRequestRejection'] | ModelTypes['ValidationRejection'] | ModelTypes['InternalErrorRejection'];
    ['CreateCapitalDepositCaseSuccessPayload']: {
        capitalDepositCase: ModelTypes['CapitalDepositCase'];
    };
    ['CreateMerchantPaymentLinkInput']: {
        /** The Merchant Profile to link this Payment Link to */
        merchantProfileId: string;
        /** Amount to be paid to sucessfully complete the payment. */
        amount: ModelTypes['AmountInput'];
        /** Merchant Website URL to redirect the user to when the payment is completed. */
        redirectUrl: ModelTypes['URL'];
        /** URL to redirect the user to if they cancel their payment */
        cancelRedirectUrl: ModelTypes['URL'];
        /** The customer billing Address
    These fields should be completed also to pre-fill a SEPA direct debit mandate.
    
    We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes */
        billingAddress?: ModelTypes['AddressInput'] | undefined;
        /** The date when the payment link expires.
    If not specified, the default time will be 120 days */
        expiresAt?: ModelTypes['DateTime'] | undefined;
        /** A date that reflects the time at which the user asked the transaction to be executed.
    For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
    For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
    
    Default value means that the execution will be as soon as possible */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** Controls if the payment mandate created from this payment link is for one-time use or can be reused
    This is applicable for card and SEPA Direct Debit payment methods only.
    If not specified, the default value is OneOff. */
        sequence?: ModelTypes['PaymentMandateSequence'] | undefined;
        /** Any string that you want to be attached to this payment link.
    Usually something to help you reference the link in an external system. */
        externalReference?: string | undefined;
        /** Optional field intended to provide a way for you to include a reference number or code.
    The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different. */
        reference?: string | undefined;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page. */
        label?: string | undefined;
        /** The language used for the payment page.
    Default is the browser's language, or English if not available. */
        language?: ModelTypes['Language'] | undefined;
        /** We will use the information specified here to prefill the payment link fields
    depending on the payment method the end user chooses.
    Keep in mind that your end customer will be able to edit these fields. */
        customer?: ModelTypes['CustomerInput'] | undefined;
        /** List of payment methods enabled for this payment link.
    If the array is empty, Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit)
    If you want to make payment possible via SEPA Direct Debit, the list should be populated either by a SEPA Direct Debit CORE or B2B. */
        paymentMethodIds?: Array<string> | undefined;
    };
    ['CreateMerchantPaymentLinkPayload']: ModelTypes['CreateMerchantPaymentLinkSuccessPayload'] | ModelTypes['MerchantProfileWrongStatusRejection'] | ModelTypes['MerchantPaymentMethodNotActiveRejection'] | ModelTypes['PaymentMethodNotCompatibleRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ValidationRejection'];
    ['CreateMerchantPaymentLinkSuccessPayload']: {
        merchantPaymentLink: ModelTypes['MerchantPaymentLink'];
    };
    /** Input of the `createMultiConsent` mutation */
    ['CreateMultiConsentInput']: {
        /** A list of consent IDs with their related execution orders */
        orderedConsentIds: Array<ModelTypes['ConsentIdWithOrder']>;
        /** URL the user is redirected to after consent has been given */
        redirectUrl: string;
    };
    /** Payload of the `createMultiConsent` mutation */
    ['CreateMultiConsentPayload']: ModelTypes['CreateMultiConsentSuccessPayload'] | ModelTypes['ConsentsNotAllInCreatedStatusRejection'] | ModelTypes['ConsentsNotFoundRejection'] | ModelTypes['TooManyChildConsentsRejection'] | ModelTypes['ConsentsAlreadyLinkedToMultiConsentRejection'];
    /** Success payload of the `createMultiConsent` mutation */
    ['CreateMultiConsentSuccessPayload']: {
        consent?: ModelTypes['Consent'] | undefined;
    };
    /** Credit transfer */
    ['CreditTransferInput']: {
        /** if the transfer will credit a beneficiary already created */
        beneficiaryId?: string | undefined;
        /** if the transfer will credit a new swan account beneficiary */
        swanAccountBeneficiary?: ModelTypes['SwanAccountBeneficiaryInput'] | undefined;
        /** if the transfer will credit a new SEPA beneficiary */
        sepaBeneficiary?: ModelTypes['SepaBeneficiaryInput'] | undefined;
        /** amount of the transfer */
        amount: ModelTypes['AmountInput'];
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined;
        /** label (max 140 characters) */
        label?: string | undefined;
        /** requested date at which the credit transfer will try to be executed, if `null` the credit transfer is executed right away */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** an arbitrary identifier that you can define to easily identify this transaction later */
        externalReference?: string | undefined;
        /** if the transfer will execute as instant and fallbacked to a regular one if an error happend during the instant transfer */
        mode?: ModelTypes['CreditTransferMode'] | undefined;
    };
    ['CreditTransferMode']: CreditTransferMode;
    /** Custom information for a CSV statement */
    ['CsvStatement']: {
        /** statement type */
        type?: ModelTypes['StatementType'] | undefined;
        /** temporary public url on which the file can be accessed */
        url?: string | undefined;
        /** date at which the link will not be useable anymore */
        expiresAt?: ModelTypes['DateTime'] | undefined;
    };
    /** currency code alpha 3 (ISO 4217) */
    ['Currency']: any;
    ['Customer']: {
        /** A customer id present in a third-party system.
    Alows to link a customer to a payment link and by extension, to a Merchant Payment. */
        externalCustomerId?: string | undefined;
        name?: string | undefined;
        iban?: string | undefined;
    };
    ['CustomerInput']: {
        /** A customer ID present in a third-party system.
    Alows to link a customer to a payment link and by extension, to a merchant payment. */
        externalCustomerId?: string | undefined;
        /** Customer name */
        name?: string | undefined;
        /** Customer IBAN */
        iban?: string | undefined;
    };
    /** Date with YYYY-MM-DD format */
    ['Date']: any;
    ['DateField']: {
        example?: string | undefined;
        key: string;
        name: string;
        required: boolean;
        validationRegex?: string | undefined;
    };
    /** Date time (ISO 8601 with time information)
  ex: 2021-04-12T16:28:22.867Z */
    ['DateTime']: any;
    /** Rejection returned when the Debtor is closed */
    ['DebtorAccountClosedRejection']: {
        message: string;
    };
    /** Rejection returned when the Debtor does not belong to the same project as the creditor */
    ['DebtorAccountNotAllowedRejection']: {
        message: string;
    };
    ['DeleteSupportingDocumentInput']: {
        /** Id of the supporting document to delete */
        id: string;
    };
    ['DeleteSupportingDocumentPayload']: ModelTypes['DeleteSupportingDocumentSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['SupportingDocumentCollectionNotFoundRejection'] | ModelTypes['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection'] | ModelTypes['SupportingDocumentNotFoundRejection'] | ModelTypes['SupportingDocumentStatusDoesNotAllowDeletionRejection'] | ModelTypes['ValidationRejection'];
    ['DeleteSupportingDocumentSuccessPayload']: {
        id: string;
    };
    ['DenySddInput']: {
        accountId: string;
    };
    ['DenySddPayload']: ModelTypes['DenySddSuccessPayload'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['InvalidArgumentRejection'] | ModelTypes['ValidationRejection'];
    ['DenySddSuccessPayload']: {
        account: ModelTypes['Account'];
    };
    ['DenySddVirtualIbanEntryInput']: {
        ibanEntryId: string;
    };
    ['DenySddVirtualIbanEntryPayload']: ModelTypes['DenySddVirtualIbanEntrySuccessPayload'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['ValidationRejection'];
    ['DenySddVirtualIbanEntrySuccessPayload']: {
        virtualIbanEntry: ModelTypes['VirtualIBANEntry'];
    };
    /** Device */
    ['Device']: {
        /** The type of device. It can be a Phone, Tablet, Watch */
        type?: string | undefined;
        /** Device name
    End user defined name of the device on which the card id provided */
        name?: string | undefined;
        /** Secure Element ID */
        SEID?: string | undefined;
    };
    /** Digital Card used for ApplePay or GooglePay */
    ['DigitalCard']: ModelTypes['CompleteDigitalCard'] | ModelTypes['PendingDigitalCard'];
    /** Digital Card Canceled Status Information */
    ['DigitalCardCanceledStatusInfo']: {
        /** Card status (always Canceled for type DigitalCardCanceledStatusInfo). */
        status: ModelTypes['CompleteDigitalCardStatus'];
        /** Enable Date */
        enabledAt: ModelTypes['DateTime'];
        /** Cancel Date */
        canceledAt: ModelTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['DigitalCardConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** CardEdge list */
        edges: Array<ModelTypes['DigitalCardEdge']>;
    };
    /** Digital Card ConsentPending Status Information */
    ['DigitalCardConsentPendingStatusInfo']: {
        /** Digital Card status (always ConsentPending for type DigitalCardConsentPendingStatusInfo). */
        status: ModelTypes['PendingDigitalCardStatus'];
        /** A reference to the consent to validate */
        consent: ModelTypes['Consent'];
    };
    /** Digital Card Declined Status Information */
    ['DigitalCardDeclinedStatusInfo']: {
        /** Digital Card status (always Declined for type DigitalCardDeclinedStatusInfo). */
        status: ModelTypes['PendingDigitalCardStatus'];
    };
    /** Implements the Relay Edge interface */
    ['DigitalCardEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The Card entry */
        node: ModelTypes['DigitalCard'];
    };
    /** Digital Card Enabled Status Information */
    ['DigitalCardEnabledStatusInfo']: {
        /** Digital Card status (always Enabled for type DigitalCardEnabledStatusInfo). */
        status: ModelTypes['CompleteDigitalCardStatus'];
        /** Enable Date */
        enabledAt: ModelTypes['DateTime'];
    };
    /** Filters that can be applied when listing digitalCards */
    ['DigitalCardFiltersInput']: {
        /** The id of the digitalCard */
        id?: string | undefined;
        /** The status of the digital card. It can be a CompleteDigitalCardStatus or a PendingDigitalCardStatus */
        status?: string | undefined;
        /** The Secure Element ID
    Mostly present on APple Devices */
        SEID?: string | undefined;
        /** The digital card masker number */
        cardMaskedNumber?: string | undefined;
        /** The ID of the wallet provider in the scheme system */
        walletProviderId?: string | undefined;
        /** Either ApplePay, GooglePay or Merchant */
        walletProviderName?: string | undefined;
        /** The wallet application ID in the user phone */
        walletId?: string | undefined;
    };
    /** Rejection returned when the Digital Card does not exist */
    ['DigitalCardNotFoundRejection']: {
        message: string;
        identifier: string;
    };
    ['DigitalCardOrderByFieldInput']: DigitalCardOrderByFieldInput;
    /** Order that can be applied when listing digital cards */
    ['DigitalCardOrderByInput']: {
        field?: ModelTypes['DigitalCardOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    /** Digital Card Pending Status Information */
    ['DigitalCardPendingStatusInfo']: {
        /** Digital Card status (always Pending for type DigitalCardPendingStatusInfo). */
        status: ModelTypes['PendingDigitalCardStatus'];
    };
    /** Digital Card Suspended Status Information */
    ['DigitalCardSuspendedStatusInfo']: {
        /** Digital Card status (always Suspended for type DigitalCardSuspendedStatusInfo). */
        status: ModelTypes['CompleteDigitalCardStatus'];
        /** Enable Date */
        enabledAt: ModelTypes['DateTime'];
        /** Suspend Date */
        suspendedAt: ModelTypes['DateTime'];
    };
    ['DigitalizationType']: DigitalizationType;
    /** Direct Debit Account Verification */
    ['DirectDebitAccountVerification']: {
        /** Creation date of the account verification */
        createdAt: ModelTypes['DateTime'];
        /** IBAN of the account to cross check with account holder information */
        iban: ModelTypes['IBAN'];
        /** Unique identifier of the Account Verification */
        id: string;
        /** Account Verification Status Information */
        statusInfo: ModelTypes['AccountVerificationStatusInfo'];
        /** Last update date of the account verification */
        updatedAt: ModelTypes['DateTime'];
    };
    /** Funding Source with Direct Debit Mandate */
    ['DirectDebitFundingSource']: {
        /** ID of the Funding Source */
        id: string;
        /** Name of the Funding Source */
        name?: string | undefined;
        /** Funding Source status information */
        statusInfo: ModelTypes['FundingSourceStatusInfo'];
        /** IBAN to use in the direct debit transaction that will be triggered when funding the account.
    Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source */
        iban: ModelTypes['IBAN'];
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Last updated date */
        updatedAt: ModelTypes['DateTime'];
        /** Can be queried to check the status of the account verification for this funding source.
    If the account verification is PendingVerification, you should ask your account holder to wire some money from his external account to any swan account */
        accountVerification: ModelTypes['DirectDebitAccountVerification'];
        /** Can be queried to check the status of payment payment Mandate.
    If the payment mandate is ConsentPending, you should confirm it to enable this funding source */
        paymentMandate: ModelTypes['PaymentDirectDebitMandate'];
    };
    ['DirectDebitSequence']: DirectDebitSequence;
    /** Input to disable an account membership */
    ['DisableAccountMembershipInput']: {
        /** Unique identifier of the account membership to disable */
        accountMembershipId: string;
    };
    ['DisableAccountMembershipPayload']: ModelTypes['DisableAccountMembershipSuccessPayload'] | ModelTypes['AccountMembershipCannotBeDisabledRejection'] | ModelTypes['AccountMembershipNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['LegalRepresentativeAccountMembershipCannotBeDisabledRejection'] | ModelTypes['UserNotAllowedToDisableItsOwnAccountMembershipRejection'] | ModelTypes['ValidationRejection'];
    ['DisableAccountMembershipSuccessPayload']: {
        accountMembership?: ModelTypes['AccountMembership'] | undefined;
    };
    /** StatusInfo when funding limit settings has been disabled */
    ['DisabledFundingLimitSettingsStatusInfo']: {
        status: ModelTypes['FundingLimitSettingsStatus'];
        reason: string;
    };
    /** EnabledMerchantPaymentMethodStatusInfo */
    ['DisabledMerchantPaymentMethodStatusInfo']: {
        status: ModelTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method disabled date */
        disabledAt: ModelTypes['Date'];
    };
    /** Retrieved document extracted from the identity verification */
    ['DocumentFile']: ModelTypes['DriversLicenseDocumentFile'] | ModelTypes['IdCardDocumentFile'] | ModelTypes['PassportDocumentFile'] | ModelTypes['ReportDocumentFile'] | ModelTypes['ResidencePermitDocumentFile'];
    ['DocumentFileSide']: DocumentFileSide;
    ['DocumentReasonCode']: DocumentReasonCode;
    ['DocumentType']: DocumentType;
    /** The document corresponding to a driver's license */
    ['DriversLicenseDocument']: {
        /** Unique identifier of the driver's license document */
        id: string;
        /** The type of the document */
        type: ModelTypes['DocumentType'];
        /** List of the associated files */
        files: Array<ModelTypes['DriversLicenseDocumentFile']>;
    };
    /** The file associated to the driver's license document */
    ['DriversLicenseDocumentFile']: {
        /** The file's temporary download url */
        downloadUrl: string;
        /** From which side the deiver's license's picture was taken */
        side: ModelTypes['DocumentFileSide'];
    };
    /** Edge type containing the node and cursor. The node is not defined in the interface because generic is not supported by GraphQL
  but all implementation contains its own node property according to the paginated type. */
    ['Edge']: ModelTypes['AccountEdge'] | ModelTypes['AccountHolderEdge'] | ModelTypes['AccountMembershipEdge'] | ModelTypes['CapitalDepositCaseEdge'] | ModelTypes['CardEdge'] | ModelTypes['ConsentEdge'] | ModelTypes['DigitalCardEdge'] | ModelTypes['ExternalAccountEdge'] | ModelTypes['ExternalBalanceEdge'] | ModelTypes['FundingLimitSettingsChangeRequestEdge'] | ModelTypes['FundingSourceEdge'] | ModelTypes['IdentificationEdge'] | ModelTypes['InvoiceEdge'] | ModelTypes['LegalDocumentEdge'] | ModelTypes['MerchantProfileEdge'] | ModelTypes['OnboardingEdge'] | ModelTypes['PaymentEdge'] | ModelTypes['PaymentMandateEdge'] | ModelTypes['ReceivedDirectDebitMandateEdge'] | ModelTypes['StandingOrderEdge'] | ModelTypes['StatementEdge'] | ModelTypes['SupportingDocumentCollectionEdge'] | ModelTypes['TransactionEdge'] | ModelTypes['TrustedBeneficiaryEdge'] | ModelTypes['UserEdge'] | ModelTypes['VirtualIBANEntryEdge'];
    ['EmailAddress']: any;
    ['EmploymentStatus']: EmploymentStatus;
    /** Rejection returned if the card product don't have a card design enabled */
    ['EnabledCardDesignNotFoundRejection']: {
        message: string;
    };
    /** StatusInfo when the funding limit settings is enabled */
    ['EnabledFundingLimitSettingsStatusInfo']: {
        status: ModelTypes['FundingLimitSettingsStatus'];
    };
    /** Funding Source Enabled status information */
    ['EnabledFundingSourceStatusInfo']: {
        /** Funding Source Enabled status */
        status: ModelTypes['FundingSourceStatus'];
        /** Date at which the funding source was enabled */
        enabledAt: ModelTypes['Date'];
    };
    /** EnabledMerchantPaymentMethodStatusInfo */
    ['EnabledMerchantPaymentMethodStatusInfo']: {
        status: ModelTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method enabled date */
        enabledAt: ModelTypes['Date'];
    };
    /** EnabledMerchantProfileStatusInfo */
    ['EnabledMerchantProfileStatusInfo']: {
        status: ModelTypes['MerchantProfileStatus'];
        enabledAt: ModelTypes['Date'];
    };
    /** Inputs to enable a received direct debit mandate, i.e. to move its status back from suspended. */
    ['EnableReceivedDirectDebitMandateInput']: {
        /** The received direct debit id to enable */
        receivedDirectDebitMandateId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl?: string | undefined;
    };
    /** Union type return by the enableReceivedDirectDebitMandate mutation */
    ['EnableReceivedDirectDebitMandatePayload']: ModelTypes['EnableReceivedDirectDebitMandateSuccessPayload'] | ModelTypes['ReceivedDirectDebitMandateNotFoundRejection'] | ModelTypes['ReceivedDirectDebitMandateCanceledRejection'] | ModelTypes['ForbiddenRejection'];
    /** Return type in case of a successful response of the enableReceivedDirectDebitMandate mutation */
    ['EnableReceivedDirectDebitMandateSuccessPayload']: {
        /** The received direct debit mandate is enable, i.e that it is moved back to from the suspended to the enabled status */
        receivedDirectDebitMandate: ModelTypes['ReceivedDirectDebitMandate'];
    };
    ['EnvType']: EnvType;
    /** Describes an identification level for the process associated to this identification that has expired and is no longer considered valid */
    ['ExpiredIdentificationLevelStatusInfo']: {
        /** Always set to `Expired` */
        status: ModelTypes['SwanIdentificationStatus'];
        /** When this identification level expired */
        expiredAt: ModelTypes['Date'];
    };
    ['ExpiredMerchantPaymentLinkStatusInfo']: {
        status: ModelTypes['MerchantPaymentLinkStatus'];
        /** The date when the payment link expired.
    By default the payment link expires 120 days after it was created. */
        expiredAt: ModelTypes['DateTime'];
    };
    ['ExternalAccount']: {
        /** Unique identifier of an external account */
        id: string;
        /** External account identifier following ISO-20022 standard */
        externalId: string;
        /** Name of the account */
        name?: string | undefined;
        /** Type of the account */
        cashAccountType: ModelTypes['CashAccountType'];
        /** Bank Identifier Code */
        BIC: ModelTypes['BIC'];
        /** International Bank Account Number */
        IBAN: ModelTypes['IBAN'];
        /** Currency */
        currency: ModelTypes['Currency'];
        /** Account Holder name */
        holderName: string;
        /** Country */
        country: ModelTypes['CCA3'];
        /** Original Created date */
        originalCreatedAt: ModelTypes['DateTime'];
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** A list of balances regarding an external account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        balances: ModelTypes['ExternalBalanceConnection'];
        /** Source used for this account */
        source: ModelTypes['ExternalAccountDataSource'];
        /** Financial institution */
        institution?: ModelTypes['FinancialInstitution'] | undefined;
        /** Usage information of the account */
        usage: ModelTypes['ExternalAccountUsage'];
        /** Account holder for the external account */
        accountHolder?: ModelTypes['AccountHolder'] | undefined;
    };
    ['ExternalAccountAlreadyExistsRejection']: {
        iban: string;
        accountHolderId: string;
        message: string;
    };
    ['ExternalAccountBalance']: {
        /** Unique identifier of an external balance */
        id: string;
        /** Amount with currency */
        amount?: ModelTypes['Amount'] | undefined;
        /** Type of Balance */
        type: ModelTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: ModelTypes['DateTime'];
    };
    ['ExternalAccountBalanceAlreadyExistsRejection']: {
        type: ModelTypes['ExternalAccountBalanceType'];
        lastChangedAt: ModelTypes['DateTime'];
        message: string;
    };
    ['ExternalAccountBalanceInput']: {
        /** Amount with currency */
        amount: ModelTypes['AmountInput'];
        /** Type of Balance */
        type: ModelTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: ModelTypes['DateTime'];
    };
    ['ExternalAccountBalanceType']: ExternalAccountBalanceType;
    /** Implements the Relay Connection interface, used to paginate the list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ExternalAccountConnection']: {
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** ExternalAccountEdge list */
        edges: Array<ModelTypes['ExternalAccountEdge']>;
    };
    ['ExternalAccountDataSource']: {
        type: ModelTypes['ExternalAccountDataSourceType'];
        name: string;
    };
    ['ExternalAccountDataSourceType']: ExternalAccountDataSourceType;
    /** Implements the Relay Edge interface */
    ['ExternalAccountEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The external account */
        node: ModelTypes['ExternalAccount'];
    };
    ['ExternalAccountUsage']: ExternalAccountUsage;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ExternalBalanceConnection']: {
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** ExternalBalanceEdge list */
        edges: Array<ModelTypes['ExternalBalanceEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['ExternalBalanceEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The external balance */
        node: ModelTypes['ExternalAccountBalance'];
    };
    /** The document corresponding to a face photo */
    ['FacePhotoDocument']: {
        /** Unique identifier of the face photo document. For privacy reasons, no temporary download url is exposed for this document */
        id: string;
        /** The type of the document */
        type: ModelTypes['DocumentType'];
    };
    /** Fee creditor */
    ['FeeCreditor']: ModelTypes['FeeInCreditor'] | ModelTypes['FeeOutCreditor'];
    ['FeeDebtor']: ModelTypes['FeeInDebtor'] | ModelTypes['FeeOutDebtor'];
    /** Fee creditor for Incoming transaction */
    ['FeeInCreditor']: {
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Fee debtor for Incoming transaction */
    ['FeeInDebtor']: {
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Fee creditor for Outgoing transaction */
    ['FeeOutCreditor']: {
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Fee debtor for Outgoing transaction */
    ['FeeOutDebtor']: {
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    ['FeeSettingsNotFoundRejection']: {
        message: string;
    };
    ['FeesTypeEnum']: FeesTypeEnum;
    /** Fee Transaction */
    ['FeeTransaction']: {
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain. */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: ModelTypes['TransactionSide'];
        /** type */
        type: ModelTypes['TransactionTypeEnum'];
        /** amount */
        amount: ModelTypes['Amount'];
        /** label */
        label: string;
        /** feesType */
        feesType: ModelTypes['FeesTypeEnum'];
        /** status information */
        statusInfo: ModelTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: ModelTypes['Payment'] | undefined;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ModelTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: ModelTypes['PaymentProduct'];
        /** creditor information */
        creditor: ModelTypes['FeeCreditor'];
        /** debtor information */
        debtor: ModelTypes['FeeDebtor'];
        /** matching account for the transaction */
        account?: ModelTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: ModelTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: ModelTypes['Transaction'] | undefined;
    };
    ['Field']: ModelTypes['DateField'] | ModelTypes['RadioField'] | ModelTypes['SelectField'] | ModelTypes['TextField'];
    ['FieldValidationError']: FieldValidationError;
    ['FinalizeOnboardingInput']: {
        onboardingId: string;
    };
    ['FinalizeOnboardingPayload']: ModelTypes['FinalizeOnboardingSuccessPayload'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['OnboardingNotCompletedRejection'] | ModelTypes['ValidationRejection'];
    ['FinalizeOnboardingSuccessPayload']: {
        onboarding: ModelTypes['Onboarding'];
    };
    ['FinancialInstitution']: {
        id: string;
        name: string;
        country: ModelTypes['CCA3'];
    };
    ['FnciInfo']: {
        colorCode: string;
        cpt1: number;
        cpt2: number;
        cpt3: number;
        holderEstablishment: string;
        responseCode: number;
    };
    ['ForbiddenRejection']: {
        message: string;
    };
    ['FundingLimit']: {
        /** Maximum Funding Amount authorized */
        amount: ModelTypes['Amount'];
        /** Funding Amount that has already been used during the interval */
        funding?: ModelTypes['Amount'] | undefined;
        /** Interval in number of calendar days where the limit is applied */
        rollingDays: number;
    };
    /** Funding Limit Amount */
    ['FundingLimitAmount']: {
        /** The amount settings */
        amount: ModelTypes['Amount'];
    };
    /** Funding Limit Amount Input */
    ['FundingLimitAmountInput']: {
        /** The amount settings */
        amount: ModelTypes['AmountInput'];
    };
    /** Rejection returned when the Account Holder Funding has been exceeded */
    ['FundingLimitExceededRejection']: {
        message: string;
    };
    ['FundingLimitSettings']: {
        /** Instant funding limit */
        instantFundingLimit?: ModelTypes['InstantFundingLimit'] | undefined;
        /** Periodic funding limit */
        fundingLimit?: ModelTypes['FundingLimit'] | undefined;
        /** Related change request */
        fundingLimitSettingsChangeRequest?: ModelTypes['FundingLimitSettingsChangeRequest'] | undefined;
        /** Status of the resource */
        statusInfo: ModelTypes['FundingLimitSettingsStatusInfo'];
    };
    /** Funding Limit Settings Change Request */
    ['FundingLimitSettingsChangeRequest']: {
        /** Unique identifier of a funding limit settings change request */
        id: string;
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit: ModelTypes['FundingLimitAmount'];
        /** Requested amount settings for the funding limit */
        fundingLimit: ModelTypes['FundingLimitAmount'];
        /** Approved amount settings for the the instant funding limit and the funding limit */
        approved?: ModelTypes['ApprovedFundingLimit'] | undefined;
        /** Status of the request */
        statusInfo: ModelTypes['FundingLimitSettingsChangeRequestStatusInfo'];
        /** Date of creation */
        createdAt?: ModelTypes['Date'] | undefined;
        /** Date of last update */
        updatedAt?: ModelTypes['Date'] | undefined;
    };
    /** StatusInfo when funding limit settings change request has been approved */
    ['FundingLimitSettingsChangeRequestApprovedStatusInfo']: {
        status: ModelTypes['FundingLimitSettingsChangeRequestStatus'];
        reason: string;
    };
    /** Funding Limit Settings Change Request Bad Amount Rejection */
    ['FundingLimitSettingsChangeRequestBadAmountRejection']: {
        message: string;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['FundingLimitSettingsChangeRequestConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** FundingLimitSettingsChangeRequestEdge list */
        edges: Array<ModelTypes['FundingLimitSettingsChangeRequestEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['FundingLimitSettingsChangeRequestEdge']: {
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor: string;
        /** The FundingLimitSettingsChangeRequest */
        node: ModelTypes['FundingLimitSettingsChangeRequest'];
    };
    /** Filters that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestFiltersInput']: {
        /** The ids of the funding limit settings change requests */
        id?: Array<string> | undefined;
        /** Status we want to filter on */
        status?: Array<ModelTypes['FundingLimitSettingsChangeRequestStatus']> | undefined;
    };
    ['FundingLimitSettingsChangeRequestOrderByFieldInput']: FundingLimitSettingsChangeRequestOrderByFieldInput;
    /** Order that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestOrderByInput']: {
        field?: ModelTypes['FundingLimitSettingsChangeRequestOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    /** StatusInfo when funding limit settings change request is pending */
    ['FundingLimitSettingsChangeRequestPendingStatusInfo']: {
        status: ModelTypes['FundingLimitSettingsChangeRequestStatus'];
    };
    /** StatusInfo when funding limit settings change request has been rejected */
    ['FundingLimitSettingsChangeRequestRefusedStatusInfo']: {
        status: ModelTypes['FundingLimitSettingsChangeRequestStatus'];
        reason: string;
    };
    ['FundingLimitSettingsChangeRequestStatus']: FundingLimitSettingsChangeRequestStatus;
    /** Object containing details about funding limit settings change request status */
    ['FundingLimitSettingsChangeRequestStatusInfo']: ModelTypes['FundingLimitSettingsChangeRequestApprovedStatusInfo'] | ModelTypes['FundingLimitSettingsChangeRequestPendingStatusInfo'] | ModelTypes['FundingLimitSettingsChangeRequestRefusedStatusInfo'] | ModelTypes['FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo'];
    /** StatusInfo when funding limit settings change request is waiting for more information */
    ['FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo']: {
        status: ModelTypes['FundingLimitSettingsChangeRequestStatus'];
    };
    ['FundingLimitSettingsStatus']: FundingLimitSettingsStatus;
    /** Object containing details about funding limit settings status */
    ['FundingLimitSettingsStatusInfo']: ModelTypes['DisabledFundingLimitSettingsStatusInfo'] | ModelTypes['EnabledFundingLimitSettingsStatusInfo'] | ModelTypes['SuspendedFundingLimitSettingsStatusInfo'];
    /** Funding Source */
    ['FundingSource']: ModelTypes['DirectDebitFundingSource'];
    /** Please see the Connection interface */
    ['FundingSourceConnection']: {
        pageInfo: ModelTypes['PageInfo'];
        edges: Array<ModelTypes['FundingSourceEdge']>;
        totalCount: number;
    };
    /** Please see the Connection interface */
    ['FundingSourceEdge']: {
        node: ModelTypes['FundingSource'];
        cursor: string;
    };
    /** Filters that can be applied when listing Funding Sources */
    ['FundingSourceFiltersInput']: {
        status: Array<ModelTypes['FundingSourceStatus']>;
    };
    ['FundingSourceNotFoundRejection']: {
        id: string;
        message: string;
    };
    ['FundingSourceOrderByFieldInput']: FundingSourceOrderByFieldInput;
    /** Order that can be applied when listing funding source results */
    ['FundingSourceOrderByInput']: {
        field?: ModelTypes['FundingSourceOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['FundingSourceStatus']: FundingSourceStatus;
    /** Funding Source status information */
    ['FundingSourceStatusInfo']: ModelTypes['CanceledFundingSourceStatusInfo'] | ModelTypes['EnabledFundingSourceStatusInfo'] | ModelTypes['PendingFundingSourceStatusInfo'] | ModelTypes['RejectedFundingSourceStatusInfo'] | ModelTypes['SuspendedFundingSourceStatusInfo'];
    /** Rejection returned when the Funding Source is not in the expected status */
    ['FundingSourceWrongStatusRejection']: {
        message: string;
        currentStatus: ModelTypes['FundingSourceStatus'];
        expectedStatus: ModelTypes['FundingSourceStatus'];
    };
    /** Inputs to generate an account */
    ['GenerateAccountStatementInput']: {
        /** Unique identifier of an account */
        accountId: string;
        /** starting date of the date window */
        openingDate: ModelTypes['DateTime'];
        /** ending date of the date window */
        closingDate: ModelTypes['DateTime'];
        /** language to generate the statement in (default to account's language) */
        language?: ModelTypes['AccountLanguage'] | undefined;
        /** Type of statement to generate */
        statementType?: ModelTypes['StatementType'] | undefined;
    };
    ['GenerateCapitalDepositDocumentUploadUrlInput']: {
        /** Unique identifier of the document. */
        documentId: string;
        /** Unique identifier of the capitalDepositCase associated to the document. */
        capitalDepositCaseId: string;
        /** Filename of the document. */
        filename: string;
    };
    ['GenerateCapitalDepositDocumentUploadUrlPayload']: ModelTypes['GenerateCapitalDepositDocumentUploadUrlSuccessPayload'] | ModelTypes['CapitalDepositDocumentCanNotBeUploaded'] | ModelTypes['CapitalDepositDocumentCanNotBeUploadedRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['BadRequestRejection'] | ModelTypes['InternalErrorRejection'];
    ['GenerateCapitalDepositDocumentUploadUrlSuccessPayload']: {
        /** URL to be used to upload the document. */
        uploadUrl?: string | undefined;
    };
    ['GenerateSupportingDocumentUploadUrlInput']: {
        /** Unique identifier of a supporting document collection */
        supportingDocumentCollectionId: string;
        /** Type of document */
        supportingDocumentType?: ModelTypes['SupportingDocumentType'] | undefined;
        /** Name of the document which will be sent */
        filename: string;
        /** Purpose of document */
        supportingDocumentPurpose?: ModelTypes['SupportingDocumentPurposeEnum'] | undefined;
    };
    ['GenerateSupportingDocumentUploadUrlPayload']: ModelTypes['GenerateSupportingDocumentUploadUrlSuccessPayload'] | ModelTypes['SupportingDocumentCollectionNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['SupportingDocumentUploadNotAllowedRejection'] | ModelTypes['ValidationRejection'];
    ['GenerateSupportingDocumentUploadUrlSuccessPayload']: {
        /** Id of the supporting document created for this uploadUrl */
        supportingDocumentId: string;
        /** Info to upload the document : url and fields to add along file in form (POST) */
        upload: ModelTypes['SupportingDocumentUploadInfo'];
    };
    /** Rejection returned when the Global Funding has been exceeded */
    ['GlobalFundingLimitExceededRejection']: {
        message: string;
    };
    /** Rejection returned when the Global Instant Funding limit has been exceeded */
    ['GlobalInstantFundingLimitExceededRejection']: {
        message: string;
    };
    /** Input of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignatureInput']: {
        /** ID of the consent to grant */
        consentId: string;
        /** Consent challenge signed with server consent credentials */
        signature: string;
    };
    /** Payload of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignaturePayload']: ModelTypes['GrantConsentWithServerSignatureSuccessPayload'] | ModelTypes['ConsentNotFoundRejection'] | ModelTypes['NotReachableConsentStatusRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ConsentTypeNotSupportedByServerConsentRejection'] | ModelTypes['ServerConsentNotAllowedForConsentOperationRejection'] | ModelTypes['ProjectNotFoundRejection'] | ModelTypes['ServerConsentNotAllowedForProjectRejection'] | ModelTypes['ServerConsentProjectSettingsNotFoundRejection'] | ModelTypes['ServerConsentProjectCredentialMissingRejection'] | ModelTypes['ServerConsentProjectCredentialNotFoundRejection'] | ModelTypes['ServerConsentCredentialsNotValidOrOutdatedRejection'] | ModelTypes['ServerConsentSignatureNotValidRejection'];
    /** Success payload of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignatureSuccessPayload']: {
        consent: ModelTypes['Consent'];
    };
    ['Headquarters']: {
        town: string;
        zipCode: string;
        address: string;
    };
    ['HexColorCode']: any;
    /** International Bank Account Number */
    ['IBAN']: any;
    /** Rejection returned when the IBAN is not reachable */
    ['IBANNotReachableRejection']: {
        message: string;
    };
    /** Rejection returned when the IBAN is not valid */
    ['IBANNotValidRejection']: {
        message: string;
    };
    ['IBANStatus']: IBANStatus;
    /** ibanValidation input */
    ['IbanValidationInput']: {
        /** IBAN to validate */
        iban: ModelTypes['IBAN'];
    };
    ['IbanValidationRejection']: {
        message: string;
    };
    /** IbanValidationResult */
    ['IbanValidationResult']: ModelTypes['ValidIban'] | ModelTypes['InvalidIban'];
    /** The document corresponding to an ID card */
    ['IdCardDocument']: {
        /** Unique identifier of the ID card document */
        id: string;
        /** The type of the document */
        type: ModelTypes['DocumentType'];
        /** The date at which the ID card was issued */
        issueDate?: ModelTypes['Date'] | undefined;
        /** The date at which the ID card expires */
        expiryDate?: ModelTypes['Date'] | undefined;
        /** Machine-readable zone code of the ID card */
        mrz?: string | undefined;
        /** Number of the ID card */
        number?: string | undefined;
        /** List of the associated files */
        files: Array<ModelTypes['IdCardDocumentFile']>;
    };
    /** The file associated to the ID card document */
    ['IdCardDocumentFile']: {
        /** The file's temporary download url */
        downloadUrl: string;
        /** From which side the ID card's picture was taken */
        side: ModelTypes['DocumentFileSide'];
    };
    /** The identification represents an ongoing identification process or its result */
    ['Identification']: {
        /** Unique identifier of the identification */
        id: string;
        /** Creation date of the identification */
        createdAt: ModelTypes['DateTime'];
        /** Last update date of the identification */
        updatedAt: ModelTypes['DateTime'];
        /** The global status of the identification */
        status: ModelTypes['SwanIdentificationStatus'];
        /** The process that was used for this identification */
        process: ModelTypes['IdentificationProcess'];
        /** The status and results associated to the available identification processes */
        levels: ModelTypes['IdentificationLevelStatusesInfo'];
        /** The available documents related to the identification (id doc, selfie, report...) */
        documents?: Array<ModelTypes['IdentificationDocument']> | undefined;
        /** The identity document type used for the current identification (passport, id card ...) */
        identityDocumentType?: ModelTypes['IdentityDocumentType'] | undefined;
    };
    /** Fields we can use when ordering that can be applied when listing identifications */
    ['IdentificationConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo?: ModelTypes['PageInfo'] | undefined;
        /** IdentificationEdge list */
        edges: Array<ModelTypes['IdentificationEdge']>;
    };
    /** Union representing all the possible identification document types */
    ['IdentificationDocument']: ModelTypes['IdCardDocument'] | ModelTypes['PassportDocument'] | ModelTypes['ResidencePermitDocument'] | ModelTypes['DriversLicenseDocument'] | ModelTypes['FacePhotoDocument'] | ModelTypes['ReportDocument'];
    /** Implements the Relay Edge interface */
    ['IdentificationEdge']: {
        /** The identification entry */
        node: ModelTypes['Identification'];
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
    };
    /** Filter that can be passed to get the identifications in specific data ranges */
    ['IdentificationFiltersInput']: {
        /** To filter on status values */
        statuses?: Array<ModelTypes['SwanIdentificationStatus']> | undefined;
        /** To filter on level values */
        levels?: Array<ModelTypes['IdentificationLevel']> | undefined;
        /** To filter on process values */
        processes?: Array<ModelTypes['IdentificationProcess']> | undefined;
    };
    ['IdentificationInvalidReason']: IdentificationInvalidReason;
    ['IdentificationLevel']: IdentificationLevel;
    ['IdentificationLevelInput']: IdentificationLevelInput;
    /** Identification levels */
    ['IdentificationLevels']: {
        PVID: boolean;
        QES: boolean;
        expert: boolean;
    };
    /** The status and results associated to the available identification processes */
    ['IdentificationLevelStatusesInfo']: {
        /** The status and results associated to the expert level */
        expert: ModelTypes['IdentificationLevelStatusInfo'];
        /** The status and results associated to the Qualified Electronic Signature level */
        qes: ModelTypes['IdentificationLevelStatusInfo'];
        /** The status and results associated to the Remote Identity Verification Service level */
        pvid: ModelTypes['IdentificationLevelStatusInfo'];
    };
    /** Union representing all the possible statuses: not supported, not started, pending, valid, invalid, cancelled, expired
  Each variant contains its relevant data, for example invalid contains a `reason` field, expired contains an `expiredAt` field, valid contains a `documents` field */
    ['IdentificationLevelStatusInfo']: ModelTypes['NotSupportedIdentificationLevelStatusInfo'] | ModelTypes['NotStartedIdentificationLevelStatusInfo'] | ModelTypes['StartedIdentificationLevelStatusInfo'] | ModelTypes['PendingIdentificationLevelStatusInfo'] | ModelTypes['ValidIdentificationLevelStatusInfo'] | ModelTypes['InvalidIdentificationLevelStatusInfo'] | ModelTypes['CanceledIdentificationLevelStatusInfo'] | ModelTypes['ExpiredIdentificationLevelStatusInfo'];
    ['IdentificationProcess']: IdentificationProcess;
    ['IdentificationsOrderByField']: IdentificationsOrderByField;
    /** Order that can be applied when listing identifications */
    ['IdentificationsOrderByInput']: {
        /** The field by which the Identification list should be ordered */
        field?: ModelTypes['IdentificationsOrderByField'] | undefined;
        /** The order in which the Identification list should be ordered */
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['IdentificationStatus']: IdentificationStatus;
    /** Rejection returned if identity and the account memberships are already bind */
    ['IdentityAlreadyBindToAccountMembershipRejection']: {
        accountId: string;
        identityId: string;
        message: string;
    };
    ['IdentityDocumentType']: IdentityDocumentType;
    /** Data used for in app provisioning */
    ['InAppProvisioningData']: {
        /** Cryptographic OTP used to pre-validate digitalization */
        activationData: string;
        /** Base64 public key used with the wallet provider public key to encrypt the card data */
        ephemeralPublicKey: string;
        /** Encrypted card data */
        encryptedData: string;
        /** IV used to encrypt the card Data (Useful for Google Pay) */
        iv?: string | undefined;
        /** public key fingerprint of the key used to encrypt card data (Useful for Google Pay) */
        publicKeyFingerprint?: string | undefined;
        /** hash algorithm used during encryption of the card data (Useful for Google Pay) */
        oaepHashingAlgorithm?: string | undefined;
    };
    /** Individual shareholder info. */
    ['IndividualShareholder']: {
        /** Whether the shareholder is an individual or a company. */
        type: ModelTypes['ShareholderType'];
        /** First name of the shareholder. */
        firstName: string;
        /** Last name of the shareholder. */
        lastName: string;
        /** Birth date of the shareholder. */
        birthDate: string;
        /** CCA3 code for the country of nationality of the shareholder. */
        nationality: ModelTypes['CCA3'];
    };
    /** Individual Ultimate Beneficial Owner
  You need to describe the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company.
  Please describe the company (s) that owns the company that wishes to open an account, when an individual holds in fine more than 25% */
    ['IndividualUltimateBeneficialOwner']: {
        /** individual first name */
        firstName?: string | undefined;
        /** individual last name */
        lastName?: string | undefined;
        /** individual birth date */
        birthDate?: ModelTypes['DateTime'] | undefined;
        /** individual birth city */
        birthCity?: string | undefined;
        /** individual birth city postal code */
        birthCityPostalCode?: string | undefined;
        /** individual birth country code */
        birthCountryCode?: ModelTypes['CCA3'] | undefined;
        /** Information relating to the type of the UBO */
        info: ModelTypes['IndividualUltimateBeneficialOwnerInfo'];
        /** Individual beneficial owner Tax or Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Individual beneficial owner residency Address */
        residencyAddress?: ModelTypes['AddressInformation'] | undefined;
        /** Individual beneficial owner title (Mr/Ms) */
        title?: ModelTypes['TitleEnum'] | undefined;
    };
    /** Define the type of the UBO */
    ['IndividualUltimateBeneficialOwnerInfo']: ModelTypes['IndividualUltimateBeneficialOwnerTypeHasCapital'] | ModelTypes['IndividualUltimateBeneficialOwnerTypeLegalRepresentative'] | ModelTypes['IndividualUltimateBeneficialOwnerTypeOther'];
    ['IndividualUltimateBeneficialOwnerInput']: {
        /** Individual beneficial owner first name. Length must be from 0 to 100 characters */
        firstName?: string | undefined;
        /** Individual beneficial owner last name. Length must be from 0 to 100 characters */
        lastName?: string | undefined;
        /** Individual birth date. Must be a valid date in the YYYY/MM/DD format */
        birthDate?: string | undefined;
        /** Individual birth city. Length must be from 0 to 100 characters */
        birthCity?: string | undefined;
        /** Individual birth city postal code. Length must be from 0 to 50 characters */
        birthCityPostalCode?: string | undefined;
        /** Individual birth country code */
        birthCountryCode?: ModelTypes['CCA3'] | undefined;
        /** Define UBO is an Indirect Owner */
        indirect?: boolean | undefined;
        /** Define UBO is a Direct Owner */
        direct?: boolean | undefined;
        /** Total of capital (in percentage, ex: 50 = 50%). Must be between 1 and 100. */
        totalCapitalPercentage?: number | undefined;
        /** Define UBO is a Legal Representative */
        type: ModelTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
        /** Individual beneficial owner Tax or Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Individual beneficial owner residency address */
        residencyAddress?: ModelTypes['AddressInformationInput'] | undefined;
        /** Individual ultimate beneficial owner title (Mr/Ms) */
        title?: ModelTypes['TitleEnum'] | undefined;
    };
    ['IndividualUltimateBeneficialOwnerTypeEnum']: IndividualUltimateBeneficialOwnerTypeEnum;
    /** Individual Ultimate Beneficial Owner Type Has Capital */
    ['IndividualUltimateBeneficialOwnerTypeHasCapital']: {
        /** Individual type */
        type: ModelTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
        /** Define UBO is an Indirect Owner */
        indirect?: boolean | undefined;
        /** Define UBO is an Direct Owner */
        direct?: boolean | undefined;
        /** Total of capital (in percentage, ex: 50 = 50%) */
        totalCapitalPercentage?: number | undefined;
    };
    /** Individual Ultimate Beneficial Owner Type Legal Representative */
    ['IndividualUltimateBeneficialOwnerTypeLegalRepresentative']: {
        /** Individual type */
        type: ModelTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
    };
    /** Individual Ultimate Beneficial Owner Type Other */
    ['IndividualUltimateBeneficialOwnerTypeOther']: {
        /** Individual type */
        type: ModelTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
    };
    ['InitiateCheckMerchantPaymentInput']: {
        /** Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€. */
        amount: ModelTypes['AmountInput'];
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement.
    If empty, default label will be set as "Check N° [1st 7 characters of CMC7] */
        label?: string | undefined;
        /** End-to-end reference of the concerned payment collection. */
        reference?: string | undefined;
        /** ID of the merchant profile associated to the Swan creditor account. */
        merchantProfileId: string;
        /** 31-character unique identifier located at the bottom of the check.
    CMC7 is composed of 3 sections (check number (7 characters), check issuing bank code (12 characters), check holder account number (12 characters)).
    Combined with RLMC key, it  allows the check to be traced. */
        cmc7: string;
        /** 2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
    Combined with CMC7 line, it allows the check to be traced. */
        rlmcKey: string;
    };
    ['InitiateCheckMerchantPaymentPayload']: ModelTypes['InitiateCheckMerchantPaymentSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['NotFoundRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ValidationRejection'] | ModelTypes['CheckRejection'];
    ['InitiateCheckMerchantPaymentSuccessPayload']: {
        merchantPayment: ModelTypes['Payment'];
        /** Details of the FNCI (Fichier national des chèques irréguliers) response */
        fnciInfo: ModelTypes['FnciInfo'];
    };
    /** Initiate credit transfers */
    ['InitiateCreditTransfersInput']: {
        /** account to be debited identified by number */
        accountNumber?: ModelTypes['AccountNumber'] | undefined;
        /** account id to be debited identified by id */
        accountId?: string | undefined;
        /** credit transfers (max 2500 records) */
        creditTransfers: Array<ModelTypes['CreditTransferInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['InitiateCreditTransfersPayload']: ModelTypes['InitiateCreditTransfersSuccessPayload'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'];
    ['InitiateCreditTransfersSuccessPayload']: {
        payment: ModelTypes['Payment'];
    };
    /** Input to initiate a funding request */
    ['InitiateFundingRequestInput']: {
        /** ID of the funding source to be used to fund the concerned account */
        fundingSourceId: string;
        /** Amount of the requested funding, i.e. amount that will credit the concerned Swan account and debit the external funding source. */
        amount: ModelTypes['AmountInput'];
        /** Reference of the funding request that will be shown on the account holder statement and on the debtor account used. */
        reference?: string | undefined;
        /** Label of the funding request that will be shown on the account holder statement and on the debtor account used
    Always starts with 'Partner Name' truncated at 19 characters followed by a space.
    If empty, default label is "Partner Name - Account Holder Name". */
        label?: string | undefined;
        /** Url to which the authorized account member must be redirected once the consent has been finalized. */
        consentRedirectUrl: string;
        /** When the funding request should be executed. If `null`, it will be executed as soon as possible.
    It is not possible to define this value when the option `isInstant` is set to true. */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** *SOON TO BE DEPRECATED*
    If `true` the funds should be available immediately. If `false` or `null`, the funds will be available
    after the resolution of the credit transaction. */
        isInstant?: boolean | undefined;
    };
    /** Initiate A Funding Request Payload */
    ['InitiateFundingRequestPayload']: ModelTypes['InitiateFundingRequestSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ValidationRejection'] | ModelTypes['FundingLimitExceededRejection'] | ModelTypes['ProjectFundingLimitExceededRejection'] | ModelTypes['GlobalFundingLimitExceededRejection'] | ModelTypes['FundingSourceWrongStatusRejection'] | ModelTypes['FundingSourceNotFoundRejection'] | ModelTypes['InsufficientFundsRejection'] | ModelTypes['InstantFundingLimitExceededRejection'] | ModelTypes['ProjectInstantFundingLimitExceededRejection'] | ModelTypes['GlobalInstantFundingLimitExceededRejection'] | ModelTypes['AccountVerificationWrongStatusRejection'];
    /** Initiate A Funding Request Success Payload */
    ['InitiateFundingRequestSuccessPayload']: {
        /** Details of the funding payment created */
        payment: ModelTypes['Payment'];
    };
    /** *COMING SOON*
  Input to create a quote and an international beneficiary */
    ['InitiateInternationalCreditTransferInput']: {
        /** Account ID of the originator of the international credit transfer */
        accountId?: string | undefined;
        /** Account number if the beneficiary is a swan account */
        accountNumber?: ModelTypes['AccountNumber'] | undefined;
        /** Target amount of the international credit transfer */
        targetAmount: ModelTypes['AmountInput'];
        /** Beneficiary of the international credit transfer */
        internationalBeneficiary: ModelTypes['InternationalBeneficiaryInput'];
        /** Transfer details */
        internationalCreditTransferDetails: Array<ModelTypes['InternationalCreditTransferDetailsInput']>;
        /** When the consent flow is finished the user is redirected to this URL */
        consentRedirectUrl: string;
        /** External reference */
        externalReference?: string | undefined;
        /** Language used to output errors */
        language?: ModelTypes['InternationalCreditTransferDisplayLanguage'] | undefined;
    };
    /** Initiate International Credit Transfer Response Payload */
    ['InitiateInternationalCreditTransferResponsePayload']: ModelTypes['InitiateInternationalCreditTransferResponseSuccessPayload'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ValidationRejection'];
    /** Initiate International Credit Transfer Response Success Payload */
    ['InitiateInternationalCreditTransferResponseSuccessPayload']: {
        /** Details of the international credit transfer created */
        payment: ModelTypes['Payment'];
        /** Details for the quote of international credit transfer */
        quote: ModelTypes['InternationalCreditTransferQuote'];
    };
    ['InitiateMerchantPaymentCollectionInput']: {
        /** Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€. */
        amount: ModelTypes['AmountInput'];
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement -
    For checks transaction, if empty, default label will be set as "Check N° [1st part of CMC7 - 7 char.] */
        label?: string | undefined;
        /** end-to-end reference of the concerned payment collection */
        reference?: string | undefined;
        /** external reference (JSON) that can be used by the Swan merchant for reconciliation purposes */
        externalReference?: string | undefined;
        /** Internal direct debit type of payment collection */
        internalDirectDebit?: ModelTypes['InternalDirectDebitPaymentCollectionInput'] | undefined;
        /** Sepa Direct Debit type of payment collection */
        sepaDirectDebit?: ModelTypes['SepaDirectDebitPaymentCollectionInput'] | undefined;
    };
    ['InitiateMerchantPaymentCollectionPayload']: ModelTypes['InitiateMerchantPaymentCollectionSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['NotFoundRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ValidationRejection'];
    ['InitiateMerchantPaymentCollectionSuccessPayload']: {
        merchantPaymentCollection: ModelTypes['Payment'];
    };
    ['InstantFundingLimit']: {
        /** Maximum Instant Funding Amount authorized */
        amount: ModelTypes['Amount'];
        /** Instant Funding Amount that has already been used */
        funding?: ModelTypes['Amount'] | undefined;
    };
    /** Rejection returned when the Account Holder Instant Funding limit has been exceeded */
    ['InstantFundingLimitExceededRejection']: {
        message: string;
    };
    /** Rejection returned when the Available balance is insufficient */
    ['InsufficientFundsRejection']: {
        message: string;
    };
    /** Internal Beneficiary */
    ['InternalBeneficiary']: {
        /** unique identifier of a beneficiary
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        id?: string | undefined;
        /** full name of the beneficiary */
        name: string;
        /** `true` if this new beneficiary is the account holder himself in an other financial institution.
    *SOON TO BE DEPRECATED*
    Not used. It will be removed soon. */
        isMyOwnIban: boolean;
        /** account number if the beneficiary is a swan account */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Internal Credit Transfer transaction */
    ['InternalCreditTransfer']: {
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain. */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: ModelTypes['TransactionSide'];
        /** type */
        type: ModelTypes['TransactionTypeEnum'];
        /** amount */
        amount: ModelTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: ModelTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: ModelTypes['Payment'] | undefined;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ModelTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: ModelTypes['PaymentProduct'];
        /** creditor information */
        creditor: ModelTypes['InternalCreditTransferCreditor'];
        /** debtor information */
        debtor: ModelTypes['InternalCreditTransferDebtor'];
        /** matching account for the transaction */
        account?: ModelTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: ModelTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: ModelTypes['Transaction'] | undefined;
        /** r-transaction reason */
        returnReason?: ModelTypes['TransactionReasonCode'] | undefined;
    };
    /** Internal Credit Transfer creditor */
    ['InternalCreditTransferCreditor']: ModelTypes['InternalCreditTransferInCreditor'] | ModelTypes['InternalCreditTransferOutCreditor'];
    /** Internal Credit Transfer debtor */
    ['InternalCreditTransferDebtor']: ModelTypes['InternalCreditTransferInDebtor'] | ModelTypes['InternalCreditTransferOutDebtor'];
    /** Internal Credit Transfer creditor for Incoming transaction */
    ['InternalCreditTransferInCreditor']: {
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Internal Credit Transfer debtor for Incoming transaction */
    ['InternalCreditTransferInDebtor']: {
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Internal Credit Transfer creditor for Outgoing transaction */
    ['InternalCreditTransferOutCreditor']: {
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Internal Credit Transfer debtor for Outgoing transaction */
    ['InternalCreditTransferOutDebtor']: {
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** InternalDirectDebitB2BMerchantPaymentMethod */
    ['InternalDirectDebitB2BMerchantPaymentMethod']: {
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: ModelTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: ModelTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: ModelTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ModelTypes['RollingReserve'] | undefined;
    };
    ['InternalDirectDebitB2BPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined;
    };
    /** Internal Direct Debit Creditor */
    ['InternalDirectDebitCreditor']: {
        /** unique identifier of the creditor account */
        accountId: string;
    };
    /** Internal Direct Debit Debtor */
    ['InternalDirectDebitDebtor']: {
        /** unique identifier of the debtor account */
        accountId: string;
    };
    ['InternalDirectDebitMandate']: ModelTypes['InternalPaymentDirectDebitMandate'] | ModelTypes['InternalReceivedDirectDebitMandate'];
    ['InternalDirectDebitPaymentCollectionInput']: {
        /** ID of the concerned payment mandate */
        mandateId: string;
        /** Date at which the Swan merchant wishes the payment to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
    };
    ['InternalDirectDebitSequence']: InternalDirectDebitSequence;
    /** InternalDirectDebitStandardMerchantPaymentMethod */
    ['InternalDirectDebitStandardMerchantPaymentMethod']: {
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: ModelTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: ModelTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: ModelTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ModelTypes['RollingReserve'] | undefined;
    };
    ['InternalDirectDebitStandardPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined;
    };
    /** Internal Direct Debit transaction */
    ['InternalDirectDebitTransaction']: {
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference: string;
        /** payment method identifier used for this transaction: accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: ModelTypes['TransactionSide'];
        /** type */
        type: ModelTypes['TransactionTypeEnum'];
        /** amount */
        amount: ModelTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: ModelTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: ModelTypes['Payment'] | undefined;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ModelTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: ModelTypes['PaymentProduct'];
        /** creditor information */
        creditor: ModelTypes['InternalDirectDebitCreditor'];
        /** debtor information */
        debtor: ModelTypes['InternalDirectDebitDebtor'];
        /** matching account for the transaction */
        account?: ModelTypes['Account'] | undefined;
        /** matching Internal mandate for the transaction */
        mandate?: ModelTypes['InternalDirectDebitMandate'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: ModelTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: ModelTypes['Transaction'] | undefined;
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: ModelTypes['Amount'] | undefined;
        /** date on which reserved funds become available. */
        reservedAmountReleasedAt?: ModelTypes['DateTime'] | undefined;
        /** r-transaction reason */
        returnReason?: ModelTypes['TransactionReasonCode'] | undefined;
    };
    /** Rejection returned on unexpected server error */
    ['InternalErrorRejection']: {
        message: string;
    };
    /** Payment direct debit mandate for Internal */
    ['InternalPaymentDirectDebitMandate']: {
        /** Unique identifier of the Internal Direct Debit Payment Mandate */
        id: string;
        /** List of transactions associated with the Internal Payment Direct Debit Mandate.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: ModelTypes['TransactionConnection'] | undefined;
        /** Unique reference of the Internal Direct Debit Payment Mandate */
        reference: string;
        /** Internal Direct Debit Payment Mandate scheme */
        scheme: ModelTypes['InternalPaymentMandateScheme'];
        /** Internal Direct Debit Payment Mandate status information */
        statusInfo: ModelTypes['PaymentMandateStatusInfo'];
        /** Internal Direct Debit Payment Mandate sequence */
        sequence: ModelTypes['InternalPaymentMandateSequence'];
        /** Internal Direct Debit Payment Mandate PDF document URL */
        mandateDocumentUrl: string;
        /** Internal Direct Debit Payment Mandate debtor information */
        debtor: ModelTypes['InternalPaymentMandateDebtor'];
        /** Internal direct debit ultimate creditor name */
        ultimateCreditorName?: string | undefined;
        /** Internal Direct Debit Payment Mandate creditor information */
        creditor: ModelTypes['InternalPaymentMandateCreditor'];
        /** Signature date of the Internal Direct Debit Payment Mandate */
        signatureDate?: ModelTypes['Date'] | undefined;
        /** Creation date of the Internal Direct Debit Payment Mandate */
        createdAt: ModelTypes['DateTime'];
        /** Last Update date of the Internal Direct Debit Payment Mandate */
        updatedAt: ModelTypes['DateTime'];
        /** Date of the the last transaction executed for the concerned Internal Direct Debit Payment Mandate */
        executedAt?: ModelTypes['DateTime'] | undefined;
        /** Expiry date of the Internal Direct Debit Payment Mandate */
        expiredAt?: ModelTypes['Date'] | undefined;
        /** Account Holder information */
        accountHolder: ModelTypes['AccountHolder'];
        /** Language that will be used to produce the mandate PDF document */
        language: string;
        /** Custom name of the mandate */
        name?: string | undefined;
    };
    ['InternalPaymentMandateCreditor']: {
        /** Internal Direct Debit Payment Mandate creditor UUID */
        id: string;
        /** Internal Direct Debit Payment Mandate Creditor Idenfier */
        identifier: string;
        /** Internal Direct Debit Payment Mandate creditor name */
        name: string;
        /** Internal Direct Debit Payment Mandate creditor address */
        address: ModelTypes['Address'];
    };
    ['InternalPaymentMandateDebtor']: {
        /** Internal Direct Debit Payment Mandate debtor name */
        name: string;
        /** Internal Direct Debit Payment Mandate debtor e-mail */
        email: string;
        /** Internal Direct Debit Payment Mandate debtor country */
        country: ModelTypes['CCA3'];
        /** Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        address?: ModelTypes['Address'] | undefined;
        /** Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        accountId?: string | undefined;
    };
    ['InternalPaymentMandateScheme']: InternalPaymentMandateScheme;
    ['InternalPaymentMandateSequence']: InternalPaymentMandateSequence;
    /** Received direct debit mandate for SEPA */
    ['InternalReceivedDirectDebitMandate']: {
        /** Unique identifier of the received internal direct debit mandate, generated by Swan */
        id: string;
        /** List of transactions associated with the Internal Receive Direct Debit Mandate.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: ModelTypes['TransactionConnection'] | undefined;
        /** Version of the received internal direct debit mandate */
        version: string;
        /** Creation date of the received internal direct debit mandate */
        createdAt: ModelTypes['DateTime'];
        /** Last Update date of the received internal direct debit mandate */
        updatedAt: ModelTypes['DateTime'];
        /** Received internal direct debit Unique Mandate Reference (UMR) */
        reference: string;
        /** Received internal direct debit mandate scheme */
        scheme: ModelTypes['InternalReceivedDirectDebitMandateScheme'];
        /** Received internal direct debit mandate sequence */
        sequence: ModelTypes['InternalReceivedDirectDebitMandateSequence'];
        /** Received internal direct debit creditor */
        creditor: ModelTypes['InternalReceivedDirectDebitMandateCreditor'];
        /** Received internal direct debit ultimate creditor name */
        ultimateCreditorName?: string | undefined;
        /** Date of the last internal direct debit transaction executed for the concerned received internal direct debit mandate */
        executedAt?: ModelTypes['DateTime'] | undefined;
        /** Date of signature of the received internal direct debit mandate */
        signatureDate?: ModelTypes['Date'] | undefined;
        /** Expiry date of the received internal direct debit mandate, computed automatically (36 months from the executedAt date) */
        expiredAt?: ModelTypes['Date'] | undefined;
        /** Mandate status information of the received internal direct debit mandate */
        statusInfo: ModelTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Account of the received internal direct debit mandate debtor */
        account?: ModelTypes['Account'] | undefined;
        /** Iban of the received internal direct debit mandate debtor */
        iban: ModelTypes['IBAN'];
        /** Mandate name */
        name?: string | undefined;
    };
    /** Internal received direct debit mandate creditor */
    ['InternalReceivedDirectDebitMandateCreditor']: {
        /** Creditor identifier */
        identifier: string;
        /** Name of the creditor */
        name: string;
        /** Address of the creditor */
        address: ModelTypes['Address'];
    };
    ['InternalReceivedDirectDebitMandateScheme']: InternalReceivedDirectDebitMandateScheme;
    ['InternalReceivedDirectDebitMandateSequence']: InternalReceivedDirectDebitMandateSequence;
    /** Address of an international beneficiary */
    ['InternationalAddressInput']: {
        /** Address 1 */
        address1?: string | undefined;
        /** City */
        city?: string | undefined;
        /** Country */
        country?: string | undefined;
        /** Zip Code */
        zipCode?: string | undefined;
        /** State */
        state?: string | undefined;
    };
    /** International Beneficiary Details */
    ['InternationalBeneficiaryDetailsInput']: {
        /** Key */
        key: string;
        /** Value */
        value: string;
    };
    /** *COMING SOON*
  International Beneficiary Dynamic Forms */
    ['InternationalBeneficiaryDynamicForms']: {
        /** *COMING SOON*
    Schemes */
        schemes: Array<ModelTypes['Scheme']>;
    };
    /** *COMING SOON*
  International Beneficiary */
    ['InternationalBeneficiaryInput']: {
        /** Account holder name */
        name: string;
        /** Currency of the international beneficiary account */
        currency: ModelTypes['Currency'];
        /** *COMING SOON*
    Currency-specific details of the beneficiary */
        details: Array<ModelTypes['InternationalBeneficiaryDetailsInput']>;
        /** *COMING SOON*
    Route that Swan will use to transfer the funds */
        route: ModelTypes['InternationalCreditTransferRouteInput'];
    };
    ['InternationalCreditTransferCreditor']: ModelTypes['InternationalCreditTransferOutCreditor'] | ModelTypes['InternationalCreditTransferInCreditor'];
    /** International Currency Exchange / Quote */
    ['InternationalCreditTransferCurrencyExchange']: {
        /** Rate of the quote */
        exchangeRate: string;
        /** Fees */
        feesAmount?: ModelTypes['Amount'] | undefined;
        /** Source amount of the quote */
        sourceAmount?: ModelTypes['Amount'] | undefined;
        /** target amount of the quote */
        targetAmount?: ModelTypes['Amount'] | undefined;
    };
    ['InternationalCreditTransferDebtor']: ModelTypes['InternationalCreditTransferOutDebtor'] | ModelTypes['InternationalCreditTransferInDebtor'];
    /** International Credit Transfer - Currency-specific details of the beneficiary */
    ['InternationalCreditTransferDetails']: {
        /** Key */
        key: string;
        /** Value */
        value: string;
    };
    /** *COMING SOON*
  International Credit Transfer Details */
    ['InternationalCreditTransferDetailsInput']: {
        /** *COMING SOON*
    Key */
        key: string;
        /** *COMING SOON*
    Value */
        value: string;
    };
    ['InternationalCreditTransferDisplayLanguage']: InternationalCreditTransferDisplayLanguage;
    /** *COMING SOON*
  International Credit Transfer Dynamic Form */
    ['InternationalCreditTransferDynamicForm']: {
        /** List of international transaction fields */
        fields: Array<ModelTypes['Field']>;
        /** *COMING SOON*
    Number of fields that need to be updated to fill the form completely. Please re run the query internationalCreditTransferTransactionDetailsDynamicForm with updated refreshableFields if the value of this field is not 0 */
        remainingFieldsToRefreshCount: number;
    };
    /** International Credit Transfer In - Creditor info */
    ['InternationalCreditTransferInCreditor']: {
        /** Account holder name */
        name: string;
        /** Bank Identifier Code */
        BIC: ModelTypes['BIC'];
        /** International Bank Account Number
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        IBAN: ModelTypes['IBAN'];
        /** maskedIBAN if the beneficiary is a an account in an other financial institution */
        maskedIBAN: string;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
    };
    ['InternationalCreditTransferInDebtor']: {
        /** Account holder name */
        name: string;
        /** Account Number */
        accountNumber: string;
        /** BIC */
        bic?: string | undefined;
    };
    /** International Credit Transfer Out - Creditor info */
    ['InternationalCreditTransferOutCreditor']: {
        /** Currency of the international beneficiary account */
        currency: ModelTypes['Currency'];
        /** Currency-specific details of the beneficiary */
        details: Array<ModelTypes['InternationalCreditTransferDetails']>;
        /** Account holder name */
        name: string;
        /** Route that Swan will use to transfer the funds */
        route: ModelTypes['InternationalCreditTransferRoute'];
    };
    ['InternationalCreditTransferOutDebtor']: {
        /** Account holder name */
        name: string;
    };
    /** *COMING SOON*
  International Quote */
    ['InternationalCreditTransferQuote']: {
        /** Rate of the quote */
        exchangeRate: string;
        /** Source amount of the quote */
        sourceAmount: ModelTypes['Amount'];
        /** target amount of the quote */
        targetAmount: ModelTypes['Amount'];
        /** Fees */
        feesAmount: ModelTypes['Amount'];
    };
    ['InternationalCreditTransferRoute']: InternationalCreditTransferRoute;
    ['InternationalCreditTransferRouteInput']: InternationalCreditTransferRouteInput;
    ['InternationalCreditTransferTransaction']: {
        /** matching account for this transaction */
        account?: ModelTypes['Account'] | undefined;
        /** amount */
        amount: ModelTypes['Amount'];
        /** booked balance after this transaction */
        bookedBalanceAfter?: ModelTypes['Amount'] | undefined;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** creditor information */
        creditor: ModelTypes['InternationalCreditTransferCreditor'];
        /** debtor information */
        debtor: ModelTypes['InternationalCreditTransferDebtor'];
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: ModelTypes['DateTime'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** @deprecated(reason: "use `quote.feesAmount` instead") */
        fees?: ModelTypes['Amount'] | undefined;
        /** unique identifier of the transaction */
        id: string;
        /** instructed amount */
        instructedAmount?: ModelTypes['Amount'] | undefined;
        /** instructed amount */
        intermediaryBankFees?: Array<ModelTypes['Amount']> | undefined;
        /** label */
        label: string;
        /** origin transaction associated to this transaction */
        originTransaction?: ModelTypes['Transaction'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** payment associated to this transaction */
        payment?: ModelTypes['Payment'] | undefined;
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** payment product used for this transaction */
        paymentProduct: ModelTypes['PaymentProduct'];
        /** quote given by our international provider */
        currencyExchange: ModelTypes['InternationalCreditTransferCurrencyExchange'];
        /** external identifier of the transaction */
        reference: string;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** return reason */
        returnReason?: ModelTypes['TransactionReasonCode'] | undefined;
        /** side (Credit or Debit) */
        side: ModelTypes['TransactionSide'];
        /** status information */
        statusInfo: ModelTypes['TransactionStatusInfo'];
        /** type */
        type: ModelTypes['TransactionTypeEnum'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
    };
    /** Rejection returned on invalid argument error */
    ['InvalidArgumentRejection']: {
        message: string;
        code: ModelTypes['InvalidArgumentRejectionCode'];
        fields: Array<ModelTypes['InvalidArgumentRejectionField']>;
    };
    ['InvalidArgumentRejectionCode']: InvalidArgumentRejectionCode;
    ['InvalidArgumentRejectionField']: {
        name: string;
        errors: Array<string>;
    };
    /** InvalidVerification */
    ['InvalidBeneficiaryVerification']: {
        message: string;
    };
    /** Information about the invalidity of the IBAN */
    ['InvalidIban']: {
        /** Iban from input */
        iban: ModelTypes['IBAN'];
        /** Enum that can be used to discriminate on the error */
        code: ModelTypes['InvalidIbanCode'];
        /** Message that give a bit of context during development */
        message: string;
    };
    ['InvalidIbanCode']: InvalidIbanCode;
    /** Describes an invalid identification level for the process associated to this identification, and the invalid reason can be accessed */
    ['InvalidIdentificationLevelStatusInfo']: {
        /** Always set to `Invalid` */
        status: ModelTypes['SwanIdentificationStatus'];
        /** The reasons why this identification level is invalid */
        reasons?: Array<ModelTypes['IdentificationInvalidReason']> | undefined;
    };
    /** Rejection returned if phone number is not well formatted */
    ['InvalidPhoneNumberRejection']: {
        message: string;
    };
    /** Rejection returned if siren number is not well formatted */
    ['InvalidSirenNumberRejection']: {
        message: string;
    };
    /** Invoice */
    ['Invoice']: {
        /** unique id */
        id: string;
        /** account id */
        accountId: string;
        /** name of the invoice */
        name: string;
        /** type of the invoice */
        type: ModelTypes['InvoiceType'];
        /** status of the invoice */
        status: ModelTypes['InvoiceStatus'];
        /** due amount */
        amount: ModelTypes['Amount'];
        /** temporary public url on which the file can be accessible */
        url?: string | undefined;
        /** date at which the link will not be useable anymore */
        expiresAt?: ModelTypes['DateTime'] | undefined;
        /** starting date of the billing window */
        openingDate: ModelTypes['DateTime'];
        /** ending date of the billing window */
        closingDate: ModelTypes['DateTime'];
        /** creation date */
        createdAt: ModelTypes['DateTime'];
        /** last update date */
        updatedAt: ModelTypes['DateTime'];
    };
    /** Please see the Connection interface */
    ['InvoiceConnection']: {
        pageInfo: ModelTypes['PageInfo'];
        totalCount: number;
        edges: Array<ModelTypes['InvoiceEdge']>;
    };
    /** Please see the Edge interface */
    ['InvoiceEdge']: {
        node: ModelTypes['Invoice'];
        cursor: string;
    };
    ['InvoiceStatus']: InvoiceStatus;
    ['InvoiceType']: InvoiceType;
    /** Key value details */
    ['KeyValue']: {
        /** Key */
        key: string;
        /** Value */
        value: string;
    };
    ['Language']: Language;
    ['LegalDocument']: {
        /** ID of the legal document */
        id: string;
        /** Type of the legal document */
        type: ModelTypes['LegalDocumentType'];
        /** Status of the Legal Document */
        statusInfo: ModelTypes['LegalDocumentStatusInfo'];
        /** Language of the Legal Document */
        language: ModelTypes['AccountLanguage'];
        /** Url to download the Document */
        url: string;
    };
    ['LegalDocumentActiveStatusInfo']: {
        /** LegalDocument status (always Active for type LegalDocumentActiveStatusInfo) */
        status: ModelTypes['LegalDocumentStatus'];
        /** Creation date */
        createdAt: ModelTypes['DateTime'];
        /** Activation date */
        activatedAt?: ModelTypes['DateTime'] | undefined;
    };
    ['LegalDocumentConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** LegalDocumentEdge list */
        edges: Array<ModelTypes['LegalDocumentEdge']>;
    };
    ['LegalDocumentEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The account membership */
        node: ModelTypes['LegalDocument'];
    };
    ['LegalDocumentInactiveStatusInfo']: {
        /** LegalDocument status (always Inactive for type LegalDocumentInactiveStatusInfo) */
        status: ModelTypes['LegalDocumentStatus'];
        /** Creation date */
        createdAt: ModelTypes['DateTime'];
        /** Activation date */
        activatedAt?: ModelTypes['DateTime'] | undefined;
        /** Deactivation date */
        deactivatedAt?: ModelTypes['DateTime'] | undefined;
    };
    ['LegalDocumentsFilterInput']: {
        status?: ModelTypes['LegalDocumentStatus'] | undefined;
        type?: ModelTypes['LegalDocumentType'] | undefined;
    };
    ['LegalDocumentStatus']: LegalDocumentStatus;
    ['LegalDocumentStatusInfo']: ModelTypes['LegalDocumentActiveStatusInfo'] | ModelTypes['LegalDocumentInactiveStatusInfo'] | ModelTypes['LegalDocumentUpcomingStatusInfo'];
    ['LegalDocumentType']: LegalDocumentType;
    ['LegalDocumentUpcomingStatusInfo']: {
        /** LegalDocument status (always Upcoming for type LegalDocumentUpcomingStatusInfo) */
        status: ModelTypes['LegalDocumentStatus'];
        /** Creation date */
        createdAt: ModelTypes['DateTime'];
        /** Date when the LegalDocument will be activated */
        effectiveDate?: ModelTypes['DateTime'] | undefined;
    };
    ['LegalRepresentativeAccountMembershipCannotBeDisabledRejection']: {
        accountMembershipId: string;
        message: string;
    };
    ['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection']: {
        id: string;
        message: string;
    };
    ['MandateLanguage']: MandateLanguage;
    ['MembershipInfoInput']: {
        /** Email address */
        email: string;
        /** Restricted to a user if necessary */
        restrictedTo: ModelTypes['RestrictedToInput'];
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean;
        /** `true` if this account membership can invite, update, suspend or resume account membership */
        canManageAccountMembership: boolean;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** Residency address of the member to be added */
        residencyAddress?: ModelTypes['ResidencyAddressInput'] | undefined;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined;
    };
    /** Filters that can be applied when listing accounts (Only applied in user context) */
    ['MembershipsFilterInput']: {
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** Can the user initiate payments on this account */
        canInitiatePayments?: boolean | undefined;
        /** Can the user manage account membership */
        canManageAccountMembership?: boolean | undefined;
        /** Can the user manage beneficiaries */
        canManageBeneficiaries?: boolean | undefined;
        /** Can the user view account */
        canViewAccount?: boolean | undefined;
        /** Account memberships status/statuses we're looking for */
        status?: Array<ModelTypes['AccountMembershipStatus']> | undefined;
        /** Filtered by email */
        email?: string | undefined;
        /** Filtered by first name */
        firstName?: string | undefined;
        /** Filtered by last name */
        lastName?: string | undefined;
        /** Searches email, first name, last name, and id */
        search?: string | undefined;
    };
    ['MerchantCategoryDescription']: MerchantCategoryDescription;
    ['MerchantPaymentLink']: {
        /** Merchant payment link's unique ID. */
        id: string;
        /** ID of the related project */
        projectId: string;
        /** The URL at which the customer can complete the payment. */
        url: string;
        /** The merchant payment link status. */
        statusInfo: ModelTypes['MerchantPaymentLinkStatusInfo'];
        /** The Merchant Profile to link this Payment Link to */
        merchantProfile: ModelTypes['MerchantProfile'];
        /** Amount to be paid to sucessfully complete the payment. */
        amount: ModelTypes['Amount'];
        /** Merchant Website URL to redirect the user to when the payment is completed. */
        redirectUrl: string;
        /** URL to redirect the user to if they cancel their payment */
        cancelRedirectUrl: string;
        /** Controls if the payment mandate created from this payment link is for one-time use or can be reused
    This is applicable for card and SEPA Direct Debit payment methods only. */
        sequence: ModelTypes['PaymentLinkSequenceType'];
        /** The customer billing Address
    These fields should be completed also to pre-fill a SEPA direct debit mandate.
    
    We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes */
        billingAddress?: ModelTypes['Address'] | undefined;
        /**   A date that reflects the time at which the user asked the transaction to be executed.
    For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
    For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
    
    Default value means that the execution will be as soon as possible */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** Any string that you want to be attached to this payment link.
    Usually something to help you reference the link in an external system. */
        externalReference?: string | undefined;
        /** Optional field intended to provide a way for you to include a reference number or code.
    The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different. */
        reference?: string | undefined;
        /** The language used for the payment page.
    Default is the browser's language, or English if not available. */
        language?: string | undefined;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page. */
        label?: string | undefined;
        /**  We will use the information specified here to prefill the payment link fields
    depending on the payment method the end user chooses.
    Keep in mind that your end customer will be able to edit these fields. */
        customer?: ModelTypes['Customer'] | undefined;
        /** List of payment methods IDs enabled for this payment link.
    If the array is empty Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit) */
        paymentMethods: Array<ModelTypes['MerchantPaymentMethod']>;
    };
    ['MerchantPaymentLinkStatus']: MerchantPaymentLinkStatus;
    ['MerchantPaymentLinkStatusInfo']: ModelTypes['ActiveMerchantPaymentLinkStatusInfo'] | ModelTypes['CompletedMerchantPaymentLinkStatusInfo'] | ModelTypes['ExpiredMerchantPaymentLinkStatusInfo'];
    /** Base object for the different Payment Methods available */
    ['MerchantPaymentMethod']: ModelTypes['CardMerchantPaymentMethod'] | ModelTypes['CheckMerchantPaymentMethod'] | ModelTypes['InternalDirectDebitB2BMerchantPaymentMethod'] | ModelTypes['InternalDirectDebitStandardMerchantPaymentMethod'] | ModelTypes['SepaDirectDebitB2BMerchantPaymentMethod'] | ModelTypes['SepaDirectDebitCoreMerchantPaymentMethod'];
    /** Rejection returned when the Merchant Payment Method is not active */
    ['MerchantPaymentMethodNotActiveRejection']: {
        paymentMethodIds?: Array<string> | undefined;
        message: string;
    };
    ['MerchantPaymentMethodStatus']: MerchantPaymentMethodStatus;
    /** The payment method status information */
    ['MerchantPaymentMethodStatusInfo']: ModelTypes['CanceledMerchantPaymentMethodStatusInfo'] | ModelTypes['DisabledMerchantPaymentMethodStatusInfo'] | ModelTypes['EnabledMerchantPaymentMethodStatusInfo'] | ModelTypes['PendingMerchantPaymentMethodStatusInfo'] | ModelTypes['RejectedMerchantPaymentMethodStatusInfo'] | ModelTypes['SuspendedMerchantPaymentMethodStatusInfo'];
    ['MerchantPaymentMethodType']: MerchantPaymentMethodType;
    /** Merchant Profile */
    ['MerchantProfile']: {
        /** The Merchant Profile ID */
        id: string;
        /** The Account ID this Merchant Profile is linked to */
        accountId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website */
        merchantWebsite?: string | undefined;
        /** Url of the merchant's logo */
        merchantLogoUrl?: string | undefined;
        /** The status of the merchant profile */
        statusInfo: ModelTypes['MerchantProfileStatusInfo'];
        /** Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: ModelTypes['ProductType'];
        /** Expected annual activity volumes for all payment method */
        expectedMonthlyPaymentVolume: ModelTypes['Amount'];
        /** Payment Methods associated */
        merchantPaymentMethods?: Array<ModelTypes['MerchantPaymentMethod']> | undefined;
        /** Updates Requested associated */
        requestedMerchantProfileUpdates?: Array<ModelTypes['RequestMerchantProfileUpdate']> | undefined;
        /** expected average basket value. */
        expectedAverageBasket: ModelTypes['Amount'];
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page. */
        accentColor?: string | undefined;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
    };
    ['MerchantProfileConnection']: {
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** Edge list */
        edges: Array<ModelTypes['MerchantProfileEdge']>;
        /** Total number of element in the list */
        totalCount: number;
    };
    ['MerchantProfileEdge']: {
        node: ModelTypes['MerchantProfile'];
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
    };
    /** Filters that can be applied when listing Funding Sources */
    ['MerchantProfileFiltersInput']: {
        status: Array<ModelTypes['MerchantProfileStatus']>;
    };
    ['MerchantProfileOrderByFieldInput']: MerchantProfileOrderByFieldInput;
    ['MerchantProfileOrderByInput']: {
        field?: ModelTypes['MerchantProfileOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['MerchantProfileStatus']: MerchantProfileStatus;
    /** Merchant Profile Status Information */
    ['MerchantProfileStatusInfo']: ModelTypes['CanceledMerchantProfileStatusInfo'] | ModelTypes['EnabledMerchantProfileStatusInfo'] | ModelTypes['PendingReviewMerchantProfileStatusInfo'] | ModelTypes['RejectedMerchantProfileStatusInfo'] | ModelTypes['SuspendedMerchantProfileStatusInfo'];
    /** Rejection returned when the Merchant Profile is not in the expected status */
    ['MerchantProfileWrongStatusRejection']: {
        message: string;
        currentStatus: ModelTypes['MerchantProfileStatus'];
        expectedStatus: ModelTypes['MerchantProfileStatus'];
    };
    /** Rejection returned when mandatory fields are missing from the call. */
    ['MissingMandatoryFieldRejection']: {
        message: string;
    };
    ['MonthlyIncome']: MonthlyIncome;
    ['MonthlyPaymentVolume']: MonthlyPaymentVolume;
    ['Mutation']: {
        /** Activate a Physical Card.
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        activatePhysicalCard: ModelTypes['ActivatePhysicalCardPayload'];
        /** Add a new account membership to an account.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        addAccountMembership: ModelTypes['AddAccountMembershipPayload'];
        /** Add multiple new account memberships to account
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        addAccountMemberships: ModelTypes['AddAccountMembershipsPayload'];
        /** Add a new card to an account membership.
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the permission `canManageCards=true`. */
        addCard: ModelTypes['AddCardPayload'];
        /** Add several cards with Group Delivery
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the attribute `canManageAccountMembership=true`. */
        addCardsWithGroupDelivery: ModelTypes['AddCardsWithGroupDeliveryPayload'];
        /** Add several cards
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the attribute `canManageAccountMembership=true`. */
        addCards: ModelTypes['AddCardsPayload'];
        /** Add a Digital Card to push to ApplePay or GooglePay
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must be the card holder
    
    A digital card will only be valid for 1 hour after consent validation */
        addDigitalCard: ModelTypes['AddDigitalCardPayload'];
        /** Add an external balance to an external account.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        addExternalAccountBalance: ModelTypes['AddExternalAccountBalancePayload'];
        /** Add an external account to an account holder.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        addExternalAccount: ModelTypes['AddExternalAccountPayload'];
        /** Add a new request for funding limit settings change.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        addFundingLimitSettingsChangeRequest: ModelTypes['AddFundingLimitSettingsChangeRequestPayload'];
        /** Add an external balance to an external account.
    If a balance already exist for the day, the balance amount will be updated.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        addOrUpdateExternalAccountBalance: ModelTypes['AddOrUpdateExternalAccountBalancePayload'];
        /** Add a new Single Use Virtual Card to an account membership. */
        addSingleUseVirtualCard: ModelTypes['AddSingleUseVirtualCardPayload'];
        /** Add several single-use virtual cards
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the attribute `canManageAccountMembership=true`. */
        addSingleUseVirtualCards: ModelTypes['AddSingleUseVirtualCardsPayload'];
        /** Add a new Virtual IBAN. */
        addVirtualIbanEntry?: ModelTypes['AddVirtualIbanEntryPayload'] | undefined;
        /** Allows to receive Sepa Direct Debit on a Virtual IBAN. */
        allowSddVirtualIbanEntry: ModelTypes['AllowSddVirtualIbanEntryPayload'];
        /** Allows to receive Sepa Direct Debit on an account. */
        allowSdd: ModelTypes['AllowSddPayload'];
        /** Bind a user to an account membership
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.* */
        bindAccountMembership: ModelTypes['BindAccountMembershipPayload'];
        /** Cancel a Card */
        cancelCard: ModelTypes['CancelCardPayload'];
        /** Cancel a Digital Card */
        cancelDigitalCard: ModelTypes['CancelDigitalCardPayload'];
        /** Cancel a physical card. */
        cancelPhysicalCard: ModelTypes['CancelPhysicalCardPayload'];
        /** Cancels a Virtual IBAN. */
        cancelVirtualIbanEntry: ModelTypes['CancelVirtualIbanEntryPayload'];
        /** Closes an account.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must have a legal representative account membership for this account.* */
        closeAccount: ModelTypes['CloseAccountPayload'];
        /** Confirm Physical Card Renewal */
        confirmPhysicalCardRenewal: ModelTypes['ConfirmPhysicalCardRenewalPayload'];
        /** Delete a supporting document, in case uploaded file is not what was wanted. This action can not be undone.
    
    This mutation can only be used on an "Uploaded" supporting document of a "WaitingForDocument" supporting document collection.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        deleteSupportingDocument: ModelTypes['DeleteSupportingDocumentPayload'];
        /** Allows to refuse all Sepa Direct Debit received on a Virtual IBAN. */
        denySddVirtualIbanEntry: ModelTypes['DenySddVirtualIbanEntryPayload'];
        /** Allows to refuse all Sepa Direct Debit received on an account. */
        denySdd: ModelTypes['DenySddPayload'];
        /** Disable an account membership
    
    This mutation is callable with a User access token and a Project access token ([Learn More](https://docs.swan.io/api/authentication))
    
    With a User access token, the user must have the permission to manage account membership of the account */
        disableAccountMembership: ModelTypes['DisableAccountMembershipPayload'];
        /** Finalize an onboarding led to the opening of a new account for your client, who thus become the account holder.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).* */
        finalizeOnboarding: ModelTypes['FinalizeOnboardingPayload'];
        /** Creates an onboarding for a new company account holder.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        onboardCompanyAccountHolder: ModelTypes['OnboardCompanyAccountHolderPayload'];
        /** Creates an onboarding for a new individual account holder.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        onboardIndividualAccountHolder: ModelTypes['OnboardIndividualAccountHolderPayload'];
        /** Print Physical Card.
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request. */
        printPhysicalCard: ModelTypes['PrintPhysicalCardPayload'];
        /** Resumes an account membership already suspended.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        resumeAccountMembership: ModelTypes['ResumeAccountMembershipPayload'];
        /** Resume a Physical Card.
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        resumePhysicalCard: ModelTypes['ResumePhysicalCardPayload'];
        /** Suspends an account membership.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        suspendAccountMembership: ModelTypes['SuspendAccountMembershipPayload'];
        /** Suspend a Physical Card. */
        suspendPhysicalCard: ModelTypes['SuspendPhysicalCardPayload'];
        updateAccountHolder: ModelTypes['UpdateAccountHolderPayload'];
        /** Updates an account membership.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        updateAccountMembership: ModelTypes['UpdateAccountMembershipPayload'];
        /** Update an account. */
        updateAccount: ModelTypes['UpdateAccountPayload'];
        /** Update a Card. */
        updateCard?: ModelTypes['UpdateCardPayload'] | undefined;
        /** Updates a company onboarding.
    
    If you aim to update Ultimate Beneficiary Owners, you need to provide all of them as they are going to be overridden by your update payload.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        updateCompanyOnboarding: ModelTypes['UpdateCompanyOnboardingPayload'];
        /** Updates an individual onboarding.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        updateIndividualOnboarding: ModelTypes['UpdateIndividualOnboardingPayload'];
        updateSupportingDocument: ModelTypes['UpdateSupportingDocumentPayload'];
        /** Reveal the card numbers in the consent page once consent has been given by the cardholder
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        viewCardNumbers: ModelTypes['ViewCardNumbersPayload'];
        /** Reveal the physical card numbers in the consent page once consent has been given by the cardholder
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        viewPhysicalCardNumbers: ModelTypes['ViewPhysicalCardNumbersPayload'];
        /** Reveal the PIN code on Swan app after his consent
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        viewPhysicalCardPin: ModelTypes['ViewPhysicalCardPinPayload'];
        /** Generate and return a presigned URL to upload a unique file for the supporting document collection
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        generateSupportingDocumentUploadUrl: ModelTypes['GenerateSupportingDocumentUploadUrlPayload'];
        /** Ask for Swan's compliance team to review given supporting document collection.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        requestSupportingDocumentCollectionReview: ModelTypes['RequestSupportingDocumentCollectionReviewPayload'];
        /** Generate an account statement */
        generateAccountStatement: ModelTypes['Statement'];
        /** Create a capital deposit case.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        createCapitalDepositCase: ModelTypes['CreateCapitalDepositCasePayload'];
        /** Generate an url allowing the upload of a document which unique identifier is specified in parameters.
    
    This mutation is restricted to an Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        generateCapitalDepositDocumentUploadUrl: ModelTypes['GenerateCapitalDepositDocumentUploadUrlPayload'];
        /** Cancels a consent. */
        cancelConsent: ModelTypes['CancelConsentPayload'];
        /** Create a multi consent, which represents a consent of several other consents,
    executed in parallel or sequentially depending on the `order` input value
    
    This mutation is restricted to a User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request. */
        createMultiConsent?: ModelTypes['CreateMultiConsentPayload'] | undefined;
        /** Grant consent with a server signature */
        grantConsentWithServerSignature: ModelTypes['GrantConsentWithServerSignaturePayload'];
        /** Updates user preferred consent notification channel.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        updateUserConsentSettings: ModelTypes['UpdateUserConsentSettingsPayload'];
        /** Allows to add a received internal direct debit mandate B2b.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must be able to initiate payments for this account.* */
        addReceivedInternalDirectDebitB2bMandate: ModelTypes['AddReceivedInternalDirectDebitB2bMandatePayload'];
        /** Allows to add a received sepa direct debit mandate B2b.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must be able to initiate payments for this account.* */
        addReceivedSepaDirectDebitB2bMandate: ModelTypes['AddReceivedSepaDirectDebitB2bMandatePayload'];
        /** Allows to enable a received mandate in the Suspended status.
    
    *For B2b received direct debit mandate, this mutation is restricted to an User access token([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must be able to initiate payments for this account.* */
        enableReceivedDirectDebitMandate: ModelTypes['EnableReceivedDirectDebitMandatePayload'];
        /** Allows to suspend a received direct debit mandate in the Enabled status.
    
    *The user must be able to initiate payments for this account.* */
        suspendReceivedDirectDebitMandate: ModelTypes['SuspendReceivedDirectDebitMandatePayload'];
        /** Allows to update a received sepa direct debit mandate B2b.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must be able to initiate payments for this account.* */
        updateReceivedSepaDirectDebitB2bMandate: ModelTypes['UpdateReceivedSepaDirectDebitB2bMandatePayload'];
        /** Allows to add an internal direct debit payment mandate. */
        addInternalDirectDebitPaymentMandate: ModelTypes['AddInternalDirectDebitPaymentMandatePayload'];
        /** Add a merchant profile to a company account holder */
        addMerchantProfile?: ModelTypes['AddMerchantProfilePayload'] | undefined;
        addSepaDirectDebitPaymentMandate?: ModelTypes['AddSepaDirectDebitPaymentMandatePayload'] | undefined;
        initiateCheckMerchantPayment?: ModelTypes['InitiateCheckMerchantPaymentPayload'] | undefined;
        /** Create a unique URL for a merchant to collect payment from a customer */
        createMerchantPaymentLink: ModelTypes['CreateMerchantPaymentLinkPayload'];
        initiateMerchantPaymentCollection?: ModelTypes['InitiateMerchantPaymentCollectionPayload'] | undefined;
        /** Request merchant payment methods for a merchant profile */
        requestMerchantPaymentMethods?: ModelTypes['RequestMerchantPaymentMethodsPayload'] | undefined;
        /** Request an update of a MerchantProfile */
        requestMerchantProfileUpdate?: ModelTypes['RequestMerchantProfileUpdatePayload'] | undefined;
        /** Cancels an UPCOMING credit transfer
    
     *The user must have an account membership for this account with the attribute `canInitiatePayments=true`.* */
        cancelTransaction: ModelTypes['CancelTransactionPayload'];
        /** Initiates a credit transfer to an other Swan account or to an IBAN
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and if necessary ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canInitiatePayments=true`.* */
        initiateCreditTransfers: ModelTypes['InitiateCreditTransfersPayload'];
        /** initiates a refund for a list of booked transaction
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and if necessary ask the user to consent to this request.*
    
    *The user must have an account membership on the accounts that are beneficiary of the transaction with the attribute `canInitiatePayments=true`.* */
        refund: ModelTypes['RefundPayload'];
        /** Add a funding source to an account
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the attribute `canManageAccountMembership=true`. */
        addDirectDebitFundingSource?: ModelTypes['AddDirectDebitFundingSourcePayload'] | undefined;
        /** Cancel a funding source */
        cancelFundingSource?: ModelTypes['CancelFundingSourcePayload'] | undefined;
        /** Cancel a standing Order
    
    The user must have an account membership to the account and the permission to initiate credit transfer */
        cancelStandingOrder: ModelTypes['CancelStandingOrderPayload'];
        /** Initiate a funding request.
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).
    The user must have an account membership for this account with the attribute `canInitiateCreditTransfer=true`. */
        initiateFundingRequest?: ModelTypes['InitiateFundingRequestPayload'] | undefined;
        /** *COMING SOON*
    Create an international transfer */
        initiateInternationalCreditTransfer?: ModelTypes['InitiateInternationalCreditTransferResponsePayload'] | undefined;
        /** Schedule a standing Order
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership to the account and the permission to initiate credit transfer */
        scheduleStandingOrder: ModelTypes['ScheduleStandingOrderPayload'];
        /** Replays the endpoint call of a previous event */
        replayWebhookEvent: ModelTypes['ReplayWebhookEventPayload'];
        /** Add a webhook subscription */
        addWebhookSubscription: ModelTypes['WebhookSubscriptionPayload'];
    };
    /** Rejection returned if the entity was not found or if the user does not have the rights to know that the account exists */
    ['NotFoundRejection']: {
        id: string;
        message: string;
    };
    /** Rejection returned when consent status couldn't change */
    ['NotReachableConsentStatusRejection']: {
        message: string;
        currentStatus?: ModelTypes['ConsentStatus'] | undefined;
        unreachableStatus?: ModelTypes['ConsentStatus'] | undefined;
    };
    /** Describes an identification level that hasn't started for the process of the current identification */
    ['NotStartedIdentificationLevelStatusInfo']: {
        /** Always set to `NotStarted` */
        status: ModelTypes['SwanIdentificationStatus'];
    };
    /** Rejection returned if the queried service doesn't support the country code */
    ['NotSupportedCountryRejection']: {
        message: string;
    };
    /** Describes an identification level that's not supported for the process of the current identification */
    ['NotSupportedIdentificationLevelStatusInfo']: {
        /** Always set to `NotSupported` */
        status: ModelTypes['SwanIdentificationStatus'];
    };
    /** Extra parameters provided by partner */
    ['OAuthRedirectParameters']: {
        /** Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. */
        state?: string | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl?: string | undefined;
    };
    ['OAuthRedirectParametersInput']: {
        /** Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. Length must be from 0 to 255 characters */
        state?: string | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined;
    };
    /** Inputs to onboard a new company account holder */
    ['OnboardCompanyAccountHolderInput']: {
        /** Account name of the company account holder.
    Length must be from 0 to 100 characters */
        accountName?: string | undefined;
        /** Name of the company. Length must be from 0 to 255 characters */
        name?: string | undefined;
        /** Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters */
        registrationNumber?: string | undefined;
        /** Type of the company (Association ...) */
        companyType?: ModelTypes['CompanyType'] | undefined;
        /** Business activity */
        businessActivity?: ModelTypes['BusinessActivity'] | undefined;
        /** Business activity description. Length must be from 0 to 1024 characters */
        businessActivityDescription?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ModelTypes['AccountCountry'] | undefined;
        /** Estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: ModelTypes['MonthlyPaymentVolume'] | undefined;
        /** The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
    
    The ultimate beneficial owner is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<ModelTypes['IndividualUltimateBeneficialOwnerInput']> | undefined;
        /** Residency address of the head office (Must be in a European country) */
        residencyAddress?: ModelTypes['ResidencyAddressInput'] | undefined;
        /** Email of the legal representative. Length must be from 0 to 255 characters */
        email?: string | undefined;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
    Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ModelTypes['OAuthRedirectParametersInput'] | undefined;
        /** VAT number */
        vatNumber?: string | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ModelTypes['AddressInformationInput'] | undefined;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: ModelTypes['TypeOfRepresentation'] | undefined;
    };
    ['OnboardCompanyAccountHolderPayload']: ModelTypes['OnboardCompanyAccountHolderSuccessPayload'] | ModelTypes['BadRequestRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ValidationRejection'];
    ['OnboardCompanyAccountHolderSuccessPayload']: {
        onboarding: ModelTypes['Onboarding'];
    };
    /** Information on the shareholder. */
    ['OnboardCompanyShareholderInput']: {
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: ModelTypes['AmountInput'];
        /** Name ("Dénomination sociale") of the shareholder. */
        name: string;
        /** Information required for the onboarding of a company shareholder. */
        onboardingInfo: ModelTypes['OnboardCompanyAccountHolderInput'];
    };
    /** Inputs to onboard a new individual account holder */
    ['OnboardIndividualAccountHolderInput']: {
        /** Account name of the individual account holder. Length must be from 0 to 255 characters */
        accountName?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ModelTypes['AccountCountry'] | undefined;
        /** Employment status of the individual account holder */
        employmentStatus?: ModelTypes['EmploymentStatus'] | undefined;
        /** Monthly income of the individual account holder */
        monthlyIncome?: ModelTypes['MonthlyIncome'] | undefined;
        /** Residency address of the individual account holder (must be in a European country) */
        residencyAddress?: ModelTypes['ResidencyAddressInput'] | undefined;
        /** Email. Length must be from 0 to 255 characters */
        email?: string | undefined;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ModelTypes['OAuthRedirectParametersInput'] | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
    };
    ['OnboardIndividualAccountHolderPayload']: ModelTypes['OnboardIndividualAccountHolderSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ValidationRejection'];
    ['OnboardIndividualAccountHolderSuccessPayload']: {
        onboarding: ModelTypes['Onboarding'];
    };
    /** Information on the shareholder. */
    ['OnboardIndividualShareholderInput']: {
        /** First name of the shareholder. */
        firstName: string;
        /** Last name of the shareholder. */
        lastName: string;
        /** Birthdate of the shareholder in the YYYY/MM/DD format. */
        birthDate: string;
        /** CCA3 code for the country of nationality of the shareholder. */
        nationality: ModelTypes['CCA3'];
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: ModelTypes['AmountInput'];
        /** Information required for the onboarding of a individual shareholder. */
        onboardingInfo: ModelTypes['OnboardIndividualAccountHolderInput'];
    };
    /** Information provided during the onboarding process of an individual or a company */
    ['Onboarding']: {
        /** Unique identifier of an onboarding */
        id: string;
        /** Account name */
        accountName?: string | undefined;
        /** Account Country */
        accountCountry: ModelTypes['AccountCountry'];
        /** Creation date */
        createdAt: ModelTypes['DateTime'];
        /** Email */
        email?: string | undefined;
        /** Finalization date */
        finalizedAt?: ModelTypes['DateTime'] | undefined;
        /** Language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
        language?: string | undefined;
        /** Information regarding the Individual or the company to onboard */
        info: ModelTypes['OnboardingAccountHolderInfo'];
        /** Account holder created at the end of the onboarding process */
        accountHolder?: ModelTypes['AccountHolder'] | undefined;
        /** Redirect the legal representative of a new account holder to this URL to start the onboarding process */
        onboardingUrl: string;
        /** Current computed state of onboarding */
        onboardingState: ModelTypes['OnboardingState'];
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl: string;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ModelTypes['OAuthRedirectParameters'] | undefined;
        /** Status (valid/invalid/finalized) and details of errors on fields */
        statusInfo: ModelTypes['OnboardingStatusInfo'];
        /** Swan TCU URL */
        tcuUrl: string;
        /** List of supporting document collection owned by the account holder. */
        supportingDocumentCollection: ModelTypes['SupportingDocumentCollection'];
        /** Creation date */
        updatedAt: ModelTypes['DateTime'];
        /** Account opened after the onboarding finalization */
        account?: ModelTypes['Account'] | undefined;
        /** List of accepted identification level for the legal representative */
        legalRepresentativeAcceptedIdentificationLevels: Array<ModelTypes['IdentificationLevel'] | undefined>;
        /** Recommended identification level for the legal representative */
        legalRepresentativeRecommendedIdentificationLevel: ModelTypes['IdentificationLevel'];
    };
    /** The onboarding could be for an Individual or a company */
    ['OnboardingAccountHolderInfo']: ModelTypes['OnboardingCompanyAccountHolderInfo'] | ModelTypes['OnboardingIndividualAccountHolderInfo'];
    /** Company Account Holder Information */
    ['OnboardingCompanyAccountHolderInfo']: {
        /** Account holder type (always Company for type OnboardingCompanyAccountHolderInfo) */
        type: ModelTypes['AccountHolderType'];
        /** name of the company */
        name?: string | undefined;
        /** registration number of the company (SIRET, ...) */
        registrationNumber?: string | undefined;
        /** legal form of the company (SAS, SCI, SASU, ...) */
        companyType?: ModelTypes['CompanyType'] | undefined;
        /** business activity */
        businessActivity?: ModelTypes['BusinessActivity'] | undefined;
        /** business activity description
    This must be 1024 characters long maximum. */
        businessActivityDescription?: string | undefined;
        /** estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: ModelTypes['MonthlyPaymentVolume'] | undefined;
        /** The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
    
    The ultimate beneficiary is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<ModelTypes['IndividualUltimateBeneficialOwner']> | undefined;
        /** residency address of the head office (Must be in a European country) */
        residencyAddress?: ModelTypes['AddressInfo'] | undefined;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined;
        /** Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT */
        vatNumber?: string | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ModelTypes['AddressInformation'] | undefined;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: ModelTypes['TypeOfRepresentation'] | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['OnboardingConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** OnboardingEdge list */
        edges: Array<ModelTypes['OnboardingEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['OnboardingEdge']: {
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor: string;
        /** The Onboarding */
        node: ModelTypes['Onboarding'];
    };
    /** Filters that can be applied when listing onboardings */
    ['OnboardingFiltersInput']: {
        /** Type/Types we want to filter on */
        types?: Array<ModelTypes['AccountHolderType']> | undefined;
        /** Email we want to filter on */
        email?: string | undefined;
        /** Searches company name, first name, last name */
        search?: string | undefined;
        /** Status we want to filter on */
        status?: Array<ModelTypes['OnboardingStatus']> | undefined;
    };
    /** StatusInfo when onboarding has been finalized */
    ['OnboardingFinalizedStatusInfo']: {
        status: ModelTypes['OnboardingStatus'];
    };
    /** Individual Account Holder Information */
    ['OnboardingIndividualAccountHolderInfo']: {
        /** Account holder type (always Individual for type OnboardingIndividualAccountHolderInfo) */
        type: ModelTypes['AccountHolderType'];
        /** employment status of the individual account holder */
        employmentStatus?: ModelTypes['EmploymentStatus'] | undefined;
        /** monthly income of the individual account holder */
        monthlyIncome?: ModelTypes['MonthlyIncome'] | undefined;
        /** residency address of the individual account holder (must be in a European country) */
        residencyAddress?: ModelTypes['AddressInfo'] | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
    };
    ['OnboardingInfo']: {
        /** Unique identifier of an onboarding */
        id: string;
        /** Account name */
        accountName?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ModelTypes['AccountCountry'] | undefined;
        /** email */
        email?: string | undefined;
        /** language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
        language?: string | undefined;
        /** Information regarding the Individual or the company to onboard */
        info: ModelTypes['OnboardingAccountHolderInfo'];
        /** Redirect the legal representative of a new account holder to this URL to start the onboarding process */
        onboardingUrl: string;
        /** Current computed state of onboarding */
        onboardingState?: ModelTypes['OnboardingState'] | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl: string;
        /** Project infos you set in the dashboard */
        projectInfo?: ModelTypes['ProjectInfo'] | undefined;
        /** Verification Flow */
        verificationFlow: ModelTypes['VerificationFlow'];
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: ModelTypes['OAuthRedirectParameters'] | undefined;
        /** Status (valid/invalid/finalized) and details of errors on fields */
        statusInfo: ModelTypes['OnboardingStatusInfo'];
        /** Supporting document collection related to onboarding. */
        supportingDocumentCollection: ModelTypes['SupportingDocumentCollection'];
        /** List of accepted identification level for the legal representative */
        legalRepresentativeAcceptedIdentificationLevels: Array<ModelTypes['IdentificationLevel'] | undefined>;
        /** Recommended identification level for the legal representative */
        legalRepresentativeRecommendedIdentificationLevel: ModelTypes['IdentificationLevel'];
        /** Swan TCU URL */
        tcuUrl: string;
    };
    /** StatusInfo when onboarding has still at least one incorrect field */
    ['OnboardingInvalidStatusInfo']: {
        status: ModelTypes['OnboardingStatus'];
        errors: Array<ModelTypes['ValidationError']>;
    };
    /** Rejection returned if an onboarding is not completed */
    ['OnboardingNotCompletedRejection']: {
        message: string;
        /** @deprecated(reason: "use `onboarding.id` instead") */
        onboardingId: string;
        onboarding: ModelTypes['Onboarding'];
    };
    ['OnboardingOrderByFieldInput']: OnboardingOrderByFieldInput;
    /** Order that can be applied when listing onboardings */
    ['OnboardingOrderByInput']: {
        field?: ModelTypes['OnboardingOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['OnboardingState']: OnboardingState;
    ['OnboardingStatus']: OnboardingStatus;
    /** Object containing details about onboarding status (valid/invalid and why it is invalid/already finalized) */
    ['OnboardingStatusInfo']: ModelTypes['OnboardingFinalizedStatusInfo'] | ModelTypes['OnboardingInvalidStatusInfo'] | ModelTypes['OnboardingValidStatusInfo'];
    /** StatusInfo when onboarding has all onboarding fields are correctly filled */
    ['OnboardingValidStatusInfo']: {
        status: ModelTypes['OnboardingStatus'];
    };
    ['OrderByDirection']: OrderByDirection;
    /** Implements PageInfo from the Relay Connections Specification - information about a page in the pagination mechanism */
    ['PageInfo']: {
        /** Indicates whether more edges exist following this page */
        hasNextPage?: boolean | undefined;
        /** Indicates whether more edges exist preceding this page */
        hasPreviousPage?: boolean | undefined;
        /** Opaque identifier pointing to the first node of the page */
        startCursor?: string | undefined;
        /** Opaque identifier pointing to the last node of the page */
        endCursor?: string | undefined;
    };
    /** Input version */
    ['PartnerCloseAccountReasonInput']: {
        type: ModelTypes['PartnerCloseAccountReasonType'];
        message?: string | undefined;
    };
    ['PartnerCloseAccountReasonType']: PartnerCloseAccountReasonType;
    /** Partnership Status Accepted */
    ['PartnershipAcceptedStatusInfo']: {
        /** Partnership status (always Accepted for type PartnershipAcceptedStatusInfo) */
        status: ModelTypes['PartnershipStatus'];
        /** Accepted date of the partnership for this account */
        acceptedDate: ModelTypes['DateTime'];
    };
    /** Partnership Status canceled */
    ['PartnershipCanceledStatusInfo']: {
        /** Partnership status (always Canceled for type PartnershipCanceledStatusInfo) */
        status: ModelTypes['PartnershipStatus'];
        /** Accepted date of the partnership for this account */
        acceptedDate: ModelTypes['DateTime'];
        /** Canceled date of the partnership for this account */
        canceledDate: ModelTypes['DateTime'];
        /** Reason of the cancelation */
        reason: string;
    };
    /** Partnership Status currently cancelling */
    ['PartnershipCancelingStatusInfo']: {
        /** Partnership status (always Canceling for type PartnershipCancelingStatusInfo) */
        status: ModelTypes['PartnershipStatus'];
        /** Accepted date of the partnership for this account */
        acceptedDate: ModelTypes['DateTime'];
        /** Canceled date of the partnership for this account */
        canceledAfter: ModelTypes['DateTime'];
    };
    ['PartnershipStatus']: PartnershipStatus;
    /** Partnership Status information */
    ['PartnershipStatusInfo']: ModelTypes['PartnershipAcceptedStatusInfo'] | ModelTypes['PartnershipCanceledStatusInfo'] | ModelTypes['PartnershipCancelingStatusInfo'];
    /** The document corresponding to a passport */
    ['PassportDocument']: {
        /** Unique identifier of the passport document */
        id: string;
        /** The type of the document */
        type: ModelTypes['DocumentType'];
        /** The date at which the passport was issued */
        issueDate?: ModelTypes['Date'] | undefined;
        /** The date at which the passport expires */
        expiryDate?: ModelTypes['Date'] | undefined;
        /** Machine-readable zone code of the passport */
        mrz?: string | undefined;
        /** Number of the passport */
        number?: string | undefined;
        /** List of the associated files */
        files: Array<ModelTypes['PassportDocumentFile']>;
    };
    /** The file associated to the passport document */
    ['PassportDocumentFile']: {
        /** The file's temporary download url */
        downloadUrl: string;
        /** From which side the passport's picture was taken */
        side: ModelTypes['DocumentFileSide'];
    };
    /** A Payment represents a set of transactions linked to the same payment act.
  
  This payment act can be initiated:
  - either from a user
  - either from a merchant
  - either from you
  - either from Swan */
    ['Payment']: {
        /** unique identifier of a payment */
        id: string;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** status information */
        statusInfo: ModelTypes['PaymentStatusInfo'];
        /** list of transactions associated to this payment
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: ModelTypes['TransactionConnection'] | undefined;
        /** standing order that has initiated this payment */
        standingOrder?: ModelTypes['StandingOrder'] | undefined;
    };
    ['PaymentAccountType']: PaymentAccountType;
    /** Please see the Connection interface */
    ['PaymentConnection']: {
        pageInfo: ModelTypes['PageInfo'];
        edges: Array<ModelTypes['PaymentEdge']>;
        totalCount: number;
    };
    /** Payment status consent pending */
    ['PaymentConsentPending']: {
        /** status of the payment */
        status: ModelTypes['PaymentStatus'];
        /** The consent required to initiate this payment */
        consent: ModelTypes['Consent'];
    };
    ['PaymentDirectDebitMandate']: ModelTypes['InternalPaymentDirectDebitMandate'] | ModelTypes['SEPAPaymentDirectDebitMandate'];
    /** Please see the Connection interface */
    ['PaymentEdge']: {
        node: ModelTypes['Payment'];
        cursor: string;
    };
    /** Filters that can be applied when listing payments */
    ['PaymentFiltersInput']: {
        status?: Array<ModelTypes['PaymentStatus']> | undefined;
    };
    /** Payment status initiated */
    ['PaymentInitiated']: {
        /** status of the payment */
        status: ModelTypes['PaymentStatus'];
    };
    ['PaymentLevel']: PaymentLevel;
    ['PaymentLinkSequenceType']: PaymentLinkSequenceType;
    ['PaymentMandate']: ModelTypes['InternalPaymentDirectDebitMandate'] | ModelTypes['SEPAPaymentDirectDebitMandate'];
    ['PaymentMandateCanceledReason']: PaymentMandateCanceledReason;
    /** Payment Mandate Canceled status information */
    ['PaymentMandateCanceledStatusInfo']: {
        /** Payment Mandate status (always Canceled for type PaymentMandateCanceledStatusInfo). */
        status: ModelTypes['PaymentMandateStatus'];
        /** Reason behind the Payment Mandate Canceled status */
        reason: ModelTypes['PaymentMandateCanceledReason'];
        /** Date of Cancellation of the mandate. */
        canceledAt: ModelTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['PaymentMandateConnection']: {
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** PaymentMandateEdge list */
        edges: Array<ModelTypes['PaymentMandateEdge']>;
    };
    /** Payment Mandate Consent Pending status information */
    ['PaymentMandateConsentPendingStatusInfo']: {
        /** Payment Mandate status (always Enabled for type PaymentMandateEnableedStatusInfo). */
        status: ModelTypes['PaymentMandateStatus'];
        /** Consent information required to enable the concerned Payment Mandate */
        consent: ModelTypes['Consent'];
    };
    ['PaymentMandateCreditor']: ModelTypes['InternalPaymentMandateCreditor'] | ModelTypes['SEPAPaymentMandateCreditor'];
    ['PaymentMandateDebtor']: ModelTypes['InternalPaymentMandateDebtor'] | ModelTypes['SEPAPaymentMandateDebtor'];
    /** Implements the Relay Edge interface */
    ['PaymentMandateEdge']: {
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor: string;
        /** The payment mandate */
        node: ModelTypes['PaymentMandate'];
    };
    /** Payment Mandate Enabled status information */
    ['PaymentMandateEnabledStatusInfo']: {
        /** Payment Mandate status (always Enabled for type PaymentMandateEnabledStatusInfo). */
        status: ModelTypes['PaymentMandateStatus'];
    };
    /** Filter that can be passed to get the payment mandate in a specific data range */
    ['PaymentMandateFiltersInput']: {
        /** To filter on status values */
        status?: Array<ModelTypes['PaymentMandateStatus']> | undefined;
        /** To filter on scheme values */
        scheme?: Array<ModelTypes['PaymentMandateScheme']> | undefined;
    };
    /** Error returned if the payment mandate was not found */
    ['PaymentMandateMandateNotFoundRejection']: {
        id: string;
        message: string;
    };
    ['PaymentMandateOrderByFieldInput']: PaymentMandateOrderByFieldInput;
    /** Order that can be applied when listing payment mandate results */
    ['PaymentMandateOrderByInput']: {
        field?: ModelTypes['PaymentMandateOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    /** Rejection returned if the payment mandate reference is already used for the same creditor */
    ['PaymentMandateReferenceAlreadyUsedRejection']: {
        message: string;
    };
    /** Payment Mandate Rejected status information */
    ['PaymentMandateRejectedStatusInfo']: {
        /** Payment Mandate status (always Rejected for type PaymentMandateSuspendedStatusInfo). */
        status: ModelTypes['PaymentMandateStatus'];
    };
    ['PaymentMandateScheme']: PaymentMandateScheme;
    ['PaymentMandateSequence']: PaymentMandateSequence;
    ['PaymentMandateStatus']: PaymentMandateStatus;
    /** Payment Mandate status information */
    ['PaymentMandateStatusInfo']: ModelTypes['PaymentMandateCanceledStatusInfo'] | ModelTypes['PaymentMandateConsentPendingStatusInfo'] | ModelTypes['PaymentMandateEnabledStatusInfo'] | ModelTypes['PaymentMandateRejectedStatusInfo'];
    /** Rejection returned when a payment method is not compatible for the requested mutation */
    ['PaymentMethodNotCompatibleRejection']: {
        message: string;
    };
    ['PaymentOrderByFieldInput']: PaymentOrderByFieldInput;
    /** Order that can be applied when listing payments */
    ['PaymentOrderByInput']: {
        field?: ModelTypes['PaymentOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['PaymentProduct']: PaymentProduct;
    /** Payment status rejected */
    ['PaymentRejected']: {
        /** status of the payment */
        status: ModelTypes['PaymentStatus'];
        /** rejected reason */
        reason: string;
    };
    ['PaymentStatus']: PaymentStatus;
    /** Payment Status Information */
    ['PaymentStatusInfo']: ModelTypes['PaymentConsentPending'] | ModelTypes['PaymentInitiated'] | ModelTypes['PaymentRejected'];
    /** Custom information for a PDF statement */
    ['PdfStatement']: {
        /** statement type */
        type?: ModelTypes['StatementType'] | undefined;
        /** temporary public url on which the file can be accessed */
        url?: string | undefined;
        /** date at which the link will not be useable anymore */
        expiresAt?: ModelTypes['DateTime'] | undefined;
    };
    /** Pending Consent when the account membership will be updated */
    ['PendingConsentAccountMembershipUpdate']: {
        /** New account membership version waiting for consent */
        accountMembershipId: ModelTypes['AccountMembership'];
        /** The consent required to update the account membership */
        consent: ModelTypes['Consent'];
    };
    /** Pending Digital Card used for ApplePay or GooglePay */
    ['PendingDigitalCard']: {
        /** Unique identifier of a digital card */
        id: string;
        /** The type of digitalization that created this digital card. */
        type: ModelTypes['DigitalizationType'];
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider: ModelTypes['WalletProvider'];
        /** Digital Card status information
    
    In this type the status will be either ConsentPending or Pending */
        statusInfo: ModelTypes['PendingDigitalCardStatusInfo'];
        /** Data to provide to the wallet during InApp Provisioning
    
    Signature Data is mandatory for ApplePay
    
    This data is only available for a digital card in
    - status: Pending
    - type: InApp */
        inAppProvisioningData?: ModelTypes['InAppProvisioningData'] | undefined;
    };
    ['PendingDigitalCardStatus']: PendingDigitalCardStatus;
    /** Pending Digital Card Status Information */
    ['PendingDigitalCardStatusInfo']: ModelTypes['DigitalCardConsentPendingStatusInfo'] | ModelTypes['DigitalCardDeclinedStatusInfo'] | ModelTypes['DigitalCardPendingStatusInfo'];
    /** Funding Source Pending status information */
    ['PendingFundingSourceStatusInfo']: {
        /** Funding Source Pending status */
        status: ModelTypes['FundingSourceStatus'];
    };
    /** Describes an identification level that is pending for the process of the current identification, requiring an operation not related to the end-user to progress */
    ['PendingIdentificationLevelStatusInfo']: {
        /** Always set to `Pending` */
        status: ModelTypes['SwanIdentificationStatus'];
    };
    /** PendingMerchantPaymentMethodStatusInfo */
    ['PendingMerchantPaymentMethodStatusInfo']: {
        status: ModelTypes['MerchantPaymentMethodStatus'];
    };
    /** PendingReviewMerchantProfileStatusInfo */
    ['PendingReviewMerchantProfileStatusInfo']: {
        status: ModelTypes['MerchantProfileStatus'];
    };
    /** Pending Verification Information */
    ['PendingReviewStatusInfo']: {
        /** Account verification status (PendingReview) */
        status: ModelTypes['AccountVerificationStatus'];
    };
    /** Pending transaction status information */
    ['PendingTransactionStatusInfo']: {
        /** status of the transaction */
        status: ModelTypes['TransactionStatus'];
        /** The date when the pending amount of this transaction is released on the available balance of this account if not booked */
        pendingEndDate?: ModelTypes['DateTime'] | undefined;
    };
    /** Pending Verification Information */
    ['PendingVerificationStatusInfo']: {
        /** Account verification status (PendingVerification) */
        status: ModelTypes['AccountVerificationStatus'];
    };
    ['PermissionCannotBeGrantedRejection']: {
        message: string;
    };
    /** E.164 standard format phone number
  
  Examples
  +551155256325
  +44207183875 */
    ['PhoneNumber']: any;
    /** Physical Card */
    ['PhysicalCard']: {
        /** Physical Card status information */
        statusInfo: ModelTypes['PhysicalCardStatusInfo'];
        /** Physical Card expiration date  with MM/YY string format */
        expiryDate?: string | undefined;
        /** Unique identifier present on physical card, such identifier is null if the status is ToActivate or Canceled. This identifier is updated when a renewed card is activated */
        identifier?: string | undefined;
        /** Offline Spending limit defined by Swan */
        offlineSpendingLimit: ModelTypes['Amount'];
        /** Masked Card Number */
        cardMaskedNumber: string;
        /** Custom Options */
        customOptions: ModelTypes['PhysicalCardCustomOptions'];
        /** every previous Physical Card information */
        previousPhysicalCards: Array<ModelTypes['BasicPhysicalCardInfo']>;
    };
    /** Physical Card Activated Status Information */
    ['PhysicalCardActivatedStatusInfo']: {
        /** Physical Card status (always Activated for type PhysicalCardEnabledStatusInfo). */
        status: ModelTypes['PhysicalCardStatus'];
    };
    /** Physical Card Canceled Status Information */
    ['PhysicalCardCanceledStatusInfo']: {
        /** Physical Card status (always Canceled for type PhysicalCardCanceledStatusInfo). */
        status: ModelTypes['PhysicalCardStatus'];
        /** Reason why the card is canceled. */
        reason: string;
    };
    /** Physical Card Canceling Status Information */
    ['PhysicalCardCancelingStatusInfo']: {
        /** Physical Card status (always Canceling for type PhysicalCardCancelingStatusInfo). */
        status: ModelTypes['PhysicalCardStatus'];
        /** Reason why the card is canceled. */
        reason: string;
    };
    ['PhysicalCardConfigInput']: {
        /** Address to deliver the physical card */
        deliveryAddress: ModelTypes['CompleteAddressInput'];
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: ModelTypes['PhysicalCardCustomOptionsInput'] | undefined;
        /** `true` if the user must choose their PIN */
        choosePin?: boolean | undefined;
    };
    /** when the user has to authorize production of the physical card */
    ['PhysicalCardConsentPendingStatusInfo']: {
        /** Physical Card status (always ConsentPending for type PhysicalCardConsentPendingStatusInfo) */
        status: ModelTypes['PhysicalCardStatus'];
        /** The consent required to authorize production of the physical card */
        consent: ModelTypes['Consent'];
    };
    /** Custom options for physical card. */
    ['PhysicalCardCustomOptions']: {
        /** Additional line embossed on the card. */
        additionalPrintedLine?: string | undefined;
    };
    ['PhysicalCardCustomOptionsForGroupDeliveryInput']: {
        /** Additional line to be embossed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined;
    };
    ['PhysicalCardCustomOptionsForPrintInput']: {
        /** Additional line to be printed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined;
    };
    ['PhysicalCardCustomOptionsInput']: {
        /** Additional line to be embossed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined;
    };
    /** Rejection returned when the Physical Card does not exist */
    ['PhysicalCardNotFoundRejection']: {
        message: string;
        identifier: string;
    };
    /** when the physical card is in the process of being ready to use */
    ['PhysicalCardProcessingStatusInfo']: {
        /** Physical card status (always Processing for type PhysicalCardProcessingStatusInfo) */
        status: ModelTypes['PhysicalCardStatus'];
    };
    /** Physical Card Renewed Status Information */
    ['PhysicalCardRenewedStatusInfo']: {
        /** Physical Card status (always Renewed for type PhysicalCardRenewedStatusInfo). */
        status: ModelTypes['PhysicalCardStatus'];
        /** address to deliver the physical card */
        address: ModelTypes['Address'];
        /** Estimated delivery date */
        estimatedDeliveryDate?: ModelTypes['DateTime'] | undefined;
        /** Shipping tracking number */
        trackingNumber?: string | undefined;
        /** Name of the shipping provider (Ex: LaPoste, DHL ...) */
        shippingProvider?: string | undefined;
        /** `true` if PIN Code is available. */
        isPINReady: boolean;
        /** New physical Card info */
        newPhysicalCard: ModelTypes['BasicPhysicalCardInfo'];
    };
    ['PhysicalCardStatus']: PhysicalCardStatus;
    /** Physical Card Status Information */
    ['PhysicalCardStatusInfo']: ModelTypes['PhysicalCardActivatedStatusInfo'] | ModelTypes['PhysicalCardCanceledStatusInfo'] | ModelTypes['PhysicalCardCancelingStatusInfo'] | ModelTypes['PhysicalCardConsentPendingStatusInfo'] | ModelTypes['PhysicalCardProcessingStatusInfo'] | ModelTypes['PhysicalCardRenewedStatusInfo'] | ModelTypes['PhysicalCardSuspendedStatusInfo'] | ModelTypes['PhysicalCardToActivateStatusInfo'] | ModelTypes['PhysicalCardToRenewStatusInfo'];
    /** Physical Card Suspended Status Information */
    ['PhysicalCardSuspendedStatusInfo']: {
        /** Physical Card status (always Suspended for type PhysicalCardSuspendedStatusInfo). */
        status: ModelTypes['PhysicalCardStatus'];
        /** Reason why the card is suspended. */
        reason: string;
    };
    /** Physical Card To Activate Status Information */
    ['PhysicalCardToActivateStatusInfo']: {
        /** Physical Card status (always ToActivate for type PhysicalCardToActivateStatusInfo). */
        status: ModelTypes['PhysicalCardStatus'];
        /** address to deliver the physical card */
        address: ModelTypes['Address'];
        /** Estimated delivery date */
        estimatedDeliveryDate?: ModelTypes['DateTime'] | undefined;
        /** Shipping tracking number */
        trackingNumber?: string | undefined;
        /** Name of the shipping provider (Ex: LaPoste, DHL ...) */
        shippingProvider?: string | undefined;
        /** `true` if PIN Code is available. */
        isPINReady: boolean;
    };
    /** when the physical card is in the process of being renewed */
    ['PhysicalCardToRenewStatusInfo']: {
        /** Physical card status (always ToRenew for type PhysicalCardToRenewStatusInfo) */
        status: ModelTypes['PhysicalCardStatus'];
        /** registered address to deliver the new physical card */
        address: ModelTypes['Address'];
    };
    /** Rejection returned when the Physical Card is not the expected status */
    ['PhysicalCardWrongStatusRejection']: {
        message: string;
        identifier: string;
        currentStatus: ModelTypes['PhysicalCardStatus'];
        expectedStatus: ModelTypes['PhysicalCardStatus'];
    };
    /** 6 digits numeric passcode */
    ['PIN']: any;
    ['PINNotReadyRejection']: {
        physicalCardIdentifier: string;
        message: string;
    };
    ['PreferredNotificationChannel']: PreferredNotificationChannel;
    ['PreProvisioningSUVCardSettings']: {
        preProvisioningSUVCards: boolean;
        preProvisioningSUVNumberOfCards: number;
        ownerProvisioningSUVCards?: string | undefined;
        preProvisioningSUVCardsAvailablePercentage: number;
    };
    /** Inputs to print a physical card */
    ['PrintPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Address to deliver the physical card */
        address: ModelTypes['CompleteAddressInput'];
        /** `true` if the user must choose their PIN Code (will be deprecated/removed) */
        choosePINCode: boolean;
        /** `true` if the user must choose their PIN */
        choosePin?: boolean | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: ModelTypes['PhysicalCardCustomOptionsForPrintInput'] | undefined;
    };
    ['PrintPhysicalCardPayload']: ModelTypes['PrintPhysicalCardSuccessPayload'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['AlreadyValidPhysicalCardRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['BadRequestRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['CardProductNotApplicableToPhysicalCardsRejection'] | ModelTypes['CardProductDisabledRejection'] | ModelTypes['MissingMandatoryFieldRejection'] | ModelTypes['ValidationRejection'];
    ['PrintPhysicalCardSuccessPayload']: {
        /** The physicalCard created */
        physicalCard: ModelTypes['PhysicalCard'];
    };
    ['ProductType']: ProductType;
    ['ProjectCardDesigns']: {
        /** Unique identifier of a project */
        id: string;
        /** Visual Id from the issuing card processor (Monext) */
        issuingProcessorVisualId?: string | undefined;
        /** Specific card product for companies */
        specificCardProductCodeForCompanies?: string | undefined;
        /** Project name */
        name?: string | undefined;
        /** Project card product designs */
        cardDesigns: Array<ModelTypes['CardProductDesign']>;
        /** Project's pre provisioning suv card settings */
        preProvisioningSUVCardSettings?: ModelTypes['PreProvisioningSUVCardSettings'] | undefined;
    };
    ['ProjectCardSettings']: {
        /** Unique identifier of a project */
        id: string;
        /** Visual Id from the issuing card processor (Monext) */
        issuingProcessorVisualId?: string | undefined;
        /** Specific card product for companies */
        specificCardProductCodeForCompanies?: string | undefined;
        /** Project name */
        name?: string | undefined;
        /** Project's card settings */
        cardSettings: Array<ModelTypes['CardSettings']>;
        /** Project's pre provisioning suv card settings */
        preProvisioningSUVCardSettings?: ModelTypes['PreProvisioningSUVCardSettings'] | undefined;
    };
    ['ProjectCardSettingsBackgroundType']: ProjectCardSettingsBackgroundType;
    ['ProjectCardStatus']: ProjectCardStatus;
    ['ProjectForbiddenRejection']: {
        message: string;
    };
    /** Rejection returned when the Project Funding has been exceeded */
    ['ProjectFundingLimitExceededRejection']: {
        message: string;
    };
    /** Public information of a `Project` */
    ['ProjectInfo']: {
        /** The card products associated with this project. */
        cardProducts?: Array<ModelTypes['CardProduct']> | undefined;
        /** the currently active card settings */
        activeCardSettings?: ModelTypes['CardSettings'] | undefined;
        /** Unique identifier of the project */
        id: string;
        B2BMembershipIDVerification?: boolean | undefined;
        supportingDocumentSettings?: ModelTypes['SupportingDocumentSettings'] | undefined;
        /** Your project name displayed in white label interfaces and in the terms and conditions */
        name: string;
        /** The type of your project */
        type: ModelTypes['ProjectType'];
        /** URL of your logo */
        logoUri?: string | undefined;
        /** Your accent color, used in white label interfaces. Most of the time for call to actions */
        accentColor?: string | undefined;
        /** Your custom subdomain used in consents */
        customConsentSubdomain?: string | undefined;
        /** Your OAuth client id */
        oAuthClientId?: string | undefined;
        /** URL to your Terms and Conditions of Use document depending on the provided language */
        tcuDocumentUri: string;
        /** Unique id of your current Terms and Conditions of Use */
        tcuDocumentId: string;
        /** Web banking settings */
        webBankingSettings?: ModelTypes['WebBankingSettings'] | undefined;
        /** Project status */
        status: ModelTypes['ProjectStatus'];
        /** Flag that determines if desktop authentication is enabled for this project */
        allowsDesktopAuthentication: boolean;
    };
    /** Rejection returned when the Project Instant Funding limit has been exceeded */
    ['ProjectInstantFundingLimitExceededRejection']: {
        message: string;
    };
    ['ProjectInvalidStatusRejection']: {
        message: string;
    };
    ['ProjectNotFound']: {
        message: string;
    };
    /** Rejection returned when the project is not found */
    ['ProjectNotFoundRejection']: {
        message: string;
    };
    ['ProjectSettingsForbiddenError']: {
        message: string;
    };
    ['ProjectSettingsNotFound']: {
        message: string;
    };
    ['ProjectSettingsStatusNotReachable']: {
        message: string;
    };
    ['ProjectStatus']: ProjectStatus;
    ['ProjectType']: ProjectType;
    /** Rejection returned when the public onboarding is disabled */
    ['PublicOnboardingDisabledRejection']: {
        message: string;
    };
    ['Query']: {
        /** Returns a request for funding limit settings change from its id. */
        fundingLimitSettingsChangeRequest?: ModelTypes['FundingLimitSettingsChangeRequest'] | undefined;
        /** Allows to check iban validation. It also returns its bank and reachability information */
        ibanValidation?: ModelTypes['IbanValidationResult'] | undefined;
        /** Returns an account holder from its id. */
        accountHolder?: ModelTypes['AccountHolder'] | undefined;
        /** Returns the list of account holders.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *For a Project access token, this is all the account holders of the project and for an User access token, these are the holders of the accounts of which the user has an account membership.* */
        accountHolders: ModelTypes['AccountHolderConnection'];
        /** Returns an account membership from its id. */
        accountMembership?: ModelTypes['AccountMembership'] | undefined;
        /** The list of account memberships
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        accountMemberships: ModelTypes['AccountMembershipConnection'];
        /** Returns an account from its id. */
        account?: ModelTypes['Account'] | undefined;
        /** Returns the list of accounts.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *For a Project access token, this is all the accounts of the project and for an User access token, these are the accounts of which the user has an account membership.* */
        accounts: ModelTypes['AccountConnection'];
        /** Allows to verify the consistency between a beneficiary name and an IBAN. */
        beneficiaryVerification?: ModelTypes['BeneficiaryVerificationResult'] | undefined;
        /** Returns a card from its id. */
        card?: ModelTypes['Card'] | undefined;
        /** Returns the list of cards.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *For a Project access token, this is all the cards of the project and for an User access token, these are the cards owned by the user whom have an account membership.* */
        cards: ModelTypes['CardConnection'];
        /** Returns an onboarding from its id.
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        onboarding: ModelTypes['Onboarding'];
        /** Returns the list of onboardings.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        onboardings: ModelTypes['OnboardingConnection'];
        /** Returns a supporting document collection from its id. */
        supportingDocumentCollection?: ModelTypes['SupportingDocumentCollection'] | undefined;
        /** Returns an account statement by id */
        accountStatement: ModelTypes['Statement'];
        /** Returns a payment from its id. */
        payment: ModelTypes['Payment'];
        /** List of payments.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    *For a Project access token, this is all the payments of the project and for an User access token, these are the payments initiated by the user* */
        payments: ModelTypes['PaymentConnection'];
        /** Returns a transaction from its id.
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        transaction: ModelTypes['Transaction'];
        /** List of transactions of a project.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    *For a Project access token, this is all the transactions of the project (only available with project access token)* */
        transactions: ModelTypes['TransactionConnection'];
        accountInvoice?: ModelTypes['Invoice'] | undefined;
        /** Return the capital deposit case for the provided id. */
        capitalDepositCase?: ModelTypes['CapitalDepositCase'] | undefined;
        /** Returns the list of capital deposit cases.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        capitalDepositCases: ModelTypes['CapitalDepositCaseConnection'];
        /** Return the CapitalDepositDocument for the provided id. */
        capitalDepositDocument?: ModelTypes['CapitalDepositDocument'] | undefined;
        /** Return the Shareholder for the provided id. */
        shareholder?: ModelTypes['Shareholder'] | undefined;
        /** Returns the project infos you set in the dashboard. */
        projectInfo: ModelTypes['ProjectInfo'];
        /** Returns a consent by its id. */
        consent: ModelTypes['Consent'];
        /** Return the list of consents
    
    For a User access token : return the list of consents for the signed-in user
    For a Project access token : return the list of consents for the project. This list can be filtered by userId
    
    *([Learn more on authentication](https://docs.swan.io/api/authentication))* */
        consents: ModelTypes['ConsentConnection'];
        /** Returns a User
    
    For a Project access token : it requires a user id and returns the user for the given id
    For a User access token : returns the signed-in user and all of their data at Swan
    
    *([Learn more on authentication](https://docs.swan.io/api/authentication))* */
        user?: ModelTypes['User'] | undefined;
        /** Returns the list of user that joined the project
    The search field allows to search in : id, phonNumber, firstName, allFirstNames, lastName
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        users: ModelTypes['UserConnection'];
        /** Returns a received direct debit mandate from its id. */
        receivedDirectDebitMandate?: ModelTypes['ReceivedDirectDebitMandate'] | undefined;
        /** Returns a merchant profile by id. */
        merchantProfile?: ModelTypes['MerchantProfile'] | undefined;
        /** Returns funding source by id. */
        fundingSource?: ModelTypes['FundingSource'] | undefined;
        /** Returns an international beneficiary dynamic forms. */
        internationalBeneficiaryDynamicForms?: ModelTypes['InternationalBeneficiaryDynamicForms'] | undefined;
        /** Returns an international credit transfer dynamic form. */
        internationalCreditTransferTransactionDetailsDynamicForm?: ModelTypes['InternationalCreditTransferDynamicForm'] | undefined;
        /** Request an international credit transfer quote. */
        internationalCreditTransferQuote?: ModelTypes['InternationalCreditTransferQuote'] | undefined;
        /** Returns standing order from its id. */
        standingOrder?: ModelTypes['StandingOrder'] | undefined;
        /** A single webhook eventLog, queried by its id */
        webhookEventLog?: ModelTypes['WebhookEventLog'] | undefined;
    };
    ['RadioField']: {
        key: string;
        name: string;
        refreshDynamicFieldsOnChange: boolean;
        required: boolean;
        allowedValues: Array<ModelTypes['AllowedValue']>;
    };
    /** Information that can be used to determine where the iban can be used */
    ['Reachability']: {
        /** Can be used for instant transfer over SEPA */
        sepaCreditTransferInst: boolean;
        /** Can be used for direct debit over SEPA */
        sepaDirectDebitCore: boolean;
        /** Can be used for B2B direct debit over SEPA */
        sepaDirectDebitB2b: boolean;
        /** Can be used for transfer over SEPA (can be used in initiateCreditTransfer mutation) */
        sepaCreditTransfer: boolean;
    };
    /** Define a reason with a message */
    ['Reason']: ModelTypes['CloseAccountReason'] | ModelTypes['SuspendAccountReason'];
    /** Input version */
    ['ReasonInput']: {
        message?: string | undefined;
    };
    /** Interface for Received Direct Debit Mandate */
    ['ReceivedDirectDebitMandate']: ModelTypes['InternalReceivedDirectDebitMandate'] | ModelTypes['SEPAReceivedDirectDebitMandate'];
    /** Rejection returned if the received direct debit mandate already exist */
    ['ReceivedDirectDebitMandateAlreadyExistRejection']: {
        id: string;
        message: string;
    };
    /** Received direct debit mandate is canceled and therefore can't be enabled/suspended or updated */
    ['ReceivedDirectDebitMandateCanceledRejection']: {
        id: string;
        message: string;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ReceivedDirectDebitMandateConnection']: {
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** ReceivedDirectDebitMandateEdge list */
        edges: Array<ModelTypes['ReceivedDirectDebitMandateEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['ReceivedDirectDebitMandateEdge']: {
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor: string;
        /** The received direct debit mandate */
        node: ModelTypes['ReceivedDirectDebitMandate'];
    };
    /** Rejection returned if the received direct debit mandate is not a B2b mandate */
    ['ReceivedDirectDebitMandateNotB2bRejection']: {
        id: string;
        message: string;
    };
    /** Error returned if the received direct debit mandate was not found or if the user does not have the rights to receive information abo
  ut the existence of the received direct debit mandate */
    ['ReceivedDirectDebitMandateNotFoundRejection']: {
        id: string;
        message: string;
    };
    ['ReceivedDirectDebitMandateScheme']: ReceivedDirectDebitMandateScheme;
    ['ReceivedDirectDebitMandateStatus']: ReceivedDirectDebitMandateStatus;
    /** Received Direct Debit Mandate status information */
    ['ReceivedDirectDebitMandateStatusInfo']: ModelTypes['ReceivedDirectDebitMandateStatusInfoCanceled'] | ModelTypes['ReceivedDirectDebitMandateStatusInfoConsentInitiationPending'] | ModelTypes['ReceivedDirectDebitMandateStatusInfoConsentPending'] | ModelTypes['ReceivedDirectDebitMandateStatusInfoEnabled'] | ModelTypes['ReceivedDirectDebitMandateStatusInfoSuspended'];
    /** Received Direct Debit Mandate Canceled status information */
    ['ReceivedDirectDebitMandateStatusInfoCanceled']: {
        /** Received Direct Debit Mandate status (always Canceled for type ReceivedDirectDebitMandateStatusInfoCanceled) */
        status: ModelTypes['ReceivedDirectDebitMandateStatus'];
        /** Date of cancellation */
        canceledAt: ModelTypes['DateTime'];
    };
    /** Received Direct Debit Mandate ConsentInitiationPending status information */
    ['ReceivedDirectDebitMandateStatusInfoConsentInitiationPending']: {
        /** Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending) */
        status: ModelTypes['ReceivedDirectDebitMandateStatus'];
    };
    /** Received Direct Debit Mandate ConsentPending status information */
    ['ReceivedDirectDebitMandateStatusInfoConsentPending']: {
        /** Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentPending) */
        status: ModelTypes['ReceivedDirectDebitMandateStatus'];
        /** The consent required to consent to a received direct debit mandate */
        consent: ModelTypes['Consent'];
    };
    /** Received Direct Debit Mandate Enabled status information */
    ['ReceivedDirectDebitMandateStatusInfoEnabled']: {
        /** Received Direct Debit Mandate status (always Enabled for type ReceivedDirectDebitMandateStatusInfoEnabled) */
        status: ModelTypes['ReceivedDirectDebitMandateStatus'];
        /** Date at which the received direct debit mandate has been moved to the enabled status */
        enabledAt: ModelTypes['DateTime'];
    };
    /** Received Direct Debit Mandate Suspended status information */
    ['ReceivedDirectDebitMandateStatusInfoSuspended']: {
        /** Received Direct Debit Mandate status (always Suspended for type ReceivedDirectDebitMandateStatusInfoSuspended) */
        status: ModelTypes['ReceivedDirectDebitMandateStatus'];
        /** Date of the last time the received direct debit mandate has been moved to the suspended status */
        suspendedAt: ModelTypes['DateTime'];
    };
    /** Input to select the beneficiary and the originator to perform a refund */
    ['RefundInput']: {
        /** transactions to refund */
        refundTransactions: Array<ModelTypes['RefundTransaction']>;
        /** url the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** The respond body to a refund mutation */
    ['RefundPayload']: ModelTypes['RefundSuccessPayload'] | ModelTypes['RefundRejection'];
    /** Rejection returned if the transaction status is not correct for the desired action */
    ['RefundRejection']: {
        message: string;
        code: ModelTypes['RefundRejectionCode'];
    };
    ['RefundRejectionCode']: RefundRejectionCode;
    /** Consent generated by the refund mutation */
    ['RefundSuccessPayload']: {
        /** optional consent that need to be validated for the refund to go through */
        consent?: ModelTypes['Consent'] | undefined;
    };
    /** Information about the transaction to refund */
    ['RefundTransaction']: {
        /** id of the transaction to refund */
        originTransactionId: string;
        /** amount to refund in the same currency as the account */
        amount: ModelTypes['AmountInput'];
        /** reference assigned by the initiating party, to unambiguously identify the transaction.
    This reference is passed on, unchanged, throughout the entire end-to-end chain for credit transfers. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined;
        /** label for the refund transaction (max 140 characters) */
        label?: string | undefined;
        /** only used when the transaction was a credit transfer
    
    date when the credit transfer will be executed, if `null` the credit transfer is executed today */
        executionDate?: ModelTypes['DateTime'] | undefined;
    };
    ['RejectedFundingSourceReason']: RejectedFundingSourceReason;
    /** Funding Source Rejected status information */
    ['RejectedFundingSourceStatusInfo']: {
        /** Funding Source Rejected status */
        status: ModelTypes['FundingSourceStatus'];
        /** Date at which the funding source was rejected */
        rejectedAt: ModelTypes['Date'];
        /** Reason code of the rejection */
        reasonCode: ModelTypes['RejectedFundingSourceReason'];
    };
    /** RejectedMerchantPaymentMethodStatusInfo */
    ['RejectedMerchantPaymentMethodStatusInfo']: {
        status: ModelTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method rejected date */
        rejectedAt: ModelTypes['Date'];
    };
    /** RejectedMerchantProfileStatusInfo */
    ['RejectedMerchantProfileStatusInfo']: {
        status: ModelTypes['MerchantProfileStatus'];
        rejectedAt: ModelTypes['Date'];
    };
    ['RejectedReasonCode']: RejectedReasonCode;
    /** Rejected transaction status information */
    ['RejectedTransactionStatusInfo']: {
        /** status of the transaction */
        status: ModelTypes['TransactionStatus'];
        /** reason code */
        reason: ModelTypes['RejectedReasonCode'];
        /** `true` if the transaction had a fallback */
        hasFallback: boolean;
    };
    ['RejectedVerificationReason']: RejectedVerificationReason;
    /** Rejected Information */
    ['RejectedVerificationStatusInfo']: {
        /** Rejected Reason */
        reason: ModelTypes['RejectedVerificationReason'];
        /** Date at which the verification was rejected */
        rejectedAt: ModelTypes['DateTime'];
        /** Account verification status (Rejected) */
        status: ModelTypes['AccountVerificationStatus'];
    };
    ['Rejection']: ModelTypes['AccountHolderNotFoundRejection'] | ModelTypes['AccountHolderTypeIndividualRejection'] | ModelTypes['AccountMembershipCannotBeDisabledRejection'] | ModelTypes['AccountMembershipCannotBeUpdatedRejection'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['AccountMembershipNotFoundRejection'] | ModelTypes['AccountMembershipNotReadyToBeBoundRejection'] | ModelTypes['AccountNotEligibleRejection'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['AccountVerificationAlreadyRejectedRejection'] | ModelTypes['AccountVerificationWrongStatusRejection'] | ModelTypes['ActionNotAllowedRejection'] | ModelTypes['AddingCardsToDifferentAccountsRejection'] | ModelTypes['AlreadyValidPhysicalCardRejection'] | ModelTypes['ApplePayNotAllowedForProjectRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['BadRequestRejection'] | ModelTypes['CannotActivatePhysicalCardRejection'] | ModelTypes['CapitalDepositDocumentCanNotBeUploaded'] | ModelTypes['CapitalDepositDocumentCanNotBeUploadedRejection'] | ModelTypes['CardCanNotBeDigitalizedRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['CardProductDisabledRejection'] | ModelTypes['CardProductNotApplicableToPhysicalCardsRejection'] | ModelTypes['CardProductNotFoundRejection'] | ModelTypes['CardProductSuspendedRejection'] | ModelTypes['CardProductUsedRejection'] | ModelTypes['CardWrongStatusRejection'] | ModelTypes['CheckRejection'] | ModelTypes['ConsentNotFoundRejection'] | ModelTypes['ConsentsAlreadyLinkedToMultiConsentRejection'] | ModelTypes['ConsentsNotAllInCreatedStatusRejection'] | ModelTypes['ConsentsNotFoundRejection'] | ModelTypes['ConsentTypeNotSupportedByServerConsentRejection'] | ModelTypes['DebtorAccountClosedRejection'] | ModelTypes['DebtorAccountNotAllowedRejection'] | ModelTypes['DigitalCardNotFoundRejection'] | ModelTypes['EnabledCardDesignNotFoundRejection'] | ModelTypes['ExternalAccountAlreadyExistsRejection'] | ModelTypes['ExternalAccountBalanceAlreadyExistsRejection'] | ModelTypes['FeeSettingsNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['FundingLimitExceededRejection'] | ModelTypes['FundingLimitSettingsChangeRequestBadAmountRejection'] | ModelTypes['FundingSourceNotFoundRejection'] | ModelTypes['FundingSourceWrongStatusRejection'] | ModelTypes['GlobalFundingLimitExceededRejection'] | ModelTypes['GlobalInstantFundingLimitExceededRejection'] | ModelTypes['IBANNotReachableRejection'] | ModelTypes['IBANNotValidRejection'] | ModelTypes['IbanValidationRejection'] | ModelTypes['IdentityAlreadyBindToAccountMembershipRejection'] | ModelTypes['InstantFundingLimitExceededRejection'] | ModelTypes['InsufficientFundsRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['InvalidArgumentRejection'] | ModelTypes['InvalidPhoneNumberRejection'] | ModelTypes['InvalidSirenNumberRejection'] | ModelTypes['LegalRepresentativeAccountMembershipCannotBeDisabledRejection'] | ModelTypes['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection'] | ModelTypes['MerchantPaymentMethodNotActiveRejection'] | ModelTypes['MerchantProfileWrongStatusRejection'] | ModelTypes['MissingMandatoryFieldRejection'] | ModelTypes['NotFoundRejection'] | ModelTypes['NotReachableConsentStatusRejection'] | ModelTypes['NotSupportedCountryRejection'] | ModelTypes['OnboardingNotCompletedRejection'] | ModelTypes['PaymentMandateMandateNotFoundRejection'] | ModelTypes['PaymentMandateReferenceAlreadyUsedRejection'] | ModelTypes['PaymentMethodNotCompatibleRejection'] | ModelTypes['PermissionCannotBeGrantedRejection'] | ModelTypes['PhysicalCardNotFoundRejection'] | ModelTypes['PhysicalCardWrongStatusRejection'] | ModelTypes['PINNotReadyRejection'] | ModelTypes['ProjectForbiddenRejection'] | ModelTypes['ProjectFundingLimitExceededRejection'] | ModelTypes['ProjectInstantFundingLimitExceededRejection'] | ModelTypes['ProjectInvalidStatusRejection'] | ModelTypes['ProjectNotFound'] | ModelTypes['ProjectNotFoundRejection'] | ModelTypes['ProjectSettingsForbiddenError'] | ModelTypes['ProjectSettingsNotFound'] | ModelTypes['ProjectSettingsStatusNotReachable'] | ModelTypes['PublicOnboardingDisabledRejection'] | ModelTypes['ReceivedDirectDebitMandateAlreadyExistRejection'] | ModelTypes['ReceivedDirectDebitMandateCanceledRejection'] | ModelTypes['ReceivedDirectDebitMandateNotB2bRejection'] | ModelTypes['ReceivedDirectDebitMandateNotFoundRejection'] | ModelTypes['RefundRejection'] | ModelTypes['RestrictedToUserRejection'] | ModelTypes['SchemeWrongRejection'] | ModelTypes['ServerConsentCredentialsNotValidOrOutdatedRejection'] | ModelTypes['ServerConsentNotAllowedForConsentOperationRejection'] | ModelTypes['ServerConsentNotAllowedForProjectRejection'] | ModelTypes['ServerConsentProjectCredentialMissingRejection'] | ModelTypes['ServerConsentProjectCredentialNotFoundRejection'] | ModelTypes['ServerConsentProjectSettingsNotFoundRejection'] | ModelTypes['ServerConsentSignatureNotValidRejection'] | ModelTypes['StandingOrderNotFoundRejection'] | ModelTypes['SupportingDocumentCollectionNotFoundRejection'] | ModelTypes['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection'] | ModelTypes['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection'] | ModelTypes['SupportingDocumentCollectionStatusNotAllowedRejection'] | ModelTypes['SupportingDocumentNotFoundRejection'] | ModelTypes['SupportingDocumentStatusDoesNotAllowDeletionRejection'] | ModelTypes['SupportingDocumentStatusDoesNotAllowUpdateRejection'] | ModelTypes['SupportingDocumentStatusNotAllowedRejection'] | ModelTypes['SupportingDocumentUploadNotAllowedRejection'] | ModelTypes['SuspendReceivedDirectDebitMandatedRejection'] | ModelTypes['SwanTCUDocumentNotFoundRejection'] | ModelTypes['SwanTCUDocumentStatusNotAllowedRejection'] | ModelTypes['TooManyChildConsentsRejection'] | ModelTypes['TooManyItemsRejection'] | ModelTypes['TransactionNotFoundRejection'] | ModelTypes['UpdateUserConsentSettingsTokenRejection'] | ModelTypes['UserNotAllowedToDisableItsOwnAccountMembershipRejection'] | ModelTypes['UserNotAllowedToManageAccountMembershipRejection'] | ModelTypes['UserNotAllowedToSuspendItsOwnAccountMembershipRejection'] | ModelTypes['UserNotCardHolderRejection'] | ModelTypes['ValidationRejection'] | ModelTypes['WebhookEventLogNotFoundRejection'] | ModelTypes['WebhookSubscriptionNotFoundRejection'] | ModelTypes['WrongValueProvidedRejection'];
    ['ReleasedReason']: ReleasedReason;
    /** Released card transaction status information */
    ['ReleasedTransactionStatusInfo']: {
        /** status of the transaction */
        status: ModelTypes['TransactionStatus'];
        /** The date when the transaction was released */
        releaseDate: ModelTypes['DateTime'];
        /** reason of the released transaction */
        reason: ModelTypes['ReleasedReason'];
    };
    /** Input to replay a Webhook event */
    ['ReplayWebhookEventInput']: {
        /** The ID of a webhook Event */
        webhookEventId: string;
    };
    /** Invoke Webhook Endpoint Payload */
    ['ReplayWebhookEventPayload']: ModelTypes['ReplayWebhookEventSuccessPayload'] | ModelTypes['WebhookEventLogNotFoundRejection'] | ModelTypes['WebhookSubscriptionNotFoundRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['InvalidArgumentRejection'];
    /** Invoke Webhook Endpoint Success Payload */
    ['ReplayWebhookEventSuccessPayload']: {
        webhookEventLogEntryId: string;
        endpointStatus?: number | undefined;
    };
    /** The document corresponding to a identification report */
    ['ReportDocument']: {
        /** Unique identifier of the report document */
        id: string;
        /** The type of the document */
        type: ModelTypes['DocumentType'];
        /** List of the associated files */
        files: Array<ModelTypes['ReportDocumentFile']>;
    };
    /** The file associated to the report document */
    ['ReportDocumentFile']: {
        /** The file's temporary download url */
        downloadUrl: string;
    };
    /** here is the exchange rate detail */
    ['ReportExchangeRate']: {
        sourceCurrency: ModelTypes['Currency'];
        exchangeRate: number;
        unitCurrency: ModelTypes['Currency'];
        targetCurrency: ModelTypes['Currency'];
        quotationDate: ModelTypes['Date'];
        contractIdentification?: string | undefined;
    };
    ['RequestMerchantPaymentMethodsInput']: {
        /** ID of the Merchant Profile */
        merchantProfileId: string;
        /** Input for the Internal Direct Debit Standard payment method */
        internalDirectDebitStandard?: ModelTypes['InternalDirectDebitStandardPaymentMethodInput'] | undefined;
        /** Input for the Internal Direct Debit B2B payment method */
        internalDirectDebitB2B?: ModelTypes['InternalDirectDebitB2BPaymentMethodInput'] | undefined;
        /** Input for the Sepa Direct Debit Core payment method */
        sepaDirectDebitCore?: ModelTypes['SepaDirectDebitCorePaymentMethodInput'] | undefined;
        /** Input for the Sepa Direct Debit B2B payment method */
        sepaDirectDebitB2B?: ModelTypes['SepaDirectDebitB2BPaymentMethodInput'] | undefined;
        /** Input for Check payment method */
        check?: ModelTypes['CheckPaymentMethodInput'] | undefined;
        /** Input for Card payment method */
        card?: ModelTypes['CardPaymentMethodInput'] | undefined;
    };
    ['RequestMerchantPaymentMethodsPayload']: ModelTypes['RequestMerchantPaymentMethodsSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['NotFoundRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ValidationRejection'];
    ['RequestMerchantPaymentMethodsSuccessPayload']: {
        merchantProfile?: ModelTypes['MerchantProfile'] | undefined;
    };
    /** Request Update Merchant Profile */
    ['RequestMerchantProfileUpdate']: {
        /** The Request ID */
        id: string;
        /** The Merchant Profile ID to update */
        merchantProfileId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website */
        merchantWebsite?: string | undefined;
        /** Url of the merchant's logo */
        merchantLogoUrl?: string | undefined;
        /** The status of the request */
        status: ModelTypes['RequestMerchantProfileUpdateStatus'];
        /** Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: ModelTypes['ProductType'];
        /** Expected annual activity volumes for all payment method */
        expectedMonthlyPaymentVolume: ModelTypes['Amount'];
        /** expected average basket value. */
        expectedAverageBasket: ModelTypes['Amount'];
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
    };
    /** Input to update a Merchant Profile */
    ['RequestMerchantProfileUpdateInput']: {
        /** ID of the MerchantProfile to update */
        merchantProfileId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website.
    Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value. */
        merchantWebsite?: string | undefined;
        /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: ModelTypes['ProductType'];
        /** Expected annual activity volumes for all payment methods. */
        expectedMonthlyPaymentVolume: ModelTypes['AmountInput'];
        /** expected average basket value. */
        expectedAverageBasket: ModelTypes['AmountInput'];
        /** base64 encoded merchant's logo.
    Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value. */
        merchantLogo?: string | undefined;
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page.
    Unlike the other fields in this mutation, the value specified here updates the merchant profile's accent color immediately. */
        accentColor?: string | undefined;
    };
    /** Add Merchant Profile Payload */
    ['RequestMerchantProfileUpdatePayload']: ModelTypes['RequestMerchantProfileUpdateSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ValidationRejection'];
    ['RequestMerchantProfileUpdateStatus']: RequestMerchantProfileUpdateStatus;
    /** Add Merchant Profile Success Payload */
    ['RequestMerchantProfileUpdateSuccessPayload']: {
        /** Request Update Merchant Profile */
        requestMerchantProfileUpdate: ModelTypes['RequestMerchantProfileUpdate'];
    };
    ['RequestSupportingDocumentCollectionReviewInput']: {
        /** Id of the supporting document collection to review. */
        supportingDocumentCollectionId: string;
    };
    ['RequestSupportingDocumentCollectionReviewPayload']: ModelTypes['RequestSupportingDocumentCollectionReviewSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['SupportingDocumentCollectionNotFoundRejection'] | ModelTypes['SupportingDocumentCollectionStatusNotAllowedRejection'] | ModelTypes['ValidationRejection'];
    ['RequestSupportingDocumentCollectionReviewSuccessPayload']: {
        supportingDocumentCollection: ModelTypes['SupportingDocumentCollection'];
    };
    /** The document corresponding to a residence permit */
    ['ResidencePermitDocument']: {
        /** Unique identifier of the residence permit document */
        id: string;
        /** The type of the document */
        type: ModelTypes['DocumentType'];
        /** The date at which the residence permit was issued */
        issueDate?: ModelTypes['Date'] | undefined;
        /** The date at which the residence permit expires */
        expiryDate?: ModelTypes['Date'] | undefined;
        /** Machine-readable zone code of the residence permit */
        mrz?: string | undefined;
        /** Number of the residence permit */
        number?: string | undefined;
        /** List of the associated files */
        files: Array<ModelTypes['ResidencePermitDocumentFile']>;
    };
    /** The file associated to the resident permit document */
    ['ResidencePermitDocumentFile']: {
        /** The file's temporary download url */
        downloadUrl: string;
        /** From which side the residence permit's picture was taken */
        side: ModelTypes['DocumentFileSide'];
    };
    ['ResidencyAddressInput']: {
        /** Address line 1. Length must be from 0 to 255 characters */
        addressLine1?: string | undefined;
        /** AddressLine2. Length must be from 0 to 255 characters */
        addressLine2?: string | undefined;
        /** City. Length must be from 0 to 100 characters */
        city?: string | undefined;
        /** Postal code. Length must be from 0 to 50 characters */
        postalCode?: string | undefined;
        /** State of residency. Length must be from 0 to 100 characters */
        state?: string | undefined;
        /** Country */
        country?: ModelTypes['CCA3'] | undefined;
    };
    /** Account membership restricted to */
    ['RestrictedTo']: {
        /** first name */
        firstName: string;
        /** last name */
        lastName: string;
        /** birth date */
        birthDate?: ModelTypes['Date'] | undefined;
        /** phone number */
        phoneNumber: string;
    };
    /** Input when the account membership is restricted to a verified user */
    ['RestrictedToInput']: {
        /** Account member first name */
        firstName: string;
        /** Account member last name */
        lastName: string;
        /** Account member birth date */
        birthDate?: ModelTypes['Date'] | undefined;
        /** Account member phone number */
        phoneNumber: ModelTypes['PhoneNumber'];
    };
    /** Rejection returned if the mutation cannot be executed in another context than user */
    ['RestrictedToUserRejection']: {
        message: string;
    };
    ['ResumeAccountMembershipInput']: {
        /** Unique identifier of a given account membership to resume */
        accountMembershipId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ResumeAccountMembershipPayload']: ModelTypes['ResumeAccountMembershipSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['UserNotAllowedToManageAccountMembershipRejection'] | ModelTypes['ValidationRejection'];
    ['ResumeAccountMembershipSuccessPayload']: {
        consent: ModelTypes['Consent'];
    };
    /** Inputs to resume a physical card */
    ['ResumePhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ResumePhysicalCardPayload']: ModelTypes['ResumePhysicalCardSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['UserNotCardHolderRejection'] | ModelTypes['PhysicalCardNotFoundRejection'] | ModelTypes['PhysicalCardWrongStatusRejection'] | ModelTypes['ValidationRejection'];
    ['ResumePhysicalCardSuccessPayload']: {
        /** The physicalCard to resume */
        physicalCard: ModelTypes['PhysicalCard'];
        /** The consent required to resume a physical card */
        consent: ModelTypes['Consent'];
    };
    /** Percentage over a number of business days, that is applied to all funds collected to compute a Reserved amount
  This amount cannot be used over the corresponding business days */
    ['RollingReserve']: {
        /** Percentage of the funding amount to be reserved */
        percentage: number;
        /** Number of business days the computed amount is reserved */
        rollingDays: number;
    };
    ['ScheduleStandingOrderInput']: {
        /** Fix Amount that will be periodically transferred
         *the value must be empty when `targetAvailableBalance` is defined* */
        amount?: ModelTypes['AmountInput'] | undefined;
        /** Target available balance that will be used for periodically clipping the account
         *the value must be empty when `amount` is defined* */
        targetAvailableBalance?: ModelTypes['AmountInput'] | undefined;
        /** Scheduled period of Standing Order */
        period: ModelTypes['StandingOrderPeriod'];
        /** Earlier date the Standing Order will be executed */
        firstExecutionDate?: ModelTypes['DateTime'] | undefined;
        /** Latest date the Standing Order will be executed */
        lastExecutionDate?: ModelTypes['DateTime'] | undefined;
        /** SEPA beneficiary of the Standing ORder */
        sepaBeneficiary?: ModelTypes['SepaBeneficiaryInput'] | undefined;
        /** Account the Standing Order will be attached to */
        accountId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined;
        /** label (max 140 characters) */
        label?: string | undefined;
        /** Transfer mode of the Standing Order */
        creditTransferMode?: ModelTypes['CreditTransferMode'] | undefined;
    };
    ['ScheduleStandingOrderPayload']: ModelTypes['ScheduleStandingOrderSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['InvalidArgumentRejection'];
    ['ScheduleStandingOrderSuccessPayload']: {
        standingOrder: ModelTypes['StandingOrder'];
    };
    ['Scheme']: {
        fields: Array<ModelTypes['Field']>;
        title: string;
        type: ModelTypes['InternationalCreditTransferRouteInput'];
        remainingFieldsToRefreshCount: number;
    };
    /** Rejection returned when adding a B2B mandate with an Individual debtor */
    ['SchemeWrongRejection']: {
        message: string;
    };
    ['SelectField']: {
        key: string;
        name: string;
        refreshDynamicFieldsOnChange: boolean;
        required: boolean;
        allowedValues: Array<ModelTypes['AllowedValue']>;
    };
    /** External Beneficiary type SEPA */
    ['SEPABeneficiary']: {
        /** unique identifier of a beneficiary
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        id?: string | undefined;
        /** full name of the beneficiary */
        name: string;
        /** `true` if this new beneficiary is the account holder himself in an other financial institution.
    *SOON TO BE DEPRECATED*
    Not used. It will be removed soon. */
        isMyOwnIban: boolean;
        /** beneficiary address */
        address?: ModelTypes['Address'] | undefined;
        /** maskedIBAN if the beneficiary is a an account in an other financial institution */
        maskedIBAN?: string | undefined;
    };
    /** Sepa beneficiary account */
    ['SepaBeneficiaryInput']: {
        /** International Bank Account Number */
        iban: ModelTypes['IBAN'];
        /** Full name of the beneficiary (min 2 characters, max 70 characters). The name should not include any special characters. */
        name: string;
        /** beneficiary address */
        address?: ModelTypes['AddressInput'] | undefined;
        /** `true` if this new beneficiary is the account holder himself in another financial institution. */
        isMyOwnIban: boolean;
        /** `true` if this new beneficiary will be saved to the beneficiary list of the debited account. */
        save: boolean;
    };
    /** SEPA Creditor Identifier
  format :
      1 – 2: ISO Country Code
      3 – 4: Check Digit
      5 – 7: Creditor Business Code – you (Creditor) choose this. The default is ZZZ
      8 - 35: Creditor National Identifier – a consecutive number that will be assigned by country
  example:
      FR11ABC123456 */
    ['SepaCreditorIdentifier']: any;
    /** Sepa Credit Transfer Creditor */
    ['SEPACreditTransferCreditor']: ModelTypes['SEPACreditTransferInCreditor'] | ModelTypes['SEPACreditTransferInternalOutCreditor'] | ModelTypes['SEPACreditTransferOutCreditor'];
    /** Sepa Credit Transfer Debtor */
    ['SEPACreditTransferDebtor']: ModelTypes['SEPACreditTransferInDebtor'] | ModelTypes['SEPACreditTransferInternalInDebtor'] | ModelTypes['SEPACreditTransferOutDebtor'];
    /** Sepa Credit Transfer Creditor for Incoming transaction */
    ['SEPACreditTransferInCreditor']: {
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Sepa Credit Transfer Debtor for Incoming transaction */
    ['SEPACreditTransferInDebtor']: {
        /** full name of the debtor (max 70 characters) */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
    };
    /** *SOON TO BE DEPRECATED*
  Sepa Credit Transfer Debtor for Incoming transaction */
    ['SEPACreditTransferInternalInDebtor']: {
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** *SOON TO BE DEPRECATED*
  Sepa Credit Transfer Creditor for internal transaction */
    ['SEPACreditTransferInternalOutCreditor']: {
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ModelTypes['InternalBeneficiary'] | undefined;
    };
    /** Sepa Credit Transfer Creditor for Outgoing transaction */
    ['SEPACreditTransferOutCreditor']: {
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ModelTypes['SEPABeneficiary'] | undefined;
    };
    /** Sepa Credit Transfer Debtor for internal transaction */
    ['SEPACreditTransferOutDebtor']: {
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Sepa Credit Transfer transaction */
    ['SEPACreditTransferTransaction']: {
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: ModelTypes['TransactionSide'];
        /** type */
        type: ModelTypes['TransactionTypeEnum'];
        /** amount */
        amount: ModelTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: ModelTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: ModelTypes['Payment'] | undefined;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ModelTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: ModelTypes['PaymentProduct'];
        /** creditor information */
        creditor: ModelTypes['SEPACreditTransferCreditor'];
        /** debtor information */
        debtor: ModelTypes['SEPACreditTransferDebtor'];
        /** matching account for the transaction */
        account?: ModelTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: ModelTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: ModelTypes['Transaction'] | undefined;
        /** r-transaction reason */
        returnReason?: ModelTypes['TransactionReasonCode'] | undefined;
    };
    /** SepaDirectDebitB2BMerchantPaymentMethod */
    ['SepaDirectDebitB2BMerchantPaymentMethod']: {
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: ModelTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: ModelTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: ModelTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ModelTypes['RollingReserve'] | undefined;
        /** Whether this payment method uses the Swan Sepa Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** When the above is false, the value of the Sepa Creditor Identifier used */
        sepaCreditorIdentifier?: string | undefined;
    };
    ['SepaDirectDebitB2BPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Enabled */
        activate?: boolean | undefined;
        /** If `true`, the transaction will be created with the Swan Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty) */
        sepaCreditorIdentifier?: string | undefined;
    };
    /** SepaDirectDebitCoreMerchantPaymentMethod */
    ['SepaDirectDebitCoreMerchantPaymentMethod']: {
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: ModelTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: ModelTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: ModelTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: ModelTypes['RollingReserve'] | undefined;
        /** Whether this payment method uses the Swan Sepa Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** When the above is false, the value of the Sepa Creditor Identifier used */
        sepaCreditorIdentifier?: string | undefined;
    };
    ['SepaDirectDebitCorePaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined;
        /** If `true`, the transaction will be created with the Swan Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty) */
        sepaCreditorIdentifier?: string | undefined;
    };
    /** Sepa Direct Debit Creditor */
    ['SEPADirectDebitCreditor']: ModelTypes['SEPADirectDebitInCreditor'] | ModelTypes['SEPADirectDebitOutCreditor'];
    /** Sepa Direct Debit Debtor */
    ['SEPADirectDebitDebtor']: ModelTypes['SEPADirectDebitInDebtor'] | ModelTypes['SEPADirectDebitOutDebtor'];
    /** Sepa Direct Debit Creditor for Input transaction */
    ['SEPADirectDebitInCreditor']: {
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    /** Sepa Direct Debtor for Input transaction */
    ['SEPADirectDebitInDebtor']: {
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ModelTypes['SEPABeneficiary'] | undefined;
    };
    ['SEPADirectDebitMandate']: ModelTypes['SEPAPaymentDirectDebitMandate'] | ModelTypes['SEPAReceivedDirectDebitMandate'];
    /** Sepa Direct Debit Creditor for Outgoing transaction */
    ['SEPADirectDebitOutCreditor']: {
        /** full name of the creditor (max 70 characters) */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: ModelTypes['SEPABeneficiary'] | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
    };
    /** Sepa Direct Debtor for Outgoing transaction */
    ['SEPADirectDebitOutDebtor']: {
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: ModelTypes['AccountNumber'];
    };
    ['SepaDirectDebitPaymentCollectionInput']: {
        /** Payment Mandate ID generated by Swan */
        mandateId: string;
        /** Date at which the Swan merchant wishes the payment to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
    };
    ['SEPADirectDebitScheme']: SEPADirectDebitScheme;
    /** Sepa Direct Debit transaction */
    ['SEPADirectDebitTransaction']: {
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: ModelTypes['TransactionSide'];
        /** type */
        type: ModelTypes['TransactionTypeEnum'];
        /** amount */
        amount: ModelTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: ModelTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: ModelTypes['Payment'] | undefined;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: ModelTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: ModelTypes['PaymentProduct'];
        /** creditor information */
        creditor: ModelTypes['SEPADirectDebitCreditor'];
        /** debtor information */
        debtor: ModelTypes['SEPADirectDebitDebtor'];
        /** matching account for the transaction */
        account?: ModelTypes['Account'] | undefined;
        /** matching SEPA mandate for the transaction */
        mandate?: ModelTypes['SEPADirectDebitMandate'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: ModelTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: ModelTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: ModelTypes['Transaction'] | undefined;
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: ModelTypes['Amount'] | undefined;
        /** date on which reserved funds become available. */
        reservedAmountReleasedAt?: ModelTypes['DateTime'] | undefined;
        /** r-transaction reason */
        returnReason?: ModelTypes['TransactionReasonCode'] | undefined;
    };
    /** Payment direct debit mandate for SEPA */
    ['SEPAPaymentDirectDebitMandate']: {
        /** Unique identifier of the SEPA Direct Debit Payment Mandate */
        id: string;
        /** List of transactions associated with the SEPA Payment Direct Debit Mandate.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: ModelTypes['TransactionConnection'] | undefined;
        /** Unique reference of the SEPA Direct Debit Payment Mandate */
        reference: string;
        /** SEPA Direct Debit Payment Mandate scheme */
        scheme: ModelTypes['SEPAPaymentMandateScheme'];
        /** SEPA Direct Debit Payment Mandate status information */
        statusInfo: ModelTypes['PaymentMandateStatusInfo'];
        /** SEPA Direct Debit Payment Mandate sequence */
        sequence: ModelTypes['SEPAPaymentMandateSequence'];
        /** SEPA Direct Debit Payment Mandate PDF document URL */
        mandateDocumentUrl: string;
        /** SEPA Direct Debit Payment Mandate debtor information */
        debtor: ModelTypes['SEPAPaymentMandateDebtor'];
        /** SEPA direct debit ultimate creditor name */
        ultimateCreditorName?: string | undefined;
        /** SEPA Direct Debit Payment Mandate creditor information */
        creditor: ModelTypes['SEPAPaymentMandateCreditor'];
        /** Signature date of the SEPA Direct Debit Payment Mandate */
        signatureDate?: ModelTypes['Date'] | undefined;
        /** Creation date of the SEPA Direct Debit Payment Mandate */
        createdAt: ModelTypes['DateTime'];
        /** Last Update date of the SEPA Direct Debit Payment Mandate */
        updatedAt: ModelTypes['DateTime'];
        /** Date of the the last transaction executed for the concerned SEPA Direct Debit Payment Mandate */
        executedAt?: ModelTypes['DateTime'] | undefined;
        /** Expiry date of the SEPA Direct Debit Payment Mandate */
        expiredAt?: ModelTypes['Date'] | undefined;
        /** Account Holder information */
        accountHolder: ModelTypes['AccountHolder'];
        /** Custom name of the mandate */
        name?: string | undefined;
    };
    ['SEPAPaymentMandateCreditor']: {
        /** SEPA Direct Debit Payment Mandate creditor UUID */
        id: string;
        /** SEPA Direct Debit Payment Mandate Sepa Creditor Idenfier (SCI) */
        identifier: ModelTypes['SepaCreditorIdentifier'];
        /** SEPA Direct Debit Payment Mandate creditor name */
        name: string;
        /** SEPA Direct Debit Payment Mandate creditor address */
        address: ModelTypes['Address'];
    };
    ['SEPAPaymentMandateDebtor']: {
        /** SEPA Direct Debit Payment Mandate debtor name */
        name: string;
        /** SEPA Direct Debit Payment Mandate debtor IBAN */
        iban: ModelTypes['IBAN'];
        /** SEPA Direct Debit Payment Mandate debtor e-mail */
        email?: string | undefined;
        /** SEPA Direct Debit Payment Mandate debtor country */
        country: ModelTypes['CCA3'];
        /** SEPA Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        address?: ModelTypes['Address'] | undefined;
    };
    ['SepaPaymentMandateDebtorInput']: {
        /** SEPA Direct Debit Payment Mandate debtor name */
        name: string;
        /** SEPA Direct Debit Payment Mandate debtor IBAN */
        IBAN: string;
        address: ModelTypes['AddressInput'];
    };
    ['SEPAPaymentMandateScheme']: SEPAPaymentMandateScheme;
    ['SEPAPaymentMandateSequence']: SEPAPaymentMandateSequence;
    /** Received direct debit mandate for SEPA */
    ['SEPAReceivedDirectDebitMandate']: {
        /** Unique identifier of the received SEPA direct debit mandate, generated by Swan */
        id: string;
        /** List of transactions associated with the SEPA Receive Direct Debit Mandate.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: ModelTypes['TransactionConnection'] | undefined;
        /** Version of the received SEPA direct debit mandate */
        version: string;
        /** Creation date of the received SEPA direct debit mandate */
        createdAt: ModelTypes['DateTime'];
        /** Last Update date of the received SEPA direct debit mandate */
        updatedAt: ModelTypes['DateTime'];
        /** Received SEPA direct debit Unique Mandate Reference (UMR) */
        reference: string;
        /** Received SEPA direct debit mandate scheme */
        scheme: ModelTypes['SEPAReceivedDirectDebitMandateScheme'];
        /** Received SEPA direct debit mandate sequence */
        sequence: ModelTypes['SEPAReceivedDirectDebitMandateSequence'];
        /** Received SEPA direct debit creditor */
        creditor: ModelTypes['SEPAReceivedDirectDebitMandateCreditor'];
        /** Received SEPA direct debit ultimate creditor name */
        ultimateCreditorName?: string | undefined;
        /** Date of the last SEPA direct debit transaction executed for the concerned received SEPA direct debit mandate */
        executedAt?: ModelTypes['DateTime'] | undefined;
        /** Date of signature of the received SEPA direct debit mandate */
        signatureDate?: ModelTypes['Date'] | undefined;
        /** Expiry date of the received SEPA direct debit mandate, computed automatically (36 months from the executedAt date) */
        expiredAt?: ModelTypes['Date'] | undefined;
        /** Mandate status information of the received SEPA direct debit mandate */
        statusInfo: ModelTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Account of the received SEPA direct debit mandate debtor */
        account?: ModelTypes['Account'] | undefined;
        /** Iban of the received SEPA direct debit mandate debtor */
        iban: ModelTypes['IBAN'];
        /** Mandate name */
        name?: string | undefined;
    };
    /** SEPA received direct debit mandate creditor */
    ['SEPAReceivedDirectDebitMandateCreditor']: {
        /** SEPA Creditor identifier (SCI) */
        identifier: string;
        /** Name of the SEPA creditor */
        name: string;
        /** Address of the SEPA creditor */
        address: ModelTypes['Address'];
    };
    ['SEPAReceivedDirectDebitMandateScheme']: SEPAReceivedDirectDebitMandateScheme;
    ['SEPAReceivedDirectDebitMandateSequence']: SEPAReceivedDirectDebitMandateSequence;
    /** SEPA Identifier
  max 35 Latin characters as follow :
      a b c d e f g h i j k l m n o p q r s t u v w x y z
      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
      0 1 2 3 4 5 6 7 8 9
      / - ? : ( ) . , '  +
  with some follow extra rules :
      Content must not start or end with a ‘/’
      Content must not contain ‘//’s */
    ['SepaReference']: any;
    /** Rejection returned when signature is not valid or remote IP address is not allowed */
    ['ServerConsentCredentialsNotValidOrOutdatedRejection']: {
        message: string;
    };
    /** Rejection returned when server consent is not allowed on the consent */
    ['ServerConsentNotAllowedForConsentOperationRejection']: {
        message: string;
    };
    /** Rejection returned when server consent is not allowed for the project associated with the consent */
    ['ServerConsentNotAllowedForProjectRejection']: {
        message: string;
    };
    /** Rejection returned when there are no server consent credentials for the project */
    ['ServerConsentProjectCredentialMissingRejection']: {
        message: string;
    };
    /** Rejection returned when the server consent project credentials are not found */
    ['ServerConsentProjectCredentialNotFoundRejection']: {
        message: string;
    };
    /** Rejection returned when the server consent project settings are not found */
    ['ServerConsentProjectSettingsNotFoundRejection']: {
        message: string;
    };
    /** Rejection returned when the signature is not valid
  @Deprecated */
    ['ServerConsentSignatureNotValidRejection']: {
        message: string;
    };
    /** Shareholder of a company creating a Capital Deposit Case */
    ['Shareholder']: {
        /** Unique identifier of a shareholder. */
        id: string;
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: ModelTypes['Amount'];
        /** Onboarding information of the shareholder. */
        onboarding?: ModelTypes['Onboarding'] | undefined;
        /** Unique identifier of the shareholder account. */
        accountId?: string | undefined;
        /** Status of the shareholder during the process with Swan. */
        status: ModelTypes['ShareholderStatus'];
        /** Extra information about the shareholder */
        info: ModelTypes['ShareholderInfo'];
        /** Shareholder documents for the capital deposit case */
        documents: Array<ModelTypes['CapitalDepositDocument']>;
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** Information about capital deposit case. */
        relatedCapitalDepositCase: ModelTypes['CapitalDepositCase'];
    };
    /** Shareholder information. */
    ['ShareholderInfo']: ModelTypes['IndividualShareholder'] | ModelTypes['CompanyShareholder'];
    ['ShareholderStatus']: ShareholderStatus;
    ['ShareholderType']: ShareholderType;
    /** Signature data used during apple pay inApp provisioning */
    ['SignatureData']: {
        /** nonce */
        nonce: string;
        /** nonce signed by the secure element */
        nonceSignature: string;
        /** list of apple generated certificates */
        certificates: Array<ModelTypes['Certificate']>;
    };
    ['SimulationCardType']: SimulationCardType;
    ['SingleUseVirtualCardConfigInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card name */
        name?: string | undefined;
        /** Spending limit */
        spendingLimit: ModelTypes['SpendingLimitInput'];
    };
    /** Spending */
    ['Spending']: {
        /** period concerned */
        period: ModelTypes['SpendingLimitPeriod'];
        /** amount spent during the period */
        amount?: ModelTypes['Amount'] | undefined;
    };
    /** Spending limits */
    ['SpendingLimit']: {
        /** type of limit (defined by the Partner, defined by Swan, etc.) */
        type: ModelTypes['SpendingLimitType'];
        /** period concerned */
        period: ModelTypes['SpendingLimitPeriod'];
        /** sum of amount of spending authorized during the period */
        amount: ModelTypes['Amount'];
    };
    /** Inputs when editing spending limit configuration */
    ['SpendingLimitInput']: {
        /** period concerned */
        period: ModelTypes['SpendingLimitPeriodInput'];
        /** sum of amount of spending authorized during the period */
        amount: ModelTypes['AmountInput'];
    };
    ['SpendingLimitPeriod']: SpendingLimitPeriod;
    ['SpendingLimitPeriodInput']: SpendingLimitPeriodInput;
    ['SpendingLimitType']: SpendingLimitType;
    ['StandingOrder']: {
        /** Standing Order unique identifier */
        id: string;
        /** List of payments of an standing order.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        payments: ModelTypes['PaymentConnection'];
        /** reference that will be transferred to the beneficiary throughout the entire end-to-end chain */
        reference?: string | undefined;
        /** label that will be transferred to the beneficiary */
        label?: string | undefined;
        /** Fixed Amount that will be regularly transferred */
        amount?: ModelTypes['Amount'] | undefined;
        /** Target available balance value that will be used for periodically clipping the account */
        targetAvailableBalance?: ModelTypes['Amount'] | undefined;
        /** Scheduled period of Standing Order */
        period: ModelTypes['StandingOrderPeriod'];
        /** Earlier date the Standing Order will be executed */
        firstExecutionDate?: ModelTypes['DateTime'] | undefined;
        /** Latest date the Standing Order will be executed */
        lastExecutionDate?: ModelTypes['DateTime'] | undefined;
        /** SEPA beneficiary of the Standing Order */
        sepaBeneficiary: ModelTypes['SEPABeneficiary'];
        /** Status of the Standing Order */
        statusInfo: ModelTypes['StandingOrderStatusInfo'];
        /** Date the Standing Order has been created */
        createdAt: ModelTypes['Date'];
        /** Last date the Standing Order has been updated */
        updatedAt: ModelTypes['Date'];
        /** Account of the Standing Order */
        account: ModelTypes['Account'];
        /** Identity that scheduled the Standing Order */
        createdBy: ModelTypes['User'];
        /** Next execution date of the Standing Order, if any */
        nextExecutionDate?: ModelTypes['Date'] | undefined;
        /** Transfer mode of the Standing Order */
        creditTransferMode?: ModelTypes['CreditTransferMode'] | undefined;
    };
    ['StandingOrderCanceledStatusInfo']: {
        canceledAt: ModelTypes['Date'];
        status: ModelTypes['StandingOrderStatus'];
    };
    /** Please see the Connection interface */
    ['StandingOrderConnection']: {
        pageInfo: ModelTypes['PageInfo'];
        edges: Array<ModelTypes['StandingOrderEdge']>;
        totalCount: number;
    };
    ['StandingOrderConsentPendingStatusInfo']: {
        status: ModelTypes['StandingOrderStatus'];
        consent: ModelTypes['Consent'];
    };
    /** Please see the Connection interface */
    ['StandingOrderEdge']: {
        node: ModelTypes['StandingOrder'];
        cursor: string;
    };
    ['StandingOrderEnabledStatusInfo']: {
        status: ModelTypes['StandingOrderStatus'];
    };
    /** Rejection returned when Standing Order is not found */
    ['StandingOrderNotFoundRejection']: {
        message: string;
    };
    ['StandingOrderPeriod']: StandingOrderPeriod;
    ['StandingOrderStatus']: StandingOrderStatus;
    ['StandingOrderStatusInfo']: ModelTypes['StandingOrderCanceledStatusInfo'] | ModelTypes['StandingOrderConsentPendingStatusInfo'] | ModelTypes['StandingOrderEnabledStatusInfo'];
    /** Describes an identification level that has started for the process of the current identification */
    ['StartedIdentificationLevelStatusInfo']: {
        /** Always set to `Started` */
        status: ModelTypes['SwanIdentificationStatus'];
    };
    /** A statement represent metadata around a banking document that list all of the BOOKED banking transactions that have happened between startDate and endDate */
    ['Statement']: {
        /** unique identifier of the statement */
        id: string;
        /** account of the statement */
        account: ModelTypes['Account'];
        /** booked balance at the start of the window */
        openingBalance: ModelTypes['Amount'];
        /** booked balance at the end of the window */
        closingBalance: ModelTypes['Amount'];
        /** starting date of the date window */
        openingDate: ModelTypes['DateTime'];
        /** ending date of the date window */
        closingDate: ModelTypes['DateTime'];
        /** status of the statement */
        status: ModelTypes['StatementStatus'];
        /** period of statement (either custom or monthly) */
        period?: ModelTypes['StatementPeriod'] | undefined;
        /** the sum of credit transactions during the window */
        totalCredits: ModelTypes['Amount'];
        /** the sum of debit transactions during the window */
        totalDebits: ModelTypes['Amount'];
        /** the sum of fee transactions during the window */
        fees: ModelTypes['Amount'];
        /** type of statements (ex: PDF) */
        type: Array<ModelTypes['StatementInfo'] | undefined>;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)). */
    ['StatementConnection']: {
        pageInfo: ModelTypes['PageInfo'];
        totalCount: number;
        edges: Array<ModelTypes['StatementEdge']>;
    };
    /** Implements the Relay Edge interface. */
    ['StatementEdge']: {
        node: ModelTypes['Statement'];
        cursor: string;
    };
    /** Filter that can be given to give the statement in a specific data range */
    ['StatementFiltersInput']: {
        /** To filter after an updatedAt value */
        isAfterUpdatedAt?: ModelTypes['DateTime'] | undefined;
        /** To filter before an updatedAt value */
        isBeforeUpdatedAt?: ModelTypes['DateTime'] | undefined;
        /** To filter on a specific period of statement (either custom or monthly) */
        period?: ModelTypes['StatementPeriod'] | undefined;
    };
    /** Custom information for a certain type of statement */
    ['StatementInfo']: ModelTypes['CsvStatement'] | ModelTypes['PdfStatement'];
    ['StatementPeriod']: StatementPeriod;
    ['StatementStatus']: StatementStatus;
    ['StatementType']: StatementType;
    ['StatusText']: StatusText;
    /** Supporting document used for compliance */
    ['SupportingDocument']: {
        /** Unique identifier of the document */
        id: string;
        /** Supporting document status information */
        statusInfo: ModelTypes['SupportingDocumentStatusInfo'];
        /** Type of supporting Document */
        supportingDocumentType?: ModelTypes['SupportingDocumentType'] | undefined;
        /** Purpose of supporting document */
        supportingDocumentPurpose: ModelTypes['SupportingDocumentPurposeEnum'];
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
    };
    ['SupportingDocumentAccountHolder']: {
        id?: string | undefined;
    };
    /** Collection of supporting documents used for compliance
  
  Fetching SupportingDocument is restricted to Project access token */
    ['SupportingDocumentCollection']: {
        /** Unique identifier of the supporting document collection */
        id: string;
        /** Status of the supporting document collection */
        statusInfo: ModelTypes['SupportingDocumentCollectionStatusInfo'];
        /** Created date */
        createdAt: ModelTypes['DateTime'];
        /** Updated date */
        updatedAt: ModelTypes['DateTime'];
        /** List of supported documents contained in the supporting document collection */
        supportingDocuments: Array<ModelTypes['SupportingDocument'] | undefined>;
        /** List of required supporting document purposes for this supporting document collection */
        requiredSupportingDocumentPurposes: Array<ModelTypes['SupportingDocumentPurpose']>;
        accountHolder: ModelTypes['SupportingDocumentAccountHolder'];
        onboarding: ModelTypes['SupportingDocumentOnboarding'];
        projectInfo: ModelTypes['ProjectInfo'];
    };
    /** Supporting document collection with Approved status */
    ['SupportingDocumentCollectionApprovedStatusInfo']: {
        /** When the supporting document collection is approved */
        status: ModelTypes['SupportingDocumentCollectionStatus'];
        /** Date on which the supporting document collection has been approved */
        approvedAt: ModelTypes['DateTime'];
    };
    /** Supporting document collection with Canceled status */
    ['SupportingDocumentCollectionCanceledStatusInfo']: {
        /** When the supporting document collection is canceled */
        status: ModelTypes['SupportingDocumentCollectionStatus'];
        /** Date on which the supporting document collection has been canceled */
        canceledAt: ModelTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['SupportingDocumentCollectionConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** SupportingDocumentCollectionEdge list */
        edges: Array<ModelTypes['SupportingDocumentCollectionEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['SupportingDocumentCollectionEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The supporting document collection */
        node: ModelTypes['SupportingDocumentCollection'];
    };
    /** Rejection returned if the supporting document collection was not found */
    ['SupportingDocumentCollectionNotFoundRejection']: {
        id: string;
        message: string;
    };
    /** Supporting document collection with PendingReview status */
    ['SupportingDocumentCollectionPendingReviewStatusInfo']: {
        /** When the supporting document collection is completed and in compliance review */
        status: ModelTypes['SupportingDocumentCollectionStatus'];
    };
    /** Supporting document collection with Rejected status */
    ['SupportingDocumentCollectionRejectedStatusInfo']: {
        /** When the supporting document collection is rejected */
        status: ModelTypes['SupportingDocumentCollectionStatus'];
        /** Date on which the supporting document collection has been rejected */
        rejectedAt: ModelTypes['DateTime'];
    };
    ['SupportingDocumentCollectionStatus']: SupportingDocumentCollectionStatus;
    /** Rejection returned if supporting document cannot be deleted because its supporting document collection status is not WaitingForDocument */
    ['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection']: {
        message: string;
        supportingDocumentCollectionStatus: ModelTypes['SupportingDocumentCollectionStatus'];
        supportingDocumentCollection: ModelTypes['SupportingDocumentCollection'];
    };
    /** Rejection returned if supporting document cannot be updated because its supporting document collection status is not WaitingForDocument */
    ['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection']: {
        message: string;
        supportingDocumentCollectionStatus: ModelTypes['SupportingDocumentCollectionStatus'];
        supportingDocumentCollection: ModelTypes['SupportingDocumentCollection'];
    };
    ['SupportingDocumentCollectionStatusInfo']: ModelTypes['SupportingDocumentCollectionApprovedStatusInfo'] | ModelTypes['SupportingDocumentCollectionCanceledStatusInfo'] | ModelTypes['SupportingDocumentCollectionPendingReviewStatusInfo'] | ModelTypes['SupportingDocumentCollectionRejectedStatusInfo'] | ModelTypes['SupportingDocumentCollectionWaitingForDocumentStatusInfo'];
    /** Rejection returned if the status transition is not allowed */
    ['SupportingDocumentCollectionStatusNotAllowedRejection']: {
        oldStatus: ModelTypes['SupportingDocumentCollectionStatus'];
        newStatus: ModelTypes['SupportingDocumentCollectionStatus'];
        message: string;
    };
    /** Supporting document collection with WaitingForUpload status */
    ['SupportingDocumentCollectionWaitingForDocumentStatusInfo']: {
        /** When the Supporting Document Collection is created */
        status: ModelTypes['SupportingDocumentCollectionStatus'];
    };
    ['SupportingDocumentCollectMode']: SupportingDocumentCollectMode;
    ['SupportingDocumentCommunicationLanguageSettings']: SupportingDocumentCommunicationLanguageSettings;
    /** Rejection returned if the supporting document was not found */
    ['SupportingDocumentNotFoundRejection']: {
        id: string;
        message: string;
    };
    /** Supporting document with NotUploaded status. */
    ['SupportingDocumentNotUploadedStatusInfo']: {
        /** When the document has not been updated on time. */
        status: ModelTypes['SupportingDocumentStatus'];
    };
    ['SupportingDocumentOnboarding']: {
        id?: string | undefined;
    };
    ['SupportingDocumentPostField']: {
        key: string;
        value: string;
    };
    /** Details of a supporting document purpose */
    ['SupportingDocumentPurpose']: {
        /** Technical name of the purpose */
        name: ModelTypes['SupportingDocumentPurposeEnum'];
        /** Corresponding supporting document types accepted for this supporting document purpose */
        acceptableSupportingDocumentTypes: Array<ModelTypes['SupportingDocumentType']>;
    };
    ['SupportingDocumentPurposeEnum']: SupportingDocumentPurposeEnum;
    /** Supporting document with Refused status */
    ['SupportingDocumentRefusedStatusInfo']: {
        /** When the document has been refused by Swan */
        status: ModelTypes['SupportingDocumentStatus'];
        /** An unique URL and one-time URL to download the Document */
        downloadUrl: string;
        /** Date on which the supporting document collection has been refused */
        refusedAt: ModelTypes['DateTime'];
        /** Reason why the supporting document has been refused */
        reason: string;
        /** Original file name */
        filename: string;
    };
    ['SupportingDocumentSettings']: {
        collectMode: ModelTypes['SupportingDocumentCollectMode'];
        communicationLanguage?: ModelTypes['SupportingDocumentCommunicationLanguageSettings'] | undefined;
        emailContact?: string | undefined;
    };
    ['SupportingDocumentStatus']: SupportingDocumentStatus;
    /** Rejection returned if supporting document cannot be deleted because of its status */
    ['SupportingDocumentStatusDoesNotAllowDeletionRejection']: {
        supportingDocument: ModelTypes['SupportingDocument'];
        status: ModelTypes['SupportingDocumentStatus'];
        message: string;
    };
    /** Rejection returned if supporting document cannot be updated because of its status */
    ['SupportingDocumentStatusDoesNotAllowUpdateRejection']: {
        supportingDocument: ModelTypes['SupportingDocument'];
        status: ModelTypes['SupportingDocumentStatus'];
        message: string;
    };
    ['SupportingDocumentStatusInfo']: ModelTypes['SupportingDocumentNotUploadedStatusInfo'] | ModelTypes['SupportingDocumentRefusedStatusInfo'] | ModelTypes['SupportingDocumentUploadedStatusInfo'] | ModelTypes['SupportingDocumentValidatedStatusInfo'] | ModelTypes['SupportingDocumentWaitingForUploadStatusInfo'];
    /** Rejection returned if the status transition is not allowed */
    ['SupportingDocumentStatusNotAllowedRejection']: {
        oldStatus: ModelTypes['SupportingDocumentStatus'];
        newStatus: ModelTypes['SupportingDocumentStatus'];
        message: string;
    };
    ['SupportingDocumentType']: SupportingDocumentType;
    /** Supporting document with Uploaded status */
    ['SupportingDocumentUploadedStatusInfo']: {
        /** When the document has been uploaded but not verified by Swan yet */
        status: ModelTypes['SupportingDocumentStatus'];
        /** An unique URL and one-time URL to download the Document */
        downloadUrl: string;
        /** Original file name */
        filename: string;
    };
    ['SupportingDocumentUploadInfo']: {
        url: string;
        fields: Array<ModelTypes['SupportingDocumentPostField']>;
    };
    /** Rejection returned if the supporting document collection cannot receive supporting documents anymore */
    ['SupportingDocumentUploadNotAllowedRejection']: {
        supportingDocumentCollectionStatus: ModelTypes['SupportingDocumentCollectionStatus'];
        message: string;
    };
    /** Supporting document with Validated status */
    ['SupportingDocumentValidatedStatusInfo']: {
        /** When the document has been uploaded and verified by Swan */
        status: ModelTypes['SupportingDocumentStatus'];
        /** An unique URL and one-time URL to download the Document */
        downloadUrl: string;
        /** Date on which the supporting document has been validated */
        validatedAt: ModelTypes['DateTime'];
        /** Original file name */
        filename: string;
        /** Reason why the supporting document has been validated */
        reason: string;
    };
    /** Supporting document with WaitingForUpload status */
    ['SupportingDocumentWaitingForUploadStatusInfo']: {
        /** When the document is not uploaded yet */
        status: ModelTypes['SupportingDocumentStatus'];
        /** Info to upload the document : url and fields to add along file in form (POST) */
        upload: ModelTypes['SupportingDocumentUploadInfo'];
    };
    ['SuspendAccountMembershipInput']: {
        accountMembershipId: string;
    };
    ['SuspendAccountMembershipPayload']: ModelTypes['SuspendAccountMembershipSuccessPayload'] | ModelTypes['InternalErrorRejection'] | ModelTypes['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection'] | ModelTypes['UserNotAllowedToManageAccountMembershipRejection'] | ModelTypes['UserNotAllowedToSuspendItsOwnAccountMembershipRejection'] | ModelTypes['ValidationRejection'];
    ['SuspendAccountMembershipSuccessPayload']: {
        accountMembership: ModelTypes['AccountMembership'];
    };
    /** Define a reason with a message and a specific type for suspend account action */
    ['SuspendAccountReason']: {
        type: ModelTypes['SuspendAccountReasonType'];
        message?: string | undefined;
    };
    /** Input version */
    ['SuspendAccountReasonInput']: {
        type: ModelTypes['SuspendAccountReasonType'];
        message?: string | undefined;
    };
    ['SuspendAccountReasonType']: SuspendAccountReasonType;
    /** SuspendAccountStatusReason */
    ['SuspendAccountStatusReason']: ModelTypes['SuspendAccountReason'];
    /** StatusInfo when funding limit settings has been suspended */
    ['SuspendedFundingLimitSettingsStatusInfo']: {
        status: ModelTypes['FundingLimitSettingsStatus'];
        reason: string;
    };
    /** Funding Source Suspended status information */
    ['SuspendedFundingSourceStatusInfo']: {
        /** Funding Source Suspended status */
        status: ModelTypes['FundingSourceStatus'];
        /** Date at which the funding source was suspended */
        suspendedAt: ModelTypes['Date'];
    };
    /** SuspendedMerchantPaymentMethodStatusInfo */
    ['SuspendedMerchantPaymentMethodStatusInfo']: {
        status: ModelTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method suspended date */
        suspendedAt: ModelTypes['Date'];
    };
    /** SuspendedMerchantProfileStatusInfo */
    ['SuspendedMerchantProfileStatusInfo']: {
        status: ModelTypes['MerchantProfileStatus'];
        suspendedAt: ModelTypes['Date'];
    };
    /** Inputs to suspend a physical card */
    ['SuspendPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
    };
    ['SuspendPhysicalCardPayload']: ModelTypes['SuspendPhysicalCardSuccessPayload'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['PhysicalCardNotFoundRejection'] | ModelTypes['ValidationRejection'];
    ['SuspendPhysicalCardSuccessPayload']: {
        /** The physicalCard suspended */
        physicalCard: ModelTypes['PhysicalCard'];
    };
    /** Rejection returned if the SuspendReceivedDirectDebitMandatedRejection mutation is rejected */
    ['SuspendReceivedDirectDebitMandatedRejection']: {
        message: string;
        reason: ModelTypes['SuspendReceivedDirectDebitMandatedRejectionReason'];
    };
    ['SuspendReceivedDirectDebitMandatedRejectionReason']: SuspendReceivedDirectDebitMandatedRejectionReason;
    /** Inputs to suspend a received direct debit mandate */
    ['SuspendReceivedDirectDebitMandateInput']: {
        receivedDirectDebitMandateId: string;
    };
    /** Union type returned by the suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandatePayload']: ModelTypes['SuspendReceivedDirectDebitMandateSuccessPayload'] | ModelTypes['SuspendReceivedDirectDebitMandatedRejection'] | ModelTypes['ReceivedDirectDebitMandateNotFoundRejection'] | ModelTypes['ReceivedDirectDebitMandateCanceledRejection'] | ModelTypes['ForbiddenRejection'];
    /** Return type in case of a successful response of the suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandateSuccessPayload']: {
        /** the received direct debit mandate is suspended */
        receivedDirectDebitMandate: ModelTypes['ReceivedDirectDebitMandate'];
    };
    /** Swan account beneficiary */
    ['SwanAccountBeneficiaryInput']: {
        /** account number to be credited */
        accountNumber: ModelTypes['AccountNumber'];
        /** full name of the beneficiary  (max 70 characters) */
        name: string;
        /** `true` if this new beneficiary will be saved to the beneficiary list of the debited account. */
        save: boolean;
    };
    ['SwanIdentificationStatus']: SwanIdentificationStatus;
    ['SwanTCUDocumentNotFoundRejection']: {
        message: string;
    };
    ['SwanTCUDocumentStatusNotAllowedRejection']: {
        message: string;
    };
    ['TextField']: {
        displayFormat?: string | undefined;
        example?: string | undefined;
        key: string;
        maxLength?: number | undefined;
        minLength?: number | undefined;
        name: string;
        refreshDynamicFieldsOnChange: boolean;
        required: boolean;
        validationRegex?: string | undefined;
    };
    ['TitleEnum']: TitleEnum;
    ['TokenRequestorId']: any;
    /** Rejection returned when trying to create a multi consent with too many child consents */
    ['TooManyChildConsentsRejection']: {
        message: string;
    };
    /** Rejection returned if too many items are given */
    ['TooManyItemsRejection']: {
        message: string;
    };
    /** Transaction */
    ['Transaction']: ModelTypes['CardTransaction'] | ModelTypes['CheckTransaction'] | ModelTypes['FeeTransaction'] | ModelTypes['InternalCreditTransfer'] | ModelTypes['InternalDirectDebitTransaction'] | ModelTypes['InternationalCreditTransferTransaction'] | ModelTypes['SEPACreditTransferTransaction'] | ModelTypes['SEPADirectDebitTransaction'];
    /** Please see the Connection interface */
    ['TransactionConnection']: {
        pageInfo: ModelTypes['PageInfo'];
        totalCount: number;
        edges: Array<ModelTypes['TransactionEdge']>;
    };
    /** Please see the Edge interface */
    ['TransactionEdge']: {
        node: ModelTypes['Transaction'];
        cursor: string;
    };
    /** Rejection returned if the transaction was not found */
    ['TransactionNotFoundRejection']: {
        transactionId: string;
        message: string;
    };
    ['TransactionReasonCode']: TransactionReasonCode;
    /** the criteria to filter transactions */
    ['TransactionsFiltersInput']: {
        /** To filter on some Transaction Status (all if empty) */
        status?: Array<ModelTypes['TransactionStatus']> | undefined;
        /** To filter on some Payment Products (all if empty) */
        paymentProduct?: Array<ModelTypes['PaymentProduct']> | undefined;
        /** To filter after an updatedAt value */
        isAfterUpdatedAt?: ModelTypes['DateTime'] | undefined;
        /** To filter before an updatedAt value */
        isBeforeUpdatedAt?: ModelTypes['DateTime'] | undefined;
        /** To filter on some text occurrences (words or ids) */
        search?: string | undefined;
        /** To filter on some transaction types */
        type?: Array<ModelTypes['TransactionTypeEnum']> | undefined;
        /** To filter so it includes rejected transactions that had a fallback (`true` by default) */
        includeRejectedWithFallback?: boolean | undefined;
    };
    ['TransactionSide']: TransactionSide;
    ['TransactionsOrderByField']: TransactionsOrderByField;
    /** the criteria to sort transactions */
    ['TransactionsOrderByInput']: {
        field?: ModelTypes['TransactionsOrderByField'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['TransactionStatus']: TransactionStatus;
    /** Transaction Status information */
    ['TransactionStatusInfo']: ModelTypes['BookedTransactionStatusInfo'] | ModelTypes['CanceledTransactionStatusInfo'] | ModelTypes['PendingTransactionStatusInfo'] | ModelTypes['RejectedTransactionStatusInfo'] | ModelTypes['ReleasedTransactionStatusInfo'] | ModelTypes['UpcomingTransactionStatusInfo'];
    ['TransactionTypeEnum']: TransactionTypeEnum;
    /** TrustedBeneficiary */
    ['TrustedBeneficiary']: ModelTypes['TrustedInternalBeneficiary'] | ModelTypes['TrustedInternationalBeneficiary'] | ModelTypes['TrustedSepaBeneficiary'];
    /** Please see the Connection interface */
    ['TrustedBeneficiaryConnection']: {
        pageInfo: ModelTypes['PageInfo'];
        edges: Array<ModelTypes['TrustedBeneficiaryEdge']>;
        totalCount: number;
    };
    /** TrustedBeneficiary status consent pending */
    ['TrustedBeneficiaryConsentPending']: {
        /** status of the beneficiary  (set to `ConsentPending`) */
        status: ModelTypes['TrustedBeneficiaryStatus'];
        /** The consent required to initiate this beneficiary */
        consent: ModelTypes['Consent'];
    };
    /** Please see the Edge interface */
    ['TrustedBeneficiaryEdge']: {
        node: ModelTypes['TrustedBeneficiary'];
        cursor: string;
    };
    /** Filters that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryFiltersInput']: {
        status?: Array<ModelTypes['TrustedBeneficiaryStatus']> | undefined;
        type?: Array<ModelTypes['BeneficiaryType']> | undefined;
    };
    ['TrustedBeneficiaryOrderByFieldInput']: TrustedBeneficiaryOrderByFieldInput;
    /** Order that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryOrderByInput']: {
        field?: ModelTypes['TrustedBeneficiaryOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    ['TrustedBeneficiaryStatus']: TrustedBeneficiaryStatus;
    /** TrustedBeneficiary status information */
    ['TrustedBeneficiaryStatusInfo']: ModelTypes['TrustedBeneficiaryConsentPending'] | ModelTypes['TrustedBeneficiaryStatusInfoCanceled'] | ModelTypes['TrustedBeneficiaryStatusInfoEnabled'];
    /** TrustedBeneficiary status canceled */
    ['TrustedBeneficiaryStatusInfoCanceled']: {
        /** status of the beneficiary (set to `Canceled`) */
        status: ModelTypes['TrustedBeneficiaryStatus'];
        /** canceled Date */
        canceledAt: ModelTypes['DateTime'];
    };
    /** TrustedBeneficiary status enabled */
    ['TrustedBeneficiaryStatusInfoEnabled']: {
        /** status of the beneficiary (set to `Enabled`) */
        status: ModelTypes['TrustedBeneficiaryStatus'];
        /** enabled Date */
        enabledAt: ModelTypes['DateTime'];
    };
    /** Trusted Internal Beneficiary */
    ['TrustedInternalBeneficiary']: {
        /** unique identifier of a trusted beneficiary */
        id: string;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** full name of the beneficiary */
        name: string;
        /** label of the beneficiary */
        label: string;
        /** status information */
        statusInfo: ModelTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type: ModelTypes['BeneficiaryType'];
        /** beneficiary account Id */
        accountId: string;
    };
    /** Trusted International Beneficiary */
    ['TrustedInternationalBeneficiary']: {
        /** unique identifier of a trusted beneficiary */
        id: string;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** full name of the beneficiary */
        name: string;
        /** label of the beneficiary */
        label: string;
        /** status information */
        statusInfo: ModelTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type: ModelTypes['BeneficiaryType'];
        /** Currency of the international beneficiary account */
        currency: ModelTypes['Currency'];
        /** Currency-specific details of the beneficiary */
        details: Array<ModelTypes['KeyValue']>;
        /** Route that Swan will use to transfer the funds */
        route: ModelTypes['InternationalCreditTransferRouteInput'];
    };
    /** Trusted SEPA Beneficiary type SEPA */
    ['TrustedSepaBeneficiary']: {
        /** unique identifier of a trusted beneficiary */
        id: string;
        /** created date */
        createdAt: ModelTypes['DateTime'];
        /** updated date */
        updatedAt: ModelTypes['DateTime'];
        /** full name of the beneficiary */
        name: string;
        /** label of the beneficiary */
        label: string;
        /** status information */
        statusInfo: ModelTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type: ModelTypes['BeneficiaryType'];
        /** IBAN if the beneficiary is a an account in an other financial institution */
        iban: ModelTypes['IBAN'];
        /** beneficiary address */
        address?: ModelTypes['Address'] | undefined;
    };
    ['TypeOfRepresentation']: TypeOfRepresentation;
    /** Ultimate beneficial Direct Owner company info. */
    ['UltimateBeneficialDirectOwnerCompanyInfo']: {
        /** Ultimate Beneficial Owner Unique Identifier . */
        id: string;
        /** Ultimate beneficial Direct Owner Company type. */
        type: ModelTypes['UltimateBeneficialOwnerType'];
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio: number;
        /** Name of the company. */
        name: string;
        /** Registration number. */
        registrationNumber: string;
    };
    /** Ultimate beneficial Direct Owner individual info. */
    ['UltimateBeneficialDirectOwnerIndividualInfo']: {
        /** Ultimate Beneficial Owner Unique Identifier . */
        id: string;
        /** Ultimate beneficial Direct owner Individual type . */
        type: ModelTypes['UltimateBeneficialOwnerType'];
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio: number;
        /** First name. */
        firstName: string;
        /** Last name. */
        lastName: string;
        /** Birth date. */
        birthDate: ModelTypes['Date'];
    };
    /** Ultimate beneficial owner company info. */
    ['UltimateBeneficialIndirectOwnerCompanyInfo']: {
        /** Ultimate Beneficial Owner Unique Identifier . */
        id: string;
        /** Ultimate beneficial Indirect Owner Company type. */
        type: ModelTypes['UltimateBeneficialOwnerType'];
        /** Unique Reference of the Parent Company. */
        parentCompanyReference: string;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio: number;
        /** Name of the company. */
        name: string;
        /** Registration number. */
        registrationNumber: string;
    };
    /** Ultimate beneficial Indirect Owner individual info. */
    ['UltimateBeneficialIndirectOwnerIndividualInfo']: {
        /** Ultimate Beneficial Owner Unique Identifier. */
        id: string;
        /** Ultimate beneficial Indirect Owner Individual type . */
        type: ModelTypes['UltimateBeneficialOwnerType'];
        /** Unique Reference of the Parent Company. */
        parentCompanyReference: string;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio: number;
        /** First name. */
        firstName: string;
        /** Last name. */
        lastName: string;
        /** Birth date. */
        birthDate: ModelTypes['Date'];
    };
    /** The Ultimate Beneficial Owner could be for an Individual or a Company and these can Direct or Indirect */
    ['UltimateBeneficialOwnerInfo']: ModelTypes['UltimateBeneficialDirectOwnerCompanyInfo'] | ModelTypes['UltimateBeneficialDirectOwnerIndividualInfo'] | ModelTypes['UltimateBeneficialIndirectOwnerCompanyInfo'] | ModelTypes['UltimateBeneficialIndirectOwnerIndividualInfo'];
    ['UltimateBeneficialOwnerType']: UltimateBeneficialOwnerType;
    /** Upcoming transaction status information */
    ['UpcomingTransactionStatusInfo']: {
        /** status of the transaction */
        status: ModelTypes['TransactionStatus'];
        /** The date when the transaction will be executed */
        executionDate: ModelTypes['DateTime'];
    };
    ['UpdateAccountHolderInput']: {
        accountHolderId: string;
        vatNumber?: string | undefined;
        taxIdentificationNumber?: string | undefined;
    };
    ['UpdateAccountHolderPayload']: ModelTypes['UpdateAccountHolderSuccessPayload'] | ModelTypes['AccountHolderNotFoundRejection'] | ModelTypes['ValidationRejection'];
    ['UpdateAccountHolderSuccessPayload']: {
        accountHolder: ModelTypes['AccountHolder'];
    };
    /** Inputs to update an account */
    ['UpdateAccountInput']: {
        /** Unique identifier of an account */
        accountId: string;
        /** Name */
        name?: string | undefined;
        /** Language */
        language?: ModelTypes['AccountLanguage'] | undefined;
    };
    /** Inputs to update an account membership */
    ['UpdateAccountMembershipInput']: {
        /** Unique identifier of an account membership */
        accountMembershipId: string;
        /** Email address */
        email?: string | undefined;
        /** Restricted to a user if necessary */
        restrictedTo?: ModelTypes['UpdatedRestrictedToInput'] | undefined;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount?: boolean | undefined;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries?: boolean | undefined;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments?: boolean | undefined;
        /** `true` if this account membership can invite, update, suspend or resume memberships */
        canManageAccountMembership?: boolean | undefined;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** Periodic Spending limit */
        spendingLimit?: ModelTypes['SpendingLimitInput'] | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Residency address of the member to be added */
        residencyAddress?: ModelTypes['ResidencyAddressInput'] | undefined;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined;
    };
    ['UpdateAccountMembershipPayload']: ModelTypes['UpdateAccountMembershipSuccessPayload'] | ModelTypes['AccountMembershipCannotBeUpdatedRejection'] | ModelTypes['AccountMembershipNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InvalidPhoneNumberRejection'] | ModelTypes['PermissionCannotBeGrantedRejection'] | ModelTypes['UserNotAllowedToManageAccountMembershipRejection'] | ModelTypes['ValidationRejection'];
    ['UpdateAccountMembershipSuccessPayload']: {
        consent: ModelTypes['Consent'];
    };
    ['UpdateAccountPayload']: ModelTypes['UpdateAccountSuccessPayload'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['BadAccountStatusRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['ValidationRejection'];
    ['UpdateAccountSuccessPayload']: {
        account: ModelTypes['Account'];
    };
    /** Input to Update Card */
    ['UpdateCardInput']: {
        /** Unique identifier of the card to update */
        cardId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: ModelTypes['DateTime'] | undefined;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Periodic Spending limit */
        spendingLimit?: ModelTypes['SpendingLimitInput'] | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Card name */
        name?: string | undefined;
    };
    ['UpdateCardPayload']: ModelTypes['UpdateCardSuccessPayload'] | ModelTypes['AccountNotFoundRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['AccountMembershipNotAllowedRejection'] | ModelTypes['ValidationRejection'];
    ['UpdateCardSuccessPayload']: {
        consent: ModelTypes['Consent'];
    };
    ['UpdateCompanyOnboardingInput']: {
        /** Account name of the company account holder. Length must be from 0 to 100 characters */
        accountName?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ModelTypes['AccountCountry'] | undefined;
        /** Name of the company. Length must be from 0 to 255 characters */
        name?: string | undefined;
        /** Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters */
        registrationNumber?: string | undefined;
        /** Type of the company (Association ...) */
        companyType?: ModelTypes['CompanyType'] | undefined;
        /** Business activity */
        businessActivity?: ModelTypes['BusinessActivity'] | undefined;
        /** Business activity description. Length must be from 0 to 1024 characters */
        businessActivityDescription?: string | undefined;
        /** Estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: ModelTypes['MonthlyPaymentVolume'] | undefined;
        /** The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
    
    The ultimate beneficial owner is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<ModelTypes['IndividualUltimateBeneficialOwnerInput']> | undefined;
        /** Residency address of the head office (Must be in a European country) */
        residencyAddress?: ModelTypes['ResidencyAddressInput'] | undefined;
        /** Email of the legal representative. Length must be from 0 to 255 characters */
        email?: string | undefined;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined;
        /** Id of onboarding to be updated. Must be a valid UUID v4. Required */
        onboardingId: string;
        /** VAT number */
        vatNumber?: string | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: ModelTypes['AddressInformationInput'] | undefined;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: ModelTypes['TypeOfRepresentation'] | undefined;
    };
    /** Possible results for mutation `updateCompanyOnboarding` */
    ['UpdateCompanyOnboardingPayload']: ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['UpdateCompanyOnboardingSuccessPayload'] | ModelTypes['ValidationRejection'];
    /** Result when updateCompanyOnboarding is a success */
    ['UpdateCompanyOnboardingSuccessPayload']: {
        onboarding: ModelTypes['OnboardingInfo'];
    };
    /** Input when the account membership is restricted to a verified user */
    ['UpdatedRestrictedToInput']: {
        /** Account member first name */
        firstName?: string | undefined;
        /** Account member last name */
        lastName?: string | undefined;
        /** Account member birth date */
        birthDate?: ModelTypes['Date'] | undefined;
        /** Account member phone number */
        phoneNumber?: string | undefined;
    };
    ['UpdateIndividualOnboardingInput']: {
        /** Account name of the individual account holder. Length must be from 0 to 255 characters */
        accountName?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: ModelTypes['AccountCountry'] | undefined;
        /** Employment status of the individual account holder */
        employmentStatus?: ModelTypes['EmploymentStatus'] | undefined;
        /** Monthly income of the individual account holder */
        monthlyIncome?: ModelTypes['MonthlyIncome'] | undefined;
        /** Residency address of the individual account holder (must be in a European country) */
        residencyAddress?: ModelTypes['ResidencyAddressInput'] | undefined;
        /** Email. Length must be from 0 to 255 characters */
        email?: string | undefined;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined;
        /** Id of onboarding to be updated. Must be a valid UUID v4. Required */
        onboardingId: string;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
    };
    /** Possible result types for `updateIndividualOnboarding` */
    ['UpdateIndividualOnboardingPayload']: ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['UpdateIndividualOnboardingSuccessPayload'] | ModelTypes['ValidationRejection'];
    /** Type of result when updateIndividualOnboarding is a success */
    ['UpdateIndividualOnboardingSuccessPayload']: {
        onboarding: ModelTypes['OnboardingInfo'];
    };
    /** Inputs to update a received sepa direct debit mandate B2b. */
    ['UpdateReceivedSepaDirectDebitB2bMandateInput']: {
        /** The unique mandate id */
        receivedDirectDebitMandateId: string;
        /** The unique identifier of the received direct debit mandate */
        mandateReference?: string | undefined;
        /** The Sepa Creditor Identifier of the creditor */
        creditorIdentifier?: string | undefined;
        /** The name of the creditor */
        creditorName?: string | undefined;
        /** The Swan Iban of the debtor */
        iban?: string | undefined;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** Union type returned by the updateReceivedSepaDirectDebitB2bMandate mutation */
    ['UpdateReceivedSepaDirectDebitB2bMandatePayload']: ModelTypes['UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload'] | ModelTypes['ReceivedDirectDebitMandateNotFoundRejection'] | ModelTypes['ForbiddenRejection'] | ModelTypes['ReceivedDirectDebitMandateAlreadyExistRejection'] | ModelTypes['ReceivedDirectDebitMandateNotB2bRejection'] | ModelTypes['AccountNotFoundRejection'];
    /** Return type in case of a successful response of the updateReceivedSepaDirectDebitB2bMandate mutation */
    ['UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload']: {
        /** The received direct debit mandate updated */
        receivedDirectDebitMandate: ModelTypes['ReceivedDirectDebitMandate'];
    };
    ['UpdateSupportingDocumentInput']: {
        supportingDocumentId: string;
        supportingDocumentType?: ModelTypes['SupportingDocumentType'] | undefined;
        supportingDocumentPurpose?: ModelTypes['SupportingDocumentPurposeEnum'] | undefined;
    };
    ['UpdateSupportingDocumentPayload']: ModelTypes['UpdateSupportingDocumentSuccessPayload'] | ModelTypes['ForbiddenRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['SupportingDocumentCollectionNotFoundRejection'] | ModelTypes['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection'] | ModelTypes['SupportingDocumentNotFoundRejection'] | ModelTypes['SupportingDocumentStatusDoesNotAllowUpdateRejection'] | ModelTypes['ValidationRejection'];
    ['UpdateSupportingDocumentSuccessPayload']: {
        supportingDocument: ModelTypes['SupportingDocument'];
    };
    ['UpdateUserConsentSettingsInput']: {
        /** Swan user id */
        userId: string;
        /** Preferred consent notification channel, Sms or App */
        preferredNotificationChannel: ModelTypes['PreferredNotificationChannel'];
    };
    ['UpdateUserConsentSettingsPayload']: ModelTypes['UpdateUserConsentSettingsSuccessPayload'] | ModelTypes['UpdateUserConsentSettingsTokenRejection'];
    ['UpdateUserConsentSettingsSuccessPayload']: {
        userConsentSettings: ModelTypes['UserConsentSettings'];
    };
    ['UpdateUserConsentSettingsTokenRejection']: {
        message: string;
    };
    ['Upload']: any;
    /** URL that follows the WHATWG URL Standard.
  
  [Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself. */
    ['URL']: any;
    /** The User is the unique user, natural person, of the Swan app. */
    ['User']: {
        /** unique identifier of the user */
        id: string;
        /** The list of account memberships
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        accountMemberships: ModelTypes['AccountMembershipConnection'];
        /** mobile phone number with the international format (Example: +33689788967) */
        mobilePhoneNumber?: ModelTypes['PhoneNumber'] | undefined;
        /** first name */
        firstName?: string | undefined;
        /** last name */
        lastName?: string | undefined;
        /** list of first names */
        allFirstNames?: Array<string> | undefined;
        /** birth date */
        birthDate?: ModelTypes['Date'] | undefined;
        /** nationality */
        nationalityCCA3?: ModelTypes['CCA3'] | undefined;
        /** `true` if Swan has verified the user's identity */
        idVerified: boolean;
        /** the methods used to authenticate this user */
        authenticators?: Array<ModelTypes['Authenticator']> | undefined;
        /** Identification status
    
    Each attempt to go through our identity verification process will update this value.
    
    This field is only available for the current user. */
        identificationStatus?: ModelTypes['IdentificationStatus'] | undefined;
        /** List of identification levels available for the user.
    
    Whenever TRUE, it means the identification was successful for the associated level. */
        identificationLevels?: ModelTypes['IdentificationLevels'] | undefined;
        /** Preferred notification channel
    
    When it is "null" it means that the preferences have not been updated. Default SMS in use */
        preferredNotificationChannel?: ModelTypes['PreferredNotificationChannel'] | undefined;
        /** Creation date of the user */
        createdAt: ModelTypes['DateTime'];
        /** Last update date of the user */
        updatedAt: ModelTypes['DateTime'];
        /** Date on which the user joined the project. Joining the project is done after the first accepted OAuth login. */
        joinedAt: ModelTypes['DateTime'];
        identifications?: ModelTypes['IdentificationConnection'] | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['UserConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** UserEdge list */
        edges: Array<ModelTypes['UserEdge']>;
    };
    ['UserConsentSettings']: {
        /** Preferred notification channel */
        preferredNotificationChannel: ModelTypes['PreferredNotificationChannel'];
        /** User identifier */
        userId: string;
        /** Project identifier */
        projectId: string;
    };
    /** Implements the Relay Edge interface */
    ['UserEdge']: {
        /** Opaque identifier pointing to this consent node in the pagination mechanism */
        cursor: string;
        /** The consent */
        node: ModelTypes['User'];
    };
    ['UserFilterInput']: {
        birthDate?: ModelTypes['Date'] | undefined;
        firstName?: string | undefined;
        identificationLevel?: ModelTypes['IdentificationLevelInput'] | undefined;
        lastName?: string | undefined;
        mobilePhoneNumber?: string | undefined;
        nationalityCCA3?: ModelTypes['CCA3'] | undefined;
        preferredNotificationChannel?: ModelTypes['PreferredNotificationChannel'] | undefined;
        /** Searches first name, last name, phone number and id
    Min length : 3 characters */
        search?: string | undefined;
    };
    ['UserNotAllowedToDisableItsOwnAccountMembershipRejection']: {
        accountMembershipId: string;
        message: string;
    };
    /** Rejection returned if a identity does not have enough permission to manage account membership */
    ['UserNotAllowedToManageAccountMembershipRejection']: {
        message: string;
    };
    ['UserNotAllowedToSuspendItsOwnAccountMembershipRejection']: {
        accountMembershipId: string;
        message: string;
    };
    /** Rejection returned when the User is not the Card Holder */
    ['UserNotCardHolderRejection']: {
        message: string;
    };
    ['UserOrderByFieldInput']: UserOrderByFieldInput;
    /** Order that can be applied when listing users */
    ['UserOrderByInput']: {
        field?: ModelTypes['UserOrderByFieldInput'] | undefined;
        direction?: ModelTypes['OrderByDirection'] | undefined;
    };
    /** A detail of a validation error : what field is errored and why */
    ['ValidationError']: {
        /** Onboarding property that is not matching requirements to allow a finalization */
        field: string;
        /** Constraints that are not matched on the Onboarding property */
        errors?: Array<ModelTypes['FieldValidationError']> | undefined;
    };
    ['ValidationFieldError']: {
        code: ModelTypes['ValidationFieldErrorCode'];
        message: string;
        path: Array<string>;
    };
    ['ValidationFieldErrorCode']: ValidationFieldErrorCode;
    /** Rejection returned if an input contains invalid data */
    ['ValidationRejection']: {
        fields: Array<ModelTypes['ValidationFieldError']>;
        message: string;
    };
    /** Information extracted from a valid IBAN */
    ['ValidIban']: {
        /** Iban from input */
        iban: ModelTypes['IBAN'];
        /** Account Number extracted from the IBAN */
        accountNumber: string;
        /** Checksum extracted from the IBAN */
        checksum: string;
        /** Bank that owns this IBAN */
        bank: ModelTypes['Bank'];
        /** Reachability of this IBAN over different payment methods */
        reachability: ModelTypes['Reachability'];
    };
    /** Describes a valid identification level for the process associated to this identification, and identification documents can be accessed */
    ['ValidIdentificationLevelStatusInfo']: {
        /** Always set to `Valid` */
        status: ModelTypes['SwanIdentificationStatus'];
    };
    ['VerificationFlow']: VerificationFlow;
    ['VerificationStatus']: VerificationStatus;
    /** Enabled Information */
    ['VerifiedStatusInfo']: {
        /** Date at which the verification was verified */
        verifiedAt: ModelTypes['DateTime'];
        /** Account verification status (Verified) */
        status: ModelTypes['AccountVerificationStatus'];
    };
    ['ViewCardNumbersInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ViewCardNumbersPayload']: ModelTypes['ViewCardNumbersSuccessPayload'] | ModelTypes['UserNotCardHolderRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['ValidationRejection'];
    ['ViewCardNumbersSuccessPayload']: {
        /** The consent required to view card numbers */
        consent: ModelTypes['Consent'];
    };
    ['ViewPhysicalCardNumbersInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ViewPhysicalCardNumbersPayload']: ModelTypes['ViewPhysicalCardNumbersSuccessPayload'] | ModelTypes['UserNotCardHolderRejection'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['ValidationRejection'];
    ['ViewPhysicalCardNumbersSuccessPayload']: {
        /** The consent required to view card numbers */
        consent: ModelTypes['Consent'];
    };
    ['ViewPhysicalCardPinInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ViewPhysicalCardPinPayload']: ModelTypes['ViewPhysicalCardPinSuccessPayload'] | ModelTypes['CardNotFoundRejection'] | ModelTypes['PhysicalCardNotFoundRejection'] | ModelTypes['PINNotReadyRejection'] | ModelTypes['UserNotCardHolderRejection'] | ModelTypes['ValidationRejection'];
    ['ViewPhysicalCardPinSuccessPayload']: {
        /** The consent required to view card numbers */
        consent: ModelTypes['Consent'];
    };
    /** Virtual IBAN can be used by the account holder to receive SCT (Sepa Credit Transfer) or to be debited by SDD (Sepa Direct Debit). */
    ['VirtualIBANEntry']: {
        /** Unique identifier of a Virtual IBAN entry */
        id: string;
        /** International Bank Account Number */
        IBAN: ModelTypes['IBAN'];
        /** Bank Identifier Code */
        BIC: ModelTypes['BIC'];
        /** Label (could be used to identify) */
        label?: string | undefined;
        /** Status of the Iban */
        status: ModelTypes['IBANStatus'];
        /** `true` if the Virtual IBAN refuses all Sepa Direct Debit received */
        blockSDD: boolean;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['VirtualIBANEntryConnection']: {
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: ModelTypes['PageInfo'];
        /** VirtualIBANEntryEdge list */
        edges: Array<ModelTypes['VirtualIBANEntryEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['VirtualIBANEntryEdge']: {
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The virtual iban entry */
        node: ModelTypes['VirtualIBANEntry'];
    };
    /** Wallet Provider (ApplePay, GooglePay ...) */
    ['WalletProvider']: {
        /** name of the Wallet Provider (Apple / Google / Amazon or Unknown) */
        name: string;
        /** id of the Wallet Provider */
        id: string;
    };
    ['WalletProviderType']: WalletProviderType;
    ['WalletToken']: any;
    ['WebBankingSettings']: {
        canViewAccountDetails?: boolean | undefined;
        canViewAccountStatement?: boolean | undefined;
        canManageVirtualIbans?: boolean | undefined;
        canInitiatePaymentsToNewBeneficiaries?: boolean | undefined;
        canViewPaymentList?: boolean | undefined;
        canOrderVirtualCards?: boolean | undefined;
        canOrderPhysicalCards?: boolean | undefined;
        canViewMembers?: boolean | undefined;
        canAddNewMembers?: boolean | undefined;
    };
    /** A WebhookEvent Log for webhooks service.
  It describes the response and call context for webhook endpoints
  for a specific event. */
    ['WebhookEventLog']: {
        /** Unique identifier of the EventLog */
        id: string;
        /** Date the EventLog has been created */
        createdAt: ModelTypes['DateTime'];
        /** Unique identifier of the event that triggered this eventLog */
        eventId: string;
        /** Date the Event has been generated */
        eventDate: ModelTypes['DateTime'];
        /** The type of the triggering event */
        eventType: string;
        /** Unique identifier linked of the resource carried by the Event */
        resourceId: string;
        /** Duration of the callback in MS */
        duration: number;
        /** Request payload send to callback in string format, jsonable. */
        requestPayload: string;
        /** Response payload get by the callback in string format, jsonable. */
        responsePayload?: string | undefined;
        /** The callback response status in number format. */
        statusCode?: number | undefined;
        /** The callback response status in text format. */
        statusText?: ModelTypes['StatusText'] | undefined;
        /** The webhook that triggered the event. */
        webhookSubscription?: ModelTypes['WebhookSubscription'] | undefined;
        /** Rank of this retry */
        retryCount?: number | undefined;
        /** Label of the associated subscription (inherited)
    This holds the label value of when the log was created, whereas
    webhookSubscription.label holds the current value of the label
    (it may have changed). */
        webhookSubscriptionLabel?: string | undefined;
        /** Endpoint of the associated subscription (inherited)
    This holds the endpoint value of when the log was created, whereas
    webhookSubscription.endpoint holds the current value of the endpoint
    (it may have changed). */
        webhookSubscriptionEndpoint?: string | undefined;
    };
    /** Filters that can be applied when listing eventLog */
    ['WebhookEventLogFiltersInput']: {
        statusCode?: number | undefined;
        statusText?: ModelTypes['StatusText'] | undefined;
        startDate?: ModelTypes['DateTime'] | undefined;
        endDate?: ModelTypes['DateTime'] | undefined;
        eventType?: string | undefined;
        eventId?: string | undefined;
        resourceId?: string | undefined;
        webhookSubscriptionId?: string | undefined;
    };
    /** Rejection returned when Webhook event log id is not found */
    ['WebhookEventLogNotFoundRejection']: {
        message: string;
    };
    /** A Subscription to the webhooks service.
  It describes the registration of a callback url (the endpoint)
  and a list of event types the client wants to be notified of. */
    ['WebhookSubscription']: {
        /** Unique identifier of the Subscription */
        id: string;
        /** A client provided short description of the Subscription */
        label: string;
        /** The callback URL to be used for POSTing events */
        endpoint: string;
        /** The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
    (max 36 characters) */
        secret?: string | undefined;
        /** The types of subscribed events
    A simple list of unique IDs */
        eventTypes: Array<string>;
        /** Date the Subscription has been created */
        createdAt: ModelTypes['DateTime'];
        /**   Last date the Subscription has been updated,
    except for state changes */
        updatedAt: ModelTypes['DateTime'];
        /** The current state of the Subscription */
        statusInfo: ModelTypes['WebhookSubscriptionStatusInfo'];
        /** KPI data about the subscription (7 last days) */
        kpi?: ModelTypes['WebhookSubscriptionKpi'] | undefined;
    };
    ['WebhookSubscriptionBrokenStatusInfo']: {
        status: ModelTypes['WebhookSubscriptionStatus'];
        brokenAt: ModelTypes['DateTime'];
    };
    ['WebhookSubscriptionCreationStatus']: WebhookSubscriptionCreationStatus;
    ['WebhookSubscriptionDisabledStatusInfo']: {
        status: ModelTypes['WebhookSubscriptionStatus'];
        disabledAt: ModelTypes['DateTime'];
    };
    ['WebhookSubscriptionEnabledStatusInfo']: {
        status: ModelTypes['WebhookSubscriptionStatus'];
        enabledAt: ModelTypes['DateTime'];
    };
    ['WebhookSubscriptionKpi']: {
        /** Total number of eventLogs associated to this subscription */
        totalHits: number;
        /** Total number of eventLogs that failed associated to this subscription
    errorRate = (errorRate/totalHits) * 100, rounded */
        errorRate: number;
    };
    /** Rejection returned when Webhook Subscription is not found */
    ['WebhookSubscriptionNotFoundRejection']: {
        message: string;
    };
    ['WebhookSubscriptionPayload']: ModelTypes['WebhookSubscriptionSuccessPayload'] | ModelTypes['WebhookSubscriptionNotFoundRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['InvalidArgumentRejection'];
    ['WebhookSubscriptionStatus']: WebhookSubscriptionStatus;
    ['WebhookSubscriptionStatusInfo']: ModelTypes['WebhookSubscriptionBrokenStatusInfo'] | ModelTypes['WebhookSubscriptionDisabledStatusInfo'] | ModelTypes['WebhookSubscriptionEnabledStatusInfo'];
    ['WebhookSubscriptionSuccessPayload']: {
        webhookSubscription: ModelTypes['WebhookSubscription'];
    };
    ['WebhookUnsubscribePayload']: ModelTypes['WebhookUnsubscribeSuccessPayload'] | ModelTypes['WebhookSubscriptionNotFoundRejection'] | ModelTypes['InternalErrorRejection'] | ModelTypes['InvalidArgumentRejection'];
    ['WebhookUnsubscribeSuccessPayload']: {
        unsubscribed: boolean;
    };
    /** Rejection returned when a parameter has a wrong value */
    ['WrongValueProvidedRejection']: {
        message: string;
        valueProvided: string;
        parameterName: string;
    };
    ['schema']: {
        query?: ModelTypes['Query'] | undefined;
        mutation?: ModelTypes['Mutation'] | undefined;
    };
};
export type GraphQLTypes = {
    /** Whether you call it a wallet, monetary account, payment account or bank account, the notion of account is fundamental at Swan. All payment flows necessarily go through an account. */
    ['Account']: {
        __typename: 'Account';
        /** Unique identifier of an account */
        id: string;
        /** Unique account number */
        number: GraphQLTypes['AccountNumber'];
        /** Account name */
        name: string;
        /** Account holder */
        holder: GraphQLTypes['AccountHolder'];
        /** Cash account type */
        cashAccountType: GraphQLTypes['CashAccountType'];
        /** Country of the account */
        country: GraphQLTypes['AccountCountry'];
        /** Payment level */
        paymentLevel: GraphQLTypes['PaymentLevel'];
        /** Bank Identifier Code
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        BIC: GraphQLTypes['BIC'];
        /** International Bank Account Number
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        IBAN?: GraphQLTypes['IBAN'] | undefined;
        /** Currency */
        currency: GraphQLTypes['Currency'];
        /** `true` if the main IBAN refuses all Sepa Direct Debit received */
        blockSDD?: boolean | undefined;
        /** Status of the account */
        statusInfo: GraphQLTypes['AccountStatusInfo'];
        /** Partnership status */
        partnershipStatusInfo?: GraphQLTypes['PartnershipStatusInfo'] | undefined;
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** List of Virtual IBAN
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        virtualIbanEntries: GraphQLTypes['VirtualIBANEntryConnection'];
        /** List of account membership for this account
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        memberships: GraphQLTypes['AccountMembershipConnection'];
        /** `true`if a consent is required to fetch new transactions */
        requiredConsentToFetchNewTransactions: boolean;
        /** Language used for account statements */
        language: GraphQLTypes['AccountLanguage'];
        /** Legal representative account membership */
        legalRepresentativeMembership: GraphQLTypes['AccountMembership'];
        /** Type of the account : EMoney if account holder has not finished the KYC requirements, PaymentService otherwise */
        paymentAccountType: GraphQLTypes['PaymentAccountType'];
        /** Date of the account going from eMoney to PaymentService */
        upgradedAt?: GraphQLTypes['DateTime'] | undefined;
        /** Link to the account's bank details */
        bankDetails?: string | undefined;
        /** Legal Documents linked to the account
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        legalDocuments?: GraphQLTypes['LegalDocumentConnection'] | undefined;
        /** A list of balances regarding an account. */
        balances?: GraphQLTypes['AccountBalances'] | undefined;
        /** List of statements of an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    *For a Project access token, this is all the transactions of the project (only available with project access token)* */
        statements?: GraphQLTypes['StatementConnection'] | undefined;
        /** A list of transactions of an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: GraphQLTypes['TransactionConnection'] | undefined;
        /** A list of invoices of an account.
    The list is ordered by creation date (from newest to oldest)
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        invoices?: GraphQLTypes['InvoiceConnection'] | undefined;
        /** A list of receive Direct Mandates of an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        receivedDirectDebitMandates?: GraphQLTypes['ReceivedDirectDebitMandateConnection'] | undefined;
        /** List of merchant profiles created on the account */
        merchantProfiles?: GraphQLTypes['MerchantProfileConnection'] | undefined;
        /** A list of standing orders regarding an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        standingOrders: GraphQLTypes['StandingOrderConnection'];
        /** List of funding source created on the account
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        fundingSources?: GraphQLTypes['FundingSourceConnection'] | undefined;
        /** List of trusted beneficiaries of an account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        trustedBeneficiaries: GraphQLTypes['TrustedBeneficiaryConnection'];
    };
    /** A list of balances regarding an account. */
    ['AccountBalances']: {
        __typename: 'AccountBalances';
        /** Balance composed of booked, pending transactions and rolling reserve used known at the time of calculation. */
        available: GraphQLTypes['Amount'];
        /** Balance just composed of pending transactions. */
        pending: GraphQLTypes['Amount'];
        /** Balance just composed of booked transactions. */
        booked: GraphQLTypes['Amount'];
        /** Balance just composed of rolling reserve used in booked transactions. */
        reserved: GraphQLTypes['Amount'];
    };
    /** Account Closed status information */
    ['AccountClosedStatus']: {
        __typename: 'AccountClosedStatus';
        /** Account status (always Closed for type AccountClosedStatus) */
        status: GraphQLTypes['AccountStatus'];
        /** Reason why the account is suspended
    @Deprecated */
        reason: string;
        /** Reason why the account is currently closed */
        reasonInfo: GraphQLTypes['CloseAccountStatusReason'];
    };
    /** Account Closing status information */
    ['AccountClosingStatus']: {
        __typename: 'AccountClosingStatus';
        /** Account status (always Closing for type AccountClosingStatus) */
        status: GraphQLTypes['AccountStatus'];
        /** Reason why the account is suspended
    @Deprecated */
        reason: string;
        /** Reason why the account is currently in closing */
        reasonInfo: GraphQLTypes['CloseAccountStatusReason'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['AccountConnection']: {
        __typename: 'AccountConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** AccountEdge list */
        edges: Array<GraphQLTypes['AccountEdge']>;
    };
    /** Refers to the country of the account. It will determine the country code of the local IBAN of the account.
  
  Available Account Country: CCA3 */
    ['AccountCountry']: AccountCountry;
    /** Implements the Relay Edge interface */
    ['AccountEdge']: {
        __typename: 'AccountEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The account */
        node: GraphQLTypes['Account'];
    };
    ['AccountFilterInput']: {
        /** Account Status we want to filter on */
        status?: Array<GraphQLTypes['AccountStatus']> | undefined;
        /** Account Payment Levels we want to filter on */
        paymentLevels?: Array<GraphQLTypes['PaymentLevel']> | undefined;
        /** Searches name, account number, and IBAN */
        search?: string | undefined;
    };
    ['AccountFundingLimitsReachedReason']: AccountFundingLimitsReachedReason;
    /** The account holder is the person who owns the money stored in the account. The account holder can be one of your customers, whether it is a natural person or a legal person, or quite simply you. */
    ['AccountHolder']: {
        __typename: 'AccountHolder';
        /** Unique identifier of the account holder. */
        id: string;
        /** Verification status.
         *Banking regulations require financial institutions such as Swan to know and verify their customers in order to comply with their anti-money laundering and terrorist financing obligations. In banking jargon, we talk about KYC (Know Your Customers) procedure* */
        verificationStatus: GraphQLTypes['VerificationStatus'];
        /** Account holder type information. */
        info: GraphQLTypes['AccountHolderInfo'];
        /** Account holder status information. */
        statusInfo?: GraphQLTypes['AccountHolderStatusInfo'] | undefined;
        /** Residency address. */
        residencyAddress: GraphQLTypes['AddressInfo'];
        /** Created date. */
        createdDate: GraphQLTypes['DateTime'];
        /** Updated date. */
        updatedDate: GraphQLTypes['DateTime'];
        /** List of accounts owned by the account holder.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        accounts: GraphQLTypes['AccountConnection'];
        /** List of supporting document collection for an account holder
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        supportingDocumentCollections: GraphQLTypes['SupportingDocumentCollectionConnection'];
        /** List of funding limit settings change request for an account holder
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        fundingLimitSettingsChangeRequests: GraphQLTypes['FundingLimitSettingsChangeRequestConnection'];
        /** Account holder onboarding */
        onboarding?: GraphQLTypes['Onboarding'] | undefined;
        /** List of external account owned by the account holder
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        externalAccounts: GraphQLTypes['ExternalAccountConnection'];
        /** A list of Payment Mandates for an account holder.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        paymentMandates?: GraphQLTypes['PaymentMandateConnection'] | undefined;
        /** Funding limit settings */
        fundingLimitSettings?: GraphQLTypes['FundingLimitSettings'] | undefined;
    };
    /** Account Holder Canceled Status Information */
    ['AccountHolderCanceledStatusInfo']: {
        __typename: 'AccountHolderCanceledStatusInfo';
        /** Status of the account holder. */
        status: GraphQLTypes['AccountHolderStatus'];
        /** Reason why the account holder is suspended. */
        reason: string;
    };
    ['AccountHolderCompanyInfo']: {
        __typename: 'AccountHolderCompanyInfo';
        /** Account holder type (always Company for type AccountHolderCompanyInfo) */
        type: GraphQLTypes['AccountHolderType'];
        /** Name of the company. */
        name: string;
        /** Registration number of the company (SIRET, ...). */
        registrationNumber?: string | undefined;
        /** Registration date of the company. */
        companyRegistrationDate?: GraphQLTypes['Date'] | undefined;
        /** Legal form of the company (SAS, SCI, SASU, ...). */
        companyType?: GraphQLTypes['CompanyType'] | undefined;
        /** Business activity. */
        businessActivity: GraphQLTypes['BusinessActivity'];
        /** Business activity description.
    This must be 1024 characters long maximum. */
        businessActivityDescription: string;
        /** Estimated monthly payment volume (euro). */
        monthlyPaymentVolume: GraphQLTypes['MonthlyPaymentVolume'];
        /** The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
    
    The ultimate beneficiary is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners: Array<GraphQLTypes['IndividualUltimateBeneficialOwner']>;
        /** Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT */
        vatNumber?: string | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: GraphQLTypes['AddressInformation'] | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)). */
    ['AccountHolderConnection']: {
        __typename: 'AccountHolderConnection';
        /** Total number of element in the list. */
        totalCount: number;
        /** Information about the current, the previous and the next page. */
        pageInfo: GraphQLTypes['PageInfo'];
        /** AccountHolderEdge list. */
        edges: Array<GraphQLTypes['AccountHolderEdge']>;
    };
    /** Implements the Relay Edge interface. */
    ['AccountHolderEdge']: {
        __typename: 'AccountHolderEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism. */
        cursor: string;
        /** The account holder. */
        node: GraphQLTypes['AccountHolder'];
    };
    /** Account Holder Enabled Status Information */
    ['AccountHolderEnabledStatusInfo']: {
        __typename: 'AccountHolderEnabledStatusInfo';
        /** Status of the account holder. */
        status: GraphQLTypes['AccountHolderStatus'];
    };
    ['AccountHolderFilterInput']: {
        status?: Array<GraphQLTypes['AccountHolderStatus']> | undefined;
        types?: Array<GraphQLTypes['AccountHolderType']> | undefined;
        verificationStatus?: Array<GraphQLTypes['VerificationStatus']> | undefined;
        /** Searches company name, first name, last name */
        search?: string | undefined;
        firstName?: string | undefined;
        lastName?: string | undefined;
        birthDate?: string | undefined;
        registrationNumber?: string | undefined;
    };
    /** Individual account holder. */
    ['AccountHolderIndividualInfo']: {
        __typename: 'AccountHolderIndividualInfo';
        /** Account holder type (always Individual for type AccountHolderIndividualInfo). */
        type: GraphQLTypes['AccountHolderType'];
        /** Account Holder's first name and last name. */
        name: string;
        /** Employment status of the account holder (regulatory questions). */
        employmentStatus: GraphQLTypes['EmploymentStatus'];
        /** Monthly income of the account holder (regulatory questions). */
        monthlyIncome: GraphQLTypes['MonthlyIncome'];
        /** User of the individual account holder. */
        user: GraphQLTypes['User'];
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
    };
    /** Account holder types. */
    ['AccountHolderInfo']: {
        __typename: 'AccountHolderCompanyInfo' | 'AccountHolderIndividualInfo';
        /** Account holder type */
        type: GraphQLTypes['AccountHolderType'];
        /** Account holder name */
        name: string;
        ['...on AccountHolderCompanyInfo']: '__union' & GraphQLTypes['AccountHolderCompanyInfo'];
        ['...on AccountHolderIndividualInfo']: '__union' & GraphQLTypes['AccountHolderIndividualInfo'];
    };
    /** Rejection returned when the Account Holder was not found */
    ['AccountHolderNotFoundRejection']: {
        __typename: 'AccountHolderNotFoundRejection';
        message: string;
    };
    /** Field we can use when ordering that can be applied when listing account holders */
    ['AccountHolderOrderByFieldInput']: AccountHolderOrderByFieldInput;
    /** Order that can be applied when listing account holders */
    ['AccountHolderOrderByInput']: {
        field?: GraphQLTypes['AccountHolderOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Account holder status. */
    ['AccountHolderStatus']: AccountHolderStatus;
    /** Account Holder Status Information */
    ['AccountHolderStatusInfo']: {
        __typename: 'AccountHolderCanceledStatusInfo' | 'AccountHolderEnabledStatusInfo' | 'AccountHolderSuspendedStatusInfo';
        /** Status of the account holder. */
        status: GraphQLTypes['AccountHolderStatus'];
        ['...on AccountHolderCanceledStatusInfo']: '__union' & GraphQLTypes['AccountHolderCanceledStatusInfo'];
        ['...on AccountHolderEnabledStatusInfo']: '__union' & GraphQLTypes['AccountHolderEnabledStatusInfo'];
        ['...on AccountHolderSuspendedStatusInfo']: '__union' & GraphQLTypes['AccountHolderSuspendedStatusInfo'];
    };
    /** Account Holder Suspended Status Information */
    ['AccountHolderSuspendedStatusInfo']: {
        __typename: 'AccountHolderSuspendedStatusInfo';
        /** Status of the account holder. */
        status: GraphQLTypes['AccountHolderStatus'];
        /** Reason why the account holder is suspended. */
        reason: string;
    };
    /** Account holder type */
    ['AccountHolderType']: AccountHolderType;
    /** Rejection returned if the account holder type is individual.
  An individual account holder can't create a b2b received direct debit mandate. */
    ['AccountHolderTypeIndividualRejection']: {
        __typename: 'AccountHolderTypeIndividualRejection';
        message: string;
    };
    /** Language: ISO 639-1 language code */
    ['AccountLanguage']: AccountLanguage;
    /** An account membership represents the rights of a user for a given account.
  
  *Each account is administered by an account membership having the capacity of legal representative. He has the possibility of delegating rights on this account to other users.* */
    ['AccountMembership']: {
        __typename: 'AccountMembership';
        /** Unique identifier of an account membership */
        id: string;
        /** email */
        email: string;
        /** user of this account membership */
        user?: GraphQLTypes['User'] | undefined;
        /** `true` if this account membership having the capacity of the legal representative of the account holder. */
        legalRepresentative: boolean;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean;
        /** `true` if this account membership can invite, update, suspend or resume memberships */
        canManageAccountMembership: boolean;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards: boolean;
        /** status of the account membership */
        statusInfo: GraphQLTypes['AccountMembershipStatusInfo'];
        /** account of the account membership */
        account?: GraphQLTypes['Account'] | undefined;
        /** Periodic Spending limit list */
        spendingLimits?: Array<GraphQLTypes['SpendingLimit']> | undefined;
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** version of the account membership started from '1' and incremented at every updates */
        version: string;
        /** Residency address of the member */
        residencyAddress?: GraphQLTypes['AddressInfo'] | undefined;
        /** Tax Identification Number of the member */
        taxIdentificationNumber?: string | undefined;
        /** List of accepted identification level */
        acceptedIdentificationLevels: Array<GraphQLTypes['IdentificationLevel'] | undefined>;
        /** Recommended identification level */
        recommendedIdentificationLevel: GraphQLTypes['IdentificationLevel'];
        /** Indicate if the identity bound to the account membership has required identification level */
        hasRequiredIdentificationLevel?: boolean | undefined;
        /** Disabled date */
        disabledAt?: GraphQLTypes['DateTime'] | undefined;
        /** account membership's cards
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        cards: GraphQLTypes['CardConnection'];
        /** Periodic Spending */
        spending?: GraphQLTypes['Spending'] | undefined;
    };
    /** when a user is binded with the error to the account membership */
    ['AccountMembershipBindingUserErrorStatusInfo']: {
        __typename: 'AccountMembershipBindingUserErrorStatusInfo';
        /** AccountMembership status (always BindingUserError for type AccountMembershipBindingUserErrorStatusInfo) */
        status: GraphQLTypes['AccountMembershipStatus'];
        /** `true` if the first name of the user binded doesn't match with the invitation */
        firstNameMatchError: boolean;
        /** `true` if Swan hasn't verified the user's identity */
        idVerifiedMatchError: boolean;
        /** `true` if the last name of the user binded doesn't match with the invitation */
        lastNameMatchError: boolean;
        /** `true` if the phone number of the user binded doesn't match with the invitation */
        phoneNumberMatchError: boolean;
        /** `true` if the birth date of the user binded doesn't match with the invitation */
        birthDateMatchError: boolean;
        /** restricted to a user */
        restrictedTo: GraphQLTypes['RestrictedTo'];
    };
    ['AccountMembershipCannotBeDisabledRejection']: {
        __typename: 'AccountMembershipCannotBeDisabledRejection';
        accountMembershipId: string;
        message: string;
    };
    ['AccountMembershipCannotBeUpdatedRejection']: {
        __typename: 'AccountMembershipCannotBeUpdatedRejection';
        id: string;
        message: string;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['AccountMembershipConnection']: {
        __typename: 'AccountMembershipConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** AccountMembershipEdge list */
        edges: Array<GraphQLTypes['AccountMembershipEdge']>;
    };
    /** when the user has to consent to invite a new account membership */
    ['AccountMembershipConsentPendingStatusInfo']: {
        __typename: 'AccountMembershipConsentPendingStatusInfo';
        /** AccountMembership status (always ConsentPending for type AccountMembershipConsentPendingStatusInfo) */
        status: GraphQLTypes['AccountMembershipStatus'];
        /** The consent required to invite this account membership */
        consent: GraphQLTypes['Consent'];
        /** restricted to a user */
        restrictedTo: GraphQLTypes['RestrictedTo'];
    };
    /** when the account membership is disabled */
    ['AccountMembershipDisabledStatusInfo']: {
        __typename: 'AccountMembershipDisabledStatusInfo';
        /** AccountMembership status (always Disabled for type AccountMembershipDisabledStatusInfo) */
        status: GraphQLTypes['AccountMembershipStatus'];
        /** reason why the account membership is disabled */
        reason: string;
    };
    /** Implements the Relay Edge interface */
    ['AccountMembershipEdge']: {
        __typename: 'AccountMembershipEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The account membership */
        node: GraphQLTypes['AccountMembership'];
    };
    /** when the account membership is enabled */
    ['AccountMembershipEnabledStatusInfo']: {
        __typename: 'AccountMembershipEnabledStatusInfo';
        /** AccountMembership status (always Enabled for type AccountMembershipEnabledStatusInfo) */
        status: GraphQLTypes['AccountMembershipStatus'];
    };
    /** when a new account membership is invited and there is no user binded yet */
    ['AccountMembershipInvitationSentStatusInfo']: {
        __typename: 'AccountMembershipInvitationSentStatusInfo';
        /** AccountMembership status (always InvitationSent for type AccountMembershipInvitationSentStatusInfo) */
        status: GraphQLTypes['AccountMembershipStatus'];
        /** restricted to a user */
        restrictedTo: GraphQLTypes['RestrictedTo'];
    };
    /** Rejection returned when the Account Membership is not allowed to use an operation. */
    ['AccountMembershipNotAllowedRejection']: {
        __typename: 'AccountMembershipNotAllowedRejection';
        message: string;
    };
    ['AccountMembershipNotFoundRejection']: {
        __typename: 'AccountMembershipNotFoundRejection';
        id: string;
        message: string;
    };
    /** Rejection returned if invitation has not been sent to user yet */
    ['AccountMembershipNotReadyToBeBoundRejection']: {
        __typename: 'AccountMembershipNotReadyToBeBoundRejection';
        id: string;
        message: string;
    };
    /** Field we can use when ordering that can be applied when listing account memberships */
    ['AccountMembershipOrderByFieldInput']: AccountMembershipOrderByFieldInput;
    /** Order that can be applied when listing account memberships */
    ['AccountMembershipOrderByInput']: {
        field?: GraphQLTypes['AccountMembershipOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Filters that can be applied when listing accounts (Only applied in user context) */
    ['AccountMembershipsFilterInput']: {
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** Can the user initiate payments on this account */
        canInitiatePayments?: boolean | undefined;
        /** Can the user manage account membership */
        canManageAccountMembership?: boolean | undefined;
        /** Can the user manage beneficiaries */
        canManageBeneficiaries?: boolean | undefined;
        /** Can the user view account */
        canViewAccount?: boolean | undefined;
        /** Account memberships status/statuses we're looking for */
        status?: Array<GraphQLTypes['AccountMembershipStatus']> | undefined;
        /** Filtered by email */
        email?: string | undefined;
        /** Filtered by first name */
        firstName?: string | undefined;
        /** Filtered by last name */
        lastName?: string | undefined;
        /** Searches email, first name, last name, and id */
        search?: string | undefined;
    };
    /** List of account memberships permission */
    ['AccountMembershipsPermission']: AccountMembershipsPermission;
    /** AccountMembership enabled */
    ['AccountMembershipStatus']: AccountMembershipStatus;
    /** here are the different account membership status: */
    ['AccountMembershipStatusInfo']: {
        __typename: 'AccountMembershipBindingUserErrorStatusInfo' | 'AccountMembershipConsentPendingStatusInfo' | 'AccountMembershipDisabledStatusInfo' | 'AccountMembershipEnabledStatusInfo' | 'AccountMembershipInvitationSentStatusInfo' | 'AccountMembershipSuspendedStatusInfo';
        /** AccountMembership status */
        status: GraphQLTypes['AccountMembershipStatus'];
        ['...on AccountMembershipBindingUserErrorStatusInfo']: '__union' & GraphQLTypes['AccountMembershipBindingUserErrorStatusInfo'];
        ['...on AccountMembershipConsentPendingStatusInfo']: '__union' & GraphQLTypes['AccountMembershipConsentPendingStatusInfo'];
        ['...on AccountMembershipDisabledStatusInfo']: '__union' & GraphQLTypes['AccountMembershipDisabledStatusInfo'];
        ['...on AccountMembershipEnabledStatusInfo']: '__union' & GraphQLTypes['AccountMembershipEnabledStatusInfo'];
        ['...on AccountMembershipInvitationSentStatusInfo']: '__union' & GraphQLTypes['AccountMembershipInvitationSentStatusInfo'];
        ['...on AccountMembershipSuspendedStatusInfo']: '__union' & GraphQLTypes['AccountMembershipSuspendedStatusInfo'];
    };
    /** when the account membership is suspended */
    ['AccountMembershipSuspendedStatusInfo']: {
        __typename: 'AccountMembershipSuspendedStatusInfo';
        /** AccountMembership status (always Suspended for type AccountMembershipSuspendedStatusInfo) */
        status: GraphQLTypes['AccountMembershipStatus'];
        /** reason why the account membership is suspended */
        reason: string;
    };
    /** Thrown when an related account is not eligible to the feature */
    ['AccountNotEligibleRejection']: {
        __typename: 'AccountNotEligibleRejection';
        message: string;
    };
    /** Rejection returned if the account was not found or if the user does not have the rights to know that the card exists */
    ['AccountNotFoundRejection']: {
        __typename: 'AccountNotFoundRejection';
        id: string;
        message: string;
    };
    /** Swan account number */
    ['AccountNumber']: 'scalar' & {
        name: 'AccountNumber';
    };
    /** Account Opened status information */
    ['AccountOpenedStatus']: {
        __typename: 'AccountOpenedStatus';
        /** Account status (always Opened for type AccountOpenedStatus) */
        status: GraphQLTypes['AccountStatus'];
    };
    /** Fields that can be used when ordering accounts */
    ['AccountOrderByFieldInput']: AccountOrderByFieldInput;
    /** Order that can be applied when listing accounts */
    ['AccountOrderByInput']: {
        field?: GraphQLTypes['AccountOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Filter that can be passed to get the received direct debit mandate in a specific data range */
    ['AccountReceivedDirectDebitMandateFiltersInput']: {
        /** To filter on status values */
        status?: Array<GraphQLTypes['ReceivedDirectDebitMandateStatus']> | undefined;
        /** To filter on scheme values */
        scheme?: Array<GraphQLTypes['ReceivedDirectDebitMandateScheme']> | undefined;
    };
    /** Field we can use when ordering that can be applied when listing receives direct debit mandate results */
    ['AccountReceivedDirectDebitOrderByFieldInput']: AccountReceivedDirectDebitOrderByFieldInput;
    /** Order that can be applied when listing receives direct debit mandate results */
    ['AccountReceivedDirectDebitOrderByInput']: {
        field?: GraphQLTypes['AccountReceivedDirectDebitOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Filters that can be applied when listing Standing orders */
    ['AccountStandingOrderFiltersInput']: {
        status?: Array<GraphQLTypes['StandingOrderStatus']> | undefined;
    };
    /** Field we can use when ordering that can be applied when listing standing order results */
    ['AccountStandingOrderOrderByFieldInput']: AccountStandingOrderOrderByFieldInput;
    /** Order that can be applied when listing standing order results */
    ['AccountStandingOrderOrderByInput']: {
        field?: GraphQLTypes['AccountStandingOrderOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    ['AccountStatus']: AccountStatus;
    ['AccountStatusInfo']: {
        __typename: 'AccountClosedStatus' | 'AccountClosingStatus' | 'AccountOpenedStatus' | 'AccountSuspendedStatus';
        /** Account status */
        status: GraphQLTypes['AccountStatus'];
        ['...on AccountClosedStatus']: '__union' & GraphQLTypes['AccountClosedStatus'];
        ['...on AccountClosingStatus']: '__union' & GraphQLTypes['AccountClosingStatus'];
        ['...on AccountOpenedStatus']: '__union' & GraphQLTypes['AccountOpenedStatus'];
        ['...on AccountSuspendedStatus']: '__union' & GraphQLTypes['AccountSuspendedStatus'];
    };
    /** Account Suspended status information */
    ['AccountSuspendedStatus']: {
        __typename: 'AccountSuspendedStatus';
        /** Account status (always Suspended for type AccountSuspendedStatus) */
        status: GraphQLTypes['AccountStatus'];
        /** Reason why the account is suspended
    @Deprecated */
        reason: string;
        /** Reason why the account is currently suspend */
        reasonInfo: GraphQLTypes['SuspendAccountStatusReason'];
    };
    /** Account Verification */
    ['AccountVerification']: {
        __typename: 'DirectDebitAccountVerification';
        /** Creation date of the account verification */
        createdAt: GraphQLTypes['DateTime'];
        /** Unique identifier of the Account Verification */
        id: string;
        /** Account Verification Status Information */
        statusInfo: GraphQLTypes['AccountVerificationStatusInfo'];
        /** Last update date of the account verification */
        updatedAt: GraphQLTypes['DateTime'];
        ['...on DirectDebitAccountVerification']: '__union' & GraphQLTypes['DirectDebitAccountVerification'];
    };
    /** Rejection returned when the external account has already been rejected.
  
  In such a case, contact Swan directly to resolve the situation for this specific account holder. */
    ['AccountVerificationAlreadyRejectedRejection']: {
        __typename: 'AccountVerificationAlreadyRejectedRejection';
        message: string;
    };
    /** Account Verification Status */
    ['AccountVerificationStatus']: AccountVerificationStatus;
    /** Account Verification Status Information */
    ['AccountVerificationStatusInfo']: {
        __typename: 'PendingReviewStatusInfo' | 'PendingVerificationStatusInfo' | 'RejectedVerificationStatusInfo' | 'VerifiedStatusInfo';
        /** Account verification status */
        status: GraphQLTypes['AccountVerificationStatus'];
        ['...on PendingReviewStatusInfo']: '__union' & GraphQLTypes['PendingReviewStatusInfo'];
        ['...on PendingVerificationStatusInfo']: '__union' & GraphQLTypes['PendingVerificationStatusInfo'];
        ['...on RejectedVerificationStatusInfo']: '__union' & GraphQLTypes['RejectedVerificationStatusInfo'];
        ['...on VerifiedStatusInfo']: '__union' & GraphQLTypes['VerifiedStatusInfo'];
    };
    /** Rejection returned when the Account Verification is not in the expected status */
    ['AccountVerificationWrongStatusRejection']: {
        __typename: 'AccountVerificationWrongStatusRejection';
        message: string;
    };
    ['ActionNotAllowedRejection']: {
        __typename: 'ActionNotAllowedRejection';
        message: string;
    };
    ['ActivatePhysicalCardInput']: {
        /** Unique identifier present on physical card */
        identifier: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ActivatePhysicalCardPayload']: {
        __typename: 'ActivatePhysicalCardSuccessPayload' | 'BadAccountStatusRejection' | 'PhysicalCardNotFoundRejection' | 'PhysicalCardWrongStatusRejection' | 'CannotActivatePhysicalCardRejection' | 'ForbiddenRejection' | 'CardNotFoundRejection' | 'UserNotCardHolderRejection' | 'ValidationRejection';
        ['...on ActivatePhysicalCardSuccessPayload']: '__union' & GraphQLTypes['ActivatePhysicalCardSuccessPayload'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on PhysicalCardNotFoundRejection']: '__union' & GraphQLTypes['PhysicalCardNotFoundRejection'];
        ['...on PhysicalCardWrongStatusRejection']: '__union' & GraphQLTypes['PhysicalCardWrongStatusRejection'];
        ['...on CannotActivatePhysicalCardRejection']: '__union' & GraphQLTypes['CannotActivatePhysicalCardRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on UserNotCardHolderRejection']: '__union' & GraphQLTypes['UserNotCardHolderRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['ActivatePhysicalCardSuccessPayload']: {
        __typename: 'ActivatePhysicalCardSuccessPayload';
        /** The consent required to activate this physical card */
        consent: GraphQLTypes['Consent'];
        /** The physicalCard to activate */
        physicalCard: GraphQLTypes['PhysicalCard'];
    };
    ['ActiveMerchantPaymentLinkStatusInfo']: {
        __typename: 'ActiveMerchantPaymentLinkStatusInfo';
        status: GraphQLTypes['MerchantPaymentLinkStatus'];
        /** The date when the payment link expires.
    By default the payment link expires 120 days after it was created. */
        expiresAt: GraphQLTypes['DateTime'];
    };
    /** Inputs to add a new account membership */
    ['AddAccountMembershipInput']: {
        /** Unique identifier of a given account */
        accountId: string;
        /** Email address */
        email: string;
        /** Restricted to a user if necessary */
        restrictedTo: GraphQLTypes['RestrictedToInput'];
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean;
        /** `true` if this account membership can invite, update, suspend or resume account membership */
        canManageAccountMembership: boolean;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Residency address of the member to be added */
        residencyAddress?: GraphQLTypes['ResidencyAddressInput'] | undefined;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined;
    };
    ['AddAccountMembershipPayload']: {
        __typename: 'AddAccountMembershipSuccessPayload' | 'BadAccountStatusRejection' | 'ForbiddenRejection' | 'InvalidPhoneNumberRejection' | 'PermissionCannotBeGrantedRejection' | 'ValidationRejection';
        ['...on AddAccountMembershipSuccessPayload']: '__union' & GraphQLTypes['AddAccountMembershipSuccessPayload'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InvalidPhoneNumberRejection']: '__union' & GraphQLTypes['InvalidPhoneNumberRejection'];
        ['...on PermissionCannotBeGrantedRejection']: '__union' & GraphQLTypes['PermissionCannotBeGrantedRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Inputs to add a new account membership */
    ['AddAccountMembershipsInput']: {
        /** Unique identifier of a given account */
        accountId: string;
        /** Memberships to add to the account */
        memberships: Array<GraphQLTypes['MembershipInfoInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['AddAccountMembershipsPayload']: {
        __typename: 'AddAccountMembershipsSuccessPayload' | 'BadAccountStatusRejection' | 'ForbiddenRejection' | 'InvalidPhoneNumberRejection' | 'PermissionCannotBeGrantedRejection' | 'TooManyItemsRejection' | 'ValidationRejection';
        ['...on AddAccountMembershipsSuccessPayload']: '__union' & GraphQLTypes['AddAccountMembershipsSuccessPayload'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InvalidPhoneNumberRejection']: '__union' & GraphQLTypes['InvalidPhoneNumberRejection'];
        ['...on PermissionCannotBeGrantedRejection']: '__union' & GraphQLTypes['PermissionCannotBeGrantedRejection'];
        ['...on TooManyItemsRejection']: '__union' & GraphQLTypes['TooManyItemsRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['AddAccountMembershipsSuccessPayload']: {
        __typename: 'AddAccountMembershipsSuccessPayload';
        accountMemberships: Array<GraphQLTypes['AccountMembership']>;
    };
    ['AddAccountMembershipSuccessPayload']: {
        __typename: 'AddAccountMembershipSuccessPayload';
        accountMembership: GraphQLTypes['AccountMembership'];
    };
    /** Inputs to add a new card */
    ['AddCardInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: GraphQLTypes['DateTime'] | undefined;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Card name */
        name?: string | undefined;
        /** `true` to show the card confidential information in the same request */
        viewCardNumber?: boolean | undefined;
        /** The id of the card product to use to create the new card. */
        cardProductId?: string | undefined;
        /** Spending limit */
        spendingLimit?: GraphQLTypes['SpendingLimitInput'] | undefined;
    };
    ['AddCardPayload']: {
        __typename: 'AddCardSuccessPayload' | 'AccountMembershipNotAllowedRejection' | 'BadAccountStatusRejection' | 'CardProductDisabledRejection' | 'CardProductSuspendedRejection' | 'EnabledCardDesignNotFoundRejection' | 'ForbiddenRejection' | 'MissingMandatoryFieldRejection' | 'ValidationRejection';
        ['...on AddCardSuccessPayload']: '__union' & GraphQLTypes['AddCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on CardProductDisabledRejection']: '__union' & GraphQLTypes['CardProductDisabledRejection'];
        ['...on CardProductSuspendedRejection']: '__union' & GraphQLTypes['CardProductSuspendedRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: '__union' & GraphQLTypes['EnabledCardDesignNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on MissingMandatoryFieldRejection']: '__union' & GraphQLTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Input to add a new cards */
    ['AddCardsInput']: {
        /** The configuration of all the cards you want to add */
        cards: Array<GraphQLTypes['CardConfigInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined;
    };
    ['AddCardsPayload']: {
        __typename: 'AddCardsSuccessPayload' | 'AddingCardsToDifferentAccountsRejection' | 'BadAccountStatusRejection' | 'TooManyItemsRejection' | 'AccountMembershipNotAllowedRejection' | 'CardProductSuspendedRejection' | 'CardProductNotApplicableToPhysicalCardsRejection' | 'CardProductDisabledRejection' | 'EnabledCardDesignNotFoundRejection' | 'MissingMandatoryFieldRejection' | 'ValidationRejection';
        ['...on AddCardsSuccessPayload']: '__union' & GraphQLTypes['AddCardsSuccessPayload'];
        ['...on AddingCardsToDifferentAccountsRejection']: '__union' & GraphQLTypes['AddingCardsToDifferentAccountsRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on TooManyItemsRejection']: '__union' & GraphQLTypes['TooManyItemsRejection'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardProductSuspendedRejection']: '__union' & GraphQLTypes['CardProductSuspendedRejection'];
        ['...on CardProductNotApplicableToPhysicalCardsRejection']: '__union' & GraphQLTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        ['...on CardProductDisabledRejection']: '__union' & GraphQLTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: '__union' & GraphQLTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: '__union' & GraphQLTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['AddCardsSuccessPayload']: {
        __typename: 'AddCardsSuccessPayload';
        /** The newly created cards */
        cards: Array<GraphQLTypes['Card']>;
    };
    ['AddCardSuccessPayload']: {
        __typename: 'AddCardSuccessPayload';
        /** The new card added */
        card: GraphQLTypes['Card'];
    };
    /** Input to add a new cards */
    ['AddCardsWithGroupDeliveryInput']: {
        /** Address to deliver the printed physical cards */
        groupDeliveryAddress: GraphQLTypes['CompleteAddressWithContactInput'];
        /** The configuration of all the cards you want to add */
        cards: Array<GraphQLTypes['CardConfigWithGroupDeliveryInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined;
    };
    ['AddCardsWithGroupDeliveryPayload']: {
        __typename: 'AddCardsWithGroupDeliverySuccessPayload' | 'AddingCardsToDifferentAccountsRejection' | 'BadAccountStatusRejection' | 'TooManyItemsRejection' | 'AccountMembershipNotAllowedRejection' | 'CardProductSuspendedRejection' | 'CardProductNotApplicableToPhysicalCardsRejection' | 'CardProductDisabledRejection' | 'EnabledCardDesignNotFoundRejection' | 'MissingMandatoryFieldRejection' | 'ValidationRejection';
        ['...on AddCardsWithGroupDeliverySuccessPayload']: '__union' & GraphQLTypes['AddCardsWithGroupDeliverySuccessPayload'];
        ['...on AddingCardsToDifferentAccountsRejection']: '__union' & GraphQLTypes['AddingCardsToDifferentAccountsRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on TooManyItemsRejection']: '__union' & GraphQLTypes['TooManyItemsRejection'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardProductSuspendedRejection']: '__union' & GraphQLTypes['CardProductSuspendedRejection'];
        ['...on CardProductNotApplicableToPhysicalCardsRejection']: '__union' & GraphQLTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        ['...on CardProductDisabledRejection']: '__union' & GraphQLTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: '__union' & GraphQLTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: '__union' & GraphQLTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['AddCardsWithGroupDeliverySuccessPayload']: {
        __typename: 'AddCardsWithGroupDeliverySuccessPayload';
        /** The newly created cards */
        cards: Array<GraphQLTypes['Card']>;
    };
    /** Inputs to add a new digital card */
    ['AddDigitalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Provider for which to generate a digitalCard */
        walletProvider: GraphQLTypes['WalletProviderType'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** Payload returned on mutation completion */
    ['AddDigitalCardPayload']: {
        __typename: 'AddDigitalCardSuccessPayload' | 'CardNotFoundRejection' | 'CardCanNotBeDigitalizedRejection' | 'ApplePayNotAllowedForProjectRejection' | 'BadAccountStatusRejection' | 'AccountMembershipNotAllowedRejection' | 'UserNotCardHolderRejection' | 'CardProductDisabledRejection' | 'EnabledCardDesignNotFoundRejection' | 'MissingMandatoryFieldRejection' | 'ValidationRejection';
        ['...on AddDigitalCardSuccessPayload']: '__union' & GraphQLTypes['AddDigitalCardSuccessPayload'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on CardCanNotBeDigitalizedRejection']: '__union' & GraphQLTypes['CardCanNotBeDigitalizedRejection'];
        ['...on ApplePayNotAllowedForProjectRejection']: '__union' & GraphQLTypes['ApplePayNotAllowedForProjectRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on UserNotCardHolderRejection']: '__union' & GraphQLTypes['UserNotCardHolderRejection'];
        ['...on CardProductDisabledRejection']: '__union' & GraphQLTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: '__union' & GraphQLTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: '__union' & GraphQLTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['AddDigitalCardSuccessPayload']: {
        __typename: 'AddDigitalCardSuccessPayload';
        /** Digital Card used for ApplePay or GooglePay
    
    The consent can be found in the digital card status information. */
        digitalCard: GraphQLTypes['PendingDigitalCard'];
    };
    /** Input to add a Direct Debit Funding Source */
    ['AddDirectDebitFundingSourceInput']: {
        /** Scheme of the underlying payment mandate */
        scheme: GraphQLTypes['SEPADirectDebitScheme'];
        /** Id of the account on which to create a funding source.
    Money will be funded to this account when an `initiateFundingRequest` is done using this funding source */
        accountId: string;
        /** IBAN to use in the direct debit transaction that will be triggered when funding the account.
    Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source */
        iban: GraphQLTypes['IBAN'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Name to give to this funding source */
        name?: string | undefined;
    };
    /** Add Direct Debit Funding Source Payload */
    ['AddDirectDebitFundingSourcePayload']: {
        __typename: 'AddDirectDebitFundingSourceSuccessPayload' | 'ForbiddenRejection' | 'NotFoundRejection' | 'AccountVerificationAlreadyRejectedRejection' | 'IBANNotReachableRejection' | 'ValidationRejection';
        ['...on AddDirectDebitFundingSourceSuccessPayload']: '__union' & GraphQLTypes['AddDirectDebitFundingSourceSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: '__union' & GraphQLTypes['NotFoundRejection'];
        ['...on AccountVerificationAlreadyRejectedRejection']: '__union' & GraphQLTypes['AccountVerificationAlreadyRejectedRejection'];
        ['...on IBANNotReachableRejection']: '__union' & GraphQLTypes['IBANNotReachableRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Add Direct Debit Funding Source Success Payload */
    ['AddDirectDebitFundingSourceSuccessPayload']: {
        __typename: 'AddDirectDebitFundingSourceSuccessPayload';
        /** The created funding source */
        fundingSource: GraphQLTypes['FundingSource'];
    };
    ['AddExternalAccountBalanceInput']: {
        /** Unique identifier of a given external account */
        externalAccountId: string;
        /** Amount of the balance */
        amount: GraphQLTypes['AmountInput'];
        /** Type of the balance */
        type: GraphQLTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: GraphQLTypes['DateTime'];
    };
    ['AddExternalAccountBalancePayload']: {
        __typename: 'AddExternalAccountBalanceSuccessPayload' | 'ValidationRejection' | 'ExternalAccountBalanceAlreadyExistsRejection' | 'ForbiddenRejection';
        ['...on AddExternalAccountBalanceSuccessPayload']: '__union' & GraphQLTypes['AddExternalAccountBalanceSuccessPayload'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
        ['...on ExternalAccountBalanceAlreadyExistsRejection']: '__union' & GraphQLTypes['ExternalAccountBalanceAlreadyExistsRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
    };
    ['AddExternalAccountBalanceSuccessPayload']: {
        __typename: 'AddExternalAccountBalanceSuccessPayload';
        /** The added external balance */
        externalAccountBalance: GraphQLTypes['ExternalAccountBalance'];
    };
    ['AddExternalAccountInput']: {
        /** Unique identifier of a given account holder */
        accountHolderId: string;
        /** External account identifier */
        externalId: string;
        /** Name of the account */
        name?: string | undefined;
        /** Type of account */
        cashAccountType: GraphQLTypes['CashAccountType'];
        /** Bank Identifier Code */
        BIC: GraphQLTypes['BIC'];
        /** International Bank Account Number */
        IBAN: GraphQLTypes['IBAN'];
        /** Currency */
        currency: GraphQLTypes['Currency'];
        /** Account Holder name */
        holderName: string;
        /** Country */
        country: GraphQLTypes['CCA3'];
        /** Original Created date */
        originalCreatedAt: GraphQLTypes['DateTime'];
        /** Usage information of the account */
        usage: GraphQLTypes['ExternalAccountUsage'];
        /** Source of the account information */
        source: string;
        /** Balances */
        balances?: Array<GraphQLTypes['ExternalAccountBalanceInput']> | undefined;
    };
    ['AddExternalAccountPayload']: {
        __typename: 'AddExternalAccountSuccessPayload' | 'ValidationRejection' | 'IbanValidationRejection' | 'ExternalAccountAlreadyExistsRejection' | 'ForbiddenRejection';
        ['...on AddExternalAccountSuccessPayload']: '__union' & GraphQLTypes['AddExternalAccountSuccessPayload'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
        ['...on IbanValidationRejection']: '__union' & GraphQLTypes['IbanValidationRejection'];
        ['...on ExternalAccountAlreadyExistsRejection']: '__union' & GraphQLTypes['ExternalAccountAlreadyExistsRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
    };
    ['AddExternalAccountSuccessPayload']: {
        __typename: 'AddExternalAccountSuccessPayload';
        /** The added external account */
        externalAccount: GraphQLTypes['ExternalAccount'];
    };
    /** Inputs to add a new request for funding limit settings change */
    ['AddFundingLimitSettingsChangeRequestInput']: {
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit: GraphQLTypes['FundingLimitAmountInput'];
        /** Requested amount settings for the funding limit */
        fundingLimit: GraphQLTypes['FundingLimitAmountInput'];
        /** Unique identifier of a given account holder */
        accountHolderId: string;
    };
    /** Payload returned on mutation completion */
    ['AddFundingLimitSettingsChangeRequestPayload']: {
        __typename: 'AddFundingLimitSettingsChangeRequestSuccessPayload' | 'FundingLimitSettingsChangeRequestBadAmountRejection' | 'AccountHolderNotFoundRejection' | 'ForbiddenRejection' | 'ValidationRejection';
        ['...on AddFundingLimitSettingsChangeRequestSuccessPayload']: '__union' & GraphQLTypes['AddFundingLimitSettingsChangeRequestSuccessPayload'];
        ['...on FundingLimitSettingsChangeRequestBadAmountRejection']: '__union' & GraphQLTypes['FundingLimitSettingsChangeRequestBadAmountRejection'];
        ['...on AccountHolderNotFoundRejection']: '__union' & GraphQLTypes['AccountHolderNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Add Funding Limit Settings Change Request Success Payload */
    ['AddFundingLimitSettingsChangeRequestSuccessPayload']: {
        __typename: 'AddFundingLimitSettingsChangeRequestSuccessPayload';
        /** The new request for funding limit settings change */
        fundingLimitSettingsChangeRequest: GraphQLTypes['FundingLimitSettingsChangeRequest'];
    };
    /** Rejection returned if the attempting to add cards to different accounts. */
    ['AddingCardsToDifferentAccountsRejection']: {
        __typename: 'AddingCardsToDifferentAccountsRejection';
        message: string;
    };
    /** Inputs to add an Internal Direct Debit Payment Mandate */
    ['AddInternalDirectDebitPaymentMandateInput']: {
        /** The ID of the concerned merchant payment method */
        paymentMethodId: string;
        /** Determines whether the payment mandate is a one-off or recurrent */
        sequence?: GraphQLTypes['InternalDirectDebitSequence'] | undefined;
        /** Reference of the payment mandate */
        reference?: string | undefined;
        /** Language that will be used to produce the mandate PDF document */
        language?: GraphQLTypes['MandateLanguage'] | undefined;
        /** ID of the Swan account of the debtor */
        debtorAccountId: string;
        /** Signature date of the Internal Direct Debit mandate */
        signatureDate?: GraphQLTypes['Date'] | undefined;
        /** Custom name of the Internal Direct Debit mandate */
        name?: string | undefined;
    };
    /** Union type return by the addInternalDirectDebitPaymentMandate mutation */
    ['AddInternalDirectDebitPaymentMandatePayload']: {
        __typename: 'AddInternalDirectDebitPaymentMandateSuccessPayload' | 'ForbiddenRejection' | 'NotFoundRejection' | 'DebtorAccountNotAllowedRejection' | 'DebtorAccountClosedRejection' | 'SchemeWrongRejection' | 'PaymentMandateReferenceAlreadyUsedRejection' | 'InternalErrorRejection';
        ['...on AddInternalDirectDebitPaymentMandateSuccessPayload']: '__union' & GraphQLTypes['AddInternalDirectDebitPaymentMandateSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: '__union' & GraphQLTypes['NotFoundRejection'];
        ['...on DebtorAccountNotAllowedRejection']: '__union' & GraphQLTypes['DebtorAccountNotAllowedRejection'];
        ['...on DebtorAccountClosedRejection']: '__union' & GraphQLTypes['DebtorAccountClosedRejection'];
        ['...on SchemeWrongRejection']: '__union' & GraphQLTypes['SchemeWrongRejection'];
        ['...on PaymentMandateReferenceAlreadyUsedRejection']: '__union' & GraphQLTypes['PaymentMandateReferenceAlreadyUsedRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
    };
    /** Return type in case of a successful response of the addInternalDirectDebitPaymentMandate mutation */
    ['AddInternalDirectDebitPaymentMandateSuccessPayload']: {
        __typename: 'AddInternalDirectDebitPaymentMandateSuccessPayload';
        paymentMandate: GraphQLTypes['InternalPaymentDirectDebitMandate'];
    };
    /** Input to add a Merchant Profile */
    ['AddMerchantProfileInput']: {
        /** ID of the Swan account which the merchantProfile is associated to */
        accountId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website */
        merchantWebsite?: string | undefined;
        /** base64 encoded merchant's logo */
        merchantLogo?: string | undefined;
        /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: GraphQLTypes['ProductType'];
        /** Expected annual activity volumes for all payment methods. */
        expectedMonthlyPaymentVolume: GraphQLTypes['AmountInput'];
        /** expected average basket value. */
        expectedAverageBasket: GraphQLTypes['AmountInput'];
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page. */
        accentColor?: string | undefined;
    };
    /** Add Merchant Profile Payload */
    ['AddMerchantProfilePayload']: {
        __typename: 'AddMerchantProfileSuccessPayload' | 'ForbiddenRejection' | 'AccountNotFoundRejection' | 'InternalErrorRejection' | 'ValidationRejection';
        ['...on AddMerchantProfileSuccessPayload']: '__union' & GraphQLTypes['AddMerchantProfileSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Add Merchant Profile Success Payload */
    ['AddMerchantProfileSuccessPayload']: {
        __typename: 'AddMerchantProfileSuccessPayload';
        /** Merchant Profile */
        merchantProfile: GraphQLTypes['MerchantProfile'];
    };
    ['AddOrUpdateExternalAccountBalanceInput']: {
        /** Unique identifier of a given external account */
        externalAccountId: string;
        /** Amount of the balance */
        amount: GraphQLTypes['AmountInput'];
        /** Type of the balance */
        type: GraphQLTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: GraphQLTypes['DateTime'];
    };
    ['AddOrUpdateExternalAccountBalancePayload']: {
        __typename: 'AddOrUpdateExternalAccountBalanceSuccessPayload' | 'ValidationRejection' | 'ForbiddenRejection';
        ['...on AddOrUpdateExternalAccountBalanceSuccessPayload']: '__union' & GraphQLTypes['AddOrUpdateExternalAccountBalanceSuccessPayload'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
    };
    ['AddOrUpdateExternalAccountBalanceSuccessPayload']: {
        __typename: 'AddOrUpdateExternalAccountBalanceSuccessPayload';
        /** The added external balance */
        externalAccountBalance: GraphQLTypes['ExternalAccountBalance'];
    };
    /** Inputs to add a received internal direct debit mandate B2b. */
    ['AddReceivedInternalDirectDebitB2bMandateInput']: {
        /** The associated Payment Mandate ID */
        paymentMandateId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined;
    };
    /** Union type return by the addReceivedInternalDirectDebitB2bMandate mutation */
    ['AddReceivedInternalDirectDebitB2bMandatePayload']: {
        __typename: 'AddReceivedInternalDirectDebitB2bMandateSuccessPayload' | 'ForbiddenRejection' | 'PaymentMandateMandateNotFoundRejection' | 'AccountHolderTypeIndividualRejection';
        ['...on AddReceivedInternalDirectDebitB2bMandateSuccessPayload']: '__union' & GraphQLTypes['AddReceivedInternalDirectDebitB2bMandateSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on PaymentMandateMandateNotFoundRejection']: '__union' & GraphQLTypes['PaymentMandateMandateNotFoundRejection'];
        ['...on AccountHolderTypeIndividualRejection']: '__union' & GraphQLTypes['AccountHolderTypeIndividualRejection'];
    };
    /** Return type in case of a successful response of the addReceivedInternalDirectDebitB2bMandate mutation */
    ['AddReceivedInternalDirectDebitB2bMandateSuccessPayload']: {
        __typename: 'AddReceivedInternalDirectDebitB2bMandateSuccessPayload';
        /** The received direct debit mandate is added */
        receivedDirectDebitMandate: GraphQLTypes['ReceivedDirectDebitMandate'];
    };
    /** Inputs to add a received sepa direct debit mandate B2b. */
    ['AddReceivedSepaDirectDebitB2bMandateInput']: {
        /** The unique identifier of the received direct debit mandate */
        mandateReference: string;
        /** The Sepa Creditor Identifier of the creditor */
        creditorIdentifier: string;
        /** The name of the creditor */
        creditorName: string;
        /** The Swan Iban of the debtor */
        iban: string;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined;
        /** Sequence of the mandate */
        sequence: GraphQLTypes['SEPAReceivedDirectDebitMandateSequence'];
        /** Date of signature of the mandate */
        signatureDate?: GraphQLTypes['Date'] | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** Union type return by the addReceivedSepaDirectDebitB2bMandate mutation */
    ['AddReceivedSepaDirectDebitB2bMandatePayload']: {
        __typename: 'AddReceivedSepaDirectDebitB2bMandateSuccessPayload' | 'ForbiddenRejection' | 'AccountNotFoundRejection' | 'AccountHolderTypeIndividualRejection';
        ['...on AddReceivedSepaDirectDebitB2bMandateSuccessPayload']: '__union' & GraphQLTypes['AddReceivedSepaDirectDebitB2bMandateSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on AccountHolderTypeIndividualRejection']: '__union' & GraphQLTypes['AccountHolderTypeIndividualRejection'];
    };
    /** Return type in case of a successful response of the addReceivedSepaDirectDebitB2bMandate mutation */
    ['AddReceivedSepaDirectDebitB2bMandateSuccessPayload']: {
        __typename: 'AddReceivedSepaDirectDebitB2bMandateSuccessPayload';
        /** The received direct debit mandate is added */
        receivedDirectDebitMandate: GraphQLTypes['ReceivedDirectDebitMandate'];
    };
    /** Address Information */
    ['Address']: {
        __typename: 'Address';
        /** address line 1 */
        addressLine1?: string | undefined;
        /** addressLine2 */
        addressLine2?: string | undefined;
        /** city */
        city?: string | undefined;
        /** postal code (max 10 characters) */
        postalCode?: string | undefined;
        /** state */
        state?: string | undefined;
        /** country */
        country?: GraphQLTypes['CCA3'] | undefined;
    };
    /** Address information. */
    ['AddressInfo']: {
        __typename: 'AddressInfo';
        /** Address line 1. */
        addressLine1?: string | undefined;
        /** Address line 2. */
        addressLine2?: string | undefined;
        /** City. */
        city?: string | undefined;
        /** Postal code. */
        postalCode?: string | undefined;
        /** State. */
        state?: string | undefined;
        /** Country. */
        country?: GraphQLTypes['CCA3'] | undefined;
    };
    /** Address */
    ['AddressInformation']: {
        __typename: 'AddressInformation';
        /** Address */
        addressLine1: string;
        /** Address */
        addressLine2?: string | undefined;
        /** City */
        city: string;
        /** Country */
        country: GraphQLTypes['CCA3'];
        /** Postal code */
        postalCode: string;
        /** State */
        state?: string | undefined;
    };
    /** Address */
    ['AddressInformationInput']: {
        /** Address */
        addressLine1: string;
        /** Address */
        addressLine2?: string | undefined;
        /** City */
        city: string;
        /** Country */
        country: GraphQLTypes['CCA3'];
        /** Postal code */
        postalCode: string;
        /** State */
        state?: string | undefined;
    };
    /** Address Information */
    ['AddressInput']: {
        /** address line 1 (max 100 characters) */
        addressLine1?: string | undefined;
        /** address line 2 (max 100 characters) */
        addressLine2?: string | undefined;
        /** city (max 100 characters) */
        city?: string | undefined;
        /** postal code (max 10 characters) */
        postalCode?: string | undefined;
        /** state (max 100 characters) */
        state?: string | undefined;
        /** country code */
        country: GraphQLTypes['CCA3'];
    };
    ['AddSepaDirectDebitPaymentMandateInput']: {
        /** Specifies payment ID of a SEPA Direct Debit CORE or B2B payment method. */
        paymentMethodId: string;
        /** Determines whether the payment mandate is a one-off or recurrent */
        sequence: GraphQLTypes['DirectDebitSequence'];
        /** Unique reference of the SEPA Direct Debit Payment Mandate. */
        reference?: string | undefined;
        /** Language that will be used to produce the mandate PDF document */
        language: GraphQLTypes['MandateLanguage'];
        /** Signature date of the SEPA Direct Debit Payment Mandate */
        signatureDate: GraphQLTypes['Date'];
        /** Debtor of the SEPA Direct Debit Payment Mandate */
        debtor: GraphQLTypes['SepaPaymentMandateDebtorInput'];
        /** Custom name of the SEPA Direct Debit Payment Mandate */
        name?: string | undefined;
    };
    /** Union type return by the addSepaDirectDebitPaymentMandate mutation */
    ['AddSepaDirectDebitPaymentMandatePayload']: {
        __typename: 'AddSepaDirectDebitPaymentMandateSuccessPayload' | 'ForbiddenRejection' | 'NotFoundRejection' | 'DebtorAccountNotAllowedRejection' | 'DebtorAccountClosedRejection' | 'SchemeWrongRejection' | 'PaymentMandateReferenceAlreadyUsedRejection' | 'ValidationRejection' | 'PaymentMethodNotCompatibleRejection' | 'InternalErrorRejection';
        ['...on AddSepaDirectDebitPaymentMandateSuccessPayload']: '__union' & GraphQLTypes['AddSepaDirectDebitPaymentMandateSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: '__union' & GraphQLTypes['NotFoundRejection'];
        ['...on DebtorAccountNotAllowedRejection']: '__union' & GraphQLTypes['DebtorAccountNotAllowedRejection'];
        ['...on DebtorAccountClosedRejection']: '__union' & GraphQLTypes['DebtorAccountClosedRejection'];
        ['...on SchemeWrongRejection']: '__union' & GraphQLTypes['SchemeWrongRejection'];
        ['...on PaymentMandateReferenceAlreadyUsedRejection']: '__union' & GraphQLTypes['PaymentMandateReferenceAlreadyUsedRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
        ['...on PaymentMethodNotCompatibleRejection']: '__union' & GraphQLTypes['PaymentMethodNotCompatibleRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
    };
    /** Return type in case of a successful response of the addSepaDirectDebitPaymentMandate mutation */
    ['AddSepaDirectDebitPaymentMandateSuccessPayload']: {
        __typename: 'AddSepaDirectDebitPaymentMandateSuccessPayload';
        paymentMandate: GraphQLTypes['SEPAPaymentDirectDebitMandate'];
    };
    /** Inputs to add a new card */
    ['AddSingleUseVirtualCardInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Spending limit */
        spendingLimit: GraphQLTypes['SpendingLimitInput'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Card name */
        name?: string | undefined;
        /** `true` to show the card confidential information in the same request */
        viewCardNumber?: boolean | undefined;
        /** The id of the card product to use to create the new card. */
        cardProductId?: string | undefined;
    };
    ['AddSingleUseVirtualCardPayload']: {
        __typename: 'AddSingleUseVirtualCardSuccessForUserPayload' | 'AddSingleUseVirtualCardSuccessForProjectOwnerPayload' | 'BadAccountStatusRejection' | 'AccountMembershipNotAllowedRejection' | 'CardProductSuspendedRejection' | 'CardProductDisabledRejection' | 'EnabledCardDesignNotFoundRejection' | 'MissingMandatoryFieldRejection' | 'ValidationRejection';
        ['...on AddSingleUseVirtualCardSuccessForUserPayload']: '__union' & GraphQLTypes['AddSingleUseVirtualCardSuccessForUserPayload'];
        ['...on AddSingleUseVirtualCardSuccessForProjectOwnerPayload']: '__union' & GraphQLTypes['AddSingleUseVirtualCardSuccessForProjectOwnerPayload'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardProductSuspendedRejection']: '__union' & GraphQLTypes['CardProductSuspendedRejection'];
        ['...on CardProductDisabledRejection']: '__union' & GraphQLTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: '__union' & GraphQLTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: '__union' & GraphQLTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Input to add a new single-use virtual cards */
    ['AddSingleUseVirtualCardsInput']: {
        /** The configuration of all the cards you want to add */
        cards: Array<GraphQLTypes['SingleUseVirtualCardConfigInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** The id of the card product to use to create the new cards. */
        cardProductId?: string | undefined;
    };
    ['AddSingleUseVirtualCardsPayload']: {
        __typename: 'AddSingleUseVirtualCardsSuccessPayload' | 'AddingCardsToDifferentAccountsRejection' | 'TooManyItemsRejection' | 'BadAccountStatusRejection' | 'AccountMembershipNotAllowedRejection' | 'CardProductSuspendedRejection' | 'CardProductDisabledRejection' | 'EnabledCardDesignNotFoundRejection' | 'MissingMandatoryFieldRejection' | 'ValidationRejection';
        ['...on AddSingleUseVirtualCardsSuccessPayload']: '__union' & GraphQLTypes['AddSingleUseVirtualCardsSuccessPayload'];
        ['...on AddingCardsToDifferentAccountsRejection']: '__union' & GraphQLTypes['AddingCardsToDifferentAccountsRejection'];
        ['...on TooManyItemsRejection']: '__union' & GraphQLTypes['TooManyItemsRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardProductSuspendedRejection']: '__union' & GraphQLTypes['CardProductSuspendedRejection'];
        ['...on CardProductDisabledRejection']: '__union' & GraphQLTypes['CardProductDisabledRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: '__union' & GraphQLTypes['EnabledCardDesignNotFoundRejection'];
        ['...on MissingMandatoryFieldRejection']: '__union' & GraphQLTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['AddSingleUseVirtualCardsSuccessPayload']: {
        __typename: 'AddSingleUseVirtualCardsSuccessPayload';
        /** The newly created single use virtual cards */
        cards: Array<GraphQLTypes['Card']>;
    };
    ['AddSingleUseVirtualCardSuccessForProjectOwnerPayload']: {
        __typename: 'AddSingleUseVirtualCardSuccessForProjectOwnerPayload';
        /** The new card added */
        card: GraphQLTypes['Card'];
        /** Card confidential */
        confidential: GraphQLTypes['CardConfidential'];
    };
    ['AddSingleUseVirtualCardSuccessForUserPayload']: {
        __typename: 'AddSingleUseVirtualCardSuccessForUserPayload';
        /** The new card added */
        card: GraphQLTypes['Card'];
    };
    ['AddVirtualIbanEntryPayload']: {
        __typename: 'AddVirtualIbanEntrySuccessPayload' | 'AccountNotFoundRejection' | 'BadAccountStatusRejection' | 'ForbiddenRejection' | 'ValidationRejection';
        ['...on AddVirtualIbanEntrySuccessPayload']: '__union' & GraphQLTypes['AddVirtualIbanEntrySuccessPayload'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['AddVirtualIbanEntrySuccessPayload']: {
        __typename: 'AddVirtualIbanEntrySuccessPayload';
        virtualIbanEntry: GraphQLTypes['VirtualIBANEntry'];
    };
    /** Input to Add a Virtual IBAN */
    ['AddVirtualIbanInput']: {
        /** Unique identifier of a given account */
        accountId: string;
    };
    /** Input values needed to add a webhook subscription */
    ['AddWebhookSubscriptionInput']: {
        /** A short descriptive label for the subscription
    (max 255 characters) */
        label: string;
        /** The endpoint URL events will be sent to
    (max 255 characters) */
        endpoint: string;
        /** The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
    (max 36 characters) */
        secret?: string | undefined;
        /** The types of subscribed events
    A subset of unique IDs from `webhookEventTypes` */
        eventTypes: Array<string>;
        /** Control if the subscription should be enabled on creation */
        status: GraphQLTypes['WebhookSubscriptionCreationStatus'];
    };
    ['AllowedValue']: {
        __typename: 'AllowedValue';
        key: string;
        name: string;
    };
    /** Input to Allow SDD */
    ['AllowSddInput']: {
        /** Unique identifier of a given account */
        accountId: string;
    };
    ['AllowSddPayload']: {
        __typename: 'AllowSddSuccessPayload' | 'AccountNotFoundRejection' | 'ValidationRejection';
        ['...on AllowSddSuccessPayload']: '__union' & GraphQLTypes['AllowSddSuccessPayload'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['AllowSddSuccessPayload']: {
        __typename: 'AllowSddSuccessPayload';
        account: GraphQLTypes['Account'];
    };
    ['AllowSddVirtualIbanEntryInput']: {
        ibanEntryId: string;
    };
    ['AllowSddVirtualIbanEntryPayload']: {
        __typename: 'AllowSddVirtualIbanEntrySuccessPayload' | 'BadAccountStatusRejection' | 'ValidationRejection';
        ['...on AllowSddVirtualIbanEntrySuccessPayload']: '__union' & GraphQLTypes['AllowSddVirtualIbanEntrySuccessPayload'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['AllowSddVirtualIbanEntrySuccessPayload']: {
        __typename: 'AllowSddVirtualIbanEntrySuccessPayload';
        virtualIbanEntry: GraphQLTypes['VirtualIBANEntry'];
    };
    /** Rejection returned if card already has a valid Physical Card */
    ['AlreadyValidPhysicalCardRejection']: {
        __typename: 'AlreadyValidPhysicalCardRejection';
        message: string;
    };
    ['AmlRiskLevel']: AmlRiskLevel;
    /** Amount with its currency */
    ['Amount']: {
        __typename: 'Amount';
        /** currency */
        currency: GraphQLTypes['Currency'];
        /** value of the amount */
        value: GraphQLTypes['AmountValue'];
    };
    /** Amount with its currency */
    ['AmountInput']: {
        /** value of the amount */
        value: GraphQLTypes['AmountValue'];
        /** currency */
        currency: GraphQLTypes['Currency'];
    };
    /** The amount given with fractional digits, where fractions must be compliant to the currency definition. Up to 14 significant figures. Negative amounts are signed by minus. The decimal separator is a dot.
  
  Example: Valid representations for EUR with up to two decimals are:
  
  1056
  5768.2
  -1.50
  5877.78 */
    ['AmountValue']: 'scalar' & {
        name: 'AmountValue';
    };
    /** Rejection return if the project is not configured to allow Apple Pay */
    ['ApplePayNotAllowedForProjectRejection']: {
        __typename: 'ApplePayNotAllowedForProjectRejection';
        id: string;
        message: string;
    };
    /** Approved Funding Limit */
    ['ApprovedFundingLimit']: {
        __typename: 'ApprovedFundingLimit';
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit: GraphQLTypes['FundingLimitAmount'];
        /** Requested amount settings for the funding limit */
        fundingLimit: GraphQLTypes['FundingLimitAmount'];
    };
    ['AuditId']: 'scalar' & {
        name: 'AuditId';
    };
    /** A method used to authenticate a user */
    ['Authenticator']: {
        __typename: 'Authenticator';
        /** Operating System parsed from the user agent (eg AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, ...) */
        os?: string | undefined;
        /** Device Brand parsed from the user agent (eg: Acer, Alcatel, Amazon, Apple, ...) */
        brand?: string | undefined;
        /** Device Model parsed from the user agent */
        model?: string | undefined;
        /** Type of authenticator */
        type: GraphQLTypes['AuthenticatorType'];
        /** Raw user agent */
        userAgent?: string | undefined;
        /** Accept-Language header used during registration */
        acceptLanguage?: string | undefined;
    };
    ['AuthenticatorType']: AuthenticatorType;
    ['AuthorizationId']: 'scalar' & {
        name: 'AuthorizationId';
    };
    /** Type of the card authorization transaction */
    ['AuthorizationType']: AuthorizationType;
    /** Rejection returned if the status account is not valid */
    ['BadAccountStatusRejection']: {
        __typename: 'BadAccountStatusRejection';
        id: string;
        message: string;
    };
    ['BadRequestRejection']: {
        __typename: 'BadRequestRejection';
        message: string;
    };
    /** Balance Information */
    ['Balance']: {
        __typename: 'Balance';
        /** Matching account for this balance */
        account: GraphQLTypes['Account'];
        /** A list of balances regarding an account. */
        balances?: GraphQLTypes['AccountBalances'] | undefined;
        /** Last SCT OUT transaction */
        lastSctOut?: GraphQLTypes['SEPACreditTransferTransaction'] | undefined;
        /** Last SCT IN transaction */
        lastSctIn?: GraphQLTypes['SEPACreditTransferTransaction'] | undefined;
    };
    /** Information about the banking institution */
    ['Bank']: {
        __typename: 'Bank';
        /** Bank name */
        name: string;
        /** Bank Branch Code */
        branch?: string | undefined;
        /** Bank local identifier (unique by country) */
        nationalId: string;
        /** Bank BIC code */
        bic: GraphQLTypes['BIC'];
        /** Bank address (We might only be able to fill in the country) */
        address: GraphQLTypes['Address'];
    };
    /** Basic Physical Card Info */
    ['BasicPhysicalCardInfo']: {
        __typename: 'BasicPhysicalCardInfo';
        /** Physical Card expiration date  with MM/YY string format */
        expiryDate?: string | undefined;
        /** Offline Spending limit defined by Swan */
        offlineSpendingLimit: GraphQLTypes['Amount'];
        /** Masked Card Number */
        cardMaskedNumber: string;
        /** Custom Options */
        customOptions: GraphQLTypes['PhysicalCardCustomOptions'];
    };
    /** BeneficiaryAccountHolderType */
    ['BeneficiaryAccountHolderType']: BeneficiaryAccountHolderType;
    /** BeneficiaryAccountStatus */
    ['BeneficiaryAccountStatus']: BeneficiaryAccountStatus;
    /** Beneficiary name and IBAN match */
    ['BeneficiaryMatch']: {
        __typename: 'BeneficiaryMatch';
        accountStatus: GraphQLTypes['BeneficiaryAccountStatus'];
        accountHolderType: GraphQLTypes['BeneficiaryAccountHolderType'];
    };
    /** Beneficiary name and IBAN did not match */
    ['BeneficiaryMismatch']: {
        __typename: 'BeneficiaryMismatch';
        accountStatus: GraphQLTypes['BeneficiaryAccountStatus'];
        accountHolderType: GraphQLTypes['BeneficiaryAccountHolderType'];
        /** Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank */
        nameSuggestion?: string | undefined;
        /** Only returned if accountHolderType is Company and if the information is provided by the beneficiary's bank */
        accountHolderResidencyCity?: string | undefined;
    };
    /** Beneficiary type */
    ['BeneficiaryType']: BeneficiaryType;
    /** Beneficiary name and IBAN did not match entirely possibly caused by a mistype */
    ['BeneficiaryTypo']: {
        __typename: 'BeneficiaryTypo';
        accountStatus: GraphQLTypes['BeneficiaryAccountStatus'];
        accountHolderType: GraphQLTypes['BeneficiaryAccountHolderType'];
        /** Only returned if the information is provided by the beneficiary's bank */
        nameSuggestion?: string | undefined;
    };
    /** BeneficiaryVerification input */
    ['BeneficiaryVerificationInput']: {
        /** IBAN to verify */
        iban: GraphQLTypes['IBAN'];
        /** Name to correlate */
        name: string;
        /** AccountId of the initiator of the payment */
        debtorAccountId: string;
    };
    /** BeneficiaryVerificationResult */
    ['BeneficiaryVerificationResult']: {
        __typename: 'BeneficiaryMatch' | 'BeneficiaryTypo' | 'BeneficiaryMismatch' | 'InvalidBeneficiaryVerification';
        ['...on BeneficiaryMatch']: '__union' & GraphQLTypes['BeneficiaryMatch'];
        ['...on BeneficiaryTypo']: '__union' & GraphQLTypes['BeneficiaryTypo'];
        ['...on BeneficiaryMismatch']: '__union' & GraphQLTypes['BeneficiaryMismatch'];
        ['...on InvalidBeneficiaryVerification']: '__union' & GraphQLTypes['InvalidBeneficiaryVerification'];
    };
    /** Bank Identifier Code */
    ['BIC']: 'scalar' & {
        name: 'BIC';
    };
    ['BindAccountMembershipInput']: {
        accountMembershipId: string;
    };
    ['BindAccountMembershipPayload']: {
        __typename: 'BindAccountMembershipSuccessPayload' | 'BadAccountStatusRejection' | 'AccountMembershipNotFoundRejection' | 'AccountMembershipNotReadyToBeBoundRejection' | 'IdentityAlreadyBindToAccountMembershipRejection' | 'RestrictedToUserRejection' | 'ValidationRejection';
        ['...on BindAccountMembershipSuccessPayload']: '__union' & GraphQLTypes['BindAccountMembershipSuccessPayload'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on AccountMembershipNotFoundRejection']: '__union' & GraphQLTypes['AccountMembershipNotFoundRejection'];
        ['...on AccountMembershipNotReadyToBeBoundRejection']: '__union' & GraphQLTypes['AccountMembershipNotReadyToBeBoundRejection'];
        ['...on IdentityAlreadyBindToAccountMembershipRejection']: '__union' & GraphQLTypes['IdentityAlreadyBindToAccountMembershipRejection'];
        ['...on RestrictedToUserRejection']: '__union' & GraphQLTypes['RestrictedToUserRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['BindAccountMembershipSuccessPayload']: {
        __typename: 'BindAccountMembershipSuccessPayload';
        accountMembership: GraphQLTypes['AccountMembership'];
    };
    /** Booked transaction status information */
    ['BookedTransactionStatusInfo']: {
        __typename: 'BookedTransactionStatusInfo';
        /** status of the transaction */
        status: GraphQLTypes['TransactionStatus'];
        /** The Date when the transaction is posted to an account on the Swan books. */
        bookingDate: GraphQLTypes['DateTime'];
        /** The Date when the transaction is considered effective in accounting */
        valueDate: GraphQLTypes['DateTime'];
    };
    /** Business activity. */
    ['BusinessActivity']: BusinessActivity;
    /** Inputs to cancel a card */
    ['CancelCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
    };
    ['CancelCardPayload']: {
        __typename: 'CancelCardSuccessPayload' | 'AccountMembershipNotAllowedRejection' | 'CardNotFoundRejection' | 'ForbiddenRejection' | 'ValidationRejection';
        ['...on CancelCardSuccessPayload']: '__union' & GraphQLTypes['CancelCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['CancelCardSuccessPayload']: {
        __typename: 'CancelCardSuccessPayload';
        /** The canceled card */
        card: GraphQLTypes['Card'];
    };
    /** Input of the `cancelConsent` mutation */
    ['CancelConsentInput']: {
        consentId: string;
    };
    /** Payload of the `cancelConsent` mutation */
    ['CancelConsentPayload']: {
        __typename: 'CancelConsentSuccessPayload' | 'ConsentNotFoundRejection' | 'NotReachableConsentStatusRejection';
        ['...on CancelConsentSuccessPayload']: '__union' & GraphQLTypes['CancelConsentSuccessPayload'];
        ['...on ConsentNotFoundRejection']: '__union' & GraphQLTypes['ConsentNotFoundRejection'];
        ['...on NotReachableConsentStatusRejection']: '__union' & GraphQLTypes['NotReachableConsentStatusRejection'];
    };
    /** Success payload of the `cancelConsent` mutation */
    ['CancelConsentSuccessPayload']: {
        __typename: 'CancelConsentSuccessPayload';
        consent: GraphQLTypes['Consent'];
    };
    /** Inputs to cancel a digital card */
    ['CancelDigitalCardInput']: {
        /** Unique identifier of a digital card */
        digitalCardId: string;
    };
    ['CancelDigitalCardPayload']: {
        __typename: 'CancelDigitalCardSuccessPayload' | 'AccountMembershipNotAllowedRejection' | 'CardNotFoundRejection' | 'DigitalCardNotFoundRejection' | 'ForbiddenRejection' | 'ValidationRejection';
        ['...on CancelDigitalCardSuccessPayload']: '__union' & GraphQLTypes['CancelDigitalCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on DigitalCardNotFoundRejection']: '__union' & GraphQLTypes['DigitalCardNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['CancelDigitalCardSuccessPayload']: {
        __typename: 'CancelDigitalCardSuccessPayload';
        /** The canceled digital card */
        digitalCard: GraphQLTypes['DigitalCard'];
    };
    /** Funding Source Canceled Reason */
    ['CanceledFundingSourceReason']: CanceledFundingSourceReason;
    /** Funding Source Canceled status information */
    ['CanceledFundingSourceStatusInfo']: {
        __typename: 'CanceledFundingSourceStatusInfo';
        /** Funding Source Canceled status */
        status: GraphQLTypes['FundingSourceStatus'];
        /** Date at which the funding source was enabled */
        enabledAt?: GraphQLTypes['Date'] | undefined;
        /** Date at which the funding source was canceled */
        canceledAt: GraphQLTypes['Date'];
        /** Reason code of the cancellation */
        reasonCode: GraphQLTypes['CanceledFundingSourceReason'];
    };
    /** Describes an identification level for the process associated to this identification that has been cancelled by the end-user */
    ['CanceledIdentificationLevelStatusInfo']: {
        __typename: 'CanceledIdentificationLevelStatusInfo';
        /** Always set to `Cancelled` */
        status: GraphQLTypes['SwanIdentificationStatus'];
    };
    /** CanceledMerchantPaymentMethodStatusInfo */
    ['CanceledMerchantPaymentMethodStatusInfo']: {
        __typename: 'CanceledMerchantPaymentMethodStatusInfo';
        status: GraphQLTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method canceled date */
        canceledAt: GraphQLTypes['Date'];
    };
    /** CanceledMerchantProfileStatusInfo */
    ['CanceledMerchantProfileStatusInfo']: {
        __typename: 'CanceledMerchantProfileStatusInfo';
        status: GraphQLTypes['MerchantProfileStatus'];
        canceledAt: GraphQLTypes['Date'];
        enabledAt?: GraphQLTypes['Date'] | undefined;
    };
    /** Canceled transaction status information */
    ['CanceledTransactionStatusInfo']: {
        __typename: 'CanceledTransactionStatusInfo';
        /** status of the transaction */
        status: GraphQLTypes['TransactionStatus'];
        /** The date when the transaction was canceled */
        canceledDate?: GraphQLTypes['DateTime'] | undefined;
    };
    /** Cancel Funding Source Input */
    ['CancelFundingSourceInput']: {
        /** ID of the funding source to cancel */
        id: string;
    };
    /** Cancel Funding Source Payload */
    ['CancelFundingSourcePayload']: {
        __typename: 'CancelFundingSourceSuccessPayload' | 'ForbiddenRejection' | 'NotFoundRejection';
        ['...on CancelFundingSourceSuccessPayload']: '__union' & GraphQLTypes['CancelFundingSourceSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: '__union' & GraphQLTypes['NotFoundRejection'];
    };
    /** Cancel Funding Source Success Payload */
    ['CancelFundingSourceSuccessPayload']: {
        __typename: 'CancelFundingSourceSuccessPayload';
        /** Canceled Funding Source */
        fundingSource?: GraphQLTypes['FundingSource'] | undefined;
    };
    /** Inputs to cancel a physical card */
    ['CancelPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Reason why the physical card is canceled */
        reason: GraphQLTypes['CancelPhysicalCardReason'];
    };
    ['CancelPhysicalCardPayload']: {
        __typename: 'CancelPhysicalCardSuccessPayload' | 'AccountMembershipNotAllowedRejection' | 'CardNotFoundRejection' | 'ForbiddenRejection' | 'PhysicalCardNotFoundRejection' | 'ValidationRejection';
        ['...on CancelPhysicalCardSuccessPayload']: '__union' & GraphQLTypes['CancelPhysicalCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on PhysicalCardNotFoundRejection']: '__union' & GraphQLTypes['PhysicalCardNotFoundRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** reason why the physical card is canceled */
    ['CancelPhysicalCardReason']: CancelPhysicalCardReason;
    ['CancelPhysicalCardSuccessPayload']: {
        __typename: 'CancelPhysicalCardSuccessPayload';
        /** The canceled physical card */
        physicalCard: GraphQLTypes['PhysicalCard'];
    };
    ['CancelStandingOrderInput']: {
        standingOrderId: string;
    };
    ['CancelStandingOrderPayload']: {
        __typename: 'CancelStandingOrderSuccessPayload' | 'ForbiddenRejection' | 'InternalErrorRejection' | 'StandingOrderNotFoundRejection';
        ['...on CancelStandingOrderSuccessPayload']: '__union' & GraphQLTypes['CancelStandingOrderSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on StandingOrderNotFoundRejection']: '__union' & GraphQLTypes['StandingOrderNotFoundRejection'];
    };
    ['CancelStandingOrderSuccessPayload']: {
        __typename: 'CancelStandingOrderSuccessPayload';
        standingOrder: GraphQLTypes['StandingOrder'];
    };
    /** Cancel transaction */
    ['CancelTransactionInput']: {
        /** transaction ID to cancel */
        transactionId: string;
    };
    ['CancelTransactionPayload']: {
        __typename: 'CancelTransactionSuccessPayload' | 'ForbiddenRejection';
        ['...on CancelTransactionSuccessPayload']: '__union' & GraphQLTypes['CancelTransactionSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
    };
    ['CancelTransactionSuccessPayload']: {
        __typename: 'CancelTransactionSuccessPayload';
        message: string;
    };
    ['CancelVirtualIbanEntryInput']: {
        virtualIbanEntryId: string;
    };
    ['CancelVirtualIbanEntryPayload']: {
        __typename: 'CancelVirtualIbanEntrySuccessPayload' | 'AccountNotFoundRejection' | 'BadAccountStatusRejection' | 'InternalErrorRejection' | 'ValidationRejection';
        ['...on CancelVirtualIbanEntrySuccessPayload']: '__union' & GraphQLTypes['CancelVirtualIbanEntrySuccessPayload'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['CancelVirtualIbanEntrySuccessPayload']: {
        __typename: 'CancelVirtualIbanEntrySuccessPayload';
        virtualIbanEntry: GraphQLTypes['VirtualIBANEntry'];
    };
    /** Rejection returned when the Physical Card cannot be activated */
    ['CannotActivatePhysicalCardRejection']: {
        __typename: 'CannotActivatePhysicalCardRejection';
        message: string;
        identifier: string;
    };
    /** Capital deposit case for a company. */
    ['CapitalDepositCase']: {
        __typename: 'CapitalDepositCase';
        /** Unique identifier of a capital deposit case. */
        id: string;
        /** List of the company’s shareholders. */
        shareholders: Array<GraphQLTypes['Shareholder']>;
        /** Amount of the capital deposit. */
        totalCapitalDepositAmount: GraphQLTypes['Amount'];
        /** Name of the company. */
        companyName: string;
        /** Onboarding information of the company. */
        companyOnboarding?: GraphQLTypes['Onboarding'] | undefined;
        /** Unique identifier of the company account. */
        companyAccountId?: string | undefined;
        /** Status of the capital deposit case. */
        status: GraphQLTypes['CapitalDepositCaseStatus'];
        /** Documents to provide to fulfill the capital deposit case. */
        documents: Array<GraphQLTypes['CapitalDepositDocument']>;
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of elements ([Learn More](https://docs.swan.io/api/pagination)) */
    ['CapitalDepositCaseConnection']: {
        __typename: 'CapitalDepositCaseConnection';
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** CapitalDepositCaseEdge list */
        edges: Array<GraphQLTypes['CapitalDepositCaseEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['CapitalDepositCaseEdge']: {
        __typename: 'CapitalDepositCaseEdge';
        /** Opaque identifier pointing to this capital deposit case node in the pagination mechanism */
        cursor: string;
        /** The CapitalDepositCase */
        node: GraphQLTypes['CapitalDepositCase'];
    };
    /** Filters that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseFiltersInput']: {
        /** Searches company shareholder name, individual shareholder first name, last name, and id */
        search?: string | undefined;
        /** Status we want to filter on */
        status?: Array<GraphQLTypes['CapitalDepositCaseStatus']> | undefined;
    };
    /** Field we can use when ordering that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseOrderByFieldInput']: CapitalDepositCaseOrderByFieldInput;
    /** Order that can be applied when listing capital deposit cases */
    ['CapitalDepositCaseOrderByInput']: {
        field?: GraphQLTypes['CapitalDepositCaseOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Status of a capital deposit case. */
    ['CapitalDepositCaseStatus']: CapitalDepositCaseStatus;
    /** Document provided for a capital deposit case. */
    ['CapitalDepositDocument']: {
        __typename: 'CapitalDepositDocument';
        /** Unique identifier of a document. */
        id: string;
        /** Type of the document. */
        type: GraphQLTypes['CapitalDepositDocumentType'];
        /** Url to download the document, null if it has not already been uploaded. */
        downloadUrl?: string | undefined;
        /** Date when the last version of the document has been uploaded. */
        uploadedAt?: GraphQLTypes['Date'] | undefined;
        /** Status of the document. */
        status: GraphQLTypes['CapitalDepositDocumentStatus'];
        /** Status info of the document. */
        statusInfo: GraphQLTypes['CapitalDepositDocumentStatusInfo'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Information about capital deposit case. */
        relatedCapitalDepositCase?: GraphQLTypes['CapitalDepositCase'] | undefined;
        /** Information about shareholder. */
        relatedShareholder?: GraphQLTypes['Shareholder'] | undefined;
    };
    /** Rejection returned if the document from a capital deposit case cannot be uploaded in its context
  @deprecated(reason: "use `CapitalDepositDocumentCanNotBeUploadedRejection` instead") */
    ['CapitalDepositDocumentCanNotBeUploaded']: {
        __typename: 'CapitalDepositDocumentCanNotBeUploaded';
        id: string;
        message: string;
    };
    /** Rejection returned if the document from a capital deposit case cannot be uploaded in its context */
    ['CapitalDepositDocumentCanNotBeUploadedRejection']: {
        __typename: 'CapitalDepositDocumentCanNotBeUploadedRejection';
        id: string;
        message: string;
    };
    /** Capital Deposit Document with Pending status */
    ['CapitalDepositDocumentPendingStatusInfo']: {
        __typename: 'CapitalDepositDocumentPendingStatusInfo';
        /** Pending */
        status: GraphQLTypes['CapitalDepositDocumentStatus'];
    };
    /** Capital Deposit Document with Refused status */
    ['CapitalDepositDocumentRefusedStatusInfo']: {
        __typename: 'CapitalDepositDocumentRefusedStatusInfo';
        /** Refused */
        status: GraphQLTypes['CapitalDepositDocumentStatus'];
        /** Reason for the rejection. */
        reasonCode: GraphQLTypes['DocumentReasonCode'];
    };
    /** Status of the Capital Deposit Case */
    ['CapitalDepositDocumentStatus']: CapitalDepositDocumentStatus;
    /** Status info of the document. */
    ['CapitalDepositDocumentStatusInfo']: {
        __typename: 'CapitalDepositDocumentPendingStatusInfo' | 'CapitalDepositDocumentRefusedStatusInfo' | 'CapitalDepositDocumentUploadedStatusInfo' | 'CapitalDepositDocumentValidatedStatusInfo';
        /** Status of the document. */
        status: GraphQLTypes['CapitalDepositDocumentStatus'];
        ['...on CapitalDepositDocumentPendingStatusInfo']: '__union' & GraphQLTypes['CapitalDepositDocumentPendingStatusInfo'];
        ['...on CapitalDepositDocumentRefusedStatusInfo']: '__union' & GraphQLTypes['CapitalDepositDocumentRefusedStatusInfo'];
        ['...on CapitalDepositDocumentUploadedStatusInfo']: '__union' & GraphQLTypes['CapitalDepositDocumentUploadedStatusInfo'];
        ['...on CapitalDepositDocumentValidatedStatusInfo']: '__union' & GraphQLTypes['CapitalDepositDocumentValidatedStatusInfo'];
    };
    /** Type of the document. */
    ['CapitalDepositDocumentType']: CapitalDepositDocumentType;
    /** Capital Deposit Document with Uploaded status */
    ['CapitalDepositDocumentUploadedStatusInfo']: {
        __typename: 'CapitalDepositDocumentUploadedStatusInfo';
        /** Uploaded */
        status: GraphQLTypes['CapitalDepositDocumentStatus'];
    };
    /** Capital Deposit Document with Validated status */
    ['CapitalDepositDocumentValidatedStatusInfo']: {
        __typename: 'CapitalDepositDocumentValidatedStatusInfo';
        /** Validated */
        status: GraphQLTypes['CapitalDepositDocumentStatus'];
    };
    /** Card */
    ['Card']: {
        __typename: 'Card';
        /** Unique identifier of a card */
        id: string;
        /** Type of a card */
        type: GraphQLTypes['CardType'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Account membership to define the card holder and the account linked to the card. */
        accountMembership: GraphQLTypes['AccountMembership'];
        /** Main Currency */
        mainCurrency: GraphQLTypes['Currency'];
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: GraphQLTypes['DateTime'] | undefined;
        /** URL of the card design */
        cardDesignUrl: string;
        /** URL of the card with masked card information (like its number) and with full card information if connected user consented beforehand */
        cardUrl: string;
        /** Card status information */
        statusInfo: GraphQLTypes['CardStatusInfo'];
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Periodic Spending limit list */
        spendingLimits?: Array<GraphQLTypes['SpendingLimit']> | undefined;
        /** Physical card if the card holder has ordered one */
        physicalCard?: GraphQLTypes['PhysicalCard'] | undefined;
        /** Masked Card Number */
        cardMaskedNumber: string;
        /** Card expiry date with MM/YY format */
        expiryDate?: string | undefined;
        /** Card name */
        name?: string | undefined;
        /** Card product */
        cardProduct: GraphQLTypes['CardProduct'];
        /** Issuing Country */
        issuingCountry: GraphQLTypes['CCA3'];
        /** Digital Cards linked to this card
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        digitalCards: GraphQLTypes['DigitalCardConnection'];
        /** List of transactions of a card.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: GraphQLTypes['TransactionConnection'] | undefined;
        /** Periodic Spending */
        spending?: GraphQLTypes['Spending'] | undefined;
    };
    ['CardAuthorizationOutcome']: CardAuthorizationOutcome;
    ['CardAuthorizationType']: CardAuthorizationType;
    /** Card Canceled Status Information */
    ['CardCanceledStatusInfo']: {
        __typename: 'CardCanceledStatusInfo';
        /** Card status (always Canceled for type CardCanceledStatusInfo). */
        status: GraphQLTypes['CardStatus'];
        /** Reason why the card is canceled */
        reason: string;
    };
    /** Card Canceling Status Information */
    ['CardCancelingStatusInfo']: {
        __typename: 'CardCancelingStatusInfo';
        /** Card status (always Canceling for type CardCancelingStatusInfo). */
        status: GraphQLTypes['CardStatus'];
        /** Reason why the card is about to be canceled. */
        reason: string;
    };
    /** Rejection returned if the card could not be digitalized */
    ['CardCanNotBeDigitalizedRejection']: {
        __typename: 'CardCanNotBeDigitalizedRejection';
        id: string;
        message: string;
    };
    ['CardConfidential']: {
        __typename: 'CardConfidential';
        /** Card number */
        pan: string;
        /** Card verification value */
        cvv: string;
        /** Expiration date */
        expiryDate: string;
    };
    ['CardConfigInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: GraphQLTypes['DateTime'] | undefined;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Card name */
        name?: string | undefined;
        /** Spending limit */
        spendingLimit: GraphQLTypes['SpendingLimitInput'];
        /** If used a physical card will be printed and sent to the given address */
        physicalCard?: GraphQLTypes['PhysicalCardConfigInput'] | undefined;
    };
    ['CardConfigWithGroupDeliveryInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: GraphQLTypes['DateTime'] | undefined;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Card name */
        name?: string | undefined;
        /** Spending limit */
        spendingLimit: GraphQLTypes['SpendingLimitInput'];
        /** `true` when you wish for print an associated physical card */
        printPhysicalCard: boolean;
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: GraphQLTypes['PhysicalCardCustomOptionsForGroupDeliveryInput'] | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['CardConnection']: {
        __typename: 'CardConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** CardEdge list */
        edges: Array<GraphQLTypes['CardEdge']>;
    };
    /** when the user has to consent to add this card */
    ['CardConsentPendingStatusInfo']: {
        __typename: 'CardConsentPendingStatusInfo';
        /** Card status (always ConsentPending for type CardConsentPendingStatusInfo) */
        status: GraphQLTypes['CardStatus'];
        /** The consent required to add this card */
        consent: GraphQLTypes['Consent'];
    };
    ['CardDesignBackground']: {
        __typename: 'CardDesignBackground';
        /** Unique identifier of a project card design background */
        id: string;
        /** Card design background name */
        name: string;
        /** Card design background type */
        type: string;
        /** Card design background text color */
        cardTextColor: string;
        /** Card design background url */
        cardBackgroundUrl: string;
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
    };
    /** Project Card Design Background Type */
    ['CardDesignBackgroundType']: CardDesignBackgroundType;
    /** Card designs Status */
    ['CardDesignStatus']: CardDesignStatus;
    /** Implements the Relay Edge interface */
    ['CardEdge']: {
        __typename: 'CardEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The Card entry */
        node: GraphQLTypes['Card'];
    };
    /** Card Enabled Status Information */
    ['CardEnabledStatusInfo']: {
        __typename: 'CardEnabledStatusInfo';
        /** Card status (always Enabled for type CardEnabledStatusInfo). */
        status: GraphQLTypes['CardStatus'];
    };
    /** Filters that can be applied when listing cards */
    ['CardFiltersInput']: {
        /** The status of the card.
    
    @deprecated(reason: "use `statuses` instead") */
        status?: GraphQLTypes['CardStatus'] | undefined;
        /** Statuses of the card. */
        statuses?: Array<GraphQLTypes['CardStatus']> | undefined;
        /** Type of card
    
    @deprecated(reason: "use `types` instead") */
        type?: GraphQLTypes['CardType'] | undefined;
        /** Types of card */
        types?: Array<GraphQLTypes['CardType']> | undefined;
        /** String searched */
        search?: string | undefined;
        /** Account identifier
    
    This filter is only available for User Access Token, for the moment */
        accountId?: string | undefined;
    };
    /** COMING SOON */
    ['CardMerchantPaymentMethod']: {
        __typename: 'CardMerchantPaymentMethod';
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: GraphQLTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: GraphQLTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: GraphQLTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: GraphQLTypes['RollingReserve'] | undefined;
    };
    /** Rejection returned if the card was not found or if the user does not have the rights to know that the account exists */
    ['CardNotFoundRejection']: {
        __typename: 'CardNotFoundRejection';
        id: string;
        message: string;
    };
    /** Field we can use when ordering that can be applied when listing cards */
    ['CardOrderByFieldInput']: CardOrderByFieldInput;
    /** Order that can be applied when listing cards */
    ['CardOrderByInput']: {
        field?: GraphQLTypes['CardOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    ['CardPaymentMethodInput']: {
        /** Determine whether the payment method must be activated or not */
        activate?: boolean | undefined;
    };
    /** when the card is in the process of being ready to use */
    ['CardProcessingStatusInfo']: {
        __typename: 'CardProcessingStatusInfo';
        /** Card status (always Processing for type CardProcessingStatusInfo) */
        status: GraphQLTypes['CardStatus'];
    };
    /** Card Product */
    ['CardProduct']: {
        __typename: 'CardProduct';
        id: string;
        name?: string | undefined;
        projectId: string;
        status: GraphQLTypes['CardProductStatus'];
        createdAt: GraphQLTypes['DateTime'];
        updatedAt: GraphQLTypes['DateTime'];
        applicableToPhysicalCards: boolean;
        cardDesigns: Array<GraphQLTypes['CardProductDesign']>;
        defaultCardProduct: boolean;
        individualSpendingLimit: GraphQLTypes['SpendingLimit'];
        companySpendingLimit: GraphQLTypes['SpendingLimit'];
    };
    /** Card design of a Card Product */
    ['CardProductDesign']: {
        __typename: 'CardProductDesign';
        /** Unique identifier of a card design */
        id: string;
        /** Design version */
        version: number;
        /** Logo url svg */
        cardProjectLogoSvgUrl?: string | undefined;
        /** Logo url 300 dpi */
        cardProjectLogo300dpiUrl?: string | undefined;
        /** Logo url 300 dpi */
        cardProjectLogo600dpiUrl?: string | undefined;
        /** Zoom level */
        zoomRatioProjectLogo?: number | undefined;
        /** Card Design URL */
        cardDesignUrl?: string | undefined;
        /** Accent color */
        accentColor: string;
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Status of the card design */
        status: GraphQLTypes['CardDesignStatus'];
        /** Card Background of the Card design */
        cardBackground: GraphQLTypes['CardDesignBackground'];
    };
    /** Rejection returned if the card product is disabled. */
    ['CardProductDisabledRejection']: {
        __typename: 'CardProductDisabledRejection';
        message: string;
    };
    /** Rejection returned if the card product is not applicable to physical card. */
    ['CardProductNotApplicableToPhysicalCardsRejection']: {
        __typename: 'CardProductNotApplicableToPhysicalCardsRejection';
        message: string;
    };
    ['CardProductNotFoundRejection']: {
        __typename: 'CardProductNotFoundRejection';
        message: string;
    };
    /** Card Product Status */
    ['CardProductStatus']: CardProductStatus;
    /** Rejection returned if the card product is suspended. */
    ['CardProductSuspendedRejection']: {
        __typename: 'CardProductSuspendedRejection';
        message: string;
    };
    ['CardProductUsedRejection']: {
        __typename: 'CardProductUsedRejection';
        message: string;
    };
    /** Card settings for a Project */
    ['CardSettings']: {
        __typename: 'CardSettings';
        /** Unique identifier of a project card settings */
        id: string;
        /** Flag used to indicate if ApplePay is activated for the project */
        allowsApplePay: boolean;
        /** Settings version */
        version: number;
        /** Logo url svg */
        cardProjectLogoSvgUrl?: string | undefined;
        /** Logo url 300 dpi */
        cardProjectLogo300dpiUrl?: string | undefined;
        /** Logo url 300 dpi */
        cardProjectLogo600dpiUrl?: string | undefined;
        /** Zoom level */
        zoomRatioProjectLogo?: number | undefined;
        /** Card Design URL */
        cardDesignUrl?: string | undefined;
        /** Accent color */
        accentColor: string;
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Status of the card settings */
        status: GraphQLTypes['ProjectCardStatus'];
        /** Card Background of the Card Settings */
        cardBackground: GraphQLTypes['CardSettingsBackground'];
    };
    ['CardSettingsBackground']: {
        __typename: 'CardSettingsBackground';
        /** Unique identifier of a project card settings */
        id: string;
        /** Card settings background name */
        name: string;
        /** Card settings background type */
        type: string;
        /** Card settings background text color */
        cardTextColor: string;
        /** Card settings background url */
        cardBackgroundUrl: string;
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
    };
    /** Card Settings Background Type */
    ['CardSettingsBackgroundType']: CardSettingsBackgroundType;
    /** Card Status */
    ['CardStatus']: CardStatus;
    /** Card Status Information */
    ['CardStatusInfo']: {
        __typename: 'CardCanceledStatusInfo' | 'CardCancelingStatusInfo' | 'CardConsentPendingStatusInfo' | 'CardEnabledStatusInfo' | 'CardProcessingStatusInfo';
        /** Status of the card. */
        status: GraphQLTypes['CardStatus'];
        ['...on CardCanceledStatusInfo']: '__union' & GraphQLTypes['CardCanceledStatusInfo'];
        ['...on CardCancelingStatusInfo']: '__union' & GraphQLTypes['CardCancelingStatusInfo'];
        ['...on CardConsentPendingStatusInfo']: '__union' & GraphQLTypes['CardConsentPendingStatusInfo'];
        ['...on CardEnabledStatusInfo']: '__union' & GraphQLTypes['CardEnabledStatusInfo'];
        ['...on CardProcessingStatusInfo']: '__union' & GraphQLTypes['CardProcessingStatusInfo'];
    };
    ['CardToken']: 'scalar' & {
        name: 'CardToken';
    };
    /** Card transaction */
    ['CardTransaction']: {
        __typename: 'CardTransaction';
        /** unique identifier of the transaction */
        id: string;
        /** external identifier of the transaction */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: GraphQLTypes['TransactionSide'];
        /** type */
        type: GraphQLTypes['TransactionTypeEnum'];
        /** amount */
        amount: GraphQLTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: GraphQLTypes['Payment'] | undefined;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: GraphQLTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: GraphQLTypes['PaymentProduct'];
        /** card numbers masked (Primary Account Number) */
        maskedPan: string;
        /** unique identifier of the card */
        cardId: string;
        /** card used for this transaction */
        card: GraphQLTypes['Card'];
        /** unique identifier of the terminal */
        terminalId: string;
        /** original amount and currency of the transaction */
        originalAmount: GraphQLTypes['Amount'];
        /** currency exchange if any */
        currencyExchange: Array<GraphQLTypes['ReportExchangeRate']>;
        /** unique identifier of the merchant */
        merchantId: string;
        /** merchant name */
        merchantName: string;
        /** merchant city */
        merchantCity: string;
        /** merchant country */
        merchantCountry?: GraphQLTypes['CCA3'] | undefined;
        /** merchant postal code */
        merchantPostalCode?: string | undefined;
        /** merchant category code (MCC) */
        merchantCategoryCode: string;
        /** merchant category description
    Enum that explains what the MCC corresponds to in a more readable way */
        merchantCategoryDescription: GraphQLTypes['MerchantCategoryDescription'];
        /** category of the payment flow */
        category: GraphQLTypes['Category'];
        /** type of the authorization.
    Only available for:
    - authorization transaction
    - debit transaction linked to a previous authorization transaction */
        authorizationType?: GraphQLTypes['AuthorizationType'] | undefined;
        /** matching account for the transaction */
        account?: GraphQLTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: GraphQLTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: GraphQLTypes['Transaction'] | undefined;
    };
    ['CardTransactionCategory']: CardTransactionCategory;
    /** Card Type */
    ['CardType']: CardType;
    /** Rejection returned when the Card is not the expected status */
    ['CardWrongStatusRejection']: {
        __typename: 'CardWrongStatusRejection';
        message: string;
        identifier: string;
        currentStatus: GraphQLTypes['CardStatus'];
        expectedStatus: GraphQLTypes['CardStatus'];
    };
    /** Cash account type (Always Current) */
    ['CashAccountType']: CashAccountType;
    /** Payment flow available options */
    ['Category']: Category;
    /** Country code alpha 2 (ISO 3166) */
    ['CCA2']: 'scalar' & {
        name: 'CCA2';
    };
    /** Country code alpha 3 (ISO 3166) */
    ['CCA3']: 'scalar' & {
        name: 'CCA3';
    };
    /** Certificate */
    ['Certificate']: {
        /** CertificateType
    
    Can be either LEAF or INTERMEDIATE */
        key: string;
        /** Base64 value of the certificate */
        value: string;
    };
    /** CheckMerchantPaymentMethod */
    ['CheckMerchantPaymentMethod']: {
        __typename: 'CheckMerchantPaymentMethod';
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: GraphQLTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: GraphQLTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: GraphQLTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: GraphQLTypes['RollingReserve'] | undefined;
    };
    ['CheckPaymentMethodInput']: {
        /** Determine whether the payment method must be activated or not */
        activate?: boolean | undefined;
    };
    ['CheckRejection']: {
        __typename: 'CheckRejection';
        message: string;
        fnciInfo: GraphQLTypes['FnciInfo'];
    };
    /** Check transaction */
    ['CheckTransaction']: {
        __typename: 'CheckTransaction';
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference: string;
        /** payment method identifier used for this transaction: check number */
        paymentMethodIdentifier: string;
        /** 31-caracter unique identifier located at the bottom of the check.
    CMC7 is composed of 3 sections (check number (7 char.), check issuing bank code (12 char.), check holder account number (12 char.)).
    Combined with RLMC key, it  allows the check traceability. */
        cmc7: string;
        /** 2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
    Combined with CMC7 line, it allows the check traceability. */
        rlmcKey: string;
        /** side (Credit or Debit) */
        side: GraphQLTypes['TransactionSide'];
        /** type */
        type: GraphQLTypes['TransactionTypeEnum'];
        /** amount */
        amount: GraphQLTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: GraphQLTypes['Payment'] | undefined;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: GraphQLTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: GraphQLTypes['PaymentProduct'];
        /** matching account for the transaction */
        account?: GraphQLTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: GraphQLTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: GraphQLTypes['Transaction'] | undefined;
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: GraphQLTypes['Amount'] | undefined;
        /** date on which reserved funds become available */
        reservedAmountReleasedAt?: GraphQLTypes['DateTime'] | undefined;
        /** return reason */
        returnReason?: GraphQLTypes['TransactionReasonCode'] | undefined;
    };
    ['CloseAccountInput']: {
        accountId: string;
        reason: GraphQLTypes['PartnerCloseAccountReasonInput'];
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['CloseAccountPayload']: {
        __typename: 'CloseAccountSuccessPayload' | 'AccountNotFoundRejection' | 'BadAccountStatusRejection' | 'ForbiddenRejection' | 'InternalErrorRejection' | 'ValidationRejection';
        ['...on CloseAccountSuccessPayload']: '__union' & GraphQLTypes['CloseAccountSuccessPayload'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Define a reason with a message and a specific type for closing account action */
    ['CloseAccountReason']: {
        __typename: 'CloseAccountReason';
        type: GraphQLTypes['CloseAccountReasonType'];
        message?: string | undefined;
    };
    /** Specific type for closing account action */
    ['CloseAccountReasonType']: CloseAccountReasonType;
    /** Union between PartnerCloseAccountReasonType and InternalCloseAccountReason */
    ['CloseAccountStatusReason']: {
        __typename: 'CloseAccountReason';
        ['...on CloseAccountReason']: '__union' & GraphQLTypes['CloseAccountReason'];
    };
    ['CloseAccountSuccessPayload']: {
        __typename: 'CloseAccountSuccessPayload';
        consent: GraphQLTypes['Consent'];
    };
    /** Data provided following the search for company information by siren number */
    ['CompanyInfo']: {
        __typename: 'CompanyInfo';
        siren: string;
        companyName: string;
        headquarters: GraphQLTypes['Headquarters'];
        vatNumber?: string | undefined;
        taxIdentificationNumber?: string | undefined;
        legalRepresentativePersonalAddress?: GraphQLTypes['AddressInformation'] | undefined;
    };
    /** Company shareholder info. */
    ['CompanyShareholder']: {
        __typename: 'CompanyShareholder';
        /** Whether the shareholder is an individual or a company. */
        type: GraphQLTypes['ShareholderType'];
        /** Company name. */
        name: string;
    };
    /** Type of company. */
    ['CompanyType']: CompanyType;
    /** Complete Address Information */
    ['CompleteAddressInput']: {
        /** address line 1 (max 38 characters) */
        addressLine1: string;
        /** address line 2 (max 38 characters) */
        addressLine2?: string | undefined;
        /** city (max 30 characters) */
        city: string;
        /** postal code (max 10 characters) */
        postalCode: string;
        /** state (max 30 characters) */
        state?: string | undefined;
        /** country code */
        country: GraphQLTypes['CCA3'];
    };
    /** Complete Address Information with a contact */
    ['CompleteAddressWithContactInput']: {
        /** address line 1 (max 38 characters) */
        addressLine1: string;
        /** address line 2 (max 38 characters) */
        addressLine2?: string | undefined;
        /** city (max 30 characters) */
        city: string;
        /** postal code (max 10 characters) */
        postalCode: string;
        /** state (max 30 characters) */
        state?: string | undefined;
        /** country code */
        country: GraphQLTypes['CCA3'];
        /** contact first name */
        firstName: string;
        /** contact last name */
        lastName: string;
        /** contact phone number */
        phoneNumber: GraphQLTypes['PhoneNumber'];
        /** contact company name (max 38 characters) */
        companyName?: string | undefined;
    };
    /** Complete Digital Card used for ApplePay or GooglePay
  
  Once the pending phase is over, more data will be available in the response */
    ['CompleteDigitalCard']: {
        __typename: 'CompleteDigitalCard';
        /** Unique identifier of a digital card */
        id: string;
        /** The type of digitalization that created this digital card. */
        type: GraphQLTypes['DigitalizationType'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider: GraphQLTypes['WalletProvider'];
        /** Device
    In case of a wallet application, some information about the device will be provided */
        device: GraphQLTypes['Device'];
        /** Id of the wallet application.
    Will not be present for Merchant */
        walletId?: string | undefined;
        /** Masked DPAN with the last four digits visible
    
    This value is present in the user wallet application */
        cardMaskedNumber: string;
        /** Digital Card status information
    
    In this type the status will be either ConsentPending or Pending */
        statusInfo: GraphQLTypes['CompleteDigitalCardStatusInfo'];
    };
    /** Complete Digital Card Status */
    ['CompleteDigitalCardStatus']: CompleteDigitalCardStatus;
    /** Complete Digital Card Status Information */
    ['CompleteDigitalCardStatusInfo']: {
        __typename: 'DigitalCardCanceledStatusInfo' | 'DigitalCardEnabledStatusInfo' | 'DigitalCardSuspendedStatusInfo';
        /** Status of the digital card. */
        status: GraphQLTypes['CompleteDigitalCardStatus'];
        ['...on DigitalCardCanceledStatusInfo']: '__union' & GraphQLTypes['DigitalCardCanceledStatusInfo'];
        ['...on DigitalCardEnabledStatusInfo']: '__union' & GraphQLTypes['DigitalCardEnabledStatusInfo'];
        ['...on DigitalCardSuspendedStatusInfo']: '__union' & GraphQLTypes['DigitalCardSuspendedStatusInfo'];
    };
    ['CompletedMerchantPaymentLinkStatusInfo']: {
        __typename: 'CompletedMerchantPaymentLinkStatusInfo';
        status: GraphQLTypes['MerchantPaymentLinkStatus'];
        /** The time when the customer completed the payment. */
        completedAt: GraphQLTypes['DateTime'];
    };
    /** Inputs to confirm physical card renewal */
    ['ConfirmPhysicalCardRenewalInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Address to deliver the physical card */
        address: GraphQLTypes['CompleteAddressInput'];
        /** Custom Options */
        customOptions?: GraphQLTypes['PhysicalCardCustomOptionsInput'] | undefined;
    };
    ['ConfirmPhysicalCardRenewalPayload']: {
        __typename: 'ConfirmPhysicalCardRenewalSuccessPayload' | 'ForbiddenRejection' | 'CardNotFoundRejection' | 'ValidationRejection' | 'PhysicalCardWrongStatusRejection';
        ['...on ConfirmPhysicalCardRenewalSuccessPayload']: '__union' & GraphQLTypes['ConfirmPhysicalCardRenewalSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
        ['...on PhysicalCardWrongStatusRejection']: '__union' & GraphQLTypes['PhysicalCardWrongStatusRejection'];
    };
    ['ConfirmPhysicalCardRenewalSuccessPayload']: {
        __typename: 'ConfirmPhysicalCardRenewalSuccessPayload';
        /** Physical card has been updated */
        physicalCard: GraphQLTypes['PhysicalCard'];
    };
    /** Relay Connection type, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['Connection']: {
        __typename: 'AccountConnection' | 'AccountHolderConnection' | 'AccountMembershipConnection' | 'CapitalDepositCaseConnection' | 'CardConnection' | 'ConsentConnection' | 'DigitalCardConnection' | 'ExternalAccountConnection' | 'ExternalBalanceConnection' | 'FundingLimitSettingsChangeRequestConnection' | 'FundingSourceConnection' | 'InvoiceConnection' | 'LegalDocumentConnection' | 'MerchantProfileConnection' | 'OnboardingConnection' | 'PaymentConnection' | 'PaymentMandateConnection' | 'ReceivedDirectDebitMandateConnection' | 'StandingOrderConnection' | 'StatementConnection' | 'SupportingDocumentCollectionConnection' | 'TransactionConnection' | 'TrustedBeneficiaryConnection' | 'UserConnection' | 'VirtualIBANEntryConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** Edge list */
        edges: Array<GraphQLTypes['Edge']>;
        ['...on AccountConnection']: '__union' & GraphQLTypes['AccountConnection'];
        ['...on AccountHolderConnection']: '__union' & GraphQLTypes['AccountHolderConnection'];
        ['...on AccountMembershipConnection']: '__union' & GraphQLTypes['AccountMembershipConnection'];
        ['...on CapitalDepositCaseConnection']: '__union' & GraphQLTypes['CapitalDepositCaseConnection'];
        ['...on CardConnection']: '__union' & GraphQLTypes['CardConnection'];
        ['...on ConsentConnection']: '__union' & GraphQLTypes['ConsentConnection'];
        ['...on DigitalCardConnection']: '__union' & GraphQLTypes['DigitalCardConnection'];
        ['...on ExternalAccountConnection']: '__union' & GraphQLTypes['ExternalAccountConnection'];
        ['...on ExternalBalanceConnection']: '__union' & GraphQLTypes['ExternalBalanceConnection'];
        ['...on FundingLimitSettingsChangeRequestConnection']: '__union' & GraphQLTypes['FundingLimitSettingsChangeRequestConnection'];
        ['...on FundingSourceConnection']: '__union' & GraphQLTypes['FundingSourceConnection'];
        ['...on InvoiceConnection']: '__union' & GraphQLTypes['InvoiceConnection'];
        ['...on LegalDocumentConnection']: '__union' & GraphQLTypes['LegalDocumentConnection'];
        ['...on MerchantProfileConnection']: '__union' & GraphQLTypes['MerchantProfileConnection'];
        ['...on OnboardingConnection']: '__union' & GraphQLTypes['OnboardingConnection'];
        ['...on PaymentConnection']: '__union' & GraphQLTypes['PaymentConnection'];
        ['...on PaymentMandateConnection']: '__union' & GraphQLTypes['PaymentMandateConnection'];
        ['...on ReceivedDirectDebitMandateConnection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateConnection'];
        ['...on StandingOrderConnection']: '__union' & GraphQLTypes['StandingOrderConnection'];
        ['...on StatementConnection']: '__union' & GraphQLTypes['StatementConnection'];
        ['...on SupportingDocumentCollectionConnection']: '__union' & GraphQLTypes['SupportingDocumentCollectionConnection'];
        ['...on TransactionConnection']: '__union' & GraphQLTypes['TransactionConnection'];
        ['...on TrustedBeneficiaryConnection']: '__union' & GraphQLTypes['TrustedBeneficiaryConnection'];
        ['...on UserConnection']: '__union' & GraphQLTypes['UserConnection'];
        ['...on VirtualIBANEntryConnection']: '__union' & GraphQLTypes['VirtualIBANEntryConnection'];
    };
    /** Some sensitive operation at Swan, such as initiating a payment, require consent */
    ['Consent']: {
        __typename: 'Consent';
        /** unique identifier of the consent */
        id: string;
        /** `true` if the consent requires a Strong Customer Authentication */
        requireSCA: boolean;
        /** status of the consent */
        status: GraphQLTypes['ConsentStatus'];
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt?: GraphQLTypes['DateTime'] | undefined;
        /** date when the `consentUrl` was request the first time */
        startedAt?: GraphQLTypes['DateTime'] | undefined;
        /** date when the consent expire */
        expiredAt?: GraphQLTypes['DateTime'] | undefined;
        /** purpose of the consent */
        purpose: GraphQLTypes['ConsentPurpose'];
        /** Redirect the user to this URL to start the consent flow */
        consentUrl: string;
        /** When the consent flow is finished the user is redirected to this URL */
        redirectUrl: string;
        /** userId who initiated the consent */
        userId: string;
        /** user who initiated the consent */
        user?: GraphQLTypes['User'] | undefined;
        /** unique hash of the consent */
        challenge?: string | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ConsentConnection']: {
        __typename: 'ConsentConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** ConsentEdge list */
        edges: Array<GraphQLTypes['ConsentEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['ConsentEdge']: {
        __typename: 'ConsentEdge';
        /** Opaque identifier pointing to this consent node in the pagination mechanism */
        cursor: string;
        /** The consent */
        node: GraphQLTypes['Consent'];
    };
    /** Consent ID with related execution order */
    ['ConsentIdWithOrder']: {
        /** Execution order. Consents are granted in ascending order. Consents with the same order may be granted in parallel. */
        order: number;
        /** Consent ID */
        consentId: string;
    };
    /** Rejection returned if a consent was not found */
    ['ConsentNotFoundRejection']: {
        __typename: 'ConsentNotFoundRejection';
        message: string;
        consentId: string;
    };
    /** Purpose of a consent */
    ['ConsentPurpose']: ConsentPurpose;
    /** Rejection returned when a the consent is already linked to another multi consent */
    ['ConsentsAlreadyLinkedToMultiConsentRejection']: {
        __typename: 'ConsentsAlreadyLinkedToMultiConsentRejection';
        message: string;
        /** IDs of the consents that are already linked to another multi consent */
        consentIds: Array<string>;
    };
    ['ConsentsFiltersInput']: {
        userId?: string | undefined;
    };
    /** Rejection returned when all provided consents are not in created status */
    ['ConsentsNotAllInCreatedStatusRejection']: {
        __typename: 'ConsentsNotAllInCreatedStatusRejection';
        message: string;
        /** IDs of the consents that are not in created status */
        consentIds: Array<string>;
    };
    /** Rejection returned when a consent ID passed as input does not exist. */
    ['ConsentsNotFoundRejection']: {
        __typename: 'ConsentsNotFoundRejection';
        message: string;
        ids: Array<string>;
    };
    /** Status of a consent */
    ['ConsentStatus']: ConsentStatus;
    ['ConsentTypeNotSupportedByServerConsentRejection']: {
        __typename: 'ConsentTypeNotSupportedByServerConsentRejection';
        message: string;
    };
    /** Inputs to create a capital deposit case. */
    ['CreateCapitalDepositCaseInput']: {
        /** Name ("Dénomination sociale") of the company being registered and for which the capital is being deposited. */
        companyName: string;
        /** Array of shareholders of type company ("personne morale"). */
        companyShareholders: Array<GraphQLTypes['OnboardCompanyShareholderInput'] | undefined>;
        /** Array of shareholders of type individual ("personne physique"). */
        individualShareholders: Array<GraphQLTypes['OnboardIndividualShareholderInput'] | undefined>;
        /** Amount of the capital deposit. */
        totalCapitalDepositAmount: GraphQLTypes['AmountInput'];
        /** Information required for the onboarding of a company. */
        onboardingCapitalDepositCompany: GraphQLTypes['OnboardCompanyAccountHolderInput'];
    };
    ['CreateCapitalDepositCasePayload']: {
        __typename: 'CreateCapitalDepositCaseSuccessPayload' | 'ForbiddenRejection' | 'BadRequestRejection' | 'ValidationRejection' | 'InternalErrorRejection';
        ['...on CreateCapitalDepositCaseSuccessPayload']: '__union' & GraphQLTypes['CreateCapitalDepositCaseSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on BadRequestRejection']: '__union' & GraphQLTypes['BadRequestRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
    };
    ['CreateCapitalDepositCaseSuccessPayload']: {
        __typename: 'CreateCapitalDepositCaseSuccessPayload';
        capitalDepositCase: GraphQLTypes['CapitalDepositCase'];
    };
    ['CreateMerchantPaymentLinkInput']: {
        /** The Merchant Profile to link this Payment Link to */
        merchantProfileId: string;
        /** Amount to be paid to sucessfully complete the payment. */
        amount: GraphQLTypes['AmountInput'];
        /** Merchant Website URL to redirect the user to when the payment is completed. */
        redirectUrl: GraphQLTypes['URL'];
        /** URL to redirect the user to if they cancel their payment */
        cancelRedirectUrl: GraphQLTypes['URL'];
        /** The customer billing Address
    These fields should be completed also to pre-fill a SEPA direct debit mandate.
    
    We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes */
        billingAddress?: GraphQLTypes['AddressInput'] | undefined;
        /** The date when the payment link expires.
    If not specified, the default time will be 120 days */
        expiresAt?: GraphQLTypes['DateTime'] | undefined;
        /** A date that reflects the time at which the user asked the transaction to be executed.
    For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
    For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
    
    Default value means that the execution will be as soon as possible */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** Controls if the payment mandate created from this payment link is for one-time use or can be reused
    This is applicable for card and SEPA Direct Debit payment methods only.
    If not specified, the default value is OneOff. */
        sequence?: GraphQLTypes['PaymentMandateSequence'] | undefined;
        /** Any string that you want to be attached to this payment link.
    Usually something to help you reference the link in an external system. */
        externalReference?: string | undefined;
        /** Optional field intended to provide a way for you to include a reference number or code.
    The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different. */
        reference?: string | undefined;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page. */
        label?: string | undefined;
        /** The language used for the payment page.
    Default is the browser's language, or English if not available. */
        language?: GraphQLTypes['Language'] | undefined;
        /** We will use the information specified here to prefill the payment link fields
    depending on the payment method the end user chooses.
    Keep in mind that your end customer will be able to edit these fields. */
        customer?: GraphQLTypes['CustomerInput'] | undefined;
        /** List of payment methods enabled for this payment link.
    If the array is empty, Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit)
    If you want to make payment possible via SEPA Direct Debit, the list should be populated either by a SEPA Direct Debit CORE or B2B. */
        paymentMethodIds?: Array<string> | undefined;
    };
    ['CreateMerchantPaymentLinkPayload']: {
        __typename: 'CreateMerchantPaymentLinkSuccessPayload' | 'MerchantProfileWrongStatusRejection' | 'MerchantPaymentMethodNotActiveRejection' | 'PaymentMethodNotCompatibleRejection' | 'InternalErrorRejection' | 'ForbiddenRejection' | 'ValidationRejection';
        ['...on CreateMerchantPaymentLinkSuccessPayload']: '__union' & GraphQLTypes['CreateMerchantPaymentLinkSuccessPayload'];
        ['...on MerchantProfileWrongStatusRejection']: '__union' & GraphQLTypes['MerchantProfileWrongStatusRejection'];
        ['...on MerchantPaymentMethodNotActiveRejection']: '__union' & GraphQLTypes['MerchantPaymentMethodNotActiveRejection'];
        ['...on PaymentMethodNotCompatibleRejection']: '__union' & GraphQLTypes['PaymentMethodNotCompatibleRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['CreateMerchantPaymentLinkSuccessPayload']: {
        __typename: 'CreateMerchantPaymentLinkSuccessPayload';
        merchantPaymentLink: GraphQLTypes['MerchantPaymentLink'];
    };
    /** Input of the `createMultiConsent` mutation */
    ['CreateMultiConsentInput']: {
        /** A list of consent IDs with their related execution orders */
        orderedConsentIds: Array<GraphQLTypes['ConsentIdWithOrder']>;
        /** URL the user is redirected to after consent has been given */
        redirectUrl: string;
    };
    /** Payload of the `createMultiConsent` mutation */
    ['CreateMultiConsentPayload']: {
        __typename: 'CreateMultiConsentSuccessPayload' | 'ConsentsNotAllInCreatedStatusRejection' | 'ConsentsNotFoundRejection' | 'TooManyChildConsentsRejection' | 'ConsentsAlreadyLinkedToMultiConsentRejection';
        ['...on CreateMultiConsentSuccessPayload']: '__union' & GraphQLTypes['CreateMultiConsentSuccessPayload'];
        ['...on ConsentsNotAllInCreatedStatusRejection']: '__union' & GraphQLTypes['ConsentsNotAllInCreatedStatusRejection'];
        ['...on ConsentsNotFoundRejection']: '__union' & GraphQLTypes['ConsentsNotFoundRejection'];
        ['...on TooManyChildConsentsRejection']: '__union' & GraphQLTypes['TooManyChildConsentsRejection'];
        ['...on ConsentsAlreadyLinkedToMultiConsentRejection']: '__union' & GraphQLTypes['ConsentsAlreadyLinkedToMultiConsentRejection'];
    };
    /** Success payload of the `createMultiConsent` mutation */
    ['CreateMultiConsentSuccessPayload']: {
        __typename: 'CreateMultiConsentSuccessPayload';
        consent?: GraphQLTypes['Consent'] | undefined;
    };
    /** Credit transfer */
    ['CreditTransferInput']: {
        /** if the transfer will credit a beneficiary already created */
        beneficiaryId?: string | undefined;
        /** if the transfer will credit a new swan account beneficiary */
        swanAccountBeneficiary?: GraphQLTypes['SwanAccountBeneficiaryInput'] | undefined;
        /** if the transfer will credit a new SEPA beneficiary */
        sepaBeneficiary?: GraphQLTypes['SepaBeneficiaryInput'] | undefined;
        /** amount of the transfer */
        amount: GraphQLTypes['AmountInput'];
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined;
        /** label (max 140 characters) */
        label?: string | undefined;
        /** requested date at which the credit transfer will try to be executed, if `null` the credit transfer is executed right away */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** an arbitrary identifier that you can define to easily identify this transaction later */
        externalReference?: string | undefined;
        /** if the transfer will execute as instant and fallbacked to a regular one if an error happend during the instant transfer */
        mode?: GraphQLTypes['CreditTransferMode'] | undefined;
    };
    ['CreditTransferMode']: CreditTransferMode;
    /** Custom information for a CSV statement */
    ['CsvStatement']: {
        __typename: 'CsvStatement';
        /** statement type */
        type?: GraphQLTypes['StatementType'] | undefined;
        /** temporary public url on which the file can be accessed */
        url?: string | undefined;
        /** date at which the link will not be useable anymore */
        expiresAt?: GraphQLTypes['DateTime'] | undefined;
    };
    /** currency code alpha 3 (ISO 4217) */
    ['Currency']: 'scalar' & {
        name: 'Currency';
    };
    ['Customer']: {
        __typename: 'Customer';
        /** A customer id present in a third-party system.
    Alows to link a customer to a payment link and by extension, to a Merchant Payment. */
        externalCustomerId?: string | undefined;
        name?: string | undefined;
        iban?: string | undefined;
    };
    ['CustomerInput']: {
        /** A customer ID present in a third-party system.
    Alows to link a customer to a payment link and by extension, to a merchant payment. */
        externalCustomerId?: string | undefined;
        /** Customer name */
        name?: string | undefined;
        /** Customer IBAN */
        iban?: string | undefined;
    };
    /** Date with YYYY-MM-DD format */
    ['Date']: 'scalar' & {
        name: 'Date';
    };
    ['DateField']: {
        __typename: 'DateField';
        example?: string | undefined;
        key: string;
        name: string;
        required: boolean;
        validationRegex?: string | undefined;
    };
    /** Date time (ISO 8601 with time information)
  ex: 2021-04-12T16:28:22.867Z */
    ['DateTime']: 'scalar' & {
        name: 'DateTime';
    };
    /** Rejection returned when the Debtor is closed */
    ['DebtorAccountClosedRejection']: {
        __typename: 'DebtorAccountClosedRejection';
        message: string;
    };
    /** Rejection returned when the Debtor does not belong to the same project as the creditor */
    ['DebtorAccountNotAllowedRejection']: {
        __typename: 'DebtorAccountNotAllowedRejection';
        message: string;
    };
    ['DeleteSupportingDocumentInput']: {
        /** Id of the supporting document to delete */
        id: string;
    };
    ['DeleteSupportingDocumentPayload']: {
        __typename: 'DeleteSupportingDocumentSuccessPayload' | 'ForbiddenRejection' | 'InternalErrorRejection' | 'SupportingDocumentCollectionNotFoundRejection' | 'SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection' | 'SupportingDocumentNotFoundRejection' | 'SupportingDocumentStatusDoesNotAllowDeletionRejection' | 'ValidationRejection';
        ['...on DeleteSupportingDocumentSuccessPayload']: '__union' & GraphQLTypes['DeleteSupportingDocumentSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on SupportingDocumentCollectionNotFoundRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionNotFoundRejection'];
        ['...on SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection'];
        ['...on SupportingDocumentNotFoundRejection']: '__union' & GraphQLTypes['SupportingDocumentNotFoundRejection'];
        ['...on SupportingDocumentStatusDoesNotAllowDeletionRejection']: '__union' & GraphQLTypes['SupportingDocumentStatusDoesNotAllowDeletionRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['DeleteSupportingDocumentSuccessPayload']: {
        __typename: 'DeleteSupportingDocumentSuccessPayload';
        id: string;
    };
    ['DenySddInput']: {
        accountId: string;
    };
    ['DenySddPayload']: {
        __typename: 'DenySddSuccessPayload' | 'BadAccountStatusRejection' | 'AccountNotFoundRejection' | 'InvalidArgumentRejection' | 'ValidationRejection';
        ['...on DenySddSuccessPayload']: '__union' & GraphQLTypes['DenySddSuccessPayload'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on InvalidArgumentRejection']: '__union' & GraphQLTypes['InvalidArgumentRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['DenySddSuccessPayload']: {
        __typename: 'DenySddSuccessPayload';
        account: GraphQLTypes['Account'];
    };
    ['DenySddVirtualIbanEntryInput']: {
        ibanEntryId: string;
    };
    ['DenySddVirtualIbanEntryPayload']: {
        __typename: 'DenySddVirtualIbanEntrySuccessPayload' | 'BadAccountStatusRejection' | 'ValidationRejection';
        ['...on DenySddVirtualIbanEntrySuccessPayload']: '__union' & GraphQLTypes['DenySddVirtualIbanEntrySuccessPayload'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['DenySddVirtualIbanEntrySuccessPayload']: {
        __typename: 'DenySddVirtualIbanEntrySuccessPayload';
        virtualIbanEntry: GraphQLTypes['VirtualIBANEntry'];
    };
    /** Device */
    ['Device']: {
        __typename: 'Device';
        /** The type of device. It can be a Phone, Tablet, Watch */
        type?: string | undefined;
        /** Device name
    End user defined name of the device on which the card id provided */
        name?: string | undefined;
        /** Secure Element ID */
        SEID?: string | undefined;
    };
    /** Digital Card used for ApplePay or GooglePay */
    ['DigitalCard']: {
        __typename: 'CompleteDigitalCard' | 'PendingDigitalCard';
        /** Unique identifier of a digital card */
        id: string;
        /** The type of digitalization that created this digital card. */
        type: GraphQLTypes['DigitalizationType'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider: GraphQLTypes['WalletProvider'];
        ['...on CompleteDigitalCard']: '__union' & GraphQLTypes['CompleteDigitalCard'];
        ['...on PendingDigitalCard']: '__union' & GraphQLTypes['PendingDigitalCard'];
    };
    /** Digital Card Canceled Status Information */
    ['DigitalCardCanceledStatusInfo']: {
        __typename: 'DigitalCardCanceledStatusInfo';
        /** Card status (always Canceled for type DigitalCardCanceledStatusInfo). */
        status: GraphQLTypes['CompleteDigitalCardStatus'];
        /** Enable Date */
        enabledAt: GraphQLTypes['DateTime'];
        /** Cancel Date */
        canceledAt: GraphQLTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['DigitalCardConnection']: {
        __typename: 'DigitalCardConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** CardEdge list */
        edges: Array<GraphQLTypes['DigitalCardEdge']>;
    };
    /** Digital Card ConsentPending Status Information */
    ['DigitalCardConsentPendingStatusInfo']: {
        __typename: 'DigitalCardConsentPendingStatusInfo';
        /** Digital Card status (always ConsentPending for type DigitalCardConsentPendingStatusInfo). */
        status: GraphQLTypes['PendingDigitalCardStatus'];
        /** A reference to the consent to validate */
        consent: GraphQLTypes['Consent'];
    };
    /** Digital Card Declined Status Information */
    ['DigitalCardDeclinedStatusInfo']: {
        __typename: 'DigitalCardDeclinedStatusInfo';
        /** Digital Card status (always Declined for type DigitalCardDeclinedStatusInfo). */
        status: GraphQLTypes['PendingDigitalCardStatus'];
    };
    /** Implements the Relay Edge interface */
    ['DigitalCardEdge']: {
        __typename: 'DigitalCardEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The Card entry */
        node: GraphQLTypes['DigitalCard'];
    };
    /** Digital Card Enabled Status Information */
    ['DigitalCardEnabledStatusInfo']: {
        __typename: 'DigitalCardEnabledStatusInfo';
        /** Digital Card status (always Enabled for type DigitalCardEnabledStatusInfo). */
        status: GraphQLTypes['CompleteDigitalCardStatus'];
        /** Enable Date */
        enabledAt: GraphQLTypes['DateTime'];
    };
    /** Filters that can be applied when listing digitalCards */
    ['DigitalCardFiltersInput']: {
        /** The id of the digitalCard */
        id?: string | undefined;
        /** The status of the digital card. It can be a CompleteDigitalCardStatus or a PendingDigitalCardStatus */
        status?: string | undefined;
        /** The Secure Element ID
    Mostly present on APple Devices */
        SEID?: string | undefined;
        /** The digital card masker number */
        cardMaskedNumber?: string | undefined;
        /** The ID of the wallet provider in the scheme system */
        walletProviderId?: string | undefined;
        /** Either ApplePay, GooglePay or Merchant */
        walletProviderName?: string | undefined;
        /** The wallet application ID in the user phone */
        walletId?: string | undefined;
    };
    /** Rejection returned when the Digital Card does not exist */
    ['DigitalCardNotFoundRejection']: {
        __typename: 'DigitalCardNotFoundRejection';
        message: string;
        identifier: string;
    };
    /** Field we can use when ordering that can be applied when listing digital cards */
    ['DigitalCardOrderByFieldInput']: DigitalCardOrderByFieldInput;
    /** Order that can be applied when listing digital cards */
    ['DigitalCardOrderByInput']: {
        field?: GraphQLTypes['DigitalCardOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Digital Card Pending Status Information */
    ['DigitalCardPendingStatusInfo']: {
        __typename: 'DigitalCardPendingStatusInfo';
        /** Digital Card status (always Pending for type DigitalCardPendingStatusInfo). */
        status: GraphQLTypes['PendingDigitalCardStatus'];
    };
    /** Digital Card Suspended Status Information */
    ['DigitalCardSuspendedStatusInfo']: {
        __typename: 'DigitalCardSuspendedStatusInfo';
        /** Digital Card status (always Suspended for type DigitalCardSuspendedStatusInfo). */
        status: GraphQLTypes['CompleteDigitalCardStatus'];
        /** Enable Date */
        enabledAt: GraphQLTypes['DateTime'];
        /** Suspend Date */
        suspendedAt: GraphQLTypes['DateTime'];
    };
    /** Digitalization Type */
    ['DigitalizationType']: DigitalizationType;
    /** Direct Debit Account Verification */
    ['DirectDebitAccountVerification']: {
        __typename: 'DirectDebitAccountVerification';
        /** Creation date of the account verification */
        createdAt: GraphQLTypes['DateTime'];
        /** IBAN of the account to cross check with account holder information */
        iban: GraphQLTypes['IBAN'];
        /** Unique identifier of the Account Verification */
        id: string;
        /** Account Verification Status Information */
        statusInfo: GraphQLTypes['AccountVerificationStatusInfo'];
        /** Last update date of the account verification */
        updatedAt: GraphQLTypes['DateTime'];
    };
    /** Funding Source with Direct Debit Mandate */
    ['DirectDebitFundingSource']: {
        __typename: 'DirectDebitFundingSource';
        /** ID of the Funding Source */
        id: string;
        /** Name of the Funding Source */
        name?: string | undefined;
        /** Funding Source status information */
        statusInfo: GraphQLTypes['FundingSourceStatusInfo'];
        /** IBAN to use in the direct debit transaction that will be triggered when funding the account.
    Money will be debited from this IBAN when an `initiateFundingRequest` is done using this funding source */
        iban: GraphQLTypes['IBAN'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Last updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Can be queried to check the status of the account verification for this funding source.
    If the account verification is PendingVerification, you should ask your account holder to wire some money from his external account to any swan account */
        accountVerification: GraphQLTypes['DirectDebitAccountVerification'];
        /** Can be queried to check the status of payment payment Mandate.
    If the payment mandate is ConsentPending, you should confirm it to enable this funding source */
        paymentMandate: GraphQLTypes['PaymentDirectDebitMandate'];
    };
    ['DirectDebitSequence']: DirectDebitSequence;
    /** Input to disable an account membership */
    ['DisableAccountMembershipInput']: {
        /** Unique identifier of the account membership to disable */
        accountMembershipId: string;
    };
    ['DisableAccountMembershipPayload']: {
        __typename: 'DisableAccountMembershipSuccessPayload' | 'AccountMembershipCannotBeDisabledRejection' | 'AccountMembershipNotFoundRejection' | 'ForbiddenRejection' | 'InternalErrorRejection' | 'LegalRepresentativeAccountMembershipCannotBeDisabledRejection' | 'UserNotAllowedToDisableItsOwnAccountMembershipRejection' | 'ValidationRejection';
        ['...on DisableAccountMembershipSuccessPayload']: '__union' & GraphQLTypes['DisableAccountMembershipSuccessPayload'];
        ['...on AccountMembershipCannotBeDisabledRejection']: '__union' & GraphQLTypes['AccountMembershipCannotBeDisabledRejection'];
        ['...on AccountMembershipNotFoundRejection']: '__union' & GraphQLTypes['AccountMembershipNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on LegalRepresentativeAccountMembershipCannotBeDisabledRejection']: '__union' & GraphQLTypes['LegalRepresentativeAccountMembershipCannotBeDisabledRejection'];
        ['...on UserNotAllowedToDisableItsOwnAccountMembershipRejection']: '__union' & GraphQLTypes['UserNotAllowedToDisableItsOwnAccountMembershipRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['DisableAccountMembershipSuccessPayload']: {
        __typename: 'DisableAccountMembershipSuccessPayload';
        accountMembership?: GraphQLTypes['AccountMembership'] | undefined;
    };
    /** StatusInfo when funding limit settings has been disabled */
    ['DisabledFundingLimitSettingsStatusInfo']: {
        __typename: 'DisabledFundingLimitSettingsStatusInfo';
        status: GraphQLTypes['FundingLimitSettingsStatus'];
        reason: string;
    };
    /** EnabledMerchantPaymentMethodStatusInfo */
    ['DisabledMerchantPaymentMethodStatusInfo']: {
        __typename: 'DisabledMerchantPaymentMethodStatusInfo';
        status: GraphQLTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method disabled date */
        disabledAt: GraphQLTypes['Date'];
    };
    /** Retrieved document extracted from the identity verification */
    ['DocumentFile']: {
        __typename: 'DriversLicenseDocumentFile' | 'IdCardDocumentFile' | 'PassportDocumentFile' | 'ReportDocumentFile' | 'ResidencePermitDocumentFile';
        downloadUrl: string;
        ['...on DriversLicenseDocumentFile']: '__union' & GraphQLTypes['DriversLicenseDocumentFile'];
        ['...on IdCardDocumentFile']: '__union' & GraphQLTypes['IdCardDocumentFile'];
        ['...on PassportDocumentFile']: '__union' & GraphQLTypes['PassportDocumentFile'];
        ['...on ReportDocumentFile']: '__union' & GraphQLTypes['ReportDocumentFile'];
        ['...on ResidencePermitDocumentFile']: '__union' & GraphQLTypes['ResidencePermitDocumentFile'];
    };
    /** From which side the document picture was taken */
    ['DocumentFileSide']: DocumentFileSide;
    /** Reason code of the document. */
    ['DocumentReasonCode']: DocumentReasonCode;
    /** The type of the document */
    ['DocumentType']: DocumentType;
    /** The document corresponding to a driver's license */
    ['DriversLicenseDocument']: {
        __typename: 'DriversLicenseDocument';
        /** Unique identifier of the driver's license document */
        id: string;
        /** The type of the document */
        type: GraphQLTypes['DocumentType'];
        /** List of the associated files */
        files: Array<GraphQLTypes['DriversLicenseDocumentFile']>;
    };
    /** The file associated to the driver's license document */
    ['DriversLicenseDocumentFile']: {
        __typename: 'DriversLicenseDocumentFile';
        /** The file's temporary download url */
        downloadUrl: string;
        /** From which side the deiver's license's picture was taken */
        side: GraphQLTypes['DocumentFileSide'];
    };
    /** Edge type containing the node and cursor. The node is not defined in the interface because generic is not supported by GraphQL
  but all implementation contains its own node property according to the paginated type. */
    ['Edge']: {
        __typename: 'AccountEdge' | 'AccountHolderEdge' | 'AccountMembershipEdge' | 'CapitalDepositCaseEdge' | 'CardEdge' | 'ConsentEdge' | 'DigitalCardEdge' | 'ExternalAccountEdge' | 'ExternalBalanceEdge' | 'FundingLimitSettingsChangeRequestEdge' | 'FundingSourceEdge' | 'IdentificationEdge' | 'InvoiceEdge' | 'LegalDocumentEdge' | 'MerchantProfileEdge' | 'OnboardingEdge' | 'PaymentEdge' | 'PaymentMandateEdge' | 'ReceivedDirectDebitMandateEdge' | 'StandingOrderEdge' | 'StatementEdge' | 'SupportingDocumentCollectionEdge' | 'TransactionEdge' | 'TrustedBeneficiaryEdge' | 'UserEdge' | 'VirtualIBANEntryEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        ['...on AccountEdge']: '__union' & GraphQLTypes['AccountEdge'];
        ['...on AccountHolderEdge']: '__union' & GraphQLTypes['AccountHolderEdge'];
        ['...on AccountMembershipEdge']: '__union' & GraphQLTypes['AccountMembershipEdge'];
        ['...on CapitalDepositCaseEdge']: '__union' & GraphQLTypes['CapitalDepositCaseEdge'];
        ['...on CardEdge']: '__union' & GraphQLTypes['CardEdge'];
        ['...on ConsentEdge']: '__union' & GraphQLTypes['ConsentEdge'];
        ['...on DigitalCardEdge']: '__union' & GraphQLTypes['DigitalCardEdge'];
        ['...on ExternalAccountEdge']: '__union' & GraphQLTypes['ExternalAccountEdge'];
        ['...on ExternalBalanceEdge']: '__union' & GraphQLTypes['ExternalBalanceEdge'];
        ['...on FundingLimitSettingsChangeRequestEdge']: '__union' & GraphQLTypes['FundingLimitSettingsChangeRequestEdge'];
        ['...on FundingSourceEdge']: '__union' & GraphQLTypes['FundingSourceEdge'];
        ['...on IdentificationEdge']: '__union' & GraphQLTypes['IdentificationEdge'];
        ['...on InvoiceEdge']: '__union' & GraphQLTypes['InvoiceEdge'];
        ['...on LegalDocumentEdge']: '__union' & GraphQLTypes['LegalDocumentEdge'];
        ['...on MerchantProfileEdge']: '__union' & GraphQLTypes['MerchantProfileEdge'];
        ['...on OnboardingEdge']: '__union' & GraphQLTypes['OnboardingEdge'];
        ['...on PaymentEdge']: '__union' & GraphQLTypes['PaymentEdge'];
        ['...on PaymentMandateEdge']: '__union' & GraphQLTypes['PaymentMandateEdge'];
        ['...on ReceivedDirectDebitMandateEdge']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateEdge'];
        ['...on StandingOrderEdge']: '__union' & GraphQLTypes['StandingOrderEdge'];
        ['...on StatementEdge']: '__union' & GraphQLTypes['StatementEdge'];
        ['...on SupportingDocumentCollectionEdge']: '__union' & GraphQLTypes['SupportingDocumentCollectionEdge'];
        ['...on TransactionEdge']: '__union' & GraphQLTypes['TransactionEdge'];
        ['...on TrustedBeneficiaryEdge']: '__union' & GraphQLTypes['TrustedBeneficiaryEdge'];
        ['...on UserEdge']: '__union' & GraphQLTypes['UserEdge'];
        ['...on VirtualIBANEntryEdge']: '__union' & GraphQLTypes['VirtualIBANEntryEdge'];
    };
    ['EmailAddress']: 'scalar' & {
        name: 'EmailAddress';
    };
    /** Employment status. */
    ['EmploymentStatus']: EmploymentStatus;
    /** Rejection returned if the card product don't have a card design enabled */
    ['EnabledCardDesignNotFoundRejection']: {
        __typename: 'EnabledCardDesignNotFoundRejection';
        message: string;
    };
    /** StatusInfo when the funding limit settings is enabled */
    ['EnabledFundingLimitSettingsStatusInfo']: {
        __typename: 'EnabledFundingLimitSettingsStatusInfo';
        status: GraphQLTypes['FundingLimitSettingsStatus'];
    };
    /** Funding Source Enabled status information */
    ['EnabledFundingSourceStatusInfo']: {
        __typename: 'EnabledFundingSourceStatusInfo';
        /** Funding Source Enabled status */
        status: GraphQLTypes['FundingSourceStatus'];
        /** Date at which the funding source was enabled */
        enabledAt: GraphQLTypes['Date'];
    };
    /** EnabledMerchantPaymentMethodStatusInfo */
    ['EnabledMerchantPaymentMethodStatusInfo']: {
        __typename: 'EnabledMerchantPaymentMethodStatusInfo';
        status: GraphQLTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method enabled date */
        enabledAt: GraphQLTypes['Date'];
    };
    /** EnabledMerchantProfileStatusInfo */
    ['EnabledMerchantProfileStatusInfo']: {
        __typename: 'EnabledMerchantProfileStatusInfo';
        status: GraphQLTypes['MerchantProfileStatus'];
        enabledAt: GraphQLTypes['Date'];
    };
    /** Inputs to enable a received direct debit mandate, i.e. to move its status back from suspended. */
    ['EnableReceivedDirectDebitMandateInput']: {
        /** The received direct debit id to enable */
        receivedDirectDebitMandateId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl?: string | undefined;
    };
    /** Union type return by the enableReceivedDirectDebitMandate mutation */
    ['EnableReceivedDirectDebitMandatePayload']: {
        __typename: 'EnableReceivedDirectDebitMandateSuccessPayload' | 'ReceivedDirectDebitMandateNotFoundRejection' | 'ReceivedDirectDebitMandateCanceledRejection' | 'ForbiddenRejection';
        ['...on EnableReceivedDirectDebitMandateSuccessPayload']: '__union' & GraphQLTypes['EnableReceivedDirectDebitMandateSuccessPayload'];
        ['...on ReceivedDirectDebitMandateNotFoundRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ['...on ReceivedDirectDebitMandateCanceledRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateCanceledRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
    };
    /** Return type in case of a successful response of the enableReceivedDirectDebitMandate mutation */
    ['EnableReceivedDirectDebitMandateSuccessPayload']: {
        __typename: 'EnableReceivedDirectDebitMandateSuccessPayload';
        /** The received direct debit mandate is enable, i.e that it is moved back to from the suspended to the enabled status */
        receivedDirectDebitMandate: GraphQLTypes['ReceivedDirectDebitMandate'];
    };
    ['EnvType']: EnvType;
    /** Describes an identification level for the process associated to this identification that has expired and is no longer considered valid */
    ['ExpiredIdentificationLevelStatusInfo']: {
        __typename: 'ExpiredIdentificationLevelStatusInfo';
        /** Always set to `Expired` */
        status: GraphQLTypes['SwanIdentificationStatus'];
        /** When this identification level expired */
        expiredAt: GraphQLTypes['Date'];
    };
    ['ExpiredMerchantPaymentLinkStatusInfo']: {
        __typename: 'ExpiredMerchantPaymentLinkStatusInfo';
        status: GraphQLTypes['MerchantPaymentLinkStatus'];
        /** The date when the payment link expired.
    By default the payment link expires 120 days after it was created. */
        expiredAt: GraphQLTypes['DateTime'];
    };
    ['ExternalAccount']: {
        __typename: 'ExternalAccount';
        /** Unique identifier of an external account */
        id: string;
        /** External account identifier following ISO-20022 standard */
        externalId: string;
        /** Name of the account */
        name?: string | undefined;
        /** Type of the account */
        cashAccountType: GraphQLTypes['CashAccountType'];
        /** Bank Identifier Code */
        BIC: GraphQLTypes['BIC'];
        /** International Bank Account Number */
        IBAN: GraphQLTypes['IBAN'];
        /** Currency */
        currency: GraphQLTypes['Currency'];
        /** Account Holder name */
        holderName: string;
        /** Country */
        country: GraphQLTypes['CCA3'];
        /** Original Created date */
        originalCreatedAt: GraphQLTypes['DateTime'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** A list of balances regarding an external account.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        balances: GraphQLTypes['ExternalBalanceConnection'];
        /** Source used for this account */
        source: GraphQLTypes['ExternalAccountDataSource'];
        /** Financial institution */
        institution?: GraphQLTypes['FinancialInstitution'] | undefined;
        /** Usage information of the account */
        usage: GraphQLTypes['ExternalAccountUsage'];
        /** Account holder for the external account */
        accountHolder?: GraphQLTypes['AccountHolder'] | undefined;
    };
    ['ExternalAccountAlreadyExistsRejection']: {
        __typename: 'ExternalAccountAlreadyExistsRejection';
        iban: string;
        accountHolderId: string;
        message: string;
    };
    ['ExternalAccountBalance']: {
        __typename: 'ExternalAccountBalance';
        /** Unique identifier of an external balance */
        id: string;
        /** Amount with currency */
        amount?: GraphQLTypes['Amount'] | undefined;
        /** Type of Balance */
        type: GraphQLTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: GraphQLTypes['DateTime'];
    };
    ['ExternalAccountBalanceAlreadyExistsRejection']: {
        __typename: 'ExternalAccountBalanceAlreadyExistsRejection';
        type: GraphQLTypes['ExternalAccountBalanceType'];
        lastChangedAt: GraphQLTypes['DateTime'];
        message: string;
    };
    ['ExternalAccountBalanceInput']: {
        /** Amount with currency */
        amount: GraphQLTypes['AmountInput'];
        /** Type of Balance */
        type: GraphQLTypes['ExternalAccountBalanceType'];
        /** Last changed Date */
        lastChangedAt: GraphQLTypes['DateTime'];
    };
    ['ExternalAccountBalanceType']: ExternalAccountBalanceType;
    /** Implements the Relay Connection interface, used to paginate the list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ExternalAccountConnection']: {
        __typename: 'ExternalAccountConnection';
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** ExternalAccountEdge list */
        edges: Array<GraphQLTypes['ExternalAccountEdge']>;
    };
    ['ExternalAccountDataSource']: {
        __typename: 'ExternalAccountDataSource';
        type: GraphQLTypes['ExternalAccountDataSourceType'];
        name: string;
    };
    ['ExternalAccountDataSourceType']: ExternalAccountDataSourceType;
    /** Implements the Relay Edge interface */
    ['ExternalAccountEdge']: {
        __typename: 'ExternalAccountEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The external account */
        node: GraphQLTypes['ExternalAccount'];
    };
    ['ExternalAccountUsage']: ExternalAccountUsage;
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ExternalBalanceConnection']: {
        __typename: 'ExternalBalanceConnection';
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** ExternalBalanceEdge list */
        edges: Array<GraphQLTypes['ExternalBalanceEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['ExternalBalanceEdge']: {
        __typename: 'ExternalBalanceEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The external balance */
        node: GraphQLTypes['ExternalAccountBalance'];
    };
    /** The document corresponding to a face photo */
    ['FacePhotoDocument']: {
        __typename: 'FacePhotoDocument';
        /** Unique identifier of the face photo document. For privacy reasons, no temporary download url is exposed for this document */
        id: string;
        /** The type of the document */
        type: GraphQLTypes['DocumentType'];
    };
    /** Fee creditor */
    ['FeeCreditor']: {
        __typename: 'FeeInCreditor' | 'FeeOutCreditor';
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
        ['...on FeeInCreditor']: '__union' & GraphQLTypes['FeeInCreditor'];
        ['...on FeeOutCreditor']: '__union' & GraphQLTypes['FeeOutCreditor'];
    };
    ['FeeDebtor']: {
        __typename: 'FeeInDebtor' | 'FeeOutDebtor';
        /** full name of the debtor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
        ['...on FeeInDebtor']: '__union' & GraphQLTypes['FeeInDebtor'];
        ['...on FeeOutDebtor']: '__union' & GraphQLTypes['FeeOutDebtor'];
    };
    /** Fee creditor for Incoming transaction */
    ['FeeInCreditor']: {
        __typename: 'FeeInCreditor';
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Fee debtor for Incoming transaction */
    ['FeeInDebtor']: {
        __typename: 'FeeInDebtor';
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Fee creditor for Outgoing transaction */
    ['FeeOutCreditor']: {
        __typename: 'FeeOutCreditor';
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Fee debtor for Outgoing transaction */
    ['FeeOutDebtor']: {
        __typename: 'FeeOutDebtor';
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    ['FeeSettingsNotFoundRejection']: {
        __typename: 'FeeSettingsNotFoundRejection';
        message: string;
    };
    /** Fees type */
    ['FeesTypeEnum']: FeesTypeEnum;
    /** Fee Transaction */
    ['FeeTransaction']: {
        __typename: 'FeeTransaction';
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain. */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: GraphQLTypes['TransactionSide'];
        /** type */
        type: GraphQLTypes['TransactionTypeEnum'];
        /** amount */
        amount: GraphQLTypes['Amount'];
        /** label */
        label: string;
        /** feesType */
        feesType: GraphQLTypes['FeesTypeEnum'];
        /** status information */
        statusInfo: GraphQLTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: GraphQLTypes['Payment'] | undefined;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: GraphQLTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: GraphQLTypes['PaymentProduct'];
        /** creditor information */
        creditor: GraphQLTypes['FeeCreditor'];
        /** debtor information */
        debtor: GraphQLTypes['FeeDebtor'];
        /** matching account for the transaction */
        account?: GraphQLTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: GraphQLTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: GraphQLTypes['Transaction'] | undefined;
    };
    ['Field']: {
        __typename: 'DateField' | 'RadioField' | 'SelectField' | 'TextField';
        key: string;
        name: string;
        required: boolean;
        ['...on DateField']: '__union' & GraphQLTypes['DateField'];
        ['...on RadioField']: '__union' & GraphQLTypes['RadioField'];
        ['...on SelectField']: '__union' & GraphQLTypes['SelectField'];
        ['...on TextField']: '__union' & GraphQLTypes['TextField'];
    };
    ['FieldValidationError']: FieldValidationError;
    ['FinalizeOnboardingInput']: {
        onboardingId: string;
    };
    ['FinalizeOnboardingPayload']: {
        __typename: 'FinalizeOnboardingSuccessPayload' | 'InternalErrorRejection' | 'ForbiddenRejection' | 'OnboardingNotCompletedRejection' | 'ValidationRejection';
        ['...on FinalizeOnboardingSuccessPayload']: '__union' & GraphQLTypes['FinalizeOnboardingSuccessPayload'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on OnboardingNotCompletedRejection']: '__union' & GraphQLTypes['OnboardingNotCompletedRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['FinalizeOnboardingSuccessPayload']: {
        __typename: 'FinalizeOnboardingSuccessPayload';
        onboarding: GraphQLTypes['Onboarding'];
    };
    ['FinancialInstitution']: {
        __typename: 'FinancialInstitution';
        id: string;
        name: string;
        country: GraphQLTypes['CCA3'];
    };
    ['FnciInfo']: {
        __typename: 'FnciInfo';
        colorCode: string;
        cpt1: number;
        cpt2: number;
        cpt3: number;
        holderEstablishment: string;
        responseCode: number;
    };
    ['ForbiddenRejection']: {
        __typename: 'ForbiddenRejection';
        message: string;
    };
    ['FundingLimit']: {
        __typename: 'FundingLimit';
        /** Maximum Funding Amount authorized */
        amount: GraphQLTypes['Amount'];
        /** Funding Amount that has already been used during the interval */
        funding?: GraphQLTypes['Amount'] | undefined;
        /** Interval in number of calendar days where the limit is applied */
        rollingDays: number;
    };
    /** Funding Limit Amount */
    ['FundingLimitAmount']: {
        __typename: 'FundingLimitAmount';
        /** The amount settings */
        amount: GraphQLTypes['Amount'];
    };
    /** Funding Limit Amount Input */
    ['FundingLimitAmountInput']: {
        /** The amount settings */
        amount: GraphQLTypes['AmountInput'];
    };
    /** Rejection returned when the Account Holder Funding has been exceeded */
    ['FundingLimitExceededRejection']: {
        __typename: 'FundingLimitExceededRejection';
        message: string;
    };
    ['FundingLimitSettings']: {
        __typename: 'FundingLimitSettings';
        /** Instant funding limit */
        instantFundingLimit?: GraphQLTypes['InstantFundingLimit'] | undefined;
        /** Periodic funding limit */
        fundingLimit?: GraphQLTypes['FundingLimit'] | undefined;
        /** Related change request */
        fundingLimitSettingsChangeRequest?: GraphQLTypes['FundingLimitSettingsChangeRequest'] | undefined;
        /** Status of the resource */
        statusInfo: GraphQLTypes['FundingLimitSettingsStatusInfo'];
    };
    /** Funding Limit Settings Change Request */
    ['FundingLimitSettingsChangeRequest']: {
        __typename: 'FundingLimitSettingsChangeRequest';
        /** Unique identifier of a funding limit settings change request */
        id: string;
        /** Requested amount settings for the instant funding limit */
        instantFundingLimit: GraphQLTypes['FundingLimitAmount'];
        /** Requested amount settings for the funding limit */
        fundingLimit: GraphQLTypes['FundingLimitAmount'];
        /** Approved amount settings for the the instant funding limit and the funding limit */
        approved?: GraphQLTypes['ApprovedFundingLimit'] | undefined;
        /** Status of the request */
        statusInfo: GraphQLTypes['FundingLimitSettingsChangeRequestStatusInfo'];
        /** Date of creation */
        createdAt?: GraphQLTypes['Date'] | undefined;
        /** Date of last update */
        updatedAt?: GraphQLTypes['Date'] | undefined;
    };
    /** StatusInfo when funding limit settings change request has been approved */
    ['FundingLimitSettingsChangeRequestApprovedStatusInfo']: {
        __typename: 'FundingLimitSettingsChangeRequestApprovedStatusInfo';
        status: GraphQLTypes['FundingLimitSettingsChangeRequestStatus'];
        reason: string;
    };
    /** Funding Limit Settings Change Request Bad Amount Rejection */
    ['FundingLimitSettingsChangeRequestBadAmountRejection']: {
        __typename: 'FundingLimitSettingsChangeRequestBadAmountRejection';
        message: string;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['FundingLimitSettingsChangeRequestConnection']: {
        __typename: 'FundingLimitSettingsChangeRequestConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** FundingLimitSettingsChangeRequestEdge list */
        edges: Array<GraphQLTypes['FundingLimitSettingsChangeRequestEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['FundingLimitSettingsChangeRequestEdge']: {
        __typename: 'FundingLimitSettingsChangeRequestEdge';
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor: string;
        /** The FundingLimitSettingsChangeRequest */
        node: GraphQLTypes['FundingLimitSettingsChangeRequest'];
    };
    /** Filters that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestFiltersInput']: {
        /** The ids of the funding limit settings change requests */
        id?: Array<string> | undefined;
        /** Status we want to filter on */
        status?: Array<GraphQLTypes['FundingLimitSettingsChangeRequestStatus']> | undefined;
    };
    /** Field we can use when ordering that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestOrderByFieldInput']: FundingLimitSettingsChangeRequestOrderByFieldInput;
    /** Order that can be applied when listing funding limit settings change requests */
    ['FundingLimitSettingsChangeRequestOrderByInput']: {
        field?: GraphQLTypes['FundingLimitSettingsChangeRequestOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** StatusInfo when funding limit settings change request is pending */
    ['FundingLimitSettingsChangeRequestPendingStatusInfo']: {
        __typename: 'FundingLimitSettingsChangeRequestPendingStatusInfo';
        status: GraphQLTypes['FundingLimitSettingsChangeRequestStatus'];
    };
    /** StatusInfo when funding limit settings change request has been rejected */
    ['FundingLimitSettingsChangeRequestRefusedStatusInfo']: {
        __typename: 'FundingLimitSettingsChangeRequestRefusedStatusInfo';
        status: GraphQLTypes['FundingLimitSettingsChangeRequestStatus'];
        reason: string;
    };
    /** Funding Limit Settings Change Request Status */
    ['FundingLimitSettingsChangeRequestStatus']: FundingLimitSettingsChangeRequestStatus;
    /** Object containing details about funding limit settings change request status */
    ['FundingLimitSettingsChangeRequestStatusInfo']: {
        __typename: 'FundingLimitSettingsChangeRequestApprovedStatusInfo' | 'FundingLimitSettingsChangeRequestPendingStatusInfo' | 'FundingLimitSettingsChangeRequestRefusedStatusInfo' | 'FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo';
        /** Current limit settings change request status. */
        status: GraphQLTypes['FundingLimitSettingsChangeRequestStatus'];
        ['...on FundingLimitSettingsChangeRequestApprovedStatusInfo']: '__union' & GraphQLTypes['FundingLimitSettingsChangeRequestApprovedStatusInfo'];
        ['...on FundingLimitSettingsChangeRequestPendingStatusInfo']: '__union' & GraphQLTypes['FundingLimitSettingsChangeRequestPendingStatusInfo'];
        ['...on FundingLimitSettingsChangeRequestRefusedStatusInfo']: '__union' & GraphQLTypes['FundingLimitSettingsChangeRequestRefusedStatusInfo'];
        ['...on FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo']: '__union' & GraphQLTypes['FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo'];
    };
    /** StatusInfo when funding limit settings change request is waiting for more information */
    ['FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo']: {
        __typename: 'FundingLimitSettingsChangeRequestWaitingForInformationStatusInfo';
        status: GraphQLTypes['FundingLimitSettingsChangeRequestStatus'];
    };
    /** Possible values for funding limit settings status */
    ['FundingLimitSettingsStatus']: FundingLimitSettingsStatus;
    /** Object containing details about funding limit settings status */
    ['FundingLimitSettingsStatusInfo']: {
        __typename: 'DisabledFundingLimitSettingsStatusInfo' | 'EnabledFundingLimitSettingsStatusInfo' | 'SuspendedFundingLimitSettingsStatusInfo';
        /** Current funding limit settings. */
        status: GraphQLTypes['FundingLimitSettingsStatus'];
        ['...on DisabledFundingLimitSettingsStatusInfo']: '__union' & GraphQLTypes['DisabledFundingLimitSettingsStatusInfo'];
        ['...on EnabledFundingLimitSettingsStatusInfo']: '__union' & GraphQLTypes['EnabledFundingLimitSettingsStatusInfo'];
        ['...on SuspendedFundingLimitSettingsStatusInfo']: '__union' & GraphQLTypes['SuspendedFundingLimitSettingsStatusInfo'];
    };
    /** Funding Source */
    ['FundingSource']: {
        __typename: 'DirectDebitFundingSource';
        /** ID of the Funding Source */
        id: string;
        /** Name of the Funding Source */
        name?: string | undefined;
        /** Funding Source status information */
        statusInfo: GraphQLTypes['FundingSourceStatusInfo'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Last updated date */
        updatedAt: GraphQLTypes['DateTime'];
        ['...on DirectDebitFundingSource']: '__union' & GraphQLTypes['DirectDebitFundingSource'];
    };
    /** Please see the Connection interface */
    ['FundingSourceConnection']: {
        __typename: 'FundingSourceConnection';
        pageInfo: GraphQLTypes['PageInfo'];
        edges: Array<GraphQLTypes['FundingSourceEdge']>;
        totalCount: number;
    };
    /** Please see the Connection interface */
    ['FundingSourceEdge']: {
        __typename: 'FundingSourceEdge';
        node: GraphQLTypes['FundingSource'];
        cursor: string;
    };
    /** Filters that can be applied when listing Funding Sources */
    ['FundingSourceFiltersInput']: {
        status: Array<GraphQLTypes['FundingSourceStatus']>;
    };
    ['FundingSourceNotFoundRejection']: {
        __typename: 'FundingSourceNotFoundRejection';
        id: string;
        message: string;
    };
    /** Field we can use when ordering that can be applied when listing funding source results */
    ['FundingSourceOrderByFieldInput']: FundingSourceOrderByFieldInput;
    /** Order that can be applied when listing funding source results */
    ['FundingSourceOrderByInput']: {
        field?: GraphQLTypes['FundingSourceOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Funding Source Statuses */
    ['FundingSourceStatus']: FundingSourceStatus;
    /** Funding Source status information */
    ['FundingSourceStatusInfo']: {
        __typename: 'CanceledFundingSourceStatusInfo' | 'EnabledFundingSourceStatusInfo' | 'PendingFundingSourceStatusInfo' | 'RejectedFundingSourceStatusInfo' | 'SuspendedFundingSourceStatusInfo';
        /** Funding Source Pending status */
        status: GraphQLTypes['FundingSourceStatus'];
        ['...on CanceledFundingSourceStatusInfo']: '__union' & GraphQLTypes['CanceledFundingSourceStatusInfo'];
        ['...on EnabledFundingSourceStatusInfo']: '__union' & GraphQLTypes['EnabledFundingSourceStatusInfo'];
        ['...on PendingFundingSourceStatusInfo']: '__union' & GraphQLTypes['PendingFundingSourceStatusInfo'];
        ['...on RejectedFundingSourceStatusInfo']: '__union' & GraphQLTypes['RejectedFundingSourceStatusInfo'];
        ['...on SuspendedFundingSourceStatusInfo']: '__union' & GraphQLTypes['SuspendedFundingSourceStatusInfo'];
    };
    /** Rejection returned when the Funding Source is not in the expected status */
    ['FundingSourceWrongStatusRejection']: {
        __typename: 'FundingSourceWrongStatusRejection';
        message: string;
        currentStatus: GraphQLTypes['FundingSourceStatus'];
        expectedStatus: GraphQLTypes['FundingSourceStatus'];
    };
    /** Inputs to generate an account */
    ['GenerateAccountStatementInput']: {
        /** Unique identifier of an account */
        accountId: string;
        /** starting date of the date window */
        openingDate: GraphQLTypes['DateTime'];
        /** ending date of the date window */
        closingDate: GraphQLTypes['DateTime'];
        /** language to generate the statement in (default to account's language) */
        language?: GraphQLTypes['AccountLanguage'] | undefined;
        /** Type of statement to generate */
        statementType?: GraphQLTypes['StatementType'] | undefined;
    };
    ['GenerateCapitalDepositDocumentUploadUrlInput']: {
        /** Unique identifier of the document. */
        documentId: string;
        /** Unique identifier of the capitalDepositCase associated to the document. */
        capitalDepositCaseId: string;
        /** Filename of the document. */
        filename: string;
    };
    ['GenerateCapitalDepositDocumentUploadUrlPayload']: {
        __typename: 'GenerateCapitalDepositDocumentUploadUrlSuccessPayload' | 'CapitalDepositDocumentCanNotBeUploaded' | 'CapitalDepositDocumentCanNotBeUploadedRejection' | 'ForbiddenRejection' | 'BadRequestRejection' | 'InternalErrorRejection';
        ['...on GenerateCapitalDepositDocumentUploadUrlSuccessPayload']: '__union' & GraphQLTypes['GenerateCapitalDepositDocumentUploadUrlSuccessPayload'];
        ['...on CapitalDepositDocumentCanNotBeUploaded']: '__union' & GraphQLTypes['CapitalDepositDocumentCanNotBeUploaded'];
        ['...on CapitalDepositDocumentCanNotBeUploadedRejection']: '__union' & GraphQLTypes['CapitalDepositDocumentCanNotBeUploadedRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on BadRequestRejection']: '__union' & GraphQLTypes['BadRequestRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
    };
    ['GenerateCapitalDepositDocumentUploadUrlSuccessPayload']: {
        __typename: 'GenerateCapitalDepositDocumentUploadUrlSuccessPayload';
        /** URL to be used to upload the document. */
        uploadUrl?: string | undefined;
    };
    ['GenerateSupportingDocumentUploadUrlInput']: {
        /** Unique identifier of a supporting document collection */
        supportingDocumentCollectionId: string;
        /** Type of document */
        supportingDocumentType?: GraphQLTypes['SupportingDocumentType'] | undefined;
        /** Name of the document which will be sent */
        filename: string;
        /** Purpose of document */
        supportingDocumentPurpose?: GraphQLTypes['SupportingDocumentPurposeEnum'] | undefined;
    };
    ['GenerateSupportingDocumentUploadUrlPayload']: {
        __typename: 'GenerateSupportingDocumentUploadUrlSuccessPayload' | 'SupportingDocumentCollectionNotFoundRejection' | 'ForbiddenRejection' | 'InternalErrorRejection' | 'SupportingDocumentUploadNotAllowedRejection' | 'ValidationRejection';
        ['...on GenerateSupportingDocumentUploadUrlSuccessPayload']: '__union' & GraphQLTypes['GenerateSupportingDocumentUploadUrlSuccessPayload'];
        ['...on SupportingDocumentCollectionNotFoundRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on SupportingDocumentUploadNotAllowedRejection']: '__union' & GraphQLTypes['SupportingDocumentUploadNotAllowedRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['GenerateSupportingDocumentUploadUrlSuccessPayload']: {
        __typename: 'GenerateSupportingDocumentUploadUrlSuccessPayload';
        /** Id of the supporting document created for this uploadUrl */
        supportingDocumentId: string;
        /** Info to upload the document : url and fields to add along file in form (POST) */
        upload: GraphQLTypes['SupportingDocumentUploadInfo'];
    };
    /** Rejection returned when the Global Funding has been exceeded */
    ['GlobalFundingLimitExceededRejection']: {
        __typename: 'GlobalFundingLimitExceededRejection';
        message: string;
    };
    /** Rejection returned when the Global Instant Funding limit has been exceeded */
    ['GlobalInstantFundingLimitExceededRejection']: {
        __typename: 'GlobalInstantFundingLimitExceededRejection';
        message: string;
    };
    /** Input of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignatureInput']: {
        /** ID of the consent to grant */
        consentId: string;
        /** Consent challenge signed with server consent credentials */
        signature: string;
    };
    /** Payload of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignaturePayload']: {
        __typename: 'GrantConsentWithServerSignatureSuccessPayload' | 'ConsentNotFoundRejection' | 'NotReachableConsentStatusRejection' | 'ForbiddenRejection' | 'ConsentTypeNotSupportedByServerConsentRejection' | 'ServerConsentNotAllowedForConsentOperationRejection' | 'ProjectNotFoundRejection' | 'ServerConsentNotAllowedForProjectRejection' | 'ServerConsentProjectSettingsNotFoundRejection' | 'ServerConsentProjectCredentialMissingRejection' | 'ServerConsentProjectCredentialNotFoundRejection' | 'ServerConsentCredentialsNotValidOrOutdatedRejection' | 'ServerConsentSignatureNotValidRejection';
        ['...on GrantConsentWithServerSignatureSuccessPayload']: '__union' & GraphQLTypes['GrantConsentWithServerSignatureSuccessPayload'];
        ['...on ConsentNotFoundRejection']: '__union' & GraphQLTypes['ConsentNotFoundRejection'];
        ['...on NotReachableConsentStatusRejection']: '__union' & GraphQLTypes['NotReachableConsentStatusRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ConsentTypeNotSupportedByServerConsentRejection']: '__union' & GraphQLTypes['ConsentTypeNotSupportedByServerConsentRejection'];
        ['...on ServerConsentNotAllowedForConsentOperationRejection']: '__union' & GraphQLTypes['ServerConsentNotAllowedForConsentOperationRejection'];
        ['...on ProjectNotFoundRejection']: '__union' & GraphQLTypes['ProjectNotFoundRejection'];
        ['...on ServerConsentNotAllowedForProjectRejection']: '__union' & GraphQLTypes['ServerConsentNotAllowedForProjectRejection'];
        ['...on ServerConsentProjectSettingsNotFoundRejection']: '__union' & GraphQLTypes['ServerConsentProjectSettingsNotFoundRejection'];
        ['...on ServerConsentProjectCredentialMissingRejection']: '__union' & GraphQLTypes['ServerConsentProjectCredentialMissingRejection'];
        ['...on ServerConsentProjectCredentialNotFoundRejection']: '__union' & GraphQLTypes['ServerConsentProjectCredentialNotFoundRejection'];
        ['...on ServerConsentCredentialsNotValidOrOutdatedRejection']: '__union' & GraphQLTypes['ServerConsentCredentialsNotValidOrOutdatedRejection'];
        ['...on ServerConsentSignatureNotValidRejection']: '__union' & GraphQLTypes['ServerConsentSignatureNotValidRejection'];
    };
    /** Success payload of the `grantConsentWithServerSignature` mutation */
    ['GrantConsentWithServerSignatureSuccessPayload']: {
        __typename: 'GrantConsentWithServerSignatureSuccessPayload';
        consent: GraphQLTypes['Consent'];
    };
    ['Headquarters']: {
        __typename: 'Headquarters';
        town: string;
        zipCode: string;
        address: string;
    };
    ['HexColorCode']: 'scalar' & {
        name: 'HexColorCode';
    };
    /** International Bank Account Number */
    ['IBAN']: 'scalar' & {
        name: 'IBAN';
    };
    /** Rejection returned when the IBAN is not reachable */
    ['IBANNotReachableRejection']: {
        __typename: 'IBANNotReachableRejection';
        message: string;
    };
    /** Rejection returned when the IBAN is not valid */
    ['IBANNotValidRejection']: {
        __typename: 'IBANNotValidRejection';
        message: string;
    };
    /** Virtual IBAN Status */
    ['IBANStatus']: IBANStatus;
    /** ibanValidation input */
    ['IbanValidationInput']: {
        /** IBAN to validate */
        iban: GraphQLTypes['IBAN'];
    };
    ['IbanValidationRejection']: {
        __typename: 'IbanValidationRejection';
        message: string;
    };
    /** IbanValidationResult */
    ['IbanValidationResult']: {
        __typename: 'ValidIban' | 'InvalidIban';
        ['...on ValidIban']: '__union' & GraphQLTypes['ValidIban'];
        ['...on InvalidIban']: '__union' & GraphQLTypes['InvalidIban'];
    };
    /** The document corresponding to an ID card */
    ['IdCardDocument']: {
        __typename: 'IdCardDocument';
        /** Unique identifier of the ID card document */
        id: string;
        /** The type of the document */
        type: GraphQLTypes['DocumentType'];
        /** The date at which the ID card was issued */
        issueDate?: GraphQLTypes['Date'] | undefined;
        /** The date at which the ID card expires */
        expiryDate?: GraphQLTypes['Date'] | undefined;
        /** Machine-readable zone code of the ID card */
        mrz?: string | undefined;
        /** Number of the ID card */
        number?: string | undefined;
        /** List of the associated files */
        files: Array<GraphQLTypes['IdCardDocumentFile']>;
    };
    /** The file associated to the ID card document */
    ['IdCardDocumentFile']: {
        __typename: 'IdCardDocumentFile';
        /** The file's temporary download url */
        downloadUrl: string;
        /** From which side the ID card's picture was taken */
        side: GraphQLTypes['DocumentFileSide'];
    };
    /** The identification represents an ongoing identification process or its result */
    ['Identification']: {
        __typename: 'Identification';
        /** Unique identifier of the identification */
        id: string;
        /** Creation date of the identification */
        createdAt: GraphQLTypes['DateTime'];
        /** Last update date of the identification */
        updatedAt: GraphQLTypes['DateTime'];
        /** The global status of the identification */
        status: GraphQLTypes['SwanIdentificationStatus'];
        /** The process that was used for this identification */
        process: GraphQLTypes['IdentificationProcess'];
        /** The status and results associated to the available identification processes */
        levels: GraphQLTypes['IdentificationLevelStatusesInfo'];
        /** The available documents related to the identification (id doc, selfie, report...) */
        documents?: Array<GraphQLTypes['IdentificationDocument']> | undefined;
        /** The identity document type used for the current identification (passport, id card ...) */
        identityDocumentType?: GraphQLTypes['IdentityDocumentType'] | undefined;
    };
    /** Fields we can use when ordering that can be applied when listing identifications */
    ['IdentificationConnection']: {
        __typename: 'IdentificationConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo?: GraphQLTypes['PageInfo'] | undefined;
        /** IdentificationEdge list */
        edges: Array<GraphQLTypes['IdentificationEdge']>;
    };
    /** Union representing all the possible identification document types */
    ['IdentificationDocument']: {
        __typename: 'IdCardDocument' | 'PassportDocument' | 'ResidencePermitDocument' | 'DriversLicenseDocument' | 'FacePhotoDocument' | 'ReportDocument';
        ['...on IdCardDocument']: '__union' & GraphQLTypes['IdCardDocument'];
        ['...on PassportDocument']: '__union' & GraphQLTypes['PassportDocument'];
        ['...on ResidencePermitDocument']: '__union' & GraphQLTypes['ResidencePermitDocument'];
        ['...on DriversLicenseDocument']: '__union' & GraphQLTypes['DriversLicenseDocument'];
        ['...on FacePhotoDocument']: '__union' & GraphQLTypes['FacePhotoDocument'];
        ['...on ReportDocument']: '__union' & GraphQLTypes['ReportDocument'];
    };
    /** Implements the Relay Edge interface */
    ['IdentificationEdge']: {
        __typename: 'IdentificationEdge';
        /** The identification entry */
        node: GraphQLTypes['Identification'];
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
    };
    /** Filter that can be passed to get the identifications in specific data ranges */
    ['IdentificationFiltersInput']: {
        /** To filter on status values */
        statuses?: Array<GraphQLTypes['SwanIdentificationStatus']> | undefined;
        /** To filter on level values */
        levels?: Array<GraphQLTypes['IdentificationLevel']> | undefined;
        /** To filter on process values */
        processes?: Array<GraphQLTypes['IdentificationProcess']> | undefined;
    };
    /** The various reasons that can lead to an invalid identification level */
    ['IdentificationInvalidReason']: IdentificationInvalidReason;
    /** Possible value for the field IdentificationLevel */
    ['IdentificationLevel']: IdentificationLevel;
    /** User identification levels input payload. */
    ['IdentificationLevelInput']: IdentificationLevelInput;
    /** Identification levels */
    ['IdentificationLevels']: {
        __typename: 'IdentificationLevels';
        PVID: boolean;
        QES: boolean;
        expert: boolean;
    };
    /** The status and results associated to the available identification processes */
    ['IdentificationLevelStatusesInfo']: {
        __typename: 'IdentificationLevelStatusesInfo';
        /** The status and results associated to the expert level */
        expert: GraphQLTypes['IdentificationLevelStatusInfo'];
        /** The status and results associated to the Qualified Electronic Signature level */
        qes: GraphQLTypes['IdentificationLevelStatusInfo'];
        /** The status and results associated to the Remote Identity Verification Service level */
        pvid: GraphQLTypes['IdentificationLevelStatusInfo'];
    };
    /** Union representing all the possible statuses: not supported, not started, pending, valid, invalid, cancelled, expired
  Each variant contains its relevant data, for example invalid contains a `reason` field, expired contains an `expiredAt` field, valid contains a `documents` field */
    ['IdentificationLevelStatusInfo']: {
        __typename: 'NotSupportedIdentificationLevelStatusInfo' | 'NotStartedIdentificationLevelStatusInfo' | 'StartedIdentificationLevelStatusInfo' | 'PendingIdentificationLevelStatusInfo' | 'ValidIdentificationLevelStatusInfo' | 'InvalidIdentificationLevelStatusInfo' | 'CanceledIdentificationLevelStatusInfo' | 'ExpiredIdentificationLevelStatusInfo';
        ['...on NotSupportedIdentificationLevelStatusInfo']: '__union' & GraphQLTypes['NotSupportedIdentificationLevelStatusInfo'];
        ['...on NotStartedIdentificationLevelStatusInfo']: '__union' & GraphQLTypes['NotStartedIdentificationLevelStatusInfo'];
        ['...on StartedIdentificationLevelStatusInfo']: '__union' & GraphQLTypes['StartedIdentificationLevelStatusInfo'];
        ['...on PendingIdentificationLevelStatusInfo']: '__union' & GraphQLTypes['PendingIdentificationLevelStatusInfo'];
        ['...on ValidIdentificationLevelStatusInfo']: '__union' & GraphQLTypes['ValidIdentificationLevelStatusInfo'];
        ['...on InvalidIdentificationLevelStatusInfo']: '__union' & GraphQLTypes['InvalidIdentificationLevelStatusInfo'];
        ['...on CanceledIdentificationLevelStatusInfo']: '__union' & GraphQLTypes['CanceledIdentificationLevelStatusInfo'];
        ['...on ExpiredIdentificationLevelStatusInfo']: '__union' & GraphQLTypes['ExpiredIdentificationLevelStatusInfo'];
    };
    /** Process of the identification */
    ['IdentificationProcess']: IdentificationProcess;
    /** Fields we can use when ordering that can be applied when listing identifications */
    ['IdentificationsOrderByField']: IdentificationsOrderByField;
    /** Order that can be applied when listing identifications */
    ['IdentificationsOrderByInput']: {
        /** The field by which the Identification list should be ordered */
        field?: GraphQLTypes['IdentificationsOrderByField'] | undefined;
        /** The order in which the Identification list should be ordered */
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Identification status */
    ['IdentificationStatus']: IdentificationStatus;
    /** Rejection returned if identity and the account memberships are already bind */
    ['IdentityAlreadyBindToAccountMembershipRejection']: {
        __typename: 'IdentityAlreadyBindToAccountMembershipRejection';
        accountId: string;
        identityId: string;
        message: string;
    };
    /** The type of the identity document */
    ['IdentityDocumentType']: IdentityDocumentType;
    /** Data used for in app provisioning */
    ['InAppProvisioningData']: {
        __typename: 'InAppProvisioningData';
        /** Cryptographic OTP used to pre-validate digitalization */
        activationData: string;
        /** Base64 public key used with the wallet provider public key to encrypt the card data */
        ephemeralPublicKey: string;
        /** Encrypted card data */
        encryptedData: string;
        /** IV used to encrypt the card Data (Useful for Google Pay) */
        iv?: string | undefined;
        /** public key fingerprint of the key used to encrypt card data (Useful for Google Pay) */
        publicKeyFingerprint?: string | undefined;
        /** hash algorithm used during encryption of the card data (Useful for Google Pay) */
        oaepHashingAlgorithm?: string | undefined;
    };
    /** Individual shareholder info. */
    ['IndividualShareholder']: {
        __typename: 'IndividualShareholder';
        /** Whether the shareholder is an individual or a company. */
        type: GraphQLTypes['ShareholderType'];
        /** First name of the shareholder. */
        firstName: string;
        /** Last name of the shareholder. */
        lastName: string;
        /** Birth date of the shareholder. */
        birthDate: string;
        /** CCA3 code for the country of nationality of the shareholder. */
        nationality: GraphQLTypes['CCA3'];
    };
    /** Individual Ultimate Beneficial Owner
  You need to describe the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company.
  Please describe the company (s) that owns the company that wishes to open an account, when an individual holds in fine more than 25% */
    ['IndividualUltimateBeneficialOwner']: {
        __typename: 'IndividualUltimateBeneficialOwner';
        /** individual first name */
        firstName?: string | undefined;
        /** individual last name */
        lastName?: string | undefined;
        /** individual birth date */
        birthDate?: GraphQLTypes['DateTime'] | undefined;
        /** individual birth city */
        birthCity?: string | undefined;
        /** individual birth city postal code */
        birthCityPostalCode?: string | undefined;
        /** individual birth country code */
        birthCountryCode?: GraphQLTypes['CCA3'] | undefined;
        /** Information relating to the type of the UBO */
        info: GraphQLTypes['IndividualUltimateBeneficialOwnerInfo'];
        /** Individual beneficial owner Tax or Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Individual beneficial owner residency Address */
        residencyAddress?: GraphQLTypes['AddressInformation'] | undefined;
        /** Individual beneficial owner title (Mr/Ms) */
        title?: GraphQLTypes['TitleEnum'] | undefined;
    };
    /** Define the type of the UBO */
    ['IndividualUltimateBeneficialOwnerInfo']: {
        __typename: 'IndividualUltimateBeneficialOwnerTypeHasCapital' | 'IndividualUltimateBeneficialOwnerTypeLegalRepresentative' | 'IndividualUltimateBeneficialOwnerTypeOther';
        /** Individual type */
        type: GraphQLTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
        ['...on IndividualUltimateBeneficialOwnerTypeHasCapital']: '__union' & GraphQLTypes['IndividualUltimateBeneficialOwnerTypeHasCapital'];
        ['...on IndividualUltimateBeneficialOwnerTypeLegalRepresentative']: '__union' & GraphQLTypes['IndividualUltimateBeneficialOwnerTypeLegalRepresentative'];
        ['...on IndividualUltimateBeneficialOwnerTypeOther']: '__union' & GraphQLTypes['IndividualUltimateBeneficialOwnerTypeOther'];
    };
    ['IndividualUltimateBeneficialOwnerInput']: {
        /** Individual beneficial owner first name. Length must be from 0 to 100 characters */
        firstName?: string | undefined;
        /** Individual beneficial owner last name. Length must be from 0 to 100 characters */
        lastName?: string | undefined;
        /** Individual birth date. Must be a valid date in the YYYY/MM/DD format */
        birthDate?: string | undefined;
        /** Individual birth city. Length must be from 0 to 100 characters */
        birthCity?: string | undefined;
        /** Individual birth city postal code. Length must be from 0 to 50 characters */
        birthCityPostalCode?: string | undefined;
        /** Individual birth country code */
        birthCountryCode?: GraphQLTypes['CCA3'] | undefined;
        /** Define UBO is an Indirect Owner */
        indirect?: boolean | undefined;
        /** Define UBO is a Direct Owner */
        direct?: boolean | undefined;
        /** Total of capital (in percentage, ex: 50 = 50%). Must be between 1 and 100. */
        totalCapitalPercentage?: number | undefined;
        /** Define UBO is a Legal Representative */
        type: GraphQLTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
        /** Individual beneficial owner Tax or Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Individual beneficial owner residency address */
        residencyAddress?: GraphQLTypes['AddressInformationInput'] | undefined;
        /** Individual ultimate beneficial owner title (Mr/Ms) */
        title?: GraphQLTypes['TitleEnum'] | undefined;
    };
    /** Individual Ultimate beneficial owner nature */
    ['IndividualUltimateBeneficialOwnerTypeEnum']: IndividualUltimateBeneficialOwnerTypeEnum;
    /** Individual Ultimate Beneficial Owner Type Has Capital */
    ['IndividualUltimateBeneficialOwnerTypeHasCapital']: {
        __typename: 'IndividualUltimateBeneficialOwnerTypeHasCapital';
        /** Individual type */
        type: GraphQLTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
        /** Define UBO is an Indirect Owner */
        indirect?: boolean | undefined;
        /** Define UBO is an Direct Owner */
        direct?: boolean | undefined;
        /** Total of capital (in percentage, ex: 50 = 50%) */
        totalCapitalPercentage?: number | undefined;
    };
    /** Individual Ultimate Beneficial Owner Type Legal Representative */
    ['IndividualUltimateBeneficialOwnerTypeLegalRepresentative']: {
        __typename: 'IndividualUltimateBeneficialOwnerTypeLegalRepresentative';
        /** Individual type */
        type: GraphQLTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
    };
    /** Individual Ultimate Beneficial Owner Type Other */
    ['IndividualUltimateBeneficialOwnerTypeOther']: {
        __typename: 'IndividualUltimateBeneficialOwnerTypeOther';
        /** Individual type */
        type: GraphQLTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
    };
    ['InitiateCheckMerchantPaymentInput']: {
        /** Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€. */
        amount: GraphQLTypes['AmountInput'];
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement.
    If empty, default label will be set as "Check N° [1st 7 characters of CMC7] */
        label?: string | undefined;
        /** End-to-end reference of the concerned payment collection. */
        reference?: string | undefined;
        /** ID of the merchant profile associated to the Swan creditor account. */
        merchantProfileId: string;
        /** 31-character unique identifier located at the bottom of the check.
    CMC7 is composed of 3 sections (check number (7 characters), check issuing bank code (12 characters), check holder account number (12 characters)).
    Combined with RLMC key, it  allows the check to be traced. */
        cmc7: string;
        /** 2-digit key used to check the integrity of the CMC7 line, located at the bottom right of the check.
    Combined with CMC7 line, it allows the check to be traced. */
        rlmcKey: string;
    };
    ['InitiateCheckMerchantPaymentPayload']: {
        __typename: 'InitiateCheckMerchantPaymentSuccessPayload' | 'ForbiddenRejection' | 'NotFoundRejection' | 'InternalErrorRejection' | 'ValidationRejection' | 'CheckRejection';
        ['...on InitiateCheckMerchantPaymentSuccessPayload']: '__union' & GraphQLTypes['InitiateCheckMerchantPaymentSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: '__union' & GraphQLTypes['NotFoundRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
        ['...on CheckRejection']: '__union' & GraphQLTypes['CheckRejection'];
    };
    ['InitiateCheckMerchantPaymentSuccessPayload']: {
        __typename: 'InitiateCheckMerchantPaymentSuccessPayload';
        merchantPayment: GraphQLTypes['Payment'];
        /** Details of the FNCI (Fichier national des chèques irréguliers) response */
        fnciInfo: GraphQLTypes['FnciInfo'];
    };
    /** Initiate credit transfers */
    ['InitiateCreditTransfersInput']: {
        /** account to be debited identified by number */
        accountNumber?: GraphQLTypes['AccountNumber'] | undefined;
        /** account id to be debited identified by id */
        accountId?: string | undefined;
        /** credit transfers (max 2500 records) */
        creditTransfers: Array<GraphQLTypes['CreditTransferInput']>;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['InitiateCreditTransfersPayload']: {
        __typename: 'InitiateCreditTransfersSuccessPayload' | 'AccountNotFoundRejection' | 'ForbiddenRejection' | 'InternalErrorRejection';
        ['...on InitiateCreditTransfersSuccessPayload']: '__union' & GraphQLTypes['InitiateCreditTransfersSuccessPayload'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
    };
    ['InitiateCreditTransfersSuccessPayload']: {
        __typename: 'InitiateCreditTransfersSuccessPayload';
        payment: GraphQLTypes['Payment'];
    };
    /** Input to initiate a funding request */
    ['InitiateFundingRequestInput']: {
        /** ID of the funding source to be used to fund the concerned account */
        fundingSourceId: string;
        /** Amount of the requested funding, i.e. amount that will credit the concerned Swan account and debit the external funding source. */
        amount: GraphQLTypes['AmountInput'];
        /** Reference of the funding request that will be shown on the account holder statement and on the debtor account used. */
        reference?: string | undefined;
        /** Label of the funding request that will be shown on the account holder statement and on the debtor account used
    Always starts with 'Partner Name' truncated at 19 characters followed by a space.
    If empty, default label is "Partner Name - Account Holder Name". */
        label?: string | undefined;
        /** Url to which the authorized account member must be redirected once the consent has been finalized. */
        consentRedirectUrl: string;
        /** When the funding request should be executed. If `null`, it will be executed as soon as possible.
    It is not possible to define this value when the option `isInstant` is set to true. */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** *SOON TO BE DEPRECATED*
    If `true` the funds should be available immediately. If `false` or `null`, the funds will be available
    after the resolution of the credit transaction. */
        isInstant?: boolean | undefined;
    };
    /** Initiate A Funding Request Payload */
    ['InitiateFundingRequestPayload']: {
        __typename: 'InitiateFundingRequestSuccessPayload' | 'ForbiddenRejection' | 'ValidationRejection' | 'FundingLimitExceededRejection' | 'ProjectFundingLimitExceededRejection' | 'GlobalFundingLimitExceededRejection' | 'FundingSourceWrongStatusRejection' | 'FundingSourceNotFoundRejection' | 'InsufficientFundsRejection' | 'InstantFundingLimitExceededRejection' | 'ProjectInstantFundingLimitExceededRejection' | 'GlobalInstantFundingLimitExceededRejection' | 'AccountVerificationWrongStatusRejection';
        ['...on InitiateFundingRequestSuccessPayload']: '__union' & GraphQLTypes['InitiateFundingRequestSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
        ['...on FundingLimitExceededRejection']: '__union' & GraphQLTypes['FundingLimitExceededRejection'];
        ['...on ProjectFundingLimitExceededRejection']: '__union' & GraphQLTypes['ProjectFundingLimitExceededRejection'];
        ['...on GlobalFundingLimitExceededRejection']: '__union' & GraphQLTypes['GlobalFundingLimitExceededRejection'];
        ['...on FundingSourceWrongStatusRejection']: '__union' & GraphQLTypes['FundingSourceWrongStatusRejection'];
        ['...on FundingSourceNotFoundRejection']: '__union' & GraphQLTypes['FundingSourceNotFoundRejection'];
        ['...on InsufficientFundsRejection']: '__union' & GraphQLTypes['InsufficientFundsRejection'];
        ['...on InstantFundingLimitExceededRejection']: '__union' & GraphQLTypes['InstantFundingLimitExceededRejection'];
        ['...on ProjectInstantFundingLimitExceededRejection']: '__union' & GraphQLTypes['ProjectInstantFundingLimitExceededRejection'];
        ['...on GlobalInstantFundingLimitExceededRejection']: '__union' & GraphQLTypes['GlobalInstantFundingLimitExceededRejection'];
        ['...on AccountVerificationWrongStatusRejection']: '__union' & GraphQLTypes['AccountVerificationWrongStatusRejection'];
    };
    /** Initiate A Funding Request Success Payload */
    ['InitiateFundingRequestSuccessPayload']: {
        __typename: 'InitiateFundingRequestSuccessPayload';
        /** Details of the funding payment created */
        payment: GraphQLTypes['Payment'];
    };
    /** *COMING SOON*
  Input to create a quote and an international beneficiary */
    ['InitiateInternationalCreditTransferInput']: {
        /** Account ID of the originator of the international credit transfer */
        accountId?: string | undefined;
        /** Account number if the beneficiary is a swan account */
        accountNumber?: GraphQLTypes['AccountNumber'] | undefined;
        /** Target amount of the international credit transfer */
        targetAmount: GraphQLTypes['AmountInput'];
        /** Beneficiary of the international credit transfer */
        internationalBeneficiary: GraphQLTypes['InternationalBeneficiaryInput'];
        /** Transfer details */
        internationalCreditTransferDetails: Array<GraphQLTypes['InternationalCreditTransferDetailsInput']>;
        /** When the consent flow is finished the user is redirected to this URL */
        consentRedirectUrl: string;
        /** External reference */
        externalReference?: string | undefined;
        /** Language used to output errors */
        language?: GraphQLTypes['InternationalCreditTransferDisplayLanguage'] | undefined;
    };
    /** Initiate International Credit Transfer Response Payload */
    ['InitiateInternationalCreditTransferResponsePayload']: {
        __typename: 'InitiateInternationalCreditTransferResponseSuccessPayload' | 'AccountNotFoundRejection' | 'ForbiddenRejection' | 'InternalErrorRejection' | 'ValidationRejection';
        ['...on InitiateInternationalCreditTransferResponseSuccessPayload']: '__union' & GraphQLTypes['InitiateInternationalCreditTransferResponseSuccessPayload'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Initiate International Credit Transfer Response Success Payload */
    ['InitiateInternationalCreditTransferResponseSuccessPayload']: {
        __typename: 'InitiateInternationalCreditTransferResponseSuccessPayload';
        /** Details of the international credit transfer created */
        payment: GraphQLTypes['Payment'];
        /** Details for the quote of international credit transfer */
        quote: GraphQLTypes['InternationalCreditTransferQuote'];
    };
    ['InitiateMerchantPaymentCollectionInput']: {
        /** Amount of the concerned payment collection. For check deposit, the amount should not exceed 10 000€. */
        amount: GraphQLTypes['AmountInput'];
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement -
    For checks transaction, if empty, default label will be set as "Check N° [1st part of CMC7 - 7 char.] */
        label?: string | undefined;
        /** end-to-end reference of the concerned payment collection */
        reference?: string | undefined;
        /** external reference (JSON) that can be used by the Swan merchant for reconciliation purposes */
        externalReference?: string | undefined;
        /** Internal direct debit type of payment collection */
        internalDirectDebit?: GraphQLTypes['InternalDirectDebitPaymentCollectionInput'] | undefined;
        /** Sepa Direct Debit type of payment collection */
        sepaDirectDebit?: GraphQLTypes['SepaDirectDebitPaymentCollectionInput'] | undefined;
    };
    ['InitiateMerchantPaymentCollectionPayload']: {
        __typename: 'InitiateMerchantPaymentCollectionSuccessPayload' | 'ForbiddenRejection' | 'NotFoundRejection' | 'InternalErrorRejection' | 'ValidationRejection';
        ['...on InitiateMerchantPaymentCollectionSuccessPayload']: '__union' & GraphQLTypes['InitiateMerchantPaymentCollectionSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: '__union' & GraphQLTypes['NotFoundRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['InitiateMerchantPaymentCollectionSuccessPayload']: {
        __typename: 'InitiateMerchantPaymentCollectionSuccessPayload';
        merchantPaymentCollection: GraphQLTypes['Payment'];
    };
    ['InstantFundingLimit']: {
        __typename: 'InstantFundingLimit';
        /** Maximum Instant Funding Amount authorized */
        amount: GraphQLTypes['Amount'];
        /** Instant Funding Amount that has already been used */
        funding?: GraphQLTypes['Amount'] | undefined;
    };
    /** Rejection returned when the Account Holder Instant Funding limit has been exceeded */
    ['InstantFundingLimitExceededRejection']: {
        __typename: 'InstantFundingLimitExceededRejection';
        message: string;
    };
    /** Rejection returned when the Available balance is insufficient */
    ['InsufficientFundsRejection']: {
        __typename: 'InsufficientFundsRejection';
        message: string;
    };
    /** Internal Beneficiary */
    ['InternalBeneficiary']: {
        __typename: 'InternalBeneficiary';
        /** unique identifier of a beneficiary
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        id?: string | undefined;
        /** full name of the beneficiary */
        name: string;
        /** `true` if this new beneficiary is the account holder himself in an other financial institution.
    *SOON TO BE DEPRECATED*
    Not used. It will be removed soon. */
        isMyOwnIban: boolean;
        /** account number if the beneficiary is a swan account */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Internal Credit Transfer transaction */
    ['InternalCreditTransfer']: {
        __typename: 'InternalCreditTransfer';
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire reference chain. */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: GraphQLTypes['TransactionSide'];
        /** type */
        type: GraphQLTypes['TransactionTypeEnum'];
        /** amount */
        amount: GraphQLTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: GraphQLTypes['Payment'] | undefined;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: GraphQLTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: GraphQLTypes['PaymentProduct'];
        /** creditor information */
        creditor: GraphQLTypes['InternalCreditTransferCreditor'];
        /** debtor information */
        debtor: GraphQLTypes['InternalCreditTransferDebtor'];
        /** matching account for the transaction */
        account?: GraphQLTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: GraphQLTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: GraphQLTypes['Transaction'] | undefined;
        /** r-transaction reason */
        returnReason?: GraphQLTypes['TransactionReasonCode'] | undefined;
    };
    /** Internal Credit Transfer creditor */
    ['InternalCreditTransferCreditor']: {
        __typename: 'InternalCreditTransferInCreditor' | 'InternalCreditTransferOutCreditor';
        /** full name of the Creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
        ['...on InternalCreditTransferInCreditor']: '__union' & GraphQLTypes['InternalCreditTransferInCreditor'];
        ['...on InternalCreditTransferOutCreditor']: '__union' & GraphQLTypes['InternalCreditTransferOutCreditor'];
    };
    /** Internal Credit Transfer debtor */
    ['InternalCreditTransferDebtor']: {
        __typename: 'InternalCreditTransferInDebtor' | 'InternalCreditTransferOutDebtor';
        /** full name of the debtor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
        ['...on InternalCreditTransferInDebtor']: '__union' & GraphQLTypes['InternalCreditTransferInDebtor'];
        ['...on InternalCreditTransferOutDebtor']: '__union' & GraphQLTypes['InternalCreditTransferOutDebtor'];
    };
    /** Internal Credit Transfer creditor for Incoming transaction */
    ['InternalCreditTransferInCreditor']: {
        __typename: 'InternalCreditTransferInCreditor';
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Internal Credit Transfer debtor for Incoming transaction */
    ['InternalCreditTransferInDebtor']: {
        __typename: 'InternalCreditTransferInDebtor';
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Internal Credit Transfer creditor for Outgoing transaction */
    ['InternalCreditTransferOutCreditor']: {
        __typename: 'InternalCreditTransferOutCreditor';
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Internal Credit Transfer debtor for Outgoing transaction */
    ['InternalCreditTransferOutDebtor']: {
        __typename: 'InternalCreditTransferOutDebtor';
        /** full name of the creditor */
        name: string;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** InternalDirectDebitB2BMerchantPaymentMethod */
    ['InternalDirectDebitB2BMerchantPaymentMethod']: {
        __typename: 'InternalDirectDebitB2BMerchantPaymentMethod';
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: GraphQLTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: GraphQLTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: GraphQLTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: GraphQLTypes['RollingReserve'] | undefined;
    };
    ['InternalDirectDebitB2BPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined;
    };
    /** Internal Direct Debit Creditor */
    ['InternalDirectDebitCreditor']: {
        __typename: 'InternalDirectDebitCreditor';
        /** unique identifier of the creditor account */
        accountId: string;
    };
    /** Internal Direct Debit Debtor */
    ['InternalDirectDebitDebtor']: {
        __typename: 'InternalDirectDebitDebtor';
        /** unique identifier of the debtor account */
        accountId: string;
    };
    ['InternalDirectDebitMandate']: {
        __typename: 'InternalPaymentDirectDebitMandate' | 'InternalReceivedDirectDebitMandate';
        /** Unique identifier of the internal direct debit mandate, generated by Swan */
        id: string;
        ['...on InternalPaymentDirectDebitMandate']: '__union' & GraphQLTypes['InternalPaymentDirectDebitMandate'];
        ['...on InternalReceivedDirectDebitMandate']: '__union' & GraphQLTypes['InternalReceivedDirectDebitMandate'];
    };
    ['InternalDirectDebitPaymentCollectionInput']: {
        /** ID of the concerned payment mandate */
        mandateId: string;
        /** Date at which the Swan merchant wishes the payment to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
    };
    ['InternalDirectDebitSequence']: InternalDirectDebitSequence;
    /** InternalDirectDebitStandardMerchantPaymentMethod */
    ['InternalDirectDebitStandardMerchantPaymentMethod']: {
        __typename: 'InternalDirectDebitStandardMerchantPaymentMethod';
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: GraphQLTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: GraphQLTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: GraphQLTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: GraphQLTypes['RollingReserve'] | undefined;
    };
    ['InternalDirectDebitStandardPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined;
    };
    /** Internal Direct Debit transaction */
    ['InternalDirectDebitTransaction']: {
        __typename: 'InternalDirectDebitTransaction';
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference: string;
        /** payment method identifier used for this transaction: accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: GraphQLTypes['TransactionSide'];
        /** type */
        type: GraphQLTypes['TransactionTypeEnum'];
        /** amount */
        amount: GraphQLTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: GraphQLTypes['Payment'] | undefined;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: GraphQLTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: GraphQLTypes['PaymentProduct'];
        /** creditor information */
        creditor: GraphQLTypes['InternalDirectDebitCreditor'];
        /** debtor information */
        debtor: GraphQLTypes['InternalDirectDebitDebtor'];
        /** matching account for the transaction */
        account?: GraphQLTypes['Account'] | undefined;
        /** matching Internal mandate for the transaction */
        mandate?: GraphQLTypes['InternalDirectDebitMandate'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: GraphQLTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: GraphQLTypes['Transaction'] | undefined;
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: GraphQLTypes['Amount'] | undefined;
        /** date on which reserved funds become available. */
        reservedAmountReleasedAt?: GraphQLTypes['DateTime'] | undefined;
        /** r-transaction reason */
        returnReason?: GraphQLTypes['TransactionReasonCode'] | undefined;
    };
    /** Rejection returned on unexpected server error */
    ['InternalErrorRejection']: {
        __typename: 'InternalErrorRejection';
        message: string;
    };
    /** Payment direct debit mandate for Internal */
    ['InternalPaymentDirectDebitMandate']: {
        __typename: 'InternalPaymentDirectDebitMandate';
        /** Unique identifier of the Internal Direct Debit Payment Mandate */
        id: string;
        /** List of transactions associated with the Internal Payment Direct Debit Mandate.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: GraphQLTypes['TransactionConnection'] | undefined;
        /** Unique reference of the Internal Direct Debit Payment Mandate */
        reference: string;
        /** Internal Direct Debit Payment Mandate scheme */
        scheme: GraphQLTypes['InternalPaymentMandateScheme'];
        /** Internal Direct Debit Payment Mandate status information */
        statusInfo: GraphQLTypes['PaymentMandateStatusInfo'];
        /** Internal Direct Debit Payment Mandate sequence */
        sequence: GraphQLTypes['InternalPaymentMandateSequence'];
        /** Internal Direct Debit Payment Mandate PDF document URL */
        mandateDocumentUrl: string;
        /** Internal Direct Debit Payment Mandate debtor information */
        debtor: GraphQLTypes['InternalPaymentMandateDebtor'];
        /** Internal direct debit ultimate creditor name */
        ultimateCreditorName?: string | undefined;
        /** Internal Direct Debit Payment Mandate creditor information */
        creditor: GraphQLTypes['InternalPaymentMandateCreditor'];
        /** Signature date of the Internal Direct Debit Payment Mandate */
        signatureDate?: GraphQLTypes['Date'] | undefined;
        /** Creation date of the Internal Direct Debit Payment Mandate */
        createdAt: GraphQLTypes['DateTime'];
        /** Last Update date of the Internal Direct Debit Payment Mandate */
        updatedAt: GraphQLTypes['DateTime'];
        /** Date of the the last transaction executed for the concerned Internal Direct Debit Payment Mandate */
        executedAt?: GraphQLTypes['DateTime'] | undefined;
        /** Expiry date of the Internal Direct Debit Payment Mandate */
        expiredAt?: GraphQLTypes['Date'] | undefined;
        /** Account Holder information */
        accountHolder: GraphQLTypes['AccountHolder'];
        /** Language that will be used to produce the mandate PDF document */
        language: string;
        /** Custom name of the mandate */
        name?: string | undefined;
    };
    ['InternalPaymentMandateCreditor']: {
        __typename: 'InternalPaymentMandateCreditor';
        /** Internal Direct Debit Payment Mandate creditor UUID */
        id: string;
        /** Internal Direct Debit Payment Mandate Creditor Idenfier */
        identifier: string;
        /** Internal Direct Debit Payment Mandate creditor name */
        name: string;
        /** Internal Direct Debit Payment Mandate creditor address */
        address: GraphQLTypes['Address'];
    };
    ['InternalPaymentMandateDebtor']: {
        __typename: 'InternalPaymentMandateDebtor';
        /** Internal Direct Debit Payment Mandate debtor name */
        name: string;
        /** Internal Direct Debit Payment Mandate debtor e-mail */
        email: string;
        /** Internal Direct Debit Payment Mandate debtor country */
        country: GraphQLTypes['CCA3'];
        /** Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        address?: GraphQLTypes['Address'] | undefined;
        /** Internal Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        accountId?: string | undefined;
    };
    ['InternalPaymentMandateScheme']: InternalPaymentMandateScheme;
    /** Internal Direct Debit Payment Mandate Sequence */
    ['InternalPaymentMandateSequence']: InternalPaymentMandateSequence;
    /** Received direct debit mandate for SEPA */
    ['InternalReceivedDirectDebitMandate']: {
        __typename: 'InternalReceivedDirectDebitMandate';
        /** Unique identifier of the received internal direct debit mandate, generated by Swan */
        id: string;
        /** List of transactions associated with the Internal Receive Direct Debit Mandate.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: GraphQLTypes['TransactionConnection'] | undefined;
        /** Version of the received internal direct debit mandate */
        version: string;
        /** Creation date of the received internal direct debit mandate */
        createdAt: GraphQLTypes['DateTime'];
        /** Last Update date of the received internal direct debit mandate */
        updatedAt: GraphQLTypes['DateTime'];
        /** Received internal direct debit Unique Mandate Reference (UMR) */
        reference: string;
        /** Received internal direct debit mandate scheme */
        scheme: GraphQLTypes['InternalReceivedDirectDebitMandateScheme'];
        /** Received internal direct debit mandate sequence */
        sequence: GraphQLTypes['InternalReceivedDirectDebitMandateSequence'];
        /** Received internal direct debit creditor */
        creditor: GraphQLTypes['InternalReceivedDirectDebitMandateCreditor'];
        /** Received internal direct debit ultimate creditor name */
        ultimateCreditorName?: string | undefined;
        /** Date of the last internal direct debit transaction executed for the concerned received internal direct debit mandate */
        executedAt?: GraphQLTypes['DateTime'] | undefined;
        /** Date of signature of the received internal direct debit mandate */
        signatureDate?: GraphQLTypes['Date'] | undefined;
        /** Expiry date of the received internal direct debit mandate, computed automatically (36 months from the executedAt date) */
        expiredAt?: GraphQLTypes['Date'] | undefined;
        /** Mandate status information of the received internal direct debit mandate */
        statusInfo: GraphQLTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Account of the received internal direct debit mandate debtor */
        account?: GraphQLTypes['Account'] | undefined;
        /** Iban of the received internal direct debit mandate debtor */
        iban: GraphQLTypes['IBAN'];
        /** Mandate name */
        name?: string | undefined;
    };
    /** Internal received direct debit mandate creditor */
    ['InternalReceivedDirectDebitMandateCreditor']: {
        __typename: 'InternalReceivedDirectDebitMandateCreditor';
        /** Creditor identifier */
        identifier: string;
        /** Name of the creditor */
        name: string;
        /** Address of the creditor */
        address: GraphQLTypes['Address'];
    };
    /** Received internal direct debit mandate scheme */
    ['InternalReceivedDirectDebitMandateScheme']: InternalReceivedDirectDebitMandateScheme;
    /** Internal received direct debit mandate sequence */
    ['InternalReceivedDirectDebitMandateSequence']: InternalReceivedDirectDebitMandateSequence;
    /** Address of an international beneficiary */
    ['InternationalAddressInput']: {
        /** Address 1 */
        address1?: string | undefined;
        /** City */
        city?: string | undefined;
        /** Country */
        country?: string | undefined;
        /** Zip Code */
        zipCode?: string | undefined;
        /** State */
        state?: string | undefined;
    };
    /** International Beneficiary Details */
    ['InternationalBeneficiaryDetailsInput']: {
        /** Key */
        key: string;
        /** Value */
        value: string;
    };
    /** *COMING SOON*
  International Beneficiary Dynamic Forms */
    ['InternationalBeneficiaryDynamicForms']: {
        __typename: 'InternationalBeneficiaryDynamicForms';
        /** *COMING SOON*
    Schemes */
        schemes: Array<GraphQLTypes['Scheme']>;
    };
    /** *COMING SOON*
  International Beneficiary */
    ['InternationalBeneficiaryInput']: {
        /** Account holder name */
        name: string;
        /** Currency of the international beneficiary account */
        currency: GraphQLTypes['Currency'];
        /** *COMING SOON*
    Currency-specific details of the beneficiary */
        details: Array<GraphQLTypes['InternationalBeneficiaryDetailsInput']>;
        /** *COMING SOON*
    Route that Swan will use to transfer the funds */
        route: GraphQLTypes['InternationalCreditTransferRouteInput'];
    };
    ['InternationalCreditTransferCreditor']: {
        __typename: 'InternationalCreditTransferOutCreditor' | 'InternationalCreditTransferInCreditor';
        ['...on InternationalCreditTransferOutCreditor']: '__union' & GraphQLTypes['InternationalCreditTransferOutCreditor'];
        ['...on InternationalCreditTransferInCreditor']: '__union' & GraphQLTypes['InternationalCreditTransferInCreditor'];
    };
    /** International Currency Exchange / Quote */
    ['InternationalCreditTransferCurrencyExchange']: {
        __typename: 'InternationalCreditTransferCurrencyExchange';
        /** Rate of the quote */
        exchangeRate: string;
        /** Fees */
        feesAmount?: GraphQLTypes['Amount'] | undefined;
        /** Source amount of the quote */
        sourceAmount?: GraphQLTypes['Amount'] | undefined;
        /** target amount of the quote */
        targetAmount?: GraphQLTypes['Amount'] | undefined;
    };
    ['InternationalCreditTransferDebtor']: {
        __typename: 'InternationalCreditTransferOutDebtor' | 'InternationalCreditTransferInDebtor';
        ['...on InternationalCreditTransferOutDebtor']: '__union' & GraphQLTypes['InternationalCreditTransferOutDebtor'];
        ['...on InternationalCreditTransferInDebtor']: '__union' & GraphQLTypes['InternationalCreditTransferInDebtor'];
    };
    /** International Credit Transfer - Currency-specific details of the beneficiary */
    ['InternationalCreditTransferDetails']: {
        __typename: 'InternationalCreditTransferDetails';
        /** Key */
        key: string;
        /** Value */
        value: string;
    };
    /** *COMING SOON*
  International Credit Transfer Details */
    ['InternationalCreditTransferDetailsInput']: {
        /** *COMING SOON*
    Key */
        key: string;
        /** *COMING SOON*
    Value */
        value: string;
    };
    /** Language: ISO 639-1 language code */
    ['InternationalCreditTransferDisplayLanguage']: InternationalCreditTransferDisplayLanguage;
    /** *COMING SOON*
  International Credit Transfer Dynamic Form */
    ['InternationalCreditTransferDynamicForm']: {
        __typename: 'InternationalCreditTransferDynamicForm';
        /** List of international transaction fields */
        fields: Array<GraphQLTypes['Field']>;
        /** *COMING SOON*
    Number of fields that need to be updated to fill the form completely. Please re run the query internationalCreditTransferTransactionDetailsDynamicForm with updated refreshableFields if the value of this field is not 0 */
        remainingFieldsToRefreshCount: number;
    };
    /** International Credit Transfer In - Creditor info */
    ['InternationalCreditTransferInCreditor']: {
        __typename: 'InternationalCreditTransferInCreditor';
        /** Account holder name */
        name: string;
        /** Bank Identifier Code */
        BIC: GraphQLTypes['BIC'];
        /** International Bank Account Number
    Only if the account membership has `canViewAccount=true` & this account has `paymentLevel=Unlimited` */
        IBAN: GraphQLTypes['IBAN'];
        /** maskedIBAN if the beneficiary is a an account in an other financial institution */
        maskedIBAN: string;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
    };
    ['InternationalCreditTransferInDebtor']: {
        __typename: 'InternationalCreditTransferInDebtor';
        /** Account holder name */
        name: string;
        /** Account Number */
        accountNumber: string;
        /** BIC */
        bic?: string | undefined;
    };
    /** International Credit Transfer Out - Creditor info */
    ['InternationalCreditTransferOutCreditor']: {
        __typename: 'InternationalCreditTransferOutCreditor';
        /** Currency of the international beneficiary account */
        currency: GraphQLTypes['Currency'];
        /** Currency-specific details of the beneficiary */
        details: Array<GraphQLTypes['InternationalCreditTransferDetails']>;
        /** Account holder name */
        name: string;
        /** Route that Swan will use to transfer the funds */
        route: GraphQLTypes['InternationalCreditTransferRoute'];
    };
    ['InternationalCreditTransferOutDebtor']: {
        __typename: 'InternationalCreditTransferOutDebtor';
        /** Account holder name */
        name: string;
    };
    /** *COMING SOON*
  International Quote */
    ['InternationalCreditTransferQuote']: {
        __typename: 'InternationalCreditTransferQuote';
        /** Rate of the quote */
        exchangeRate: string;
        /** Source amount of the quote */
        sourceAmount: GraphQLTypes['Amount'];
        /** target amount of the quote */
        targetAmount: GraphQLTypes['Amount'];
        /** Fees */
        feesAmount: GraphQLTypes['Amount'];
    };
    /** International Credit Transfer Route */
    ['InternationalCreditTransferRoute']: InternationalCreditTransferRoute;
    /** International Credit Transfer Route */
    ['InternationalCreditTransferRouteInput']: InternationalCreditTransferRouteInput;
    ['InternationalCreditTransferTransaction']: {
        __typename: 'InternationalCreditTransferTransaction';
        /** matching account for this transaction */
        account?: GraphQLTypes['Account'] | undefined;
        /** amount */
        amount: GraphQLTypes['Amount'];
        /** booked balance after this transaction */
        bookedBalanceAfter?: GraphQLTypes['Amount'] | undefined;
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** creditor information */
        creditor: GraphQLTypes['InternationalCreditTransferCreditor'];
        /** debtor information */
        debtor: GraphQLTypes['InternationalCreditTransferDebtor'];
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: GraphQLTypes['DateTime'];
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** @deprecated(reason: "use `quote.feesAmount` instead") */
        fees?: GraphQLTypes['Amount'] | undefined;
        /** unique identifier of the transaction */
        id: string;
        /** instructed amount */
        instructedAmount?: GraphQLTypes['Amount'] | undefined;
        /** instructed amount */
        intermediaryBankFees?: Array<GraphQLTypes['Amount']> | undefined;
        /** label */
        label: string;
        /** origin transaction associated to this transaction */
        originTransaction?: GraphQLTypes['Transaction'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** payment associated to this transaction */
        payment?: GraphQLTypes['Payment'] | undefined;
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** payment product used for this transaction */
        paymentProduct: GraphQLTypes['PaymentProduct'];
        /** quote given by our international provider */
        currencyExchange: GraphQLTypes['InternationalCreditTransferCurrencyExchange'];
        /** external identifier of the transaction */
        reference: string;
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** return reason */
        returnReason?: GraphQLTypes['TransactionReasonCode'] | undefined;
        /** side (Credit or Debit) */
        side: GraphQLTypes['TransactionSide'];
        /** status information */
        statusInfo: GraphQLTypes['TransactionStatusInfo'];
        /** type */
        type: GraphQLTypes['TransactionTypeEnum'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
    };
    /** Rejection returned on invalid argument error */
    ['InvalidArgumentRejection']: {
        __typename: 'InvalidArgumentRejection';
        message: string;
        code: GraphQLTypes['InvalidArgumentRejectionCode'];
        fields: Array<GraphQLTypes['InvalidArgumentRejectionField']>;
    };
    ['InvalidArgumentRejectionCode']: InvalidArgumentRejectionCode;
    ['InvalidArgumentRejectionField']: {
        __typename: 'InvalidArgumentRejectionField';
        name: string;
        errors: Array<string>;
    };
    /** InvalidVerification */
    ['InvalidBeneficiaryVerification']: {
        __typename: 'InvalidBeneficiaryVerification';
        message: string;
    };
    /** Information about the invalidity of the IBAN */
    ['InvalidIban']: {
        __typename: 'InvalidIban';
        /** Iban from input */
        iban: GraphQLTypes['IBAN'];
        /** Enum that can be used to discriminate on the error */
        code: GraphQLTypes['InvalidIbanCode'];
        /** Message that give a bit of context during development */
        message: string;
    };
    /** InvalidIbanCode */
    ['InvalidIbanCode']: InvalidIbanCode;
    /** Describes an invalid identification level for the process associated to this identification, and the invalid reason can be accessed */
    ['InvalidIdentificationLevelStatusInfo']: {
        __typename: 'InvalidIdentificationLevelStatusInfo';
        /** Always set to `Invalid` */
        status: GraphQLTypes['SwanIdentificationStatus'];
        /** The reasons why this identification level is invalid */
        reasons?: Array<GraphQLTypes['IdentificationInvalidReason']> | undefined;
    };
    /** Rejection returned if phone number is not well formatted */
    ['InvalidPhoneNumberRejection']: {
        __typename: 'InvalidPhoneNumberRejection';
        message: string;
    };
    /** Rejection returned if siren number is not well formatted */
    ['InvalidSirenNumberRejection']: {
        __typename: 'InvalidSirenNumberRejection';
        message: string;
    };
    /** Invoice */
    ['Invoice']: {
        __typename: 'Invoice';
        /** unique id */
        id: string;
        /** account id */
        accountId: string;
        /** name of the invoice */
        name: string;
        /** type of the invoice */
        type: GraphQLTypes['InvoiceType'];
        /** status of the invoice */
        status: GraphQLTypes['InvoiceStatus'];
        /** due amount */
        amount: GraphQLTypes['Amount'];
        /** temporary public url on which the file can be accessible */
        url?: string | undefined;
        /** date at which the link will not be useable anymore */
        expiresAt?: GraphQLTypes['DateTime'] | undefined;
        /** starting date of the billing window */
        openingDate: GraphQLTypes['DateTime'];
        /** ending date of the billing window */
        closingDate: GraphQLTypes['DateTime'];
        /** creation date */
        createdAt: GraphQLTypes['DateTime'];
        /** last update date */
        updatedAt: GraphQLTypes['DateTime'];
    };
    /** Please see the Connection interface */
    ['InvoiceConnection']: {
        __typename: 'InvoiceConnection';
        pageInfo: GraphQLTypes['PageInfo'];
        totalCount: number;
        edges: Array<GraphQLTypes['InvoiceEdge']>;
    };
    /** Please see the Edge interface */
    ['InvoiceEdge']: {
        __typename: 'InvoiceEdge';
        node: GraphQLTypes['Invoice'];
        cursor: string;
    };
    /** The different statuses of invoice */
    ['InvoiceStatus']: InvoiceStatus;
    ['InvoiceType']: InvoiceType;
    /** Key value details */
    ['KeyValue']: {
        __typename: 'KeyValue';
        /** Key */
        key: string;
        /** Value */
        value: string;
    };
    ['Language']: Language;
    ['LegalDocument']: {
        __typename: 'LegalDocument';
        /** ID of the legal document */
        id: string;
        /** Type of the legal document */
        type: GraphQLTypes['LegalDocumentType'];
        /** Status of the Legal Document */
        statusInfo: GraphQLTypes['LegalDocumentStatusInfo'];
        /** Language of the Legal Document */
        language: GraphQLTypes['AccountLanguage'];
        /** Url to download the Document */
        url: string;
    };
    ['LegalDocumentActiveStatusInfo']: {
        __typename: 'LegalDocumentActiveStatusInfo';
        /** LegalDocument status (always Active for type LegalDocumentActiveStatusInfo) */
        status: GraphQLTypes['LegalDocumentStatus'];
        /** Creation date */
        createdAt: GraphQLTypes['DateTime'];
        /** Activation date */
        activatedAt?: GraphQLTypes['DateTime'] | undefined;
    };
    ['LegalDocumentConnection']: {
        __typename: 'LegalDocumentConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** LegalDocumentEdge list */
        edges: Array<GraphQLTypes['LegalDocumentEdge']>;
    };
    ['LegalDocumentEdge']: {
        __typename: 'LegalDocumentEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The account membership */
        node: GraphQLTypes['LegalDocument'];
    };
    ['LegalDocumentInactiveStatusInfo']: {
        __typename: 'LegalDocumentInactiveStatusInfo';
        /** LegalDocument status (always Inactive for type LegalDocumentInactiveStatusInfo) */
        status: GraphQLTypes['LegalDocumentStatus'];
        /** Creation date */
        createdAt: GraphQLTypes['DateTime'];
        /** Activation date */
        activatedAt?: GraphQLTypes['DateTime'] | undefined;
        /** Deactivation date */
        deactivatedAt?: GraphQLTypes['DateTime'] | undefined;
    };
    ['LegalDocumentsFilterInput']: {
        status?: GraphQLTypes['LegalDocumentStatus'] | undefined;
        type?: GraphQLTypes['LegalDocumentType'] | undefined;
    };
    ['LegalDocumentStatus']: LegalDocumentStatus;
    ['LegalDocumentStatusInfo']: {
        __typename: 'LegalDocumentActiveStatusInfo' | 'LegalDocumentInactiveStatusInfo' | 'LegalDocumentUpcomingStatusInfo';
        /** LegalDocument Status */
        status: GraphQLTypes['LegalDocumentStatus'];
        ['...on LegalDocumentActiveStatusInfo']: '__union' & GraphQLTypes['LegalDocumentActiveStatusInfo'];
        ['...on LegalDocumentInactiveStatusInfo']: '__union' & GraphQLTypes['LegalDocumentInactiveStatusInfo'];
        ['...on LegalDocumentUpcomingStatusInfo']: '__union' & GraphQLTypes['LegalDocumentUpcomingStatusInfo'];
    };
    ['LegalDocumentType']: LegalDocumentType;
    ['LegalDocumentUpcomingStatusInfo']: {
        __typename: 'LegalDocumentUpcomingStatusInfo';
        /** LegalDocument status (always Upcoming for type LegalDocumentUpcomingStatusInfo) */
        status: GraphQLTypes['LegalDocumentStatus'];
        /** Creation date */
        createdAt: GraphQLTypes['DateTime'];
        /** Date when the LegalDocument will be activated */
        effectiveDate?: GraphQLTypes['DateTime'] | undefined;
    };
    ['LegalRepresentativeAccountMembershipCannotBeDisabledRejection']: {
        __typename: 'LegalRepresentativeAccountMembershipCannotBeDisabledRejection';
        accountMembershipId: string;
        message: string;
    };
    ['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection']: {
        __typename: 'LegalRepresentativeAccountMembershipCannotBeSuspendedRejection';
        id: string;
        message: string;
    };
    /** Language: ISO 639-1 language code */
    ['MandateLanguage']: MandateLanguage;
    ['MembershipInfoInput']: {
        /** Email address */
        email: string;
        /** Restricted to a user if necessary */
        restrictedTo: GraphQLTypes['RestrictedToInput'];
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount: boolean;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries: boolean;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments: boolean;
        /** `true` if this account membership can invite, update, suspend or resume account membership */
        canManageAccountMembership: boolean;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** Residency address of the member to be added */
        residencyAddress?: GraphQLTypes['ResidencyAddressInput'] | undefined;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined;
    };
    /** Filters that can be applied when listing accounts (Only applied in user context) */
    ['MembershipsFilterInput']: {
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** Can the user initiate payments on this account */
        canInitiatePayments?: boolean | undefined;
        /** Can the user manage account membership */
        canManageAccountMembership?: boolean | undefined;
        /** Can the user manage beneficiaries */
        canManageBeneficiaries?: boolean | undefined;
        /** Can the user view account */
        canViewAccount?: boolean | undefined;
        /** Account memberships status/statuses we're looking for */
        status?: Array<GraphQLTypes['AccountMembershipStatus']> | undefined;
        /** Filtered by email */
        email?: string | undefined;
        /** Filtered by first name */
        firstName?: string | undefined;
        /** Filtered by last name */
        lastName?: string | undefined;
        /** Searches email, first name, last name, and id */
        search?: string | undefined;
    };
    /** MerchantCategoryDescription */
    ['MerchantCategoryDescription']: MerchantCategoryDescription;
    ['MerchantPaymentLink']: {
        __typename: 'MerchantPaymentLink';
        /** Merchant payment link's unique ID. */
        id: string;
        /** ID of the related project */
        projectId: string;
        /** The URL at which the customer can complete the payment. */
        url: string;
        /** The merchant payment link status. */
        statusInfo: GraphQLTypes['MerchantPaymentLinkStatusInfo'];
        /** The Merchant Profile to link this Payment Link to */
        merchantProfile: GraphQLTypes['MerchantProfile'];
        /** Amount to be paid to sucessfully complete the payment. */
        amount: GraphQLTypes['Amount'];
        /** Merchant Website URL to redirect the user to when the payment is completed. */
        redirectUrl: string;
        /** URL to redirect the user to if they cancel their payment */
        cancelRedirectUrl: string;
        /** Controls if the payment mandate created from this payment link is for one-time use or can be reused
    This is applicable for card and SEPA Direct Debit payment methods only. */
        sequence: GraphQLTypes['PaymentLinkSequenceType'];
        /** The customer billing Address
    These fields should be completed also to pre-fill a SEPA direct debit mandate.
    
    We strongly advice to complete these fields if merchants want to get paid through card payment method, in order to minimize the risk of payment rejection by Visa / Mastercard schemes */
        billingAddress?: GraphQLTypes['Address'] | undefined;
        /**   A date that reflects the time at which the user asked the transaction to be executed.
    For card transactions, request execution must occur within 7 days after authorization or the authorization may expire.
    For SEPA Direct Debit transactions, request execution must occur up to 1 year in the future.
    
    Default value means that the execution will be as soon as possible */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** Any string that you want to be attached to this payment link.
    Usually something to help you reference the link in an external system. */
        externalReference?: string | undefined;
        /** Optional field intended to provide a way for you to include a reference number or code.
    The customer will most likely see this value on their bank statement, though we can't know as every banking platform is different. */
        reference?: string | undefined;
        /** The language used for the payment page.
    Default is the browser's language, or English if not available. */
        language?: string | undefined;
        /** Label of the concerned payment collection, which will be displayed on Swan bank statement	and on the Swan merchant payment page. */
        label?: string | undefined;
        /**  We will use the information specified here to prefill the payment link fields
    depending on the payment method the end user chooses.
    Keep in mind that your end customer will be able to edit these fields. */
        customer?: GraphQLTypes['Customer'] | undefined;
        /** List of payment methods IDs enabled for this payment link.
    If the array is empty Swan will allow all the payment methods that are enabled for the merchant profile (except for Check and Internal Direct Debit) */
        paymentMethods: Array<GraphQLTypes['MerchantPaymentMethod']>;
    };
    ['MerchantPaymentLinkStatus']: MerchantPaymentLinkStatus;
    ['MerchantPaymentLinkStatusInfo']: {
        __typename: 'ActiveMerchantPaymentLinkStatusInfo' | 'CompletedMerchantPaymentLinkStatusInfo' | 'ExpiredMerchantPaymentLinkStatusInfo';
        status: GraphQLTypes['MerchantPaymentLinkStatus'];
        ['...on ActiveMerchantPaymentLinkStatusInfo']: '__union' & GraphQLTypes['ActiveMerchantPaymentLinkStatusInfo'];
        ['...on CompletedMerchantPaymentLinkStatusInfo']: '__union' & GraphQLTypes['CompletedMerchantPaymentLinkStatusInfo'];
        ['...on ExpiredMerchantPaymentLinkStatusInfo']: '__union' & GraphQLTypes['ExpiredMerchantPaymentLinkStatusInfo'];
    };
    /** Base object for the different Payment Methods available */
    ['MerchantPaymentMethod']: {
        __typename: 'CardMerchantPaymentMethod' | 'CheckMerchantPaymentMethod' | 'InternalDirectDebitB2BMerchantPaymentMethod' | 'InternalDirectDebitStandardMerchantPaymentMethod' | 'SepaDirectDebitB2BMerchantPaymentMethod' | 'SepaDirectDebitCoreMerchantPaymentMethod';
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: GraphQLTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: GraphQLTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: GraphQLTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: GraphQLTypes['RollingReserve'] | undefined;
        ['...on CardMerchantPaymentMethod']: '__union' & GraphQLTypes['CardMerchantPaymentMethod'];
        ['...on CheckMerchantPaymentMethod']: '__union' & GraphQLTypes['CheckMerchantPaymentMethod'];
        ['...on InternalDirectDebitB2BMerchantPaymentMethod']: '__union' & GraphQLTypes['InternalDirectDebitB2BMerchantPaymentMethod'];
        ['...on InternalDirectDebitStandardMerchantPaymentMethod']: '__union' & GraphQLTypes['InternalDirectDebitStandardMerchantPaymentMethod'];
        ['...on SepaDirectDebitB2BMerchantPaymentMethod']: '__union' & GraphQLTypes['SepaDirectDebitB2BMerchantPaymentMethod'];
        ['...on SepaDirectDebitCoreMerchantPaymentMethod']: '__union' & GraphQLTypes['SepaDirectDebitCoreMerchantPaymentMethod'];
    };
    /** Rejection returned when the Merchant Payment Method is not active */
    ['MerchantPaymentMethodNotActiveRejection']: {
        __typename: 'MerchantPaymentMethodNotActiveRejection';
        paymentMethodIds?: Array<string> | undefined;
        message: string;
    };
    /** The different statuses a MerchantPaymentMethod can have */
    ['MerchantPaymentMethodStatus']: MerchantPaymentMethodStatus;
    /** The payment method status information */
    ['MerchantPaymentMethodStatusInfo']: {
        __typename: 'CanceledMerchantPaymentMethodStatusInfo' | 'DisabledMerchantPaymentMethodStatusInfo' | 'EnabledMerchantPaymentMethodStatusInfo' | 'PendingMerchantPaymentMethodStatusInfo' | 'RejectedMerchantPaymentMethodStatusInfo' | 'SuspendedMerchantPaymentMethodStatusInfo';
        /** Merchant Payment Method Status */
        status: GraphQLTypes['MerchantPaymentMethodStatus'];
        ['...on CanceledMerchantPaymentMethodStatusInfo']: '__union' & GraphQLTypes['CanceledMerchantPaymentMethodStatusInfo'];
        ['...on DisabledMerchantPaymentMethodStatusInfo']: '__union' & GraphQLTypes['DisabledMerchantPaymentMethodStatusInfo'];
        ['...on EnabledMerchantPaymentMethodStatusInfo']: '__union' & GraphQLTypes['EnabledMerchantPaymentMethodStatusInfo'];
        ['...on PendingMerchantPaymentMethodStatusInfo']: '__union' & GraphQLTypes['PendingMerchantPaymentMethodStatusInfo'];
        ['...on RejectedMerchantPaymentMethodStatusInfo']: '__union' & GraphQLTypes['RejectedMerchantPaymentMethodStatusInfo'];
        ['...on SuspendedMerchantPaymentMethodStatusInfo']: '__union' & GraphQLTypes['SuspendedMerchantPaymentMethodStatusInfo'];
    };
    /** The different statuses a MerchantPaymentMethod can have */
    ['MerchantPaymentMethodType']: MerchantPaymentMethodType;
    /** Merchant Profile */
    ['MerchantProfile']: {
        __typename: 'MerchantProfile';
        /** The Merchant Profile ID */
        id: string;
        /** The Account ID this Merchant Profile is linked to */
        accountId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website */
        merchantWebsite?: string | undefined;
        /** Url of the merchant's logo */
        merchantLogoUrl?: string | undefined;
        /** The status of the merchant profile */
        statusInfo: GraphQLTypes['MerchantProfileStatusInfo'];
        /** Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: GraphQLTypes['ProductType'];
        /** Expected annual activity volumes for all payment method */
        expectedMonthlyPaymentVolume: GraphQLTypes['Amount'];
        /** Payment Methods associated */
        merchantPaymentMethods?: Array<GraphQLTypes['MerchantPaymentMethod']> | undefined;
        /** Updates Requested associated */
        requestedMerchantProfileUpdates?: Array<GraphQLTypes['RequestMerchantProfileUpdate']> | undefined;
        /** expected average basket value. */
        expectedAverageBasket: GraphQLTypes['Amount'];
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page. */
        accentColor?: string | undefined;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
    };
    ['MerchantProfileConnection']: {
        __typename: 'MerchantProfileConnection';
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** Edge list */
        edges: Array<GraphQLTypes['MerchantProfileEdge']>;
        /** Total number of element in the list */
        totalCount: number;
    };
    ['MerchantProfileEdge']: {
        __typename: 'MerchantProfileEdge';
        node: GraphQLTypes['MerchantProfile'];
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
    };
    /** Filters that can be applied when listing Funding Sources */
    ['MerchantProfileFiltersInput']: {
        status: Array<GraphQLTypes['MerchantProfileStatus']>;
    };
    ['MerchantProfileOrderByFieldInput']: MerchantProfileOrderByFieldInput;
    ['MerchantProfileOrderByInput']: {
        field?: GraphQLTypes['MerchantProfileOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Merchant Profile Statuses */
    ['MerchantProfileStatus']: MerchantProfileStatus;
    /** Merchant Profile Status Information */
    ['MerchantProfileStatusInfo']: {
        __typename: 'CanceledMerchantProfileStatusInfo' | 'EnabledMerchantProfileStatusInfo' | 'PendingReviewMerchantProfileStatusInfo' | 'RejectedMerchantProfileStatusInfo' | 'SuspendedMerchantProfileStatusInfo';
        status: GraphQLTypes['MerchantProfileStatus'];
        ['...on CanceledMerchantProfileStatusInfo']: '__union' & GraphQLTypes['CanceledMerchantProfileStatusInfo'];
        ['...on EnabledMerchantProfileStatusInfo']: '__union' & GraphQLTypes['EnabledMerchantProfileStatusInfo'];
        ['...on PendingReviewMerchantProfileStatusInfo']: '__union' & GraphQLTypes['PendingReviewMerchantProfileStatusInfo'];
        ['...on RejectedMerchantProfileStatusInfo']: '__union' & GraphQLTypes['RejectedMerchantProfileStatusInfo'];
        ['...on SuspendedMerchantProfileStatusInfo']: '__union' & GraphQLTypes['SuspendedMerchantProfileStatusInfo'];
    };
    /** Rejection returned when the Merchant Profile is not in the expected status */
    ['MerchantProfileWrongStatusRejection']: {
        __typename: 'MerchantProfileWrongStatusRejection';
        message: string;
        currentStatus: GraphQLTypes['MerchantProfileStatus'];
        expectedStatus: GraphQLTypes['MerchantProfileStatus'];
    };
    /** Rejection returned when mandatory fields are missing from the call. */
    ['MissingMandatoryFieldRejection']: {
        __typename: 'MissingMandatoryFieldRejection';
        message: string;
    };
    /** Monthly income. */
    ['MonthlyIncome']: MonthlyIncome;
    /** Monthly payment volume. */
    ['MonthlyPaymentVolume']: MonthlyPaymentVolume;
    ['Mutation']: {
        __typename: 'Mutation';
        /** Activate a Physical Card.
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        activatePhysicalCard: GraphQLTypes['ActivatePhysicalCardPayload'];
        /** Add a new account membership to an account.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        addAccountMembership: GraphQLTypes['AddAccountMembershipPayload'];
        /** Add multiple new account memberships to account
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        addAccountMemberships: GraphQLTypes['AddAccountMembershipsPayload'];
        /** Add a new card to an account membership.
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the permission `canManageCards=true`. */
        addCard: GraphQLTypes['AddCardPayload'];
        /** Add several cards with Group Delivery
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the attribute `canManageAccountMembership=true`. */
        addCardsWithGroupDelivery: GraphQLTypes['AddCardsWithGroupDeliveryPayload'];
        /** Add several cards
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the attribute `canManageAccountMembership=true`. */
        addCards: GraphQLTypes['AddCardsPayload'];
        /** Add a Digital Card to push to ApplePay or GooglePay
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must be the card holder
    
    A digital card will only be valid for 1 hour after consent validation */
        addDigitalCard: GraphQLTypes['AddDigitalCardPayload'];
        /** Add an external balance to an external account.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        addExternalAccountBalance: GraphQLTypes['AddExternalAccountBalancePayload'];
        /** Add an external account to an account holder.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        addExternalAccount: GraphQLTypes['AddExternalAccountPayload'];
        /** Add a new request for funding limit settings change.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        addFundingLimitSettingsChangeRequest: GraphQLTypes['AddFundingLimitSettingsChangeRequestPayload'];
        /** Add an external balance to an external account.
    If a balance already exist for the day, the balance amount will be updated.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        addOrUpdateExternalAccountBalance: GraphQLTypes['AddOrUpdateExternalAccountBalancePayload'];
        /** Add a new Single Use Virtual Card to an account membership. */
        addSingleUseVirtualCard: GraphQLTypes['AddSingleUseVirtualCardPayload'];
        /** Add several single-use virtual cards
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the attribute `canManageAccountMembership=true`. */
        addSingleUseVirtualCards: GraphQLTypes['AddSingleUseVirtualCardsPayload'];
        /** Add a new Virtual IBAN. */
        addVirtualIbanEntry?: GraphQLTypes['AddVirtualIbanEntryPayload'] | undefined;
        /** Allows to receive Sepa Direct Debit on a Virtual IBAN. */
        allowSddVirtualIbanEntry: GraphQLTypes['AllowSddVirtualIbanEntryPayload'];
        /** Allows to receive Sepa Direct Debit on an account. */
        allowSdd: GraphQLTypes['AllowSddPayload'];
        /** Bind a user to an account membership
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.* */
        bindAccountMembership: GraphQLTypes['BindAccountMembershipPayload'];
        /** Cancel a Card */
        cancelCard: GraphQLTypes['CancelCardPayload'];
        /** Cancel a Digital Card */
        cancelDigitalCard: GraphQLTypes['CancelDigitalCardPayload'];
        /** Cancel a physical card. */
        cancelPhysicalCard: GraphQLTypes['CancelPhysicalCardPayload'];
        /** Cancels a Virtual IBAN. */
        cancelVirtualIbanEntry: GraphQLTypes['CancelVirtualIbanEntryPayload'];
        /** Closes an account.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must have a legal representative account membership for this account.* */
        closeAccount: GraphQLTypes['CloseAccountPayload'];
        /** Confirm Physical Card Renewal */
        confirmPhysicalCardRenewal: GraphQLTypes['ConfirmPhysicalCardRenewalPayload'];
        /** Delete a supporting document, in case uploaded file is not what was wanted. This action can not be undone.
    
    This mutation can only be used on an "Uploaded" supporting document of a "WaitingForDocument" supporting document collection.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        deleteSupportingDocument: GraphQLTypes['DeleteSupportingDocumentPayload'];
        /** Allows to refuse all Sepa Direct Debit received on a Virtual IBAN. */
        denySddVirtualIbanEntry: GraphQLTypes['DenySddVirtualIbanEntryPayload'];
        /** Allows to refuse all Sepa Direct Debit received on an account. */
        denySdd: GraphQLTypes['DenySddPayload'];
        /** Disable an account membership
    
    This mutation is callable with a User access token and a Project access token ([Learn More](https://docs.swan.io/api/authentication))
    
    With a User access token, the user must have the permission to manage account membership of the account */
        disableAccountMembership: GraphQLTypes['DisableAccountMembershipPayload'];
        /** Finalize an onboarding led to the opening of a new account for your client, who thus become the account holder.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).* */
        finalizeOnboarding: GraphQLTypes['FinalizeOnboardingPayload'];
        /** Creates an onboarding for a new company account holder.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        onboardCompanyAccountHolder: GraphQLTypes['OnboardCompanyAccountHolderPayload'];
        /** Creates an onboarding for a new individual account holder.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        onboardIndividualAccountHolder: GraphQLTypes['OnboardIndividualAccountHolderPayload'];
        /** Print Physical Card.
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request. */
        printPhysicalCard: GraphQLTypes['PrintPhysicalCardPayload'];
        /** Resumes an account membership already suspended.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        resumeAccountMembership: GraphQLTypes['ResumeAccountMembershipPayload'];
        /** Resume a Physical Card.
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        resumePhysicalCard: GraphQLTypes['ResumePhysicalCardPayload'];
        /** Suspends an account membership.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        suspendAccountMembership: GraphQLTypes['SuspendAccountMembershipPayload'];
        /** Suspend a Physical Card. */
        suspendPhysicalCard: GraphQLTypes['SuspendPhysicalCardPayload'];
        updateAccountHolder: GraphQLTypes['UpdateAccountHolderPayload'];
        /** Updates an account membership.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canManageAccountMembership=true`.* */
        updateAccountMembership: GraphQLTypes['UpdateAccountMembershipPayload'];
        /** Update an account. */
        updateAccount: GraphQLTypes['UpdateAccountPayload'];
        /** Update a Card. */
        updateCard?: GraphQLTypes['UpdateCardPayload'] | undefined;
        /** Updates a company onboarding.
    
    If you aim to update Ultimate Beneficiary Owners, you need to provide all of them as they are going to be overridden by your update payload.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        updateCompanyOnboarding: GraphQLTypes['UpdateCompanyOnboardingPayload'];
        /** Updates an individual onboarding.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        updateIndividualOnboarding: GraphQLTypes['UpdateIndividualOnboardingPayload'];
        updateSupportingDocument: GraphQLTypes['UpdateSupportingDocumentPayload'];
        /** Reveal the card numbers in the consent page once consent has been given by the cardholder
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        viewCardNumbers: GraphQLTypes['ViewCardNumbersPayload'];
        /** Reveal the physical card numbers in the consent page once consent has been given by the cardholder
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        viewPhysicalCardNumbers: GraphQLTypes['ViewPhysicalCardNumbersPayload'];
        /** Reveal the PIN code on Swan app after his consent
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have the account membership for this card */
        viewPhysicalCardPin: GraphQLTypes['ViewPhysicalCardPinPayload'];
        /** Generate and return a presigned URL to upload a unique file for the supporting document collection
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        generateSupportingDocumentUploadUrl: GraphQLTypes['GenerateSupportingDocumentUploadUrlPayload'];
        /** Ask for Swan's compliance team to review given supporting document collection.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        requestSupportingDocumentCollectionReview: GraphQLTypes['RequestSupportingDocumentCollectionReviewPayload'];
        /** Generate an account statement */
        generateAccountStatement: GraphQLTypes['Statement'];
        /** Create a capital deposit case.
    
    This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        createCapitalDepositCase: GraphQLTypes['CreateCapitalDepositCasePayload'];
        /** Generate an url allowing the upload of a document which unique identifier is specified in parameters.
    
    This mutation is restricted to an Project access token ([Learn More](https://docs.swan.io/api/authentication)). */
        generateCapitalDepositDocumentUploadUrl: GraphQLTypes['GenerateCapitalDepositDocumentUploadUrlPayload'];
        /** Cancels a consent. */
        cancelConsent: GraphQLTypes['CancelConsentPayload'];
        /** Create a multi consent, which represents a consent of several other consents,
    executed in parallel or sequentially depending on the `order` input value
    
    This mutation is restricted to a User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request. */
        createMultiConsent?: GraphQLTypes['CreateMultiConsentPayload'] | undefined;
        /** Grant consent with a server signature */
        grantConsentWithServerSignature: GraphQLTypes['GrantConsentWithServerSignaturePayload'];
        /** Updates user preferred consent notification channel.
    
    *This mutation is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        updateUserConsentSettings: GraphQLTypes['UpdateUserConsentSettingsPayload'];
        /** Allows to add a received internal direct debit mandate B2b.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must be able to initiate payments for this account.* */
        addReceivedInternalDirectDebitB2bMandate: GraphQLTypes['AddReceivedInternalDirectDebitB2bMandatePayload'];
        /** Allows to add a received sepa direct debit mandate B2b.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must be able to initiate payments for this account.* */
        addReceivedSepaDirectDebitB2bMandate: GraphQLTypes['AddReceivedSepaDirectDebitB2bMandatePayload'];
        /** Allows to enable a received mandate in the Suspended status.
    
    *For B2b received direct debit mandate, this mutation is restricted to an User access token([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must be able to initiate payments for this account.* */
        enableReceivedDirectDebitMandate: GraphQLTypes['EnableReceivedDirectDebitMandatePayload'];
        /** Allows to suspend a received direct debit mandate in the Enabled status.
    
    *The user must be able to initiate payments for this account.* */
        suspendReceivedDirectDebitMandate: GraphQLTypes['SuspendReceivedDirectDebitMandatePayload'];
        /** Allows to update a received sepa direct debit mandate B2b.
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request with the Swan app.*
    
    *The user must be able to initiate payments for this account.* */
        updateReceivedSepaDirectDebitB2bMandate: GraphQLTypes['UpdateReceivedSepaDirectDebitB2bMandatePayload'];
        /** Allows to add an internal direct debit payment mandate. */
        addInternalDirectDebitPaymentMandate: GraphQLTypes['AddInternalDirectDebitPaymentMandatePayload'];
        /** Add a merchant profile to a company account holder */
        addMerchantProfile?: GraphQLTypes['AddMerchantProfilePayload'] | undefined;
        addSepaDirectDebitPaymentMandate?: GraphQLTypes['AddSepaDirectDebitPaymentMandatePayload'] | undefined;
        initiateCheckMerchantPayment?: GraphQLTypes['InitiateCheckMerchantPaymentPayload'] | undefined;
        /** Create a unique URL for a merchant to collect payment from a customer */
        createMerchantPaymentLink: GraphQLTypes['CreateMerchantPaymentLinkPayload'];
        initiateMerchantPaymentCollection?: GraphQLTypes['InitiateMerchantPaymentCollectionPayload'] | undefined;
        /** Request merchant payment methods for a merchant profile */
        requestMerchantPaymentMethods?: GraphQLTypes['RequestMerchantPaymentMethodsPayload'] | undefined;
        /** Request an update of a MerchantProfile */
        requestMerchantProfileUpdate?: GraphQLTypes['RequestMerchantProfileUpdatePayload'] | undefined;
        /** Cancels an UPCOMING credit transfer
    
     *The user must have an account membership for this account with the attribute `canInitiatePayments=true`.* */
        cancelTransaction: GraphQLTypes['CancelTransactionPayload'];
        /** Initiates a credit transfer to an other Swan account or to an IBAN
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and if necessary ask the user to consent to this request.*
    
    *The user must have an account membership for this account with the attribute `canInitiatePayments=true`.* */
        initiateCreditTransfers: GraphQLTypes['InitiateCreditTransfersPayload'];
        /** initiates a refund for a list of booked transaction
    
    *This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and if necessary ask the user to consent to this request.*
    
    *The user must have an account membership on the accounts that are beneficiary of the transaction with the attribute `canInitiatePayments=true`.* */
        refund: GraphQLTypes['RefundPayload'];
        /** Add a funding source to an account
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership for this account with the attribute `canManageAccountMembership=true`. */
        addDirectDebitFundingSource?: GraphQLTypes['AddDirectDebitFundingSourcePayload'] | undefined;
        /** Cancel a funding source */
        cancelFundingSource?: GraphQLTypes['CancelFundingSourcePayload'] | undefined;
        /** Cancel a standing Order
    
    The user must have an account membership to the account and the permission to initiate credit transfer */
        cancelStandingOrder: GraphQLTypes['CancelStandingOrderPayload'];
        /** Initiate a funding request.
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)).
    The user must have an account membership for this account with the attribute `canInitiateCreditTransfer=true`. */
        initiateFundingRequest?: GraphQLTypes['InitiateFundingRequestPayload'] | undefined;
        /** *COMING SOON*
    Create an international transfer */
        initiateInternationalCreditTransfer?: GraphQLTypes['InitiateInternationalCreditTransferResponsePayload'] | undefined;
        /** Schedule a standing Order
    
    This mutation is restricted to an User access token ([Learn More](https://docs.swan.io/api/authentication)) and ask the user to consent to this request.
    
    The user must have an account membership to the account and the permission to initiate credit transfer */
        scheduleStandingOrder: GraphQLTypes['ScheduleStandingOrderPayload'];
        /** Replays the endpoint call of a previous event */
        replayWebhookEvent: GraphQLTypes['ReplayWebhookEventPayload'];
        /** Add a webhook subscription */
        addWebhookSubscription: GraphQLTypes['WebhookSubscriptionPayload'];
    };
    /** Rejection returned if the entity was not found or if the user does not have the rights to know that the account exists */
    ['NotFoundRejection']: {
        __typename: 'NotFoundRejection';
        id: string;
        message: string;
    };
    /** Rejection returned when consent status couldn't change */
    ['NotReachableConsentStatusRejection']: {
        __typename: 'NotReachableConsentStatusRejection';
        message: string;
        currentStatus?: GraphQLTypes['ConsentStatus'] | undefined;
        unreachableStatus?: GraphQLTypes['ConsentStatus'] | undefined;
    };
    /** Describes an identification level that hasn't started for the process of the current identification */
    ['NotStartedIdentificationLevelStatusInfo']: {
        __typename: 'NotStartedIdentificationLevelStatusInfo';
        /** Always set to `NotStarted` */
        status: GraphQLTypes['SwanIdentificationStatus'];
    };
    /** Rejection returned if the queried service doesn't support the country code */
    ['NotSupportedCountryRejection']: {
        __typename: 'NotSupportedCountryRejection';
        message: string;
    };
    /** Describes an identification level that's not supported for the process of the current identification */
    ['NotSupportedIdentificationLevelStatusInfo']: {
        __typename: 'NotSupportedIdentificationLevelStatusInfo';
        /** Always set to `NotSupported` */
        status: GraphQLTypes['SwanIdentificationStatus'];
    };
    /** Extra parameters provided by partner */
    ['OAuthRedirectParameters']: {
        __typename: 'OAuthRedirectParameters';
        /** Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. */
        state?: string | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl?: string | undefined;
    };
    ['OAuthRedirectParametersInput']: {
        /** Custom state provided by partner to prevent XSRF attack, will be filled by onBoardingId in case of nullity. Length must be from 0 to 255 characters */
        state?: string | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined;
    };
    /** Inputs to onboard a new company account holder */
    ['OnboardCompanyAccountHolderInput']: {
        /** Account name of the company account holder.
    Length must be from 0 to 100 characters */
        accountName?: string | undefined;
        /** Name of the company. Length must be from 0 to 255 characters */
        name?: string | undefined;
        /** Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters */
        registrationNumber?: string | undefined;
        /** Type of the company (Association ...) */
        companyType?: GraphQLTypes['CompanyType'] | undefined;
        /** Business activity */
        businessActivity?: GraphQLTypes['BusinessActivity'] | undefined;
        /** Business activity description. Length must be from 0 to 1024 characters */
        businessActivityDescription?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: GraphQLTypes['AccountCountry'] | undefined;
        /** Estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: GraphQLTypes['MonthlyPaymentVolume'] | undefined;
        /** The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
    
    The ultimate beneficial owner is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<GraphQLTypes['IndividualUltimateBeneficialOwnerInput']> | undefined;
        /** Residency address of the head office (Must be in a European country) */
        residencyAddress?: GraphQLTypes['ResidencyAddressInput'] | undefined;
        /** Email of the legal representative. Length must be from 0 to 255 characters */
        email?: string | undefined;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking.
    Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: GraphQLTypes['OAuthRedirectParametersInput'] | undefined;
        /** VAT number */
        vatNumber?: string | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: GraphQLTypes['AddressInformationInput'] | undefined;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: GraphQLTypes['TypeOfRepresentation'] | undefined;
    };
    ['OnboardCompanyAccountHolderPayload']: {
        __typename: 'OnboardCompanyAccountHolderSuccessPayload' | 'BadRequestRejection' | 'ForbiddenRejection' | 'ValidationRejection';
        ['...on OnboardCompanyAccountHolderSuccessPayload']: '__union' & GraphQLTypes['OnboardCompanyAccountHolderSuccessPayload'];
        ['...on BadRequestRejection']: '__union' & GraphQLTypes['BadRequestRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['OnboardCompanyAccountHolderSuccessPayload']: {
        __typename: 'OnboardCompanyAccountHolderSuccessPayload';
        onboarding: GraphQLTypes['Onboarding'];
    };
    /** Information on the shareholder. */
    ['OnboardCompanyShareholderInput']: {
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: GraphQLTypes['AmountInput'];
        /** Name ("Dénomination sociale") of the shareholder. */
        name: string;
        /** Information required for the onboarding of a company shareholder. */
        onboardingInfo: GraphQLTypes['OnboardCompanyAccountHolderInput'];
    };
    /** Inputs to onboard a new individual account holder */
    ['OnboardIndividualAccountHolderInput']: {
        /** Account name of the individual account holder. Length must be from 0 to 255 characters */
        accountName?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: GraphQLTypes['AccountCountry'] | undefined;
        /** Employment status of the individual account holder */
        employmentStatus?: GraphQLTypes['EmploymentStatus'] | undefined;
        /** Monthly income of the individual account holder */
        monthlyIncome?: GraphQLTypes['MonthlyIncome'] | undefined;
        /** Residency address of the individual account holder (must be in a European country) */
        residencyAddress?: GraphQLTypes['ResidencyAddressInput'] | undefined;
        /** Email. Length must be from 0 to 255 characters */
        email?: string | undefined;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. Length must be from 0 to 255 characters */
        redirectUrl?: string | undefined;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: GraphQLTypes['OAuthRedirectParametersInput'] | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
    };
    ['OnboardIndividualAccountHolderPayload']: {
        __typename: 'OnboardIndividualAccountHolderSuccessPayload' | 'ForbiddenRejection' | 'ValidationRejection';
        ['...on OnboardIndividualAccountHolderSuccessPayload']: '__union' & GraphQLTypes['OnboardIndividualAccountHolderSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['OnboardIndividualAccountHolderSuccessPayload']: {
        __typename: 'OnboardIndividualAccountHolderSuccessPayload';
        onboarding: GraphQLTypes['Onboarding'];
    };
    /** Information on the shareholder. */
    ['OnboardIndividualShareholderInput']: {
        /** First name of the shareholder. */
        firstName: string;
        /** Last name of the shareholder. */
        lastName: string;
        /** Birthdate of the shareholder in the YYYY/MM/DD format. */
        birthDate: string;
        /** CCA3 code for the country of nationality of the shareholder. */
        nationality: GraphQLTypes['CCA3'];
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: GraphQLTypes['AmountInput'];
        /** Information required for the onboarding of a individual shareholder. */
        onboardingInfo: GraphQLTypes['OnboardIndividualAccountHolderInput'];
    };
    /** Information provided during the onboarding process of an individual or a company */
    ['Onboarding']: {
        __typename: 'Onboarding';
        /** Unique identifier of an onboarding */
        id: string;
        /** Account name */
        accountName?: string | undefined;
        /** Account Country */
        accountCountry: GraphQLTypes['AccountCountry'];
        /** Creation date */
        createdAt: GraphQLTypes['DateTime'];
        /** Email */
        email?: string | undefined;
        /** Finalization date */
        finalizedAt?: GraphQLTypes['DateTime'] | undefined;
        /** Language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
        language?: string | undefined;
        /** Information regarding the Individual or the company to onboard */
        info: GraphQLTypes['OnboardingAccountHolderInfo'];
        /** Account holder created at the end of the onboarding process */
        accountHolder?: GraphQLTypes['AccountHolder'] | undefined;
        /** Redirect the legal representative of a new account holder to this URL to start the onboarding process */
        onboardingUrl: string;
        /** Current computed state of onboarding */
        onboardingState: GraphQLTypes['OnboardingState'];
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl: string;
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: GraphQLTypes['OAuthRedirectParameters'] | undefined;
        /** Status (valid/invalid/finalized) and details of errors on fields */
        statusInfo: GraphQLTypes['OnboardingStatusInfo'];
        /** Swan TCU URL */
        tcuUrl: string;
        /** List of supporting document collection owned by the account holder. */
        supportingDocumentCollection: GraphQLTypes['SupportingDocumentCollection'];
        /** Creation date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Account opened after the onboarding finalization */
        account?: GraphQLTypes['Account'] | undefined;
        /** List of accepted identification level for the legal representative */
        legalRepresentativeAcceptedIdentificationLevels: Array<GraphQLTypes['IdentificationLevel'] | undefined>;
        /** Recommended identification level for the legal representative */
        legalRepresentativeRecommendedIdentificationLevel: GraphQLTypes['IdentificationLevel'];
    };
    /** The onboarding could be for an Individual or a company */
    ['OnboardingAccountHolderInfo']: {
        __typename: 'OnboardingCompanyAccountHolderInfo' | 'OnboardingIndividualAccountHolderInfo';
        /** Account holder type */
        type: GraphQLTypes['AccountHolderType'];
        ['...on OnboardingCompanyAccountHolderInfo']: '__union' & GraphQLTypes['OnboardingCompanyAccountHolderInfo'];
        ['...on OnboardingIndividualAccountHolderInfo']: '__union' & GraphQLTypes['OnboardingIndividualAccountHolderInfo'];
    };
    /** Company Account Holder Information */
    ['OnboardingCompanyAccountHolderInfo']: {
        __typename: 'OnboardingCompanyAccountHolderInfo';
        /** Account holder type (always Company for type OnboardingCompanyAccountHolderInfo) */
        type: GraphQLTypes['AccountHolderType'];
        /** name of the company */
        name?: string | undefined;
        /** registration number of the company (SIRET, ...) */
        registrationNumber?: string | undefined;
        /** legal form of the company (SAS, SCI, SASU, ...) */
        companyType?: GraphQLTypes['CompanyType'] | undefined;
        /** business activity */
        businessActivity?: GraphQLTypes['BusinessActivity'] | undefined;
        /** business activity description
    This must be 1024 characters long maximum. */
        businessActivityDescription?: string | undefined;
        /** estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: GraphQLTypes['MonthlyPaymentVolume'] | undefined;
        /** The ultimate beneficiary is defined as the natural person (s) who own or control, directly or indirectly, the reporting company.
    
    The ultimate beneficiary is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<GraphQLTypes['IndividualUltimateBeneficialOwner']> | undefined;
        /** residency address of the head office (Must be in a European country) */
        residencyAddress?: GraphQLTypes['AddressInfo'] | undefined;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined;
        /** Unique number that identifies a taxable person (business) or non-taxable legal entity that is registered for VAT */
        vatNumber?: string | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: GraphQLTypes['AddressInformation'] | undefined;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: GraphQLTypes['TypeOfRepresentation'] | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['OnboardingConnection']: {
        __typename: 'OnboardingConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** OnboardingEdge list */
        edges: Array<GraphQLTypes['OnboardingEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['OnboardingEdge']: {
        __typename: 'OnboardingEdge';
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor: string;
        /** The Onboarding */
        node: GraphQLTypes['Onboarding'];
    };
    /** Filters that can be applied when listing onboardings */
    ['OnboardingFiltersInput']: {
        /** Type/Types we want to filter on */
        types?: Array<GraphQLTypes['AccountHolderType']> | undefined;
        /** Email we want to filter on */
        email?: string | undefined;
        /** Searches company name, first name, last name */
        search?: string | undefined;
        /** Status we want to filter on */
        status?: Array<GraphQLTypes['OnboardingStatus']> | undefined;
    };
    /** StatusInfo when onboarding has been finalized */
    ['OnboardingFinalizedStatusInfo']: {
        __typename: 'OnboardingFinalizedStatusInfo';
        status: GraphQLTypes['OnboardingStatus'];
    };
    /** Individual Account Holder Information */
    ['OnboardingIndividualAccountHolderInfo']: {
        __typename: 'OnboardingIndividualAccountHolderInfo';
        /** Account holder type (always Individual for type OnboardingIndividualAccountHolderInfo) */
        type: GraphQLTypes['AccountHolderType'];
        /** employment status of the individual account holder */
        employmentStatus?: GraphQLTypes['EmploymentStatus'] | undefined;
        /** monthly income of the individual account holder */
        monthlyIncome?: GraphQLTypes['MonthlyIncome'] | undefined;
        /** residency address of the individual account holder (must be in a European country) */
        residencyAddress?: GraphQLTypes['AddressInfo'] | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
    };
    ['OnboardingInfo']: {
        __typename: 'OnboardingInfo';
        /** Unique identifier of an onboarding */
        id: string;
        /** Account name */
        accountName?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: GraphQLTypes['AccountCountry'] | undefined;
        /** email */
        email?: string | undefined;
        /** language of the onboarding process. This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by '-'. The most common extra information is the country or region variant (like 'en-US' or 'fr-CA') or the type of alphabet to use (like 'sr-Latn'). Other variants like the type of orthography ('de-DE-1996') are usually not used in the context of this header. [Learn More](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) */
        language?: string | undefined;
        /** Information regarding the Individual or the company to onboard */
        info: GraphQLTypes['OnboardingAccountHolderInfo'];
        /** Redirect the legal representative of a new account holder to this URL to start the onboarding process */
        onboardingUrl: string;
        /** Current computed state of onboarding */
        onboardingState?: GraphQLTypes['OnboardingState'] | undefined;
        /** URL used to redirect the user at the end of the onboarding process. If `null` the user is redirected to the white label web banking. */
        redirectUrl: string;
        /** Project infos you set in the dashboard */
        projectInfo?: GraphQLTypes['ProjectInfo'] | undefined;
        /** Verification Flow */
        verificationFlow: GraphQLTypes['VerificationFlow'];
        /** Extra parameters provided by partner */
        oAuthRedirectParameters?: GraphQLTypes['OAuthRedirectParameters'] | undefined;
        /** Status (valid/invalid/finalized) and details of errors on fields */
        statusInfo: GraphQLTypes['OnboardingStatusInfo'];
        /** Supporting document collection related to onboarding. */
        supportingDocumentCollection: GraphQLTypes['SupportingDocumentCollection'];
        /** List of accepted identification level for the legal representative */
        legalRepresentativeAcceptedIdentificationLevels: Array<GraphQLTypes['IdentificationLevel'] | undefined>;
        /** Recommended identification level for the legal representative */
        legalRepresentativeRecommendedIdentificationLevel: GraphQLTypes['IdentificationLevel'];
        /** Swan TCU URL */
        tcuUrl: string;
    };
    /** StatusInfo when onboarding has still at least one incorrect field */
    ['OnboardingInvalidStatusInfo']: {
        __typename: 'OnboardingInvalidStatusInfo';
        status: GraphQLTypes['OnboardingStatus'];
        errors: Array<GraphQLTypes['ValidationError']>;
    };
    /** Rejection returned if an onboarding is not completed */
    ['OnboardingNotCompletedRejection']: {
        __typename: 'OnboardingNotCompletedRejection';
        message: string;
        /** @deprecated(reason: "use `onboarding.id` instead") */
        onboardingId: string;
        onboarding: GraphQLTypes['Onboarding'];
    };
    /** Field we can use when ordering that can be applied when listing onboardings */
    ['OnboardingOrderByFieldInput']: OnboardingOrderByFieldInput;
    /** Order that can be applied when listing onboardings */
    ['OnboardingOrderByInput']: {
        field?: GraphQLTypes['OnboardingOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Onboarding process state */
    ['OnboardingState']: OnboardingState;
    /** Possible values for onboarding status */
    ['OnboardingStatus']: OnboardingStatus;
    /** Object containing details about onboarding status (valid/invalid and why it is invalid/already finalized) */
    ['OnboardingStatusInfo']: {
        __typename: 'OnboardingFinalizedStatusInfo' | 'OnboardingInvalidStatusInfo' | 'OnboardingValidStatusInfo';
        /** Current onboarding status. Onboarding can only be finalized if status is "valid" */
        status: GraphQLTypes['OnboardingStatus'];
        ['...on OnboardingFinalizedStatusInfo']: '__union' & GraphQLTypes['OnboardingFinalizedStatusInfo'];
        ['...on OnboardingInvalidStatusInfo']: '__union' & GraphQLTypes['OnboardingInvalidStatusInfo'];
        ['...on OnboardingValidStatusInfo']: '__union' & GraphQLTypes['OnboardingValidStatusInfo'];
    };
    /** StatusInfo when onboarding has all onboarding fields are correctly filled */
    ['OnboardingValidStatusInfo']: {
        __typename: 'OnboardingValidStatusInfo';
        status: GraphQLTypes['OnboardingStatus'];
    };
    ['OrderByDirection']: OrderByDirection;
    /** Implements PageInfo from the Relay Connections Specification - information about a page in the pagination mechanism */
    ['PageInfo']: {
        __typename: 'PageInfo';
        /** Indicates whether more edges exist following this page */
        hasNextPage?: boolean | undefined;
        /** Indicates whether more edges exist preceding this page */
        hasPreviousPage?: boolean | undefined;
        /** Opaque identifier pointing to the first node of the page */
        startCursor?: string | undefined;
        /** Opaque identifier pointing to the last node of the page */
        endCursor?: string | undefined;
    };
    /** Input version */
    ['PartnerCloseAccountReasonInput']: {
        type: GraphQLTypes['PartnerCloseAccountReasonType'];
        message?: string | undefined;
    };
    /** Specific type for closing account action */
    ['PartnerCloseAccountReasonType']: PartnerCloseAccountReasonType;
    /** Partnership Status Accepted */
    ['PartnershipAcceptedStatusInfo']: {
        __typename: 'PartnershipAcceptedStatusInfo';
        /** Partnership status (always Accepted for type PartnershipAcceptedStatusInfo) */
        status: GraphQLTypes['PartnershipStatus'];
        /** Accepted date of the partnership for this account */
        acceptedDate: GraphQLTypes['DateTime'];
    };
    /** Partnership Status canceled */
    ['PartnershipCanceledStatusInfo']: {
        __typename: 'PartnershipCanceledStatusInfo';
        /** Partnership status (always Canceled for type PartnershipCanceledStatusInfo) */
        status: GraphQLTypes['PartnershipStatus'];
        /** Accepted date of the partnership for this account */
        acceptedDate: GraphQLTypes['DateTime'];
        /** Canceled date of the partnership for this account */
        canceledDate: GraphQLTypes['DateTime'];
        /** Reason of the cancelation */
        reason: string;
    };
    /** Partnership Status currently cancelling */
    ['PartnershipCancelingStatusInfo']: {
        __typename: 'PartnershipCancelingStatusInfo';
        /** Partnership status (always Canceling for type PartnershipCancelingStatusInfo) */
        status: GraphQLTypes['PartnershipStatus'];
        /** Accepted date of the partnership for this account */
        acceptedDate: GraphQLTypes['DateTime'];
        /** Canceled date of the partnership for this account */
        canceledAfter: GraphQLTypes['DateTime'];
    };
    ['PartnershipStatus']: PartnershipStatus;
    /** Partnership Status information */
    ['PartnershipStatusInfo']: {
        __typename: 'PartnershipAcceptedStatusInfo' | 'PartnershipCanceledStatusInfo' | 'PartnershipCancelingStatusInfo';
        /** Status of the partnership for this account */
        status: GraphQLTypes['PartnershipStatus'];
        ['...on PartnershipAcceptedStatusInfo']: '__union' & GraphQLTypes['PartnershipAcceptedStatusInfo'];
        ['...on PartnershipCanceledStatusInfo']: '__union' & GraphQLTypes['PartnershipCanceledStatusInfo'];
        ['...on PartnershipCancelingStatusInfo']: '__union' & GraphQLTypes['PartnershipCancelingStatusInfo'];
    };
    /** The document corresponding to a passport */
    ['PassportDocument']: {
        __typename: 'PassportDocument';
        /** Unique identifier of the passport document */
        id: string;
        /** The type of the document */
        type: GraphQLTypes['DocumentType'];
        /** The date at which the passport was issued */
        issueDate?: GraphQLTypes['Date'] | undefined;
        /** The date at which the passport expires */
        expiryDate?: GraphQLTypes['Date'] | undefined;
        /** Machine-readable zone code of the passport */
        mrz?: string | undefined;
        /** Number of the passport */
        number?: string | undefined;
        /** List of the associated files */
        files: Array<GraphQLTypes['PassportDocumentFile']>;
    };
    /** The file associated to the passport document */
    ['PassportDocumentFile']: {
        __typename: 'PassportDocumentFile';
        /** The file's temporary download url */
        downloadUrl: string;
        /** From which side the passport's picture was taken */
        side: GraphQLTypes['DocumentFileSide'];
    };
    /** A Payment represents a set of transactions linked to the same payment act.
  
  This payment act can be initiated:
  - either from a user
  - either from a merchant
  - either from you
  - either from Swan */
    ['Payment']: {
        __typename: 'Payment';
        /** unique identifier of a payment */
        id: string;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** status information */
        statusInfo: GraphQLTypes['PaymentStatusInfo'];
        /** list of transactions associated to this payment
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: GraphQLTypes['TransactionConnection'] | undefined;
        /** standing order that has initiated this payment */
        standingOrder?: GraphQLTypes['StandingOrder'] | undefined;
    };
    ['PaymentAccountType']: PaymentAccountType;
    /** Please see the Connection interface */
    ['PaymentConnection']: {
        __typename: 'PaymentConnection';
        pageInfo: GraphQLTypes['PageInfo'];
        edges: Array<GraphQLTypes['PaymentEdge']>;
        totalCount: number;
    };
    /** Payment status consent pending */
    ['PaymentConsentPending']: {
        __typename: 'PaymentConsentPending';
        /** status of the payment */
        status: GraphQLTypes['PaymentStatus'];
        /** The consent required to initiate this payment */
        consent: GraphQLTypes['Consent'];
    };
    ['PaymentDirectDebitMandate']: {
        __typename: 'InternalPaymentDirectDebitMandate' | 'SEPAPaymentDirectDebitMandate';
        /** Unique identifier of the Direct Debit Payment Mandate */
        id: string;
        ['...on InternalPaymentDirectDebitMandate']: '__union' & GraphQLTypes['InternalPaymentDirectDebitMandate'];
        ['...on SEPAPaymentDirectDebitMandate']: '__union' & GraphQLTypes['SEPAPaymentDirectDebitMandate'];
    };
    /** Please see the Connection interface */
    ['PaymentEdge']: {
        __typename: 'PaymentEdge';
        node: GraphQLTypes['Payment'];
        cursor: string;
    };
    /** Filters that can be applied when listing payments */
    ['PaymentFiltersInput']: {
        status?: Array<GraphQLTypes['PaymentStatus']> | undefined;
    };
    /** Payment status initiated */
    ['PaymentInitiated']: {
        __typename: 'PaymentInitiated';
        /** status of the payment */
        status: GraphQLTypes['PaymentStatus'];
    };
    /** Payment Level of the account */
    ['PaymentLevel']: PaymentLevel;
    ['PaymentLinkSequenceType']: PaymentLinkSequenceType;
    ['PaymentMandate']: {
        __typename: 'InternalPaymentDirectDebitMandate' | 'SEPAPaymentDirectDebitMandate';
        /** Unique identifier of the Payment Mandate */
        id: string;
        /** List of transactions associated with the Payment Mandate. */
        transactions?: GraphQLTypes['TransactionConnection'] | undefined;
        /** Custom name of the mandate */
        name?: string | undefined;
        /** Account Holder information */
        accountHolder: GraphQLTypes['AccountHolder'];
        /** Creation date of the Payment Mandate */
        createdAt: GraphQLTypes['DateTime'];
        /** Last Update date of the Payment Mandate */
        updatedAt: GraphQLTypes['DateTime'];
        /** Date of the the last transaction executed for the concerned Payment Mandate */
        executedAt?: GraphQLTypes['DateTime'] | undefined;
        /** Expiry date of the Payment Mandate */
        expiredAt?: GraphQLTypes['Date'] | undefined;
        /** Payment Mandate status information */
        statusInfo: GraphQLTypes['PaymentMandateStatusInfo'];
        ['...on InternalPaymentDirectDebitMandate']: '__union' & GraphQLTypes['InternalPaymentDirectDebitMandate'];
        ['...on SEPAPaymentDirectDebitMandate']: '__union' & GraphQLTypes['SEPAPaymentDirectDebitMandate'];
    };
    ['PaymentMandateCanceledReason']: PaymentMandateCanceledReason;
    /** Payment Mandate Canceled status information */
    ['PaymentMandateCanceledStatusInfo']: {
        __typename: 'PaymentMandateCanceledStatusInfo';
        /** Payment Mandate status (always Canceled for type PaymentMandateCanceledStatusInfo). */
        status: GraphQLTypes['PaymentMandateStatus'];
        /** Reason behind the Payment Mandate Canceled status */
        reason: GraphQLTypes['PaymentMandateCanceledReason'];
        /** Date of Cancellation of the mandate. */
        canceledAt: GraphQLTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['PaymentMandateConnection']: {
        __typename: 'PaymentMandateConnection';
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** PaymentMandateEdge list */
        edges: Array<GraphQLTypes['PaymentMandateEdge']>;
    };
    /** Payment Mandate Consent Pending status information */
    ['PaymentMandateConsentPendingStatusInfo']: {
        __typename: 'PaymentMandateConsentPendingStatusInfo';
        /** Payment Mandate status (always Enabled for type PaymentMandateEnableedStatusInfo). */
        status: GraphQLTypes['PaymentMandateStatus'];
        /** Consent information required to enable the concerned Payment Mandate */
        consent: GraphQLTypes['Consent'];
    };
    ['PaymentMandateCreditor']: {
        __typename: 'InternalPaymentMandateCreditor' | 'SEPAPaymentMandateCreditor';
        /** Creditor UUID */
        id: string;
        /** Creditor name */
        name: string;
        /** Creditor address */
        address: GraphQLTypes['Address'];
        ['...on InternalPaymentMandateCreditor']: '__union' & GraphQLTypes['InternalPaymentMandateCreditor'];
        ['...on SEPAPaymentMandateCreditor']: '__union' & GraphQLTypes['SEPAPaymentMandateCreditor'];
    };
    ['PaymentMandateDebtor']: {
        __typename: 'InternalPaymentMandateDebtor' | 'SEPAPaymentMandateDebtor';
        /** Debtor name */
        name: string;
        /** Debtor e-mail */
        email?: string | undefined;
        /** Debtor country */
        country: GraphQLTypes['CCA3'];
        ['...on InternalPaymentMandateDebtor']: '__union' & GraphQLTypes['InternalPaymentMandateDebtor'];
        ['...on SEPAPaymentMandateDebtor']: '__union' & GraphQLTypes['SEPAPaymentMandateDebtor'];
    };
    /** Implements the Relay Edge interface */
    ['PaymentMandateEdge']: {
        __typename: 'PaymentMandateEdge';
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor: string;
        /** The payment mandate */
        node: GraphQLTypes['PaymentMandate'];
    };
    /** Payment Mandate Enabled status information */
    ['PaymentMandateEnabledStatusInfo']: {
        __typename: 'PaymentMandateEnabledStatusInfo';
        /** Payment Mandate status (always Enabled for type PaymentMandateEnabledStatusInfo). */
        status: GraphQLTypes['PaymentMandateStatus'];
    };
    /** Filter that can be passed to get the payment mandate in a specific data range */
    ['PaymentMandateFiltersInput']: {
        /** To filter on status values */
        status?: Array<GraphQLTypes['PaymentMandateStatus']> | undefined;
        /** To filter on scheme values */
        scheme?: Array<GraphQLTypes['PaymentMandateScheme']> | undefined;
    };
    /** Error returned if the payment mandate was not found */
    ['PaymentMandateMandateNotFoundRejection']: {
        __typename: 'PaymentMandateMandateNotFoundRejection';
        id: string;
        message: string;
    };
    /** Field we can use when ordering that can be applied when listing payment mandate results */
    ['PaymentMandateOrderByFieldInput']: PaymentMandateOrderByFieldInput;
    /** Order that can be applied when listing payment mandate results */
    ['PaymentMandateOrderByInput']: {
        field?: GraphQLTypes['PaymentMandateOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Rejection returned if the payment mandate reference is already used for the same creditor */
    ['PaymentMandateReferenceAlreadyUsedRejection']: {
        __typename: 'PaymentMandateReferenceAlreadyUsedRejection';
        message: string;
    };
    /** Payment Mandate Rejected status information */
    ['PaymentMandateRejectedStatusInfo']: {
        __typename: 'PaymentMandateRejectedStatusInfo';
        /** Payment Mandate status (always Rejected for type PaymentMandateSuspendedStatusInfo). */
        status: GraphQLTypes['PaymentMandateStatus'];
    };
    ['PaymentMandateScheme']: PaymentMandateScheme;
    /** Payment Mandate Sequence */
    ['PaymentMandateSequence']: PaymentMandateSequence;
    /** Payment Mandate status */
    ['PaymentMandateStatus']: PaymentMandateStatus;
    /** Payment Mandate status information */
    ['PaymentMandateStatusInfo']: {
        __typename: 'PaymentMandateCanceledStatusInfo' | 'PaymentMandateConsentPendingStatusInfo' | 'PaymentMandateEnabledStatusInfo' | 'PaymentMandateRejectedStatusInfo';
        /** Status of the payment mandate. */
        status: GraphQLTypes['PaymentMandateStatus'];
        ['...on PaymentMandateCanceledStatusInfo']: '__union' & GraphQLTypes['PaymentMandateCanceledStatusInfo'];
        ['...on PaymentMandateConsentPendingStatusInfo']: '__union' & GraphQLTypes['PaymentMandateConsentPendingStatusInfo'];
        ['...on PaymentMandateEnabledStatusInfo']: '__union' & GraphQLTypes['PaymentMandateEnabledStatusInfo'];
        ['...on PaymentMandateRejectedStatusInfo']: '__union' & GraphQLTypes['PaymentMandateRejectedStatusInfo'];
    };
    /** Rejection returned when a payment method is not compatible for the requested mutation */
    ['PaymentMethodNotCompatibleRejection']: {
        __typename: 'PaymentMethodNotCompatibleRejection';
        message: string;
    };
    /** Field we can use when ordering that can be applied when listing payment */
    ['PaymentOrderByFieldInput']: PaymentOrderByFieldInput;
    /** Order that can be applied when listing payments */
    ['PaymentOrderByInput']: {
        field?: GraphQLTypes['PaymentOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Payment product */
    ['PaymentProduct']: PaymentProduct;
    /** Payment status rejected */
    ['PaymentRejected']: {
        __typename: 'PaymentRejected';
        /** status of the payment */
        status: GraphQLTypes['PaymentStatus'];
        /** rejected reason */
        reason: string;
    };
    /** Payment status */
    ['PaymentStatus']: PaymentStatus;
    /** Payment Status Information */
    ['PaymentStatusInfo']: {
        __typename: 'PaymentConsentPending' | 'PaymentInitiated' | 'PaymentRejected';
        /** status of the payment */
        status: GraphQLTypes['PaymentStatus'];
        ['...on PaymentConsentPending']: '__union' & GraphQLTypes['PaymentConsentPending'];
        ['...on PaymentInitiated']: '__union' & GraphQLTypes['PaymentInitiated'];
        ['...on PaymentRejected']: '__union' & GraphQLTypes['PaymentRejected'];
    };
    /** Custom information for a PDF statement */
    ['PdfStatement']: {
        __typename: 'PdfStatement';
        /** statement type */
        type?: GraphQLTypes['StatementType'] | undefined;
        /** temporary public url on which the file can be accessed */
        url?: string | undefined;
        /** date at which the link will not be useable anymore */
        expiresAt?: GraphQLTypes['DateTime'] | undefined;
    };
    /** Pending Consent when the account membership will be updated */
    ['PendingConsentAccountMembershipUpdate']: {
        __typename: 'PendingConsentAccountMembershipUpdate';
        /** New account membership version waiting for consent */
        accountMembershipId: GraphQLTypes['AccountMembership'];
        /** The consent required to update the account membership */
        consent: GraphQLTypes['Consent'];
    };
    /** Pending Digital Card used for ApplePay or GooglePay */
    ['PendingDigitalCard']: {
        __typename: 'PendingDigitalCard';
        /** Unique identifier of a digital card */
        id: string;
        /** The type of digitalization that created this digital card. */
        type: GraphQLTypes['DigitalizationType'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Wallet Provider (ApplePay, GooglePay ...) */
        walletProvider: GraphQLTypes['WalletProvider'];
        /** Digital Card status information
    
    In this type the status will be either ConsentPending or Pending */
        statusInfo: GraphQLTypes['PendingDigitalCardStatusInfo'];
        /** Data to provide to the wallet during InApp Provisioning
    
    Signature Data is mandatory for ApplePay
    
    This data is only available for a digital card in
    - status: Pending
    - type: InApp */
        inAppProvisioningData?: GraphQLTypes['InAppProvisioningData'] | undefined;
    };
    /** Pending Digital Card Status */
    ['PendingDigitalCardStatus']: PendingDigitalCardStatus;
    /** Pending Digital Card Status Information */
    ['PendingDigitalCardStatusInfo']: {
        __typename: 'DigitalCardConsentPendingStatusInfo' | 'DigitalCardDeclinedStatusInfo' | 'DigitalCardPendingStatusInfo';
        /** Status of the digital card. */
        status: GraphQLTypes['PendingDigitalCardStatus'];
        ['...on DigitalCardConsentPendingStatusInfo']: '__union' & GraphQLTypes['DigitalCardConsentPendingStatusInfo'];
        ['...on DigitalCardDeclinedStatusInfo']: '__union' & GraphQLTypes['DigitalCardDeclinedStatusInfo'];
        ['...on DigitalCardPendingStatusInfo']: '__union' & GraphQLTypes['DigitalCardPendingStatusInfo'];
    };
    /** Funding Source Pending status information */
    ['PendingFundingSourceStatusInfo']: {
        __typename: 'PendingFundingSourceStatusInfo';
        /** Funding Source Pending status */
        status: GraphQLTypes['FundingSourceStatus'];
    };
    /** Describes an identification level that is pending for the process of the current identification, requiring an operation not related to the end-user to progress */
    ['PendingIdentificationLevelStatusInfo']: {
        __typename: 'PendingIdentificationLevelStatusInfo';
        /** Always set to `Pending` */
        status: GraphQLTypes['SwanIdentificationStatus'];
    };
    /** PendingMerchantPaymentMethodStatusInfo */
    ['PendingMerchantPaymentMethodStatusInfo']: {
        __typename: 'PendingMerchantPaymentMethodStatusInfo';
        status: GraphQLTypes['MerchantPaymentMethodStatus'];
    };
    /** PendingReviewMerchantProfileStatusInfo */
    ['PendingReviewMerchantProfileStatusInfo']: {
        __typename: 'PendingReviewMerchantProfileStatusInfo';
        status: GraphQLTypes['MerchantProfileStatus'];
    };
    /** Pending Verification Information */
    ['PendingReviewStatusInfo']: {
        __typename: 'PendingReviewStatusInfo';
        /** Account verification status (PendingReview) */
        status: GraphQLTypes['AccountVerificationStatus'];
    };
    /** Pending transaction status information */
    ['PendingTransactionStatusInfo']: {
        __typename: 'PendingTransactionStatusInfo';
        /** status of the transaction */
        status: GraphQLTypes['TransactionStatus'];
        /** The date when the pending amount of this transaction is released on the available balance of this account if not booked */
        pendingEndDate?: GraphQLTypes['DateTime'] | undefined;
    };
    /** Pending Verification Information */
    ['PendingVerificationStatusInfo']: {
        __typename: 'PendingVerificationStatusInfo';
        /** Account verification status (PendingVerification) */
        status: GraphQLTypes['AccountVerificationStatus'];
    };
    ['PermissionCannotBeGrantedRejection']: {
        __typename: 'PermissionCannotBeGrantedRejection';
        message: string;
    };
    /** E.164 standard format phone number
  
  Examples
  +551155256325
  +44207183875 */
    ['PhoneNumber']: 'scalar' & {
        name: 'PhoneNumber';
    };
    /** Physical Card */
    ['PhysicalCard']: {
        __typename: 'PhysicalCard';
        /** Physical Card status information */
        statusInfo: GraphQLTypes['PhysicalCardStatusInfo'];
        /** Physical Card expiration date  with MM/YY string format */
        expiryDate?: string | undefined;
        /** Unique identifier present on physical card, such identifier is null if the status is ToActivate or Canceled. This identifier is updated when a renewed card is activated */
        identifier?: string | undefined;
        /** Offline Spending limit defined by Swan */
        offlineSpendingLimit: GraphQLTypes['Amount'];
        /** Masked Card Number */
        cardMaskedNumber: string;
        /** Custom Options */
        customOptions: GraphQLTypes['PhysicalCardCustomOptions'];
        /** every previous Physical Card information */
        previousPhysicalCards: Array<GraphQLTypes['BasicPhysicalCardInfo']>;
    };
    /** Physical Card Activated Status Information */
    ['PhysicalCardActivatedStatusInfo']: {
        __typename: 'PhysicalCardActivatedStatusInfo';
        /** Physical Card status (always Activated for type PhysicalCardEnabledStatusInfo). */
        status: GraphQLTypes['PhysicalCardStatus'];
    };
    /** Physical Card Canceled Status Information */
    ['PhysicalCardCanceledStatusInfo']: {
        __typename: 'PhysicalCardCanceledStatusInfo';
        /** Physical Card status (always Canceled for type PhysicalCardCanceledStatusInfo). */
        status: GraphQLTypes['PhysicalCardStatus'];
        /** Reason why the card is canceled. */
        reason: string;
    };
    /** Physical Card Canceling Status Information */
    ['PhysicalCardCancelingStatusInfo']: {
        __typename: 'PhysicalCardCancelingStatusInfo';
        /** Physical Card status (always Canceling for type PhysicalCardCancelingStatusInfo). */
        status: GraphQLTypes['PhysicalCardStatus'];
        /** Reason why the card is canceled. */
        reason: string;
    };
    ['PhysicalCardConfigInput']: {
        /** Address to deliver the physical card */
        deliveryAddress: GraphQLTypes['CompleteAddressInput'];
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: GraphQLTypes['PhysicalCardCustomOptionsInput'] | undefined;
        /** `true` if the user must choose their PIN */
        choosePin?: boolean | undefined;
    };
    /** when the user has to authorize production of the physical card */
    ['PhysicalCardConsentPendingStatusInfo']: {
        __typename: 'PhysicalCardConsentPendingStatusInfo';
        /** Physical Card status (always ConsentPending for type PhysicalCardConsentPendingStatusInfo) */
        status: GraphQLTypes['PhysicalCardStatus'];
        /** The consent required to authorize production of the physical card */
        consent: GraphQLTypes['Consent'];
    };
    /** Custom options for physical card. */
    ['PhysicalCardCustomOptions']: {
        __typename: 'PhysicalCardCustomOptions';
        /** Additional line embossed on the card. */
        additionalPrintedLine?: string | undefined;
    };
    ['PhysicalCardCustomOptionsForGroupDeliveryInput']: {
        /** Additional line to be embossed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined;
    };
    ['PhysicalCardCustomOptionsForPrintInput']: {
        /** Additional line to be printed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined;
    };
    ['PhysicalCardCustomOptionsInput']: {
        /** Additional line to be embossed on the card.
    
    This field will only be taken into account for custom card design that include it. ([Learn More](https://docs.swan.io/guide/issue-cards#order-cards-with-additional-line))
    
    Max length allowed: 26 characters.
    Characters allowed: alphanumeric’*’ ‘.’ ‘-’ ‘/’ apostrophe */
        additionalPrintedLine?: string | undefined;
    };
    /** Rejection returned when the Physical Card does not exist */
    ['PhysicalCardNotFoundRejection']: {
        __typename: 'PhysicalCardNotFoundRejection';
        message: string;
        identifier: string;
    };
    /** when the physical card is in the process of being ready to use */
    ['PhysicalCardProcessingStatusInfo']: {
        __typename: 'PhysicalCardProcessingStatusInfo';
        /** Physical card status (always Processing for type PhysicalCardProcessingStatusInfo) */
        status: GraphQLTypes['PhysicalCardStatus'];
    };
    /** Physical Card Renewed Status Information */
    ['PhysicalCardRenewedStatusInfo']: {
        __typename: 'PhysicalCardRenewedStatusInfo';
        /** Physical Card status (always Renewed for type PhysicalCardRenewedStatusInfo). */
        status: GraphQLTypes['PhysicalCardStatus'];
        /** address to deliver the physical card */
        address: GraphQLTypes['Address'];
        /** Estimated delivery date */
        estimatedDeliveryDate?: GraphQLTypes['DateTime'] | undefined;
        /** Shipping tracking number */
        trackingNumber?: string | undefined;
        /** Name of the shipping provider (Ex: LaPoste, DHL ...) */
        shippingProvider?: string | undefined;
        /** `true` if PIN Code is available. */
        isPINReady: boolean;
        /** New physical Card info */
        newPhysicalCard: GraphQLTypes['BasicPhysicalCardInfo'];
    };
    /** Physical Card Status */
    ['PhysicalCardStatus']: PhysicalCardStatus;
    /** Physical Card Status Information */
    ['PhysicalCardStatusInfo']: {
        __typename: 'PhysicalCardActivatedStatusInfo' | 'PhysicalCardCanceledStatusInfo' | 'PhysicalCardCancelingStatusInfo' | 'PhysicalCardConsentPendingStatusInfo' | 'PhysicalCardProcessingStatusInfo' | 'PhysicalCardRenewedStatusInfo' | 'PhysicalCardSuspendedStatusInfo' | 'PhysicalCardToActivateStatusInfo' | 'PhysicalCardToRenewStatusInfo';
        /** Status of the physical card. */
        status: GraphQLTypes['PhysicalCardStatus'];
        ['...on PhysicalCardActivatedStatusInfo']: '__union' & GraphQLTypes['PhysicalCardActivatedStatusInfo'];
        ['...on PhysicalCardCanceledStatusInfo']: '__union' & GraphQLTypes['PhysicalCardCanceledStatusInfo'];
        ['...on PhysicalCardCancelingStatusInfo']: '__union' & GraphQLTypes['PhysicalCardCancelingStatusInfo'];
        ['...on PhysicalCardConsentPendingStatusInfo']: '__union' & GraphQLTypes['PhysicalCardConsentPendingStatusInfo'];
        ['...on PhysicalCardProcessingStatusInfo']: '__union' & GraphQLTypes['PhysicalCardProcessingStatusInfo'];
        ['...on PhysicalCardRenewedStatusInfo']: '__union' & GraphQLTypes['PhysicalCardRenewedStatusInfo'];
        ['...on PhysicalCardSuspendedStatusInfo']: '__union' & GraphQLTypes['PhysicalCardSuspendedStatusInfo'];
        ['...on PhysicalCardToActivateStatusInfo']: '__union' & GraphQLTypes['PhysicalCardToActivateStatusInfo'];
        ['...on PhysicalCardToRenewStatusInfo']: '__union' & GraphQLTypes['PhysicalCardToRenewStatusInfo'];
    };
    /** Physical Card Suspended Status Information */
    ['PhysicalCardSuspendedStatusInfo']: {
        __typename: 'PhysicalCardSuspendedStatusInfo';
        /** Physical Card status (always Suspended for type PhysicalCardSuspendedStatusInfo). */
        status: GraphQLTypes['PhysicalCardStatus'];
        /** Reason why the card is suspended. */
        reason: string;
    };
    /** Physical Card To Activate Status Information */
    ['PhysicalCardToActivateStatusInfo']: {
        __typename: 'PhysicalCardToActivateStatusInfo';
        /** Physical Card status (always ToActivate for type PhysicalCardToActivateStatusInfo). */
        status: GraphQLTypes['PhysicalCardStatus'];
        /** address to deliver the physical card */
        address: GraphQLTypes['Address'];
        /** Estimated delivery date */
        estimatedDeliveryDate?: GraphQLTypes['DateTime'] | undefined;
        /** Shipping tracking number */
        trackingNumber?: string | undefined;
        /** Name of the shipping provider (Ex: LaPoste, DHL ...) */
        shippingProvider?: string | undefined;
        /** `true` if PIN Code is available. */
        isPINReady: boolean;
    };
    /** when the physical card is in the process of being renewed */
    ['PhysicalCardToRenewStatusInfo']: {
        __typename: 'PhysicalCardToRenewStatusInfo';
        /** Physical card status (always ToRenew for type PhysicalCardToRenewStatusInfo) */
        status: GraphQLTypes['PhysicalCardStatus'];
        /** registered address to deliver the new physical card */
        address: GraphQLTypes['Address'];
    };
    /** Rejection returned when the Physical Card is not the expected status */
    ['PhysicalCardWrongStatusRejection']: {
        __typename: 'PhysicalCardWrongStatusRejection';
        message: string;
        identifier: string;
        currentStatus: GraphQLTypes['PhysicalCardStatus'];
        expectedStatus: GraphQLTypes['PhysicalCardStatus'];
    };
    /** 6 digits numeric passcode */
    ['PIN']: 'scalar' & {
        name: 'PIN';
    };
    ['PINNotReadyRejection']: {
        __typename: 'PINNotReadyRejection';
        physicalCardIdentifier: string;
        message: string;
    };
    ['PreferredNotificationChannel']: PreferredNotificationChannel;
    ['PreProvisioningSUVCardSettings']: {
        __typename: 'PreProvisioningSUVCardSettings';
        preProvisioningSUVCards: boolean;
        preProvisioningSUVNumberOfCards: number;
        ownerProvisioningSUVCards?: string | undefined;
        preProvisioningSUVCardsAvailablePercentage: number;
    };
    /** Inputs to print a physical card */
    ['PrintPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** Address to deliver the physical card */
        address: GraphQLTypes['CompleteAddressInput'];
        /** `true` if the user must choose their PIN Code (will be deprecated/removed) */
        choosePINCode: boolean;
        /** `true` if the user must choose their PIN */
        choosePin?: boolean | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Custom options to use for physical cards. */
        physicalCardCustomOptions?: GraphQLTypes['PhysicalCardCustomOptionsForPrintInput'] | undefined;
    };
    ['PrintPhysicalCardPayload']: {
        __typename: 'PrintPhysicalCardSuccessPayload' | 'AccountMembershipNotAllowedRejection' | 'AlreadyValidPhysicalCardRejection' | 'BadAccountStatusRejection' | 'BadRequestRejection' | 'CardNotFoundRejection' | 'CardProductNotApplicableToPhysicalCardsRejection' | 'CardProductDisabledRejection' | 'MissingMandatoryFieldRejection' | 'ValidationRejection';
        ['...on PrintPhysicalCardSuccessPayload']: '__union' & GraphQLTypes['PrintPhysicalCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on AlreadyValidPhysicalCardRejection']: '__union' & GraphQLTypes['AlreadyValidPhysicalCardRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on BadRequestRejection']: '__union' & GraphQLTypes['BadRequestRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on CardProductNotApplicableToPhysicalCardsRejection']: '__union' & GraphQLTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        ['...on CardProductDisabledRejection']: '__union' & GraphQLTypes['CardProductDisabledRejection'];
        ['...on MissingMandatoryFieldRejection']: '__union' & GraphQLTypes['MissingMandatoryFieldRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['PrintPhysicalCardSuccessPayload']: {
        __typename: 'PrintPhysicalCardSuccessPayload';
        /** The physicalCard created */
        physicalCard: GraphQLTypes['PhysicalCard'];
    };
    /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
    ['ProductType']: ProductType;
    ['ProjectCardDesigns']: {
        __typename: 'ProjectCardDesigns';
        /** Unique identifier of a project */
        id: string;
        /** Visual Id from the issuing card processor (Monext) */
        issuingProcessorVisualId?: string | undefined;
        /** Specific card product for companies */
        specificCardProductCodeForCompanies?: string | undefined;
        /** Project name */
        name?: string | undefined;
        /** Project card product designs */
        cardDesigns: Array<GraphQLTypes['CardProductDesign']>;
        /** Project's pre provisioning suv card settings */
        preProvisioningSUVCardSettings?: GraphQLTypes['PreProvisioningSUVCardSettings'] | undefined;
    };
    ['ProjectCardSettings']: {
        __typename: 'ProjectCardSettings';
        /** Unique identifier of a project */
        id: string;
        /** Visual Id from the issuing card processor (Monext) */
        issuingProcessorVisualId?: string | undefined;
        /** Specific card product for companies */
        specificCardProductCodeForCompanies?: string | undefined;
        /** Project name */
        name?: string | undefined;
        /** Project's card settings */
        cardSettings: Array<GraphQLTypes['CardSettings']>;
        /** Project's pre provisioning suv card settings */
        preProvisioningSUVCardSettings?: GraphQLTypes['PreProvisioningSUVCardSettings'] | undefined;
    };
    /** Project Card Settings Background Type */
    ['ProjectCardSettingsBackgroundType']: ProjectCardSettingsBackgroundType;
    /** Card Status */
    ['ProjectCardStatus']: ProjectCardStatus;
    ['ProjectForbiddenRejection']: {
        __typename: 'ProjectForbiddenRejection';
        message: string;
    };
    /** Rejection returned when the Project Funding has been exceeded */
    ['ProjectFundingLimitExceededRejection']: {
        __typename: 'ProjectFundingLimitExceededRejection';
        message: string;
    };
    /** Public information of a `Project` */
    ['ProjectInfo']: {
        __typename: 'ProjectInfo';
        /** The card products associated with this project. */
        cardProducts?: Array<GraphQLTypes['CardProduct']> | undefined;
        /** the currently active card settings */
        activeCardSettings?: GraphQLTypes['CardSettings'] | undefined;
        /** Unique identifier of the project */
        id: string;
        B2BMembershipIDVerification?: boolean | undefined;
        supportingDocumentSettings?: GraphQLTypes['SupportingDocumentSettings'] | undefined;
        /** Your project name displayed in white label interfaces and in the terms and conditions */
        name: string;
        /** The type of your project */
        type: GraphQLTypes['ProjectType'];
        /** URL of your logo */
        logoUri?: string | undefined;
        /** Your accent color, used in white label interfaces. Most of the time for call to actions */
        accentColor?: string | undefined;
        /** Your custom subdomain used in consents */
        customConsentSubdomain?: string | undefined;
        /** Your OAuth client id */
        oAuthClientId?: string | undefined;
        /** URL to your Terms and Conditions of Use document depending on the provided language */
        tcuDocumentUri: string;
        /** Unique id of your current Terms and Conditions of Use */
        tcuDocumentId: string;
        /** Web banking settings */
        webBankingSettings?: GraphQLTypes['WebBankingSettings'] | undefined;
        /** Project status */
        status: GraphQLTypes['ProjectStatus'];
        /** Flag that determines if desktop authentication is enabled for this project */
        allowsDesktopAuthentication: boolean;
    };
    /** Rejection returned when the Project Instant Funding limit has been exceeded */
    ['ProjectInstantFundingLimitExceededRejection']: {
        __typename: 'ProjectInstantFundingLimitExceededRejection';
        message: string;
    };
    ['ProjectInvalidStatusRejection']: {
        __typename: 'ProjectInvalidStatusRejection';
        message: string;
    };
    ['ProjectNotFound']: {
        __typename: 'ProjectNotFound';
        message: string;
    };
    /** Rejection returned when the project is not found */
    ['ProjectNotFoundRejection']: {
        __typename: 'ProjectNotFoundRejection';
        message: string;
    };
    ['ProjectSettingsForbiddenError']: {
        __typename: 'ProjectSettingsForbiddenError';
        message: string;
    };
    ['ProjectSettingsNotFound']: {
        __typename: 'ProjectSettingsNotFound';
        message: string;
    };
    ['ProjectSettingsStatusNotReachable']: {
        __typename: 'ProjectSettingsStatusNotReachable';
        message: string;
    };
    ['ProjectStatus']: ProjectStatus;
    ['ProjectType']: ProjectType;
    /** Rejection returned when the public onboarding is disabled */
    ['PublicOnboardingDisabledRejection']: {
        __typename: 'PublicOnboardingDisabledRejection';
        message: string;
    };
    ['Query']: {
        __typename: 'Query';
        /** Returns a request for funding limit settings change from its id. */
        fundingLimitSettingsChangeRequest?: GraphQLTypes['FundingLimitSettingsChangeRequest'] | undefined;
        /** Allows to check iban validation. It also returns its bank and reachability information */
        ibanValidation?: GraphQLTypes['IbanValidationResult'] | undefined;
        /** Returns an account holder from its id. */
        accountHolder?: GraphQLTypes['AccountHolder'] | undefined;
        /** Returns the list of account holders.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *For a Project access token, this is all the account holders of the project and for an User access token, these are the holders of the accounts of which the user has an account membership.* */
        accountHolders: GraphQLTypes['AccountHolderConnection'];
        /** Returns an account membership from its id. */
        accountMembership?: GraphQLTypes['AccountMembership'] | undefined;
        /** The list of account memberships
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        accountMemberships: GraphQLTypes['AccountMembershipConnection'];
        /** Returns an account from its id. */
        account?: GraphQLTypes['Account'] | undefined;
        /** Returns the list of accounts.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *For a Project access token, this is all the accounts of the project and for an User access token, these are the accounts of which the user has an account membership.* */
        accounts: GraphQLTypes['AccountConnection'];
        /** Allows to verify the consistency between a beneficiary name and an IBAN. */
        beneficiaryVerification?: GraphQLTypes['BeneficiaryVerificationResult'] | undefined;
        /** Returns a card from its id. */
        card?: GraphQLTypes['Card'] | undefined;
        /** Returns the list of cards.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *For a Project access token, this is all the cards of the project and for an User access token, these are the cards owned by the user whom have an account membership.* */
        cards: GraphQLTypes['CardConnection'];
        /** Returns an onboarding from its id.
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        onboarding: GraphQLTypes['Onboarding'];
        /** Returns the list of onboardings.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        onboardings: GraphQLTypes['OnboardingConnection'];
        /** Returns a supporting document collection from its id. */
        supportingDocumentCollection?: GraphQLTypes['SupportingDocumentCollection'] | undefined;
        /** Returns an account statement by id */
        accountStatement: GraphQLTypes['Statement'];
        /** Returns a payment from its id. */
        payment: GraphQLTypes['Payment'];
        /** List of payments.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    *For a Project access token, this is all the payments of the project and for an User access token, these are the payments initiated by the user* */
        payments: GraphQLTypes['PaymentConnection'];
        /** Returns a transaction from its id.
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        transaction: GraphQLTypes['Transaction'];
        /** List of transactions of a project.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    *For a Project access token, this is all the transactions of the project (only available with project access token)* */
        transactions: GraphQLTypes['TransactionConnection'];
        accountInvoice?: GraphQLTypes['Invoice'] | undefined;
        /** Return the capital deposit case for the provided id. */
        capitalDepositCase?: GraphQLTypes['CapitalDepositCase'] | undefined;
        /** Returns the list of capital deposit cases.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination))
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        capitalDepositCases: GraphQLTypes['CapitalDepositCaseConnection'];
        /** Return the CapitalDepositDocument for the provided id. */
        capitalDepositDocument?: GraphQLTypes['CapitalDepositDocument'] | undefined;
        /** Return the Shareholder for the provided id. */
        shareholder?: GraphQLTypes['Shareholder'] | undefined;
        /** Returns the project infos you set in the dashboard. */
        projectInfo: GraphQLTypes['ProjectInfo'];
        /** Returns a consent by its id. */
        consent: GraphQLTypes['Consent'];
        /** Return the list of consents
    
    For a User access token : return the list of consents for the signed-in user
    For a Project access token : return the list of consents for the project. This list can be filtered by userId
    
    *([Learn more on authentication](https://docs.swan.io/api/authentication))* */
        consents: GraphQLTypes['ConsentConnection'];
        /** Returns a User
    
    For a Project access token : it requires a user id and returns the user for the given id
    For a User access token : returns the signed-in user and all of their data at Swan
    
    *([Learn more on authentication](https://docs.swan.io/api/authentication))* */
        user?: GraphQLTypes['User'] | undefined;
        /** Returns the list of user that joined the project
    The search field allows to search in : id, phonNumber, firstName, allFirstNames, lastName
    
    *This query is restricted to a Project access token ([Learn More](https://docs.swan.io/api/authentication))* */
        users: GraphQLTypes['UserConnection'];
        /** Returns a received direct debit mandate from its id. */
        receivedDirectDebitMandate?: GraphQLTypes['ReceivedDirectDebitMandate'] | undefined;
        /** Returns a merchant profile by id. */
        merchantProfile?: GraphQLTypes['MerchantProfile'] | undefined;
        /** Returns funding source by id. */
        fundingSource?: GraphQLTypes['FundingSource'] | undefined;
        /** Returns an international beneficiary dynamic forms. */
        internationalBeneficiaryDynamicForms?: GraphQLTypes['InternationalBeneficiaryDynamicForms'] | undefined;
        /** Returns an international credit transfer dynamic form. */
        internationalCreditTransferTransactionDetailsDynamicForm?: GraphQLTypes['InternationalCreditTransferDynamicForm'] | undefined;
        /** Request an international credit transfer quote. */
        internationalCreditTransferQuote?: GraphQLTypes['InternationalCreditTransferQuote'] | undefined;
        /** Returns standing order from its id. */
        standingOrder?: GraphQLTypes['StandingOrder'] | undefined;
        /** A single webhook eventLog, queried by its id */
        webhookEventLog?: GraphQLTypes['WebhookEventLog'] | undefined;
    };
    ['RadioField']: {
        __typename: 'RadioField';
        key: string;
        name: string;
        refreshDynamicFieldsOnChange: boolean;
        required: boolean;
        allowedValues: Array<GraphQLTypes['AllowedValue']>;
    };
    /** Information that can be used to determine where the iban can be used */
    ['Reachability']: {
        __typename: 'Reachability';
        /** Can be used for instant transfer over SEPA */
        sepaCreditTransferInst: boolean;
        /** Can be used for direct debit over SEPA */
        sepaDirectDebitCore: boolean;
        /** Can be used for B2B direct debit over SEPA */
        sepaDirectDebitB2b: boolean;
        /** Can be used for transfer over SEPA (can be used in initiateCreditTransfer mutation) */
        sepaCreditTransfer: boolean;
    };
    /** Define a reason with a message */
    ['Reason']: {
        __typename: 'CloseAccountReason' | 'SuspendAccountReason';
        message?: string | undefined;
        ['...on CloseAccountReason']: '__union' & GraphQLTypes['CloseAccountReason'];
        ['...on SuspendAccountReason']: '__union' & GraphQLTypes['SuspendAccountReason'];
    };
    /** Input version */
    ['ReasonInput']: {
        message?: string | undefined;
    };
    /** Interface for Received Direct Debit Mandate */
    ['ReceivedDirectDebitMandate']: {
        __typename: 'InternalReceivedDirectDebitMandate' | 'SEPAReceivedDirectDebitMandate';
        /** Unique identifier of the received direct debit mandate, generated by Swan */
        id: string;
        /** Version of the received direct debit mandate */
        version: string;
        /** Creation date of the received direct debit mandate */
        createdAt: GraphQLTypes['DateTime'];
        /** Last Update date of the received direct debit mandate */
        updatedAt: GraphQLTypes['DateTime'];
        /** Date of signature of the received direct debit mandate */
        signatureDate?: GraphQLTypes['Date'] | undefined;
        /** Date of the last direct debit transaction executed for the concerned received direct debit mandate */
        executedAt?: GraphQLTypes['DateTime'] | undefined;
        /** Expiry date of the received direct debit mandate */
        expiredAt?: GraphQLTypes['Date'] | undefined;
        /** Mandate status information of the received direct debit mandate */
        statusInfo: GraphQLTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Mandate name */
        name?: string | undefined;
        ['...on InternalReceivedDirectDebitMandate']: '__union' & GraphQLTypes['InternalReceivedDirectDebitMandate'];
        ['...on SEPAReceivedDirectDebitMandate']: '__union' & GraphQLTypes['SEPAReceivedDirectDebitMandate'];
    };
    /** Rejection returned if the received direct debit mandate already exist */
    ['ReceivedDirectDebitMandateAlreadyExistRejection']: {
        __typename: 'ReceivedDirectDebitMandateAlreadyExistRejection';
        id: string;
        message: string;
    };
    /** Received direct debit mandate is canceled and therefore can't be enabled/suspended or updated */
    ['ReceivedDirectDebitMandateCanceledRejection']: {
        __typename: 'ReceivedDirectDebitMandateCanceledRejection';
        id: string;
        message: string;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['ReceivedDirectDebitMandateConnection']: {
        __typename: 'ReceivedDirectDebitMandateConnection';
        /** Total number of elements in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** ReceivedDirectDebitMandateEdge list */
        edges: Array<GraphQLTypes['ReceivedDirectDebitMandateEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['ReceivedDirectDebitMandateEdge']: {
        __typename: 'ReceivedDirectDebitMandateEdge';
        /** Opaque identifier pointing to this onboarding node in the pagination mechanism */
        cursor: string;
        /** The received direct debit mandate */
        node: GraphQLTypes['ReceivedDirectDebitMandate'];
    };
    /** Rejection returned if the received direct debit mandate is not a B2b mandate */
    ['ReceivedDirectDebitMandateNotB2bRejection']: {
        __typename: 'ReceivedDirectDebitMandateNotB2bRejection';
        id: string;
        message: string;
    };
    /** Error returned if the received direct debit mandate was not found or if the user does not have the rights to receive information abo
  ut the existence of the received direct debit mandate */
    ['ReceivedDirectDebitMandateNotFoundRejection']: {
        __typename: 'ReceivedDirectDebitMandateNotFoundRejection';
        id: string;
        message: string;
    };
    /** Received Direct Debit Mandate Scheme */
    ['ReceivedDirectDebitMandateScheme']: ReceivedDirectDebitMandateScheme;
    /** Received Direct Debit Mandate Statuses */
    ['ReceivedDirectDebitMandateStatus']: ReceivedDirectDebitMandateStatus;
    /** Received Direct Debit Mandate status information */
    ['ReceivedDirectDebitMandateStatusInfo']: {
        __typename: 'ReceivedDirectDebitMandateStatusInfoCanceled' | 'ReceivedDirectDebitMandateStatusInfoConsentInitiationPending' | 'ReceivedDirectDebitMandateStatusInfoConsentPending' | 'ReceivedDirectDebitMandateStatusInfoEnabled' | 'ReceivedDirectDebitMandateStatusInfoSuspended';
        /** Received Direct Debit Mandate status */
        status: GraphQLTypes['ReceivedDirectDebitMandateStatus'];
        ['...on ReceivedDirectDebitMandateStatusInfoCanceled']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateStatusInfoCanceled'];
        ['...on ReceivedDirectDebitMandateStatusInfoConsentInitiationPending']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateStatusInfoConsentInitiationPending'];
        ['...on ReceivedDirectDebitMandateStatusInfoConsentPending']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateStatusInfoConsentPending'];
        ['...on ReceivedDirectDebitMandateStatusInfoEnabled']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateStatusInfoEnabled'];
        ['...on ReceivedDirectDebitMandateStatusInfoSuspended']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateStatusInfoSuspended'];
    };
    /** Received Direct Debit Mandate Canceled status information */
    ['ReceivedDirectDebitMandateStatusInfoCanceled']: {
        __typename: 'ReceivedDirectDebitMandateStatusInfoCanceled';
        /** Received Direct Debit Mandate status (always Canceled for type ReceivedDirectDebitMandateStatusInfoCanceled) */
        status: GraphQLTypes['ReceivedDirectDebitMandateStatus'];
        /** Date of cancellation */
        canceledAt: GraphQLTypes['DateTime'];
    };
    /** Received Direct Debit Mandate ConsentInitiationPending status information */
    ['ReceivedDirectDebitMandateStatusInfoConsentInitiationPending']: {
        __typename: 'ReceivedDirectDebitMandateStatusInfoConsentInitiationPending';
        /** Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentInitiationPending) */
        status: GraphQLTypes['ReceivedDirectDebitMandateStatus'];
    };
    /** Received Direct Debit Mandate ConsentPending status information */
    ['ReceivedDirectDebitMandateStatusInfoConsentPending']: {
        __typename: 'ReceivedDirectDebitMandateStatusInfoConsentPending';
        /** Received Direct Debit Mandate status (always ConsentInitiationPending for type ReceivedDirectDebitMandateStatusInfoConsentPending) */
        status: GraphQLTypes['ReceivedDirectDebitMandateStatus'];
        /** The consent required to consent to a received direct debit mandate */
        consent: GraphQLTypes['Consent'];
    };
    /** Received Direct Debit Mandate Enabled status information */
    ['ReceivedDirectDebitMandateStatusInfoEnabled']: {
        __typename: 'ReceivedDirectDebitMandateStatusInfoEnabled';
        /** Received Direct Debit Mandate status (always Enabled for type ReceivedDirectDebitMandateStatusInfoEnabled) */
        status: GraphQLTypes['ReceivedDirectDebitMandateStatus'];
        /** Date at which the received direct debit mandate has been moved to the enabled status */
        enabledAt: GraphQLTypes['DateTime'];
    };
    /** Received Direct Debit Mandate Suspended status information */
    ['ReceivedDirectDebitMandateStatusInfoSuspended']: {
        __typename: 'ReceivedDirectDebitMandateStatusInfoSuspended';
        /** Received Direct Debit Mandate status (always Suspended for type ReceivedDirectDebitMandateStatusInfoSuspended) */
        status: GraphQLTypes['ReceivedDirectDebitMandateStatus'];
        /** Date of the last time the received direct debit mandate has been moved to the suspended status */
        suspendedAt: GraphQLTypes['DateTime'];
    };
    /** Input to select the beneficiary and the originator to perform a refund */
    ['RefundInput']: {
        /** transactions to refund */
        refundTransactions: Array<GraphQLTypes['RefundTransaction']>;
        /** url the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** The respond body to a refund mutation */
    ['RefundPayload']: {
        __typename: 'RefundSuccessPayload' | 'RefundRejection';
        ['...on RefundSuccessPayload']: '__union' & GraphQLTypes['RefundSuccessPayload'];
        ['...on RefundRejection']: '__union' & GraphQLTypes['RefundRejection'];
    };
    /** Rejection returned if the transaction status is not correct for the desired action */
    ['RefundRejection']: {
        __typename: 'RefundRejection';
        message: string;
        code: GraphQLTypes['RefundRejectionCode'];
    };
    /** Reason code that explains why we can't refund the transactions */
    ['RefundRejectionCode']: RefundRejectionCode;
    /** Consent generated by the refund mutation */
    ['RefundSuccessPayload']: {
        __typename: 'RefundSuccessPayload';
        /** optional consent that need to be validated for the refund to go through */
        consent?: GraphQLTypes['Consent'] | undefined;
    };
    /** Information about the transaction to refund */
    ['RefundTransaction']: {
        /** id of the transaction to refund */
        originTransactionId: string;
        /** amount to refund in the same currency as the account */
        amount: GraphQLTypes['AmountInput'];
        /** reference assigned by the initiating party, to unambiguously identify the transaction.
    This reference is passed on, unchanged, throughout the entire end-to-end chain for credit transfers. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined;
        /** label for the refund transaction (max 140 characters) */
        label?: string | undefined;
        /** only used when the transaction was a credit transfer
    
    date when the credit transfer will be executed, if `null` the credit transfer is executed today */
        executionDate?: GraphQLTypes['DateTime'] | undefined;
    };
    /** Funding Source Rejected Reason */
    ['RejectedFundingSourceReason']: RejectedFundingSourceReason;
    /** Funding Source Rejected status information */
    ['RejectedFundingSourceStatusInfo']: {
        __typename: 'RejectedFundingSourceStatusInfo';
        /** Funding Source Rejected status */
        status: GraphQLTypes['FundingSourceStatus'];
        /** Date at which the funding source was rejected */
        rejectedAt: GraphQLTypes['Date'];
        /** Reason code of the rejection */
        reasonCode: GraphQLTypes['RejectedFundingSourceReason'];
    };
    /** RejectedMerchantPaymentMethodStatusInfo */
    ['RejectedMerchantPaymentMethodStatusInfo']: {
        __typename: 'RejectedMerchantPaymentMethodStatusInfo';
        status: GraphQLTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method rejected date */
        rejectedAt: GraphQLTypes['Date'];
    };
    /** RejectedMerchantProfileStatusInfo */
    ['RejectedMerchantProfileStatusInfo']: {
        __typename: 'RejectedMerchantProfileStatusInfo';
        status: GraphQLTypes['MerchantProfileStatus'];
        rejectedAt: GraphQLTypes['Date'];
    };
    /** The following reason code for a rejected transaction are defined: */
    ['RejectedReasonCode']: RejectedReasonCode;
    /** Rejected transaction status information */
    ['RejectedTransactionStatusInfo']: {
        __typename: 'RejectedTransactionStatusInfo';
        /** status of the transaction */
        status: GraphQLTypes['TransactionStatus'];
        /** reason code */
        reason: GraphQLTypes['RejectedReasonCode'];
        /** `true` if the transaction had a fallback */
        hasFallback: boolean;
    };
    /** Rejected Verification Reason */
    ['RejectedVerificationReason']: RejectedVerificationReason;
    /** Rejected Information */
    ['RejectedVerificationStatusInfo']: {
        __typename: 'RejectedVerificationStatusInfo';
        /** Rejected Reason */
        reason: GraphQLTypes['RejectedVerificationReason'];
        /** Date at which the verification was rejected */
        rejectedAt: GraphQLTypes['DateTime'];
        /** Account verification status (Rejected) */
        status: GraphQLTypes['AccountVerificationStatus'];
    };
    ['Rejection']: {
        __typename: 'AccountHolderNotFoundRejection' | 'AccountHolderTypeIndividualRejection' | 'AccountMembershipCannotBeDisabledRejection' | 'AccountMembershipCannotBeUpdatedRejection' | 'AccountMembershipNotAllowedRejection' | 'AccountMembershipNotFoundRejection' | 'AccountMembershipNotReadyToBeBoundRejection' | 'AccountNotEligibleRejection' | 'AccountNotFoundRejection' | 'AccountVerificationAlreadyRejectedRejection' | 'AccountVerificationWrongStatusRejection' | 'ActionNotAllowedRejection' | 'AddingCardsToDifferentAccountsRejection' | 'AlreadyValidPhysicalCardRejection' | 'ApplePayNotAllowedForProjectRejection' | 'BadAccountStatusRejection' | 'BadRequestRejection' | 'CannotActivatePhysicalCardRejection' | 'CapitalDepositDocumentCanNotBeUploaded' | 'CapitalDepositDocumentCanNotBeUploadedRejection' | 'CardCanNotBeDigitalizedRejection' | 'CardNotFoundRejection' | 'CardProductDisabledRejection' | 'CardProductNotApplicableToPhysicalCardsRejection' | 'CardProductNotFoundRejection' | 'CardProductSuspendedRejection' | 'CardProductUsedRejection' | 'CardWrongStatusRejection' | 'CheckRejection' | 'ConsentNotFoundRejection' | 'ConsentsAlreadyLinkedToMultiConsentRejection' | 'ConsentsNotAllInCreatedStatusRejection' | 'ConsentsNotFoundRejection' | 'ConsentTypeNotSupportedByServerConsentRejection' | 'DebtorAccountClosedRejection' | 'DebtorAccountNotAllowedRejection' | 'DigitalCardNotFoundRejection' | 'EnabledCardDesignNotFoundRejection' | 'ExternalAccountAlreadyExistsRejection' | 'ExternalAccountBalanceAlreadyExistsRejection' | 'FeeSettingsNotFoundRejection' | 'ForbiddenRejection' | 'FundingLimitExceededRejection' | 'FundingLimitSettingsChangeRequestBadAmountRejection' | 'FundingSourceNotFoundRejection' | 'FundingSourceWrongStatusRejection' | 'GlobalFundingLimitExceededRejection' | 'GlobalInstantFundingLimitExceededRejection' | 'IBANNotReachableRejection' | 'IBANNotValidRejection' | 'IbanValidationRejection' | 'IdentityAlreadyBindToAccountMembershipRejection' | 'InstantFundingLimitExceededRejection' | 'InsufficientFundsRejection' | 'InternalErrorRejection' | 'InvalidArgumentRejection' | 'InvalidPhoneNumberRejection' | 'InvalidSirenNumberRejection' | 'LegalRepresentativeAccountMembershipCannotBeDisabledRejection' | 'LegalRepresentativeAccountMembershipCannotBeSuspendedRejection' | 'MerchantPaymentMethodNotActiveRejection' | 'MerchantProfileWrongStatusRejection' | 'MissingMandatoryFieldRejection' | 'NotFoundRejection' | 'NotReachableConsentStatusRejection' | 'NotSupportedCountryRejection' | 'OnboardingNotCompletedRejection' | 'PaymentMandateMandateNotFoundRejection' | 'PaymentMandateReferenceAlreadyUsedRejection' | 'PaymentMethodNotCompatibleRejection' | 'PermissionCannotBeGrantedRejection' | 'PhysicalCardNotFoundRejection' | 'PhysicalCardWrongStatusRejection' | 'PINNotReadyRejection' | 'ProjectForbiddenRejection' | 'ProjectFundingLimitExceededRejection' | 'ProjectInstantFundingLimitExceededRejection' | 'ProjectInvalidStatusRejection' | 'ProjectNotFound' | 'ProjectNotFoundRejection' | 'ProjectSettingsForbiddenError' | 'ProjectSettingsNotFound' | 'ProjectSettingsStatusNotReachable' | 'PublicOnboardingDisabledRejection' | 'ReceivedDirectDebitMandateAlreadyExistRejection' | 'ReceivedDirectDebitMandateCanceledRejection' | 'ReceivedDirectDebitMandateNotB2bRejection' | 'ReceivedDirectDebitMandateNotFoundRejection' | 'RefundRejection' | 'RestrictedToUserRejection' | 'SchemeWrongRejection' | 'ServerConsentCredentialsNotValidOrOutdatedRejection' | 'ServerConsentNotAllowedForConsentOperationRejection' | 'ServerConsentNotAllowedForProjectRejection' | 'ServerConsentProjectCredentialMissingRejection' | 'ServerConsentProjectCredentialNotFoundRejection' | 'ServerConsentProjectSettingsNotFoundRejection' | 'ServerConsentSignatureNotValidRejection' | 'StandingOrderNotFoundRejection' | 'SupportingDocumentCollectionNotFoundRejection' | 'SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection' | 'SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection' | 'SupportingDocumentCollectionStatusNotAllowedRejection' | 'SupportingDocumentNotFoundRejection' | 'SupportingDocumentStatusDoesNotAllowDeletionRejection' | 'SupportingDocumentStatusDoesNotAllowUpdateRejection' | 'SupportingDocumentStatusNotAllowedRejection' | 'SupportingDocumentUploadNotAllowedRejection' | 'SuspendReceivedDirectDebitMandatedRejection' | 'SwanTCUDocumentNotFoundRejection' | 'SwanTCUDocumentStatusNotAllowedRejection' | 'TooManyChildConsentsRejection' | 'TooManyItemsRejection' | 'TransactionNotFoundRejection' | 'UpdateUserConsentSettingsTokenRejection' | 'UserNotAllowedToDisableItsOwnAccountMembershipRejection' | 'UserNotAllowedToManageAccountMembershipRejection' | 'UserNotAllowedToSuspendItsOwnAccountMembershipRejection' | 'UserNotCardHolderRejection' | 'ValidationRejection' | 'WebhookEventLogNotFoundRejection' | 'WebhookSubscriptionNotFoundRejection' | 'WrongValueProvidedRejection';
        message: string;
        ['...on AccountHolderNotFoundRejection']: '__union' & GraphQLTypes['AccountHolderNotFoundRejection'];
        ['...on AccountHolderTypeIndividualRejection']: '__union' & GraphQLTypes['AccountHolderTypeIndividualRejection'];
        ['...on AccountMembershipCannotBeDisabledRejection']: '__union' & GraphQLTypes['AccountMembershipCannotBeDisabledRejection'];
        ['...on AccountMembershipCannotBeUpdatedRejection']: '__union' & GraphQLTypes['AccountMembershipCannotBeUpdatedRejection'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on AccountMembershipNotFoundRejection']: '__union' & GraphQLTypes['AccountMembershipNotFoundRejection'];
        ['...on AccountMembershipNotReadyToBeBoundRejection']: '__union' & GraphQLTypes['AccountMembershipNotReadyToBeBoundRejection'];
        ['...on AccountNotEligibleRejection']: '__union' & GraphQLTypes['AccountNotEligibleRejection'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on AccountVerificationAlreadyRejectedRejection']: '__union' & GraphQLTypes['AccountVerificationAlreadyRejectedRejection'];
        ['...on AccountVerificationWrongStatusRejection']: '__union' & GraphQLTypes['AccountVerificationWrongStatusRejection'];
        ['...on ActionNotAllowedRejection']: '__union' & GraphQLTypes['ActionNotAllowedRejection'];
        ['...on AddingCardsToDifferentAccountsRejection']: '__union' & GraphQLTypes['AddingCardsToDifferentAccountsRejection'];
        ['...on AlreadyValidPhysicalCardRejection']: '__union' & GraphQLTypes['AlreadyValidPhysicalCardRejection'];
        ['...on ApplePayNotAllowedForProjectRejection']: '__union' & GraphQLTypes['ApplePayNotAllowedForProjectRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on BadRequestRejection']: '__union' & GraphQLTypes['BadRequestRejection'];
        ['...on CannotActivatePhysicalCardRejection']: '__union' & GraphQLTypes['CannotActivatePhysicalCardRejection'];
        ['...on CapitalDepositDocumentCanNotBeUploaded']: '__union' & GraphQLTypes['CapitalDepositDocumentCanNotBeUploaded'];
        ['...on CapitalDepositDocumentCanNotBeUploadedRejection']: '__union' & GraphQLTypes['CapitalDepositDocumentCanNotBeUploadedRejection'];
        ['...on CardCanNotBeDigitalizedRejection']: '__union' & GraphQLTypes['CardCanNotBeDigitalizedRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on CardProductDisabledRejection']: '__union' & GraphQLTypes['CardProductDisabledRejection'];
        ['...on CardProductNotApplicableToPhysicalCardsRejection']: '__union' & GraphQLTypes['CardProductNotApplicableToPhysicalCardsRejection'];
        ['...on CardProductNotFoundRejection']: '__union' & GraphQLTypes['CardProductNotFoundRejection'];
        ['...on CardProductSuspendedRejection']: '__union' & GraphQLTypes['CardProductSuspendedRejection'];
        ['...on CardProductUsedRejection']: '__union' & GraphQLTypes['CardProductUsedRejection'];
        ['...on CardWrongStatusRejection']: '__union' & GraphQLTypes['CardWrongStatusRejection'];
        ['...on CheckRejection']: '__union' & GraphQLTypes['CheckRejection'];
        ['...on ConsentNotFoundRejection']: '__union' & GraphQLTypes['ConsentNotFoundRejection'];
        ['...on ConsentsAlreadyLinkedToMultiConsentRejection']: '__union' & GraphQLTypes['ConsentsAlreadyLinkedToMultiConsentRejection'];
        ['...on ConsentsNotAllInCreatedStatusRejection']: '__union' & GraphQLTypes['ConsentsNotAllInCreatedStatusRejection'];
        ['...on ConsentsNotFoundRejection']: '__union' & GraphQLTypes['ConsentsNotFoundRejection'];
        ['...on ConsentTypeNotSupportedByServerConsentRejection']: '__union' & GraphQLTypes['ConsentTypeNotSupportedByServerConsentRejection'];
        ['...on DebtorAccountClosedRejection']: '__union' & GraphQLTypes['DebtorAccountClosedRejection'];
        ['...on DebtorAccountNotAllowedRejection']: '__union' & GraphQLTypes['DebtorAccountNotAllowedRejection'];
        ['...on DigitalCardNotFoundRejection']: '__union' & GraphQLTypes['DigitalCardNotFoundRejection'];
        ['...on EnabledCardDesignNotFoundRejection']: '__union' & GraphQLTypes['EnabledCardDesignNotFoundRejection'];
        ['...on ExternalAccountAlreadyExistsRejection']: '__union' & GraphQLTypes['ExternalAccountAlreadyExistsRejection'];
        ['...on ExternalAccountBalanceAlreadyExistsRejection']: '__union' & GraphQLTypes['ExternalAccountBalanceAlreadyExistsRejection'];
        ['...on FeeSettingsNotFoundRejection']: '__union' & GraphQLTypes['FeeSettingsNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on FundingLimitExceededRejection']: '__union' & GraphQLTypes['FundingLimitExceededRejection'];
        ['...on FundingLimitSettingsChangeRequestBadAmountRejection']: '__union' & GraphQLTypes['FundingLimitSettingsChangeRequestBadAmountRejection'];
        ['...on FundingSourceNotFoundRejection']: '__union' & GraphQLTypes['FundingSourceNotFoundRejection'];
        ['...on FundingSourceWrongStatusRejection']: '__union' & GraphQLTypes['FundingSourceWrongStatusRejection'];
        ['...on GlobalFundingLimitExceededRejection']: '__union' & GraphQLTypes['GlobalFundingLimitExceededRejection'];
        ['...on GlobalInstantFundingLimitExceededRejection']: '__union' & GraphQLTypes['GlobalInstantFundingLimitExceededRejection'];
        ['...on IBANNotReachableRejection']: '__union' & GraphQLTypes['IBANNotReachableRejection'];
        ['...on IBANNotValidRejection']: '__union' & GraphQLTypes['IBANNotValidRejection'];
        ['...on IbanValidationRejection']: '__union' & GraphQLTypes['IbanValidationRejection'];
        ['...on IdentityAlreadyBindToAccountMembershipRejection']: '__union' & GraphQLTypes['IdentityAlreadyBindToAccountMembershipRejection'];
        ['...on InstantFundingLimitExceededRejection']: '__union' & GraphQLTypes['InstantFundingLimitExceededRejection'];
        ['...on InsufficientFundsRejection']: '__union' & GraphQLTypes['InsufficientFundsRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on InvalidArgumentRejection']: '__union' & GraphQLTypes['InvalidArgumentRejection'];
        ['...on InvalidPhoneNumberRejection']: '__union' & GraphQLTypes['InvalidPhoneNumberRejection'];
        ['...on InvalidSirenNumberRejection']: '__union' & GraphQLTypes['InvalidSirenNumberRejection'];
        ['...on LegalRepresentativeAccountMembershipCannotBeDisabledRejection']: '__union' & GraphQLTypes['LegalRepresentativeAccountMembershipCannotBeDisabledRejection'];
        ['...on LegalRepresentativeAccountMembershipCannotBeSuspendedRejection']: '__union' & GraphQLTypes['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection'];
        ['...on MerchantPaymentMethodNotActiveRejection']: '__union' & GraphQLTypes['MerchantPaymentMethodNotActiveRejection'];
        ['...on MerchantProfileWrongStatusRejection']: '__union' & GraphQLTypes['MerchantProfileWrongStatusRejection'];
        ['...on MissingMandatoryFieldRejection']: '__union' & GraphQLTypes['MissingMandatoryFieldRejection'];
        ['...on NotFoundRejection']: '__union' & GraphQLTypes['NotFoundRejection'];
        ['...on NotReachableConsentStatusRejection']: '__union' & GraphQLTypes['NotReachableConsentStatusRejection'];
        ['...on NotSupportedCountryRejection']: '__union' & GraphQLTypes['NotSupportedCountryRejection'];
        ['...on OnboardingNotCompletedRejection']: '__union' & GraphQLTypes['OnboardingNotCompletedRejection'];
        ['...on PaymentMandateMandateNotFoundRejection']: '__union' & GraphQLTypes['PaymentMandateMandateNotFoundRejection'];
        ['...on PaymentMandateReferenceAlreadyUsedRejection']: '__union' & GraphQLTypes['PaymentMandateReferenceAlreadyUsedRejection'];
        ['...on PaymentMethodNotCompatibleRejection']: '__union' & GraphQLTypes['PaymentMethodNotCompatibleRejection'];
        ['...on PermissionCannotBeGrantedRejection']: '__union' & GraphQLTypes['PermissionCannotBeGrantedRejection'];
        ['...on PhysicalCardNotFoundRejection']: '__union' & GraphQLTypes['PhysicalCardNotFoundRejection'];
        ['...on PhysicalCardWrongStatusRejection']: '__union' & GraphQLTypes['PhysicalCardWrongStatusRejection'];
        ['...on PINNotReadyRejection']: '__union' & GraphQLTypes['PINNotReadyRejection'];
        ['...on ProjectForbiddenRejection']: '__union' & GraphQLTypes['ProjectForbiddenRejection'];
        ['...on ProjectFundingLimitExceededRejection']: '__union' & GraphQLTypes['ProjectFundingLimitExceededRejection'];
        ['...on ProjectInstantFundingLimitExceededRejection']: '__union' & GraphQLTypes['ProjectInstantFundingLimitExceededRejection'];
        ['...on ProjectInvalidStatusRejection']: '__union' & GraphQLTypes['ProjectInvalidStatusRejection'];
        ['...on ProjectNotFound']: '__union' & GraphQLTypes['ProjectNotFound'];
        ['...on ProjectNotFoundRejection']: '__union' & GraphQLTypes['ProjectNotFoundRejection'];
        ['...on ProjectSettingsForbiddenError']: '__union' & GraphQLTypes['ProjectSettingsForbiddenError'];
        ['...on ProjectSettingsNotFound']: '__union' & GraphQLTypes['ProjectSettingsNotFound'];
        ['...on ProjectSettingsStatusNotReachable']: '__union' & GraphQLTypes['ProjectSettingsStatusNotReachable'];
        ['...on PublicOnboardingDisabledRejection']: '__union' & GraphQLTypes['PublicOnboardingDisabledRejection'];
        ['...on ReceivedDirectDebitMandateAlreadyExistRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateAlreadyExistRejection'];
        ['...on ReceivedDirectDebitMandateCanceledRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateCanceledRejection'];
        ['...on ReceivedDirectDebitMandateNotB2bRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateNotB2bRejection'];
        ['...on ReceivedDirectDebitMandateNotFoundRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ['...on RefundRejection']: '__union' & GraphQLTypes['RefundRejection'];
        ['...on RestrictedToUserRejection']: '__union' & GraphQLTypes['RestrictedToUserRejection'];
        ['...on SchemeWrongRejection']: '__union' & GraphQLTypes['SchemeWrongRejection'];
        ['...on ServerConsentCredentialsNotValidOrOutdatedRejection']: '__union' & GraphQLTypes['ServerConsentCredentialsNotValidOrOutdatedRejection'];
        ['...on ServerConsentNotAllowedForConsentOperationRejection']: '__union' & GraphQLTypes['ServerConsentNotAllowedForConsentOperationRejection'];
        ['...on ServerConsentNotAllowedForProjectRejection']: '__union' & GraphQLTypes['ServerConsentNotAllowedForProjectRejection'];
        ['...on ServerConsentProjectCredentialMissingRejection']: '__union' & GraphQLTypes['ServerConsentProjectCredentialMissingRejection'];
        ['...on ServerConsentProjectCredentialNotFoundRejection']: '__union' & GraphQLTypes['ServerConsentProjectCredentialNotFoundRejection'];
        ['...on ServerConsentProjectSettingsNotFoundRejection']: '__union' & GraphQLTypes['ServerConsentProjectSettingsNotFoundRejection'];
        ['...on ServerConsentSignatureNotValidRejection']: '__union' & GraphQLTypes['ServerConsentSignatureNotValidRejection'];
        ['...on StandingOrderNotFoundRejection']: '__union' & GraphQLTypes['StandingOrderNotFoundRejection'];
        ['...on SupportingDocumentCollectionNotFoundRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionNotFoundRejection'];
        ['...on SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection'];
        ['...on SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection'];
        ['...on SupportingDocumentCollectionStatusNotAllowedRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionStatusNotAllowedRejection'];
        ['...on SupportingDocumentNotFoundRejection']: '__union' & GraphQLTypes['SupportingDocumentNotFoundRejection'];
        ['...on SupportingDocumentStatusDoesNotAllowDeletionRejection']: '__union' & GraphQLTypes['SupportingDocumentStatusDoesNotAllowDeletionRejection'];
        ['...on SupportingDocumentStatusDoesNotAllowUpdateRejection']: '__union' & GraphQLTypes['SupportingDocumentStatusDoesNotAllowUpdateRejection'];
        ['...on SupportingDocumentStatusNotAllowedRejection']: '__union' & GraphQLTypes['SupportingDocumentStatusNotAllowedRejection'];
        ['...on SupportingDocumentUploadNotAllowedRejection']: '__union' & GraphQLTypes['SupportingDocumentUploadNotAllowedRejection'];
        ['...on SuspendReceivedDirectDebitMandatedRejection']: '__union' & GraphQLTypes['SuspendReceivedDirectDebitMandatedRejection'];
        ['...on SwanTCUDocumentNotFoundRejection']: '__union' & GraphQLTypes['SwanTCUDocumentNotFoundRejection'];
        ['...on SwanTCUDocumentStatusNotAllowedRejection']: '__union' & GraphQLTypes['SwanTCUDocumentStatusNotAllowedRejection'];
        ['...on TooManyChildConsentsRejection']: '__union' & GraphQLTypes['TooManyChildConsentsRejection'];
        ['...on TooManyItemsRejection']: '__union' & GraphQLTypes['TooManyItemsRejection'];
        ['...on TransactionNotFoundRejection']: '__union' & GraphQLTypes['TransactionNotFoundRejection'];
        ['...on UpdateUserConsentSettingsTokenRejection']: '__union' & GraphQLTypes['UpdateUserConsentSettingsTokenRejection'];
        ['...on UserNotAllowedToDisableItsOwnAccountMembershipRejection']: '__union' & GraphQLTypes['UserNotAllowedToDisableItsOwnAccountMembershipRejection'];
        ['...on UserNotAllowedToManageAccountMembershipRejection']: '__union' & GraphQLTypes['UserNotAllowedToManageAccountMembershipRejection'];
        ['...on UserNotAllowedToSuspendItsOwnAccountMembershipRejection']: '__union' & GraphQLTypes['UserNotAllowedToSuspendItsOwnAccountMembershipRejection'];
        ['...on UserNotCardHolderRejection']: '__union' & GraphQLTypes['UserNotCardHolderRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
        ['...on WebhookEventLogNotFoundRejection']: '__union' & GraphQLTypes['WebhookEventLogNotFoundRejection'];
        ['...on WebhookSubscriptionNotFoundRejection']: '__union' & GraphQLTypes['WebhookSubscriptionNotFoundRejection'];
        ['...on WrongValueProvidedRejection']: '__union' & GraphQLTypes['WrongValueProvidedRejection'];
    };
    ['ReleasedReason']: ReleasedReason;
    /** Released card transaction status information */
    ['ReleasedTransactionStatusInfo']: {
        __typename: 'ReleasedTransactionStatusInfo';
        /** status of the transaction */
        status: GraphQLTypes['TransactionStatus'];
        /** The date when the transaction was released */
        releaseDate: GraphQLTypes['DateTime'];
        /** reason of the released transaction */
        reason: GraphQLTypes['ReleasedReason'];
    };
    /** Input to replay a Webhook event */
    ['ReplayWebhookEventInput']: {
        /** The ID of a webhook Event */
        webhookEventId: string;
    };
    /** Invoke Webhook Endpoint Payload */
    ['ReplayWebhookEventPayload']: {
        __typename: 'ReplayWebhookEventSuccessPayload' | 'WebhookEventLogNotFoundRejection' | 'WebhookSubscriptionNotFoundRejection' | 'InternalErrorRejection' | 'InvalidArgumentRejection';
        ['...on ReplayWebhookEventSuccessPayload']: '__union' & GraphQLTypes['ReplayWebhookEventSuccessPayload'];
        ['...on WebhookEventLogNotFoundRejection']: '__union' & GraphQLTypes['WebhookEventLogNotFoundRejection'];
        ['...on WebhookSubscriptionNotFoundRejection']: '__union' & GraphQLTypes['WebhookSubscriptionNotFoundRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on InvalidArgumentRejection']: '__union' & GraphQLTypes['InvalidArgumentRejection'];
    };
    /** Invoke Webhook Endpoint Success Payload */
    ['ReplayWebhookEventSuccessPayload']: {
        __typename: 'ReplayWebhookEventSuccessPayload';
        webhookEventLogEntryId: string;
        endpointStatus?: number | undefined;
    };
    /** The document corresponding to a identification report */
    ['ReportDocument']: {
        __typename: 'ReportDocument';
        /** Unique identifier of the report document */
        id: string;
        /** The type of the document */
        type: GraphQLTypes['DocumentType'];
        /** List of the associated files */
        files: Array<GraphQLTypes['ReportDocumentFile']>;
    };
    /** The file associated to the report document */
    ['ReportDocumentFile']: {
        __typename: 'ReportDocumentFile';
        /** The file's temporary download url */
        downloadUrl: string;
    };
    /** here is the exchange rate detail */
    ['ReportExchangeRate']: {
        __typename: 'ReportExchangeRate';
        sourceCurrency: GraphQLTypes['Currency'];
        exchangeRate: number;
        unitCurrency: GraphQLTypes['Currency'];
        targetCurrency: GraphQLTypes['Currency'];
        quotationDate: GraphQLTypes['Date'];
        contractIdentification?: string | undefined;
    };
    ['RequestMerchantPaymentMethodsInput']: {
        /** ID of the Merchant Profile */
        merchantProfileId: string;
        /** Input for the Internal Direct Debit Standard payment method */
        internalDirectDebitStandard?: GraphQLTypes['InternalDirectDebitStandardPaymentMethodInput'] | undefined;
        /** Input for the Internal Direct Debit B2B payment method */
        internalDirectDebitB2B?: GraphQLTypes['InternalDirectDebitB2BPaymentMethodInput'] | undefined;
        /** Input for the Sepa Direct Debit Core payment method */
        sepaDirectDebitCore?: GraphQLTypes['SepaDirectDebitCorePaymentMethodInput'] | undefined;
        /** Input for the Sepa Direct Debit B2B payment method */
        sepaDirectDebitB2B?: GraphQLTypes['SepaDirectDebitB2BPaymentMethodInput'] | undefined;
        /** Input for Check payment method */
        check?: GraphQLTypes['CheckPaymentMethodInput'] | undefined;
        /** Input for Card payment method */
        card?: GraphQLTypes['CardPaymentMethodInput'] | undefined;
    };
    ['RequestMerchantPaymentMethodsPayload']: {
        __typename: 'RequestMerchantPaymentMethodsSuccessPayload' | 'ForbiddenRejection' | 'NotFoundRejection' | 'InternalErrorRejection' | 'ValidationRejection';
        ['...on RequestMerchantPaymentMethodsSuccessPayload']: '__union' & GraphQLTypes['RequestMerchantPaymentMethodsSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on NotFoundRejection']: '__union' & GraphQLTypes['NotFoundRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['RequestMerchantPaymentMethodsSuccessPayload']: {
        __typename: 'RequestMerchantPaymentMethodsSuccessPayload';
        merchantProfile?: GraphQLTypes['MerchantProfile'] | undefined;
    };
    /** Request Update Merchant Profile */
    ['RequestMerchantProfileUpdate']: {
        __typename: 'RequestMerchantProfileUpdate';
        /** The Request ID */
        id: string;
        /** The Merchant Profile ID to update */
        merchantProfileId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website */
        merchantWebsite?: string | undefined;
        /** Url of the merchant's logo */
        merchantLogoUrl?: string | undefined;
        /** The status of the request */
        status: GraphQLTypes['RequestMerchantProfileUpdateStatus'];
        /** Type of product sold. List of value: Goods, Services, VirtualGoods, GiftsAndDonations. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: GraphQLTypes['ProductType'];
        /** Expected annual activity volumes for all payment method */
        expectedMonthlyPaymentVolume: GraphQLTypes['Amount'];
        /** expected average basket value. */
        expectedAverageBasket: GraphQLTypes['Amount'];
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
    };
    /** Input to update a Merchant Profile */
    ['RequestMerchantProfileUpdateInput']: {
        /** ID of the MerchantProfile to update */
        merchantProfileId: string;
        /** Business name of the merchant, i.e. name that will be displayed on debtors' bank statements */
        merchantName: string;
        /** Url of the merchant's website.
    Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value. */
        merchantWebsite?: string | undefined;
        /** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
        productType: GraphQLTypes['ProductType'];
        /** Expected annual activity volumes for all payment methods. */
        expectedMonthlyPaymentVolume: GraphQLTypes['AmountInput'];
        /** expected average basket value. */
        expectedAverageBasket: GraphQLTypes['AmountInput'];
        /** base64 encoded merchant's logo.
    Use '' to delete the field. Don't add the field to the mutation if you want to keep the existing value. */
        merchantLogo?: string | undefined;
        /** Your accent color, used in white label interfaces.
    This color would also be inherited in the Swan Merchant Payment page.
    Unlike the other fields in this mutation, the value specified here updates the merchant profile's accent color immediately. */
        accentColor?: string | undefined;
    };
    /** Add Merchant Profile Payload */
    ['RequestMerchantProfileUpdatePayload']: {
        __typename: 'RequestMerchantProfileUpdateSuccessPayload' | 'ForbiddenRejection' | 'AccountNotFoundRejection' | 'InternalErrorRejection' | 'ValidationRejection';
        ['...on RequestMerchantProfileUpdateSuccessPayload']: '__union' & GraphQLTypes['RequestMerchantProfileUpdateSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Request Merchant Profile Update Statuses */
    ['RequestMerchantProfileUpdateStatus']: RequestMerchantProfileUpdateStatus;
    /** Add Merchant Profile Success Payload */
    ['RequestMerchantProfileUpdateSuccessPayload']: {
        __typename: 'RequestMerchantProfileUpdateSuccessPayload';
        /** Request Update Merchant Profile */
        requestMerchantProfileUpdate: GraphQLTypes['RequestMerchantProfileUpdate'];
    };
    ['RequestSupportingDocumentCollectionReviewInput']: {
        /** Id of the supporting document collection to review. */
        supportingDocumentCollectionId: string;
    };
    ['RequestSupportingDocumentCollectionReviewPayload']: {
        __typename: 'RequestSupportingDocumentCollectionReviewSuccessPayload' | 'ForbiddenRejection' | 'SupportingDocumentCollectionNotFoundRejection' | 'SupportingDocumentCollectionStatusNotAllowedRejection' | 'ValidationRejection';
        ['...on RequestSupportingDocumentCollectionReviewSuccessPayload']: '__union' & GraphQLTypes['RequestSupportingDocumentCollectionReviewSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on SupportingDocumentCollectionNotFoundRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionNotFoundRejection'];
        ['...on SupportingDocumentCollectionStatusNotAllowedRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionStatusNotAllowedRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['RequestSupportingDocumentCollectionReviewSuccessPayload']: {
        __typename: 'RequestSupportingDocumentCollectionReviewSuccessPayload';
        supportingDocumentCollection: GraphQLTypes['SupportingDocumentCollection'];
    };
    /** The document corresponding to a residence permit */
    ['ResidencePermitDocument']: {
        __typename: 'ResidencePermitDocument';
        /** Unique identifier of the residence permit document */
        id: string;
        /** The type of the document */
        type: GraphQLTypes['DocumentType'];
        /** The date at which the residence permit was issued */
        issueDate?: GraphQLTypes['Date'] | undefined;
        /** The date at which the residence permit expires */
        expiryDate?: GraphQLTypes['Date'] | undefined;
        /** Machine-readable zone code of the residence permit */
        mrz?: string | undefined;
        /** Number of the residence permit */
        number?: string | undefined;
        /** List of the associated files */
        files: Array<GraphQLTypes['ResidencePermitDocumentFile']>;
    };
    /** The file associated to the resident permit document */
    ['ResidencePermitDocumentFile']: {
        __typename: 'ResidencePermitDocumentFile';
        /** The file's temporary download url */
        downloadUrl: string;
        /** From which side the residence permit's picture was taken */
        side: GraphQLTypes['DocumentFileSide'];
    };
    ['ResidencyAddressInput']: {
        /** Address line 1. Length must be from 0 to 255 characters */
        addressLine1?: string | undefined;
        /** AddressLine2. Length must be from 0 to 255 characters */
        addressLine2?: string | undefined;
        /** City. Length must be from 0 to 100 characters */
        city?: string | undefined;
        /** Postal code. Length must be from 0 to 50 characters */
        postalCode?: string | undefined;
        /** State of residency. Length must be from 0 to 100 characters */
        state?: string | undefined;
        /** Country */
        country?: GraphQLTypes['CCA3'] | undefined;
    };
    /** Account membership restricted to */
    ['RestrictedTo']: {
        __typename: 'RestrictedTo';
        /** first name */
        firstName: string;
        /** last name */
        lastName: string;
        /** birth date */
        birthDate?: GraphQLTypes['Date'] | undefined;
        /** phone number */
        phoneNumber: string;
    };
    /** Input when the account membership is restricted to a verified user */
    ['RestrictedToInput']: {
        /** Account member first name */
        firstName: string;
        /** Account member last name */
        lastName: string;
        /** Account member birth date */
        birthDate?: GraphQLTypes['Date'] | undefined;
        /** Account member phone number */
        phoneNumber: GraphQLTypes['PhoneNumber'];
    };
    /** Rejection returned if the mutation cannot be executed in another context than user */
    ['RestrictedToUserRejection']: {
        __typename: 'RestrictedToUserRejection';
        message: string;
    };
    ['ResumeAccountMembershipInput']: {
        /** Unique identifier of a given account membership to resume */
        accountMembershipId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ResumeAccountMembershipPayload']: {
        __typename: 'ResumeAccountMembershipSuccessPayload' | 'ForbiddenRejection' | 'UserNotAllowedToManageAccountMembershipRejection' | 'ValidationRejection';
        ['...on ResumeAccountMembershipSuccessPayload']: '__union' & GraphQLTypes['ResumeAccountMembershipSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on UserNotAllowedToManageAccountMembershipRejection']: '__union' & GraphQLTypes['UserNotAllowedToManageAccountMembershipRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['ResumeAccountMembershipSuccessPayload']: {
        __typename: 'ResumeAccountMembershipSuccessPayload';
        consent: GraphQLTypes['Consent'];
    };
    /** Inputs to resume a physical card */
    ['ResumePhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ResumePhysicalCardPayload']: {
        __typename: 'ResumePhysicalCardSuccessPayload' | 'ForbiddenRejection' | 'CardNotFoundRejection' | 'UserNotCardHolderRejection' | 'PhysicalCardNotFoundRejection' | 'PhysicalCardWrongStatusRejection' | 'ValidationRejection';
        ['...on ResumePhysicalCardSuccessPayload']: '__union' & GraphQLTypes['ResumePhysicalCardSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on UserNotCardHolderRejection']: '__union' & GraphQLTypes['UserNotCardHolderRejection'];
        ['...on PhysicalCardNotFoundRejection']: '__union' & GraphQLTypes['PhysicalCardNotFoundRejection'];
        ['...on PhysicalCardWrongStatusRejection']: '__union' & GraphQLTypes['PhysicalCardWrongStatusRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['ResumePhysicalCardSuccessPayload']: {
        __typename: 'ResumePhysicalCardSuccessPayload';
        /** The physicalCard to resume */
        physicalCard: GraphQLTypes['PhysicalCard'];
        /** The consent required to resume a physical card */
        consent: GraphQLTypes['Consent'];
    };
    /** Percentage over a number of business days, that is applied to all funds collected to compute a Reserved amount
  This amount cannot be used over the corresponding business days */
    ['RollingReserve']: {
        __typename: 'RollingReserve';
        /** Percentage of the funding amount to be reserved */
        percentage: number;
        /** Number of business days the computed amount is reserved */
        rollingDays: number;
    };
    ['ScheduleStandingOrderInput']: {
        /** Fix Amount that will be periodically transferred
         *the value must be empty when `targetAvailableBalance` is defined* */
        amount?: GraphQLTypes['AmountInput'] | undefined;
        /** Target available balance that will be used for periodically clipping the account
         *the value must be empty when `amount` is defined* */
        targetAvailableBalance?: GraphQLTypes['AmountInput'] | undefined;
        /** Scheduled period of Standing Order */
        period: GraphQLTypes['StandingOrderPeriod'];
        /** Earlier date the Standing Order will be executed */
        firstExecutionDate?: GraphQLTypes['DateTime'] | undefined;
        /** Latest date the Standing Order will be executed */
        lastExecutionDate?: GraphQLTypes['DateTime'] | undefined;
        /** SEPA beneficiary of the Standing ORder */
        sepaBeneficiary?: GraphQLTypes['SepaBeneficiaryInput'] | undefined;
        /** Account the Standing Order will be attached to */
        accountId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. (regex [A-Za-z0-9(\\-)(\\_)(\\?)(\\.)(\\+),' ]{1,35}) */
        reference?: string | undefined;
        /** label (max 140 characters) */
        label?: string | undefined;
        /** Transfer mode of the Standing Order */
        creditTransferMode?: GraphQLTypes['CreditTransferMode'] | undefined;
    };
    ['ScheduleStandingOrderPayload']: {
        __typename: 'ScheduleStandingOrderSuccessPayload' | 'ForbiddenRejection' | 'InternalErrorRejection' | 'InvalidArgumentRejection';
        ['...on ScheduleStandingOrderSuccessPayload']: '__union' & GraphQLTypes['ScheduleStandingOrderSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on InvalidArgumentRejection']: '__union' & GraphQLTypes['InvalidArgumentRejection'];
    };
    ['ScheduleStandingOrderSuccessPayload']: {
        __typename: 'ScheduleStandingOrderSuccessPayload';
        standingOrder: GraphQLTypes['StandingOrder'];
    };
    ['Scheme']: {
        __typename: 'Scheme';
        fields: Array<GraphQLTypes['Field']>;
        title: string;
        type: GraphQLTypes['InternationalCreditTransferRouteInput'];
        remainingFieldsToRefreshCount: number;
    };
    /** Rejection returned when adding a B2B mandate with an Individual debtor */
    ['SchemeWrongRejection']: {
        __typename: 'SchemeWrongRejection';
        message: string;
    };
    ['SelectField']: {
        __typename: 'SelectField';
        key: string;
        name: string;
        refreshDynamicFieldsOnChange: boolean;
        required: boolean;
        allowedValues: Array<GraphQLTypes['AllowedValue']>;
    };
    /** External Beneficiary type SEPA */
    ['SEPABeneficiary']: {
        __typename: 'SEPABeneficiary';
        /** unique identifier of a beneficiary
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        id?: string | undefined;
        /** full name of the beneficiary */
        name: string;
        /** `true` if this new beneficiary is the account holder himself in an other financial institution.
    *SOON TO BE DEPRECATED*
    Not used. It will be removed soon. */
        isMyOwnIban: boolean;
        /** beneficiary address */
        address?: GraphQLTypes['Address'] | undefined;
        /** maskedIBAN if the beneficiary is a an account in an other financial institution */
        maskedIBAN?: string | undefined;
    };
    /** Sepa beneficiary account */
    ['SepaBeneficiaryInput']: {
        /** International Bank Account Number */
        iban: GraphQLTypes['IBAN'];
        /** Full name of the beneficiary (min 2 characters, max 70 characters). The name should not include any special characters. */
        name: string;
        /** beneficiary address */
        address?: GraphQLTypes['AddressInput'] | undefined;
        /** `true` if this new beneficiary is the account holder himself in another financial institution. */
        isMyOwnIban: boolean;
        /** `true` if this new beneficiary will be saved to the beneficiary list of the debited account. */
        save: boolean;
    };
    /** SEPA Creditor Identifier
  format :
      1 – 2: ISO Country Code
      3 – 4: Check Digit
      5 – 7: Creditor Business Code – you (Creditor) choose this. The default is ZZZ
      8 - 35: Creditor National Identifier – a consecutive number that will be assigned by country
  example:
      FR11ABC123456 */
    ['SepaCreditorIdentifier']: 'scalar' & {
        name: 'SepaCreditorIdentifier';
    };
    /** Sepa Credit Transfer Creditor */
    ['SEPACreditTransferCreditor']: {
        __typename: 'SEPACreditTransferInCreditor' | 'SEPACreditTransferInternalOutCreditor' | 'SEPACreditTransferOutCreditor';
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        ['...on SEPACreditTransferInCreditor']: '__union' & GraphQLTypes['SEPACreditTransferInCreditor'];
        ['...on SEPACreditTransferInternalOutCreditor']: '__union' & GraphQLTypes['SEPACreditTransferInternalOutCreditor'];
        ['...on SEPACreditTransferOutCreditor']: '__union' & GraphQLTypes['SEPACreditTransferOutCreditor'];
    };
    /** Sepa Credit Transfer Debtor */
    ['SEPACreditTransferDebtor']: {
        __typename: 'SEPACreditTransferInDebtor' | 'SEPACreditTransferInternalInDebtor' | 'SEPACreditTransferOutDebtor';
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        ['...on SEPACreditTransferInDebtor']: '__union' & GraphQLTypes['SEPACreditTransferInDebtor'];
        ['...on SEPACreditTransferInternalInDebtor']: '__union' & GraphQLTypes['SEPACreditTransferInternalInDebtor'];
        ['...on SEPACreditTransferOutDebtor']: '__union' & GraphQLTypes['SEPACreditTransferOutDebtor'];
    };
    /** Sepa Credit Transfer Creditor for Incoming transaction */
    ['SEPACreditTransferInCreditor']: {
        __typename: 'SEPACreditTransferInCreditor';
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Sepa Credit Transfer Debtor for Incoming transaction */
    ['SEPACreditTransferInDebtor']: {
        __typename: 'SEPACreditTransferInDebtor';
        /** full name of the debtor (max 70 characters) */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
    };
    /** *SOON TO BE DEPRECATED*
  Sepa Credit Transfer Debtor for Incoming transaction */
    ['SEPACreditTransferInternalInDebtor']: {
        __typename: 'SEPACreditTransferInternalInDebtor';
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** *SOON TO BE DEPRECATED*
  Sepa Credit Transfer Creditor for internal transaction */
    ['SEPACreditTransferInternalOutCreditor']: {
        __typename: 'SEPACreditTransferInternalOutCreditor';
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: GraphQLTypes['InternalBeneficiary'] | undefined;
    };
    /** Sepa Credit Transfer Creditor for Outgoing transaction */
    ['SEPACreditTransferOutCreditor']: {
        __typename: 'SEPACreditTransferOutCreditor';
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: GraphQLTypes['SEPABeneficiary'] | undefined;
    };
    /** Sepa Credit Transfer Debtor for internal transaction */
    ['SEPACreditTransferOutDebtor']: {
        __typename: 'SEPACreditTransferOutDebtor';
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Sepa Credit Transfer transaction */
    ['SEPACreditTransferTransaction']: {
        __typename: 'SEPACreditTransferTransaction';
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: GraphQLTypes['TransactionSide'];
        /** type */
        type: GraphQLTypes['TransactionTypeEnum'];
        /** amount */
        amount: GraphQLTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: GraphQLTypes['Payment'] | undefined;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: GraphQLTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: GraphQLTypes['PaymentProduct'];
        /** creditor information */
        creditor: GraphQLTypes['SEPACreditTransferCreditor'];
        /** debtor information */
        debtor: GraphQLTypes['SEPACreditTransferDebtor'];
        /** matching account for the transaction */
        account?: GraphQLTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: GraphQLTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: GraphQLTypes['Transaction'] | undefined;
        /** r-transaction reason */
        returnReason?: GraphQLTypes['TransactionReasonCode'] | undefined;
    };
    /** SepaDirectDebitB2BMerchantPaymentMethod */
    ['SepaDirectDebitB2BMerchantPaymentMethod']: {
        __typename: 'SepaDirectDebitB2BMerchantPaymentMethod';
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: GraphQLTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: GraphQLTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: GraphQLTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: GraphQLTypes['RollingReserve'] | undefined;
        /** Whether this payment method uses the Swan Sepa Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** When the above is false, the value of the Sepa Creditor Identifier used */
        sepaCreditorIdentifier?: string | undefined;
    };
    ['SepaDirectDebitB2BPaymentMethodInput']: {
        /** If `true`, the Payment Method will be Enabled */
        activate?: boolean | undefined;
        /** If `true`, the transaction will be created with the Swan Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty) */
        sepaCreditorIdentifier?: string | undefined;
    };
    /** SepaDirectDebitCoreMerchantPaymentMethod */
    ['SepaDirectDebitCoreMerchantPaymentMethod']: {
        __typename: 'SepaDirectDebitCoreMerchantPaymentMethod';
        /** Unique identifier tied to every version of a given Merchant Payment Method */
        id: string;
        /** The Merchant Payment Method Type */
        type: GraphQLTypes['MerchantPaymentMethodType'];
        /** Unique identifier for a given merchant Payment Method, identical for every version of a given Merchant Payment Method Type */
        methodId: string;
        /** Status of the Merchant Payment Method */
        statusInfo: GraphQLTypes['MerchantPaymentMethodStatusInfo'];
        /** Version of the Merchant Payment Method */
        version: number;
        /** Date at which the Merchant Payment Method was last updated */
        updatedAt: GraphQLTypes['Date'];
        /** Rolling Reserve applied to the Merchant Payment Method */
        rollingReserve?: GraphQLTypes['RollingReserve'] | undefined;
        /** Whether this payment method uses the Swan Sepa Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** When the above is false, the value of the Sepa Creditor Identifier used */
        sepaCreditorIdentifier?: string | undefined;
    };
    ['SepaDirectDebitCorePaymentMethodInput']: {
        /** If `true`, the Payment Method will be Pending Review */
        activate?: boolean | undefined;
        /** If `true`, the transaction will be created with the Swan Creditor Identifier */
        useSwanSepaCreditorIdentifier: boolean;
        /** Your own SCI - Mandatory if the useSwanCreditorIdentifier is set to false, otherwise Swan does not take this input into account (even if not empty) */
        sepaCreditorIdentifier?: string | undefined;
    };
    /** Sepa Direct Debit Creditor */
    ['SEPADirectDebitCreditor']: {
        __typename: 'SEPADirectDebitInCreditor' | 'SEPADirectDebitOutCreditor';
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        ['...on SEPADirectDebitInCreditor']: '__union' & GraphQLTypes['SEPADirectDebitInCreditor'];
        ['...on SEPADirectDebitOutCreditor']: '__union' & GraphQLTypes['SEPADirectDebitOutCreditor'];
    };
    /** Sepa Direct Debit Debtor */
    ['SEPADirectDebitDebtor']: {
        __typename: 'SEPADirectDebitInDebtor' | 'SEPADirectDebitOutDebtor';
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        ['...on SEPADirectDebitInDebtor']: '__union' & GraphQLTypes['SEPADirectDebitInDebtor'];
        ['...on SEPADirectDebitOutDebtor']: '__union' & GraphQLTypes['SEPADirectDebitOutDebtor'];
    };
    /** Sepa Direct Debit Creditor for Input transaction */
    ['SEPADirectDebitInCreditor']: {
        __typename: 'SEPADirectDebitInCreditor';
        /** full name of the creditor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    /** Sepa Direct Debtor for Input transaction */
    ['SEPADirectDebitInDebtor']: {
        __typename: 'SEPADirectDebitInDebtor';
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: GraphQLTypes['SEPABeneficiary'] | undefined;
    };
    ['SEPADirectDebitMandate']: {
        __typename: 'SEPAPaymentDirectDebitMandate' | 'SEPAReceivedDirectDebitMandate';
        /** Unique identifier of the received direct debit mandate, generated by Swan */
        id: string;
        ['...on SEPAPaymentDirectDebitMandate']: '__union' & GraphQLTypes['SEPAPaymentDirectDebitMandate'];
        ['...on SEPAReceivedDirectDebitMandate']: '__union' & GraphQLTypes['SEPAReceivedDirectDebitMandate'];
    };
    /** Sepa Direct Debit Creditor for Outgoing transaction */
    ['SEPADirectDebitOutCreditor']: {
        __typename: 'SEPADirectDebitOutCreditor';
        /** full name of the creditor (max 70 characters) */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** beneficiary if the beneficiary is already saved
    *SOON TO BE DEPRECATED*
    Always empty, It will be removed soon. */
        beneficiary?: GraphQLTypes['SEPABeneficiary'] | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
    };
    /** Sepa Direct Debtor for Outgoing transaction */
    ['SEPADirectDebitOutDebtor']: {
        __typename: 'SEPADirectDebitOutDebtor';
        /** full name of the debtor */
        name: string;
        /** maskedIBAN */
        maskedIBAN: string;
        /** IBAN */
        IBAN?: string | undefined;
        /** BIC */
        BIC?: string | undefined;
        /** identifier of a Virtual IBAN */
        virtualIBANEntryId?: string | undefined;
        /** account number */
        accountNumber: GraphQLTypes['AccountNumber'];
    };
    ['SepaDirectDebitPaymentCollectionInput']: {
        /** Payment Mandate ID generated by Swan */
        mandateId: string;
        /** Date at which the Swan merchant wishes the payment to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
    };
    /** Scheme that will be used to create the underlying payment mandate for this funding source */
    ['SEPADirectDebitScheme']: SEPADirectDebitScheme;
    /** Sepa Direct Debit transaction */
    ['SEPADirectDebitTransaction']: {
        __typename: 'SEPADirectDebitTransaction';
        /** unique identifier of the transaction */
        id: string;
        /** reference assigned by the initiating party, to unambiguously identify the transaction. This reference is passed on, unchanged, throughout the entire end-to-end chain. */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: GraphQLTypes['TransactionSide'];
        /** type */
        type: GraphQLTypes['TransactionTypeEnum'];
        /** amount */
        amount: GraphQLTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: GraphQLTypes['Payment'] | undefined;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: GraphQLTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: GraphQLTypes['PaymentProduct'];
        /** creditor information */
        creditor: GraphQLTypes['SEPADirectDebitCreditor'];
        /** debtor information */
        debtor: GraphQLTypes['SEPADirectDebitDebtor'];
        /** matching account for the transaction */
        account?: GraphQLTypes['Account'] | undefined;
        /** matching SEPA mandate for the transaction */
        mandate?: GraphQLTypes['SEPADirectDebitMandate'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: GraphQLTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: GraphQLTypes['Transaction'] | undefined;
        /** reserved amount of the transaction computed with the rolling reserve. */
        reservedAmount?: GraphQLTypes['Amount'] | undefined;
        /** date on which reserved funds become available. */
        reservedAmountReleasedAt?: GraphQLTypes['DateTime'] | undefined;
        /** r-transaction reason */
        returnReason?: GraphQLTypes['TransactionReasonCode'] | undefined;
    };
    /** Payment direct debit mandate for SEPA */
    ['SEPAPaymentDirectDebitMandate']: {
        __typename: 'SEPAPaymentDirectDebitMandate';
        /** Unique identifier of the SEPA Direct Debit Payment Mandate */
        id: string;
        /** List of transactions associated with the SEPA Payment Direct Debit Mandate.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: GraphQLTypes['TransactionConnection'] | undefined;
        /** Unique reference of the SEPA Direct Debit Payment Mandate */
        reference: string;
        /** SEPA Direct Debit Payment Mandate scheme */
        scheme: GraphQLTypes['SEPAPaymentMandateScheme'];
        /** SEPA Direct Debit Payment Mandate status information */
        statusInfo: GraphQLTypes['PaymentMandateStatusInfo'];
        /** SEPA Direct Debit Payment Mandate sequence */
        sequence: GraphQLTypes['SEPAPaymentMandateSequence'];
        /** SEPA Direct Debit Payment Mandate PDF document URL */
        mandateDocumentUrl: string;
        /** SEPA Direct Debit Payment Mandate debtor information */
        debtor: GraphQLTypes['SEPAPaymentMandateDebtor'];
        /** SEPA direct debit ultimate creditor name */
        ultimateCreditorName?: string | undefined;
        /** SEPA Direct Debit Payment Mandate creditor information */
        creditor: GraphQLTypes['SEPAPaymentMandateCreditor'];
        /** Signature date of the SEPA Direct Debit Payment Mandate */
        signatureDate?: GraphQLTypes['Date'] | undefined;
        /** Creation date of the SEPA Direct Debit Payment Mandate */
        createdAt: GraphQLTypes['DateTime'];
        /** Last Update date of the SEPA Direct Debit Payment Mandate */
        updatedAt: GraphQLTypes['DateTime'];
        /** Date of the the last transaction executed for the concerned SEPA Direct Debit Payment Mandate */
        executedAt?: GraphQLTypes['DateTime'] | undefined;
        /** Expiry date of the SEPA Direct Debit Payment Mandate */
        expiredAt?: GraphQLTypes['Date'] | undefined;
        /** Account Holder information */
        accountHolder: GraphQLTypes['AccountHolder'];
        /** Custom name of the mandate */
        name?: string | undefined;
    };
    ['SEPAPaymentMandateCreditor']: {
        __typename: 'SEPAPaymentMandateCreditor';
        /** SEPA Direct Debit Payment Mandate creditor UUID */
        id: string;
        /** SEPA Direct Debit Payment Mandate Sepa Creditor Idenfier (SCI) */
        identifier: GraphQLTypes['SepaCreditorIdentifier'];
        /** SEPA Direct Debit Payment Mandate creditor name */
        name: string;
        /** SEPA Direct Debit Payment Mandate creditor address */
        address: GraphQLTypes['Address'];
    };
    ['SEPAPaymentMandateDebtor']: {
        __typename: 'SEPAPaymentMandateDebtor';
        /** SEPA Direct Debit Payment Mandate debtor name */
        name: string;
        /** SEPA Direct Debit Payment Mandate debtor IBAN */
        iban: GraphQLTypes['IBAN'];
        /** SEPA Direct Debit Payment Mandate debtor e-mail */
        email?: string | undefined;
        /** SEPA Direct Debit Payment Mandate debtor country */
        country: GraphQLTypes['CCA3'];
        /** SEPA Direct Debit Payment Mandate debtor address. Mandatory for non EEA Countries */
        address?: GraphQLTypes['Address'] | undefined;
    };
    ['SepaPaymentMandateDebtorInput']: {
        /** SEPA Direct Debit Payment Mandate debtor name */
        name: string;
        /** SEPA Direct Debit Payment Mandate debtor IBAN */
        IBAN: string;
        address: GraphQLTypes['AddressInput'];
    };
    ['SEPAPaymentMandateScheme']: SEPAPaymentMandateScheme;
    /** SEPA Direct Debit Payment Mandate Sequence */
    ['SEPAPaymentMandateSequence']: SEPAPaymentMandateSequence;
    /** Received direct debit mandate for SEPA */
    ['SEPAReceivedDirectDebitMandate']: {
        __typename: 'SEPAReceivedDirectDebitMandate';
        /** Unique identifier of the received SEPA direct debit mandate, generated by Swan */
        id: string;
        /** List of transactions associated with the SEPA Receive Direct Debit Mandate.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        transactions?: GraphQLTypes['TransactionConnection'] | undefined;
        /** Version of the received SEPA direct debit mandate */
        version: string;
        /** Creation date of the received SEPA direct debit mandate */
        createdAt: GraphQLTypes['DateTime'];
        /** Last Update date of the received SEPA direct debit mandate */
        updatedAt: GraphQLTypes['DateTime'];
        /** Received SEPA direct debit Unique Mandate Reference (UMR) */
        reference: string;
        /** Received SEPA direct debit mandate scheme */
        scheme: GraphQLTypes['SEPAReceivedDirectDebitMandateScheme'];
        /** Received SEPA direct debit mandate sequence */
        sequence: GraphQLTypes['SEPAReceivedDirectDebitMandateSequence'];
        /** Received SEPA direct debit creditor */
        creditor: GraphQLTypes['SEPAReceivedDirectDebitMandateCreditor'];
        /** Received SEPA direct debit ultimate creditor name */
        ultimateCreditorName?: string | undefined;
        /** Date of the last SEPA direct debit transaction executed for the concerned received SEPA direct debit mandate */
        executedAt?: GraphQLTypes['DateTime'] | undefined;
        /** Date of signature of the received SEPA direct debit mandate */
        signatureDate?: GraphQLTypes['Date'] | undefined;
        /** Expiry date of the received SEPA direct debit mandate, computed automatically (36 months from the executedAt date) */
        expiredAt?: GraphQLTypes['Date'] | undefined;
        /** Mandate status information of the received SEPA direct debit mandate */
        statusInfo: GraphQLTypes['ReceivedDirectDebitMandateStatusInfo'];
        /** Account of the received SEPA direct debit mandate debtor */
        account?: GraphQLTypes['Account'] | undefined;
        /** Iban of the received SEPA direct debit mandate debtor */
        iban: GraphQLTypes['IBAN'];
        /** Mandate name */
        name?: string | undefined;
    };
    /** SEPA received direct debit mandate creditor */
    ['SEPAReceivedDirectDebitMandateCreditor']: {
        __typename: 'SEPAReceivedDirectDebitMandateCreditor';
        /** SEPA Creditor identifier (SCI) */
        identifier: string;
        /** Name of the SEPA creditor */
        name: string;
        /** Address of the SEPA creditor */
        address: GraphQLTypes['Address'];
    };
    /** Received SEPA direct debit mandate scheme */
    ['SEPAReceivedDirectDebitMandateScheme']: SEPAReceivedDirectDebitMandateScheme;
    /** SEPA received direct debit mandate sequence */
    ['SEPAReceivedDirectDebitMandateSequence']: SEPAReceivedDirectDebitMandateSequence;
    /** SEPA Identifier
  max 35 Latin characters as follow :
      a b c d e f g h i j k l m n o p q r s t u v w x y z
      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
      0 1 2 3 4 5 6 7 8 9
      / - ? : ( ) . , '  +
  with some follow extra rules :
      Content must not start or end with a ‘/’
      Content must not contain ‘//’s */
    ['SepaReference']: 'scalar' & {
        name: 'SepaReference';
    };
    /** Rejection returned when signature is not valid or remote IP address is not allowed */
    ['ServerConsentCredentialsNotValidOrOutdatedRejection']: {
        __typename: 'ServerConsentCredentialsNotValidOrOutdatedRejection';
        message: string;
    };
    /** Rejection returned when server consent is not allowed on the consent */
    ['ServerConsentNotAllowedForConsentOperationRejection']: {
        __typename: 'ServerConsentNotAllowedForConsentOperationRejection';
        message: string;
    };
    /** Rejection returned when server consent is not allowed for the project associated with the consent */
    ['ServerConsentNotAllowedForProjectRejection']: {
        __typename: 'ServerConsentNotAllowedForProjectRejection';
        message: string;
    };
    /** Rejection returned when there are no server consent credentials for the project */
    ['ServerConsentProjectCredentialMissingRejection']: {
        __typename: 'ServerConsentProjectCredentialMissingRejection';
        message: string;
    };
    /** Rejection returned when the server consent project credentials are not found */
    ['ServerConsentProjectCredentialNotFoundRejection']: {
        __typename: 'ServerConsentProjectCredentialNotFoundRejection';
        message: string;
    };
    /** Rejection returned when the server consent project settings are not found */
    ['ServerConsentProjectSettingsNotFoundRejection']: {
        __typename: 'ServerConsentProjectSettingsNotFoundRejection';
        message: string;
    };
    /** Rejection returned when the signature is not valid
  @Deprecated */
    ['ServerConsentSignatureNotValidRejection']: {
        __typename: 'ServerConsentSignatureNotValidRejection';
        message: string;
    };
    /** Shareholder of a company creating a Capital Deposit Case */
    ['Shareholder']: {
        __typename: 'Shareholder';
        /** Unique identifier of a shareholder. */
        id: string;
        /** Amount the shareholder has to deposit. */
        capitalDepositAmount: GraphQLTypes['Amount'];
        /** Onboarding information of the shareholder. */
        onboarding?: GraphQLTypes['Onboarding'] | undefined;
        /** Unique identifier of the shareholder account. */
        accountId?: string | undefined;
        /** Status of the shareholder during the process with Swan. */
        status: GraphQLTypes['ShareholderStatus'];
        /** Extra information about the shareholder */
        info: GraphQLTypes['ShareholderInfo'];
        /** Shareholder documents for the capital deposit case */
        documents: Array<GraphQLTypes['CapitalDepositDocument']>;
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** Information about capital deposit case. */
        relatedCapitalDepositCase: GraphQLTypes['CapitalDepositCase'];
    };
    /** Shareholder information. */
    ['ShareholderInfo']: {
        __typename: 'IndividualShareholder' | 'CompanyShareholder';
        ['...on IndividualShareholder']: '__union' & GraphQLTypes['IndividualShareholder'];
        ['...on CompanyShareholder']: '__union' & GraphQLTypes['CompanyShareholder'];
    };
    /** Status of the shareholder during the process with Swan. */
    ['ShareholderStatus']: ShareholderStatus;
    /** Shareholder type to identify individuals and companies. */
    ['ShareholderType']: ShareholderType;
    /** Signature data used during apple pay inApp provisioning */
    ['SignatureData']: {
        /** nonce */
        nonce: string;
        /** nonce signed by the secure element */
        nonceSignature: string;
        /** list of apple generated certificates */
        certificates: Array<GraphQLTypes['Certificate']>;
    };
    ['SimulationCardType']: SimulationCardType;
    ['SingleUseVirtualCardConfigInput']: {
        /** Unique identifier of a given account membership */
        accountMembershipId: string;
        /** Card name */
        name?: string | undefined;
        /** Spending limit */
        spendingLimit: GraphQLTypes['SpendingLimitInput'];
    };
    /** Spending */
    ['Spending']: {
        __typename: 'Spending';
        /** period concerned */
        period: GraphQLTypes['SpendingLimitPeriod'];
        /** amount spent during the period */
        amount?: GraphQLTypes['Amount'] | undefined;
    };
    /** Spending limits */
    ['SpendingLimit']: {
        __typename: 'SpendingLimit';
        /** type of limit (defined by the Partner, defined by Swan, etc.) */
        type: GraphQLTypes['SpendingLimitType'];
        /** period concerned */
        period: GraphQLTypes['SpendingLimitPeriod'];
        /** sum of amount of spending authorized during the period */
        amount: GraphQLTypes['Amount'];
    };
    /** Inputs when editing spending limit configuration */
    ['SpendingLimitInput']: {
        /** period concerned */
        period: GraphQLTypes['SpendingLimitPeriodInput'];
        /** sum of amount of spending authorized during the period */
        amount: GraphQLTypes['AmountInput'];
    };
    /** Available period to compute spending limits */
    ['SpendingLimitPeriod']: SpendingLimitPeriod;
    /** Available period to compute spending limits */
    ['SpendingLimitPeriodInput']: SpendingLimitPeriodInput;
    /** Available type of spending limits */
    ['SpendingLimitType']: SpendingLimitType;
    ['StandingOrder']: {
        __typename: 'StandingOrder';
        /** Standing Order unique identifier */
        id: string;
        /** List of payments of an standing order.
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        payments: GraphQLTypes['PaymentConnection'];
        /** reference that will be transferred to the beneficiary throughout the entire end-to-end chain */
        reference?: string | undefined;
        /** label that will be transferred to the beneficiary */
        label?: string | undefined;
        /** Fixed Amount that will be regularly transferred */
        amount?: GraphQLTypes['Amount'] | undefined;
        /** Target available balance value that will be used for periodically clipping the account */
        targetAvailableBalance?: GraphQLTypes['Amount'] | undefined;
        /** Scheduled period of Standing Order */
        period: GraphQLTypes['StandingOrderPeriod'];
        /** Earlier date the Standing Order will be executed */
        firstExecutionDate?: GraphQLTypes['DateTime'] | undefined;
        /** Latest date the Standing Order will be executed */
        lastExecutionDate?: GraphQLTypes['DateTime'] | undefined;
        /** SEPA beneficiary of the Standing Order */
        sepaBeneficiary: GraphQLTypes['SEPABeneficiary'];
        /** Status of the Standing Order */
        statusInfo: GraphQLTypes['StandingOrderStatusInfo'];
        /** Date the Standing Order has been created */
        createdAt: GraphQLTypes['Date'];
        /** Last date the Standing Order has been updated */
        updatedAt: GraphQLTypes['Date'];
        /** Account of the Standing Order */
        account: GraphQLTypes['Account'];
        /** Identity that scheduled the Standing Order */
        createdBy: GraphQLTypes['User'];
        /** Next execution date of the Standing Order, if any */
        nextExecutionDate?: GraphQLTypes['Date'] | undefined;
        /** Transfer mode of the Standing Order */
        creditTransferMode?: GraphQLTypes['CreditTransferMode'] | undefined;
    };
    ['StandingOrderCanceledStatusInfo']: {
        __typename: 'StandingOrderCanceledStatusInfo';
        canceledAt: GraphQLTypes['Date'];
        status: GraphQLTypes['StandingOrderStatus'];
    };
    /** Please see the Connection interface */
    ['StandingOrderConnection']: {
        __typename: 'StandingOrderConnection';
        pageInfo: GraphQLTypes['PageInfo'];
        edges: Array<GraphQLTypes['StandingOrderEdge']>;
        totalCount: number;
    };
    ['StandingOrderConsentPendingStatusInfo']: {
        __typename: 'StandingOrderConsentPendingStatusInfo';
        status: GraphQLTypes['StandingOrderStatus'];
        consent: GraphQLTypes['Consent'];
    };
    /** Please see the Connection interface */
    ['StandingOrderEdge']: {
        __typename: 'StandingOrderEdge';
        node: GraphQLTypes['StandingOrder'];
        cursor: string;
    };
    ['StandingOrderEnabledStatusInfo']: {
        __typename: 'StandingOrderEnabledStatusInfo';
        status: GraphQLTypes['StandingOrderStatus'];
    };
    /** Rejection returned when Standing Order is not found */
    ['StandingOrderNotFoundRejection']: {
        __typename: 'StandingOrderNotFoundRejection';
        message: string;
    };
    ['StandingOrderPeriod']: StandingOrderPeriod;
    ['StandingOrderStatus']: StandingOrderStatus;
    ['StandingOrderStatusInfo']: {
        __typename: 'StandingOrderCanceledStatusInfo' | 'StandingOrderConsentPendingStatusInfo' | 'StandingOrderEnabledStatusInfo';
        status: GraphQLTypes['StandingOrderStatus'];
        ['...on StandingOrderCanceledStatusInfo']: '__union' & GraphQLTypes['StandingOrderCanceledStatusInfo'];
        ['...on StandingOrderConsentPendingStatusInfo']: '__union' & GraphQLTypes['StandingOrderConsentPendingStatusInfo'];
        ['...on StandingOrderEnabledStatusInfo']: '__union' & GraphQLTypes['StandingOrderEnabledStatusInfo'];
    };
    /** Describes an identification level that has started for the process of the current identification */
    ['StartedIdentificationLevelStatusInfo']: {
        __typename: 'StartedIdentificationLevelStatusInfo';
        /** Always set to `Started` */
        status: GraphQLTypes['SwanIdentificationStatus'];
    };
    /** A statement represent metadata around a banking document that list all of the BOOKED banking transactions that have happened between startDate and endDate */
    ['Statement']: {
        __typename: 'Statement';
        /** unique identifier of the statement */
        id: string;
        /** account of the statement */
        account: GraphQLTypes['Account'];
        /** booked balance at the start of the window */
        openingBalance: GraphQLTypes['Amount'];
        /** booked balance at the end of the window */
        closingBalance: GraphQLTypes['Amount'];
        /** starting date of the date window */
        openingDate: GraphQLTypes['DateTime'];
        /** ending date of the date window */
        closingDate: GraphQLTypes['DateTime'];
        /** status of the statement */
        status: GraphQLTypes['StatementStatus'];
        /** period of statement (either custom or monthly) */
        period?: GraphQLTypes['StatementPeriod'] | undefined;
        /** the sum of credit transactions during the window */
        totalCredits: GraphQLTypes['Amount'];
        /** the sum of debit transactions during the window */
        totalDebits: GraphQLTypes['Amount'];
        /** the sum of fee transactions during the window */
        fees: GraphQLTypes['Amount'];
        /** type of statements (ex: PDF) */
        type: Array<GraphQLTypes['StatementInfo'] | undefined>;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)). */
    ['StatementConnection']: {
        __typename: 'StatementConnection';
        pageInfo: GraphQLTypes['PageInfo'];
        totalCount: number;
        edges: Array<GraphQLTypes['StatementEdge']>;
    };
    /** Implements the Relay Edge interface. */
    ['StatementEdge']: {
        __typename: 'StatementEdge';
        node: GraphQLTypes['Statement'];
        cursor: string;
    };
    /** Filter that can be given to give the statement in a specific data range */
    ['StatementFiltersInput']: {
        /** To filter after an updatedAt value */
        isAfterUpdatedAt?: GraphQLTypes['DateTime'] | undefined;
        /** To filter before an updatedAt value */
        isBeforeUpdatedAt?: GraphQLTypes['DateTime'] | undefined;
        /** To filter on a specific period of statement (either custom or monthly) */
        period?: GraphQLTypes['StatementPeriod'] | undefined;
    };
    /** Custom information for a certain type of statement */
    ['StatementInfo']: {
        __typename: 'CsvStatement' | 'PdfStatement';
        type?: GraphQLTypes['StatementType'] | undefined;
        ['...on CsvStatement']: '__union' & GraphQLTypes['CsvStatement'];
        ['...on PdfStatement']: '__union' & GraphQLTypes['PdfStatement'];
    };
    /** The different periods of statement */
    ['StatementPeriod']: StatementPeriod;
    /** The different statuses of statement */
    ['StatementStatus']: StatementStatus;
    /** The different type of statement actually available
  - PDF will be a PDF file with the statement information */
    ['StatementType']: StatementType;
    ['StatusText']: StatusText;
    /** Supporting document used for compliance */
    ['SupportingDocument']: {
        __typename: 'SupportingDocument';
        /** Unique identifier of the document */
        id: string;
        /** Supporting document status information */
        statusInfo: GraphQLTypes['SupportingDocumentStatusInfo'];
        /** Type of supporting Document */
        supportingDocumentType?: GraphQLTypes['SupportingDocumentType'] | undefined;
        /** Purpose of supporting document */
        supportingDocumentPurpose: GraphQLTypes['SupportingDocumentPurposeEnum'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
    };
    ['SupportingDocumentAccountHolder']: {
        __typename: 'SupportingDocumentAccountHolder';
        id?: string | undefined;
    };
    /** Collection of supporting documents used for compliance
  
  Fetching SupportingDocument is restricted to Project access token */
    ['SupportingDocumentCollection']: {
        __typename: 'SupportingDocumentCollection';
        /** Unique identifier of the supporting document collection */
        id: string;
        /** Status of the supporting document collection */
        statusInfo: GraphQLTypes['SupportingDocumentCollectionStatusInfo'];
        /** Created date */
        createdAt: GraphQLTypes['DateTime'];
        /** Updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** List of supported documents contained in the supporting document collection */
        supportingDocuments: Array<GraphQLTypes['SupportingDocument'] | undefined>;
        /** List of required supporting document purposes for this supporting document collection */
        requiredSupportingDocumentPurposes: Array<GraphQLTypes['SupportingDocumentPurpose']>;
        accountHolder: GraphQLTypes['SupportingDocumentAccountHolder'];
        onboarding: GraphQLTypes['SupportingDocumentOnboarding'];
        projectInfo: GraphQLTypes['ProjectInfo'];
    };
    /** Supporting document collection with Approved status */
    ['SupportingDocumentCollectionApprovedStatusInfo']: {
        __typename: 'SupportingDocumentCollectionApprovedStatusInfo';
        /** When the supporting document collection is approved */
        status: GraphQLTypes['SupportingDocumentCollectionStatus'];
        /** Date on which the supporting document collection has been approved */
        approvedAt: GraphQLTypes['DateTime'];
    };
    /** Supporting document collection with Canceled status */
    ['SupportingDocumentCollectionCanceledStatusInfo']: {
        __typename: 'SupportingDocumentCollectionCanceledStatusInfo';
        /** When the supporting document collection is canceled */
        status: GraphQLTypes['SupportingDocumentCollectionStatus'];
        /** Date on which the supporting document collection has been canceled */
        canceledAt: GraphQLTypes['DateTime'];
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['SupportingDocumentCollectionConnection']: {
        __typename: 'SupportingDocumentCollectionConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** SupportingDocumentCollectionEdge list */
        edges: Array<GraphQLTypes['SupportingDocumentCollectionEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['SupportingDocumentCollectionEdge']: {
        __typename: 'SupportingDocumentCollectionEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The supporting document collection */
        node: GraphQLTypes['SupportingDocumentCollection'];
    };
    /** Rejection returned if the supporting document collection was not found */
    ['SupportingDocumentCollectionNotFoundRejection']: {
        __typename: 'SupportingDocumentCollectionNotFoundRejection';
        id: string;
        message: string;
    };
    /** Supporting document collection with PendingReview status */
    ['SupportingDocumentCollectionPendingReviewStatusInfo']: {
        __typename: 'SupportingDocumentCollectionPendingReviewStatusInfo';
        /** When the supporting document collection is completed and in compliance review */
        status: GraphQLTypes['SupportingDocumentCollectionStatus'];
    };
    /** Supporting document collection with Rejected status */
    ['SupportingDocumentCollectionRejectedStatusInfo']: {
        __typename: 'SupportingDocumentCollectionRejectedStatusInfo';
        /** When the supporting document collection is rejected */
        status: GraphQLTypes['SupportingDocumentCollectionStatus'];
        /** Date on which the supporting document collection has been rejected */
        rejectedAt: GraphQLTypes['DateTime'];
    };
    /** Verification status of a supporting document collection */
    ['SupportingDocumentCollectionStatus']: SupportingDocumentCollectionStatus;
    /** Rejection returned if supporting document cannot be deleted because its supporting document collection status is not WaitingForDocument */
    ['SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection']: {
        __typename: 'SupportingDocumentCollectionStatusDoesNotAllowDeletionRejection';
        message: string;
        supportingDocumentCollectionStatus: GraphQLTypes['SupportingDocumentCollectionStatus'];
        supportingDocumentCollection: GraphQLTypes['SupportingDocumentCollection'];
    };
    /** Rejection returned if supporting document cannot be updated because its supporting document collection status is not WaitingForDocument */
    ['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection']: {
        __typename: 'SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection';
        message: string;
        supportingDocumentCollectionStatus: GraphQLTypes['SupportingDocumentCollectionStatus'];
        supportingDocumentCollection: GraphQLTypes['SupportingDocumentCollection'];
    };
    ['SupportingDocumentCollectionStatusInfo']: {
        __typename: 'SupportingDocumentCollectionApprovedStatusInfo' | 'SupportingDocumentCollectionCanceledStatusInfo' | 'SupportingDocumentCollectionPendingReviewStatusInfo' | 'SupportingDocumentCollectionRejectedStatusInfo' | 'SupportingDocumentCollectionWaitingForDocumentStatusInfo';
        /** Status of the supporting document collection */
        status: GraphQLTypes['SupportingDocumentCollectionStatus'];
        ['...on SupportingDocumentCollectionApprovedStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentCollectionApprovedStatusInfo'];
        ['...on SupportingDocumentCollectionCanceledStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentCollectionCanceledStatusInfo'];
        ['...on SupportingDocumentCollectionPendingReviewStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentCollectionPendingReviewStatusInfo'];
        ['...on SupportingDocumentCollectionRejectedStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentCollectionRejectedStatusInfo'];
        ['...on SupportingDocumentCollectionWaitingForDocumentStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentCollectionWaitingForDocumentStatusInfo'];
    };
    /** Rejection returned if the status transition is not allowed */
    ['SupportingDocumentCollectionStatusNotAllowedRejection']: {
        __typename: 'SupportingDocumentCollectionStatusNotAllowedRejection';
        oldStatus: GraphQLTypes['SupportingDocumentCollectionStatus'];
        newStatus: GraphQLTypes['SupportingDocumentCollectionStatus'];
        message: string;
    };
    /** Supporting document collection with WaitingForUpload status */
    ['SupportingDocumentCollectionWaitingForDocumentStatusInfo']: {
        __typename: 'SupportingDocumentCollectionWaitingForDocumentStatusInfo';
        /** When the Supporting Document Collection is created */
        status: GraphQLTypes['SupportingDocumentCollectionStatus'];
    };
    ['SupportingDocumentCollectMode']: SupportingDocumentCollectMode;
    ['SupportingDocumentCommunicationLanguageSettings']: SupportingDocumentCommunicationLanguageSettings;
    /** Rejection returned if the supporting document was not found */
    ['SupportingDocumentNotFoundRejection']: {
        __typename: 'SupportingDocumentNotFoundRejection';
        id: string;
        message: string;
    };
    /** Supporting document with NotUploaded status. */
    ['SupportingDocumentNotUploadedStatusInfo']: {
        __typename: 'SupportingDocumentNotUploadedStatusInfo';
        /** When the document has not been updated on time. */
        status: GraphQLTypes['SupportingDocumentStatus'];
    };
    ['SupportingDocumentOnboarding']: {
        __typename: 'SupportingDocumentOnboarding';
        id?: string | undefined;
    };
    ['SupportingDocumentPostField']: {
        __typename: 'SupportingDocumentPostField';
        key: string;
        value: string;
    };
    /** Details of a supporting document purpose */
    ['SupportingDocumentPurpose']: {
        __typename: 'SupportingDocumentPurpose';
        /** Technical name of the purpose */
        name: GraphQLTypes['SupportingDocumentPurposeEnum'];
        /** Corresponding supporting document types accepted for this supporting document purpose */
        acceptableSupportingDocumentTypes: Array<GraphQLTypes['SupportingDocumentType']>;
    };
    /** Supporting document purpose */
    ['SupportingDocumentPurposeEnum']: SupportingDocumentPurposeEnum;
    /** Supporting document with Refused status */
    ['SupportingDocumentRefusedStatusInfo']: {
        __typename: 'SupportingDocumentRefusedStatusInfo';
        /** When the document has been refused by Swan */
        status: GraphQLTypes['SupportingDocumentStatus'];
        /** An unique URL and one-time URL to download the Document */
        downloadUrl: string;
        /** Date on which the supporting document collection has been refused */
        refusedAt: GraphQLTypes['DateTime'];
        /** Reason why the supporting document has been refused */
        reason: string;
        /** Original file name */
        filename: string;
    };
    ['SupportingDocumentSettings']: {
        __typename: 'SupportingDocumentSettings';
        collectMode: GraphQLTypes['SupportingDocumentCollectMode'];
        communicationLanguage?: GraphQLTypes['SupportingDocumentCommunicationLanguageSettings'] | undefined;
        emailContact?: string | undefined;
    };
    /** Verification status of a document */
    ['SupportingDocumentStatus']: SupportingDocumentStatus;
    /** Rejection returned if supporting document cannot be deleted because of its status */
    ['SupportingDocumentStatusDoesNotAllowDeletionRejection']: {
        __typename: 'SupportingDocumentStatusDoesNotAllowDeletionRejection';
        supportingDocument: GraphQLTypes['SupportingDocument'];
        status: GraphQLTypes['SupportingDocumentStatus'];
        message: string;
    };
    /** Rejection returned if supporting document cannot be updated because of its status */
    ['SupportingDocumentStatusDoesNotAllowUpdateRejection']: {
        __typename: 'SupportingDocumentStatusDoesNotAllowUpdateRejection';
        supportingDocument: GraphQLTypes['SupportingDocument'];
        status: GraphQLTypes['SupportingDocumentStatus'];
        message: string;
    };
    ['SupportingDocumentStatusInfo']: {
        __typename: 'SupportingDocumentNotUploadedStatusInfo' | 'SupportingDocumentRefusedStatusInfo' | 'SupportingDocumentUploadedStatusInfo' | 'SupportingDocumentValidatedStatusInfo' | 'SupportingDocumentWaitingForUploadStatusInfo';
        /** Status of the supporting document */
        status: GraphQLTypes['SupportingDocumentStatus'];
        ['...on SupportingDocumentNotUploadedStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentNotUploadedStatusInfo'];
        ['...on SupportingDocumentRefusedStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentRefusedStatusInfo'];
        ['...on SupportingDocumentUploadedStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentUploadedStatusInfo'];
        ['...on SupportingDocumentValidatedStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentValidatedStatusInfo'];
        ['...on SupportingDocumentWaitingForUploadStatusInfo']: '__union' & GraphQLTypes['SupportingDocumentWaitingForUploadStatusInfo'];
    };
    /** Rejection returned if the status transition is not allowed */
    ['SupportingDocumentStatusNotAllowedRejection']: {
        __typename: 'SupportingDocumentStatusNotAllowedRejection';
        oldStatus: GraphQLTypes['SupportingDocumentStatus'];
        newStatus: GraphQLTypes['SupportingDocumentStatus'];
        message: string;
    };
    /** Specific type for document */
    ['SupportingDocumentType']: SupportingDocumentType;
    /** Supporting document with Uploaded status */
    ['SupportingDocumentUploadedStatusInfo']: {
        __typename: 'SupportingDocumentUploadedStatusInfo';
        /** When the document has been uploaded but not verified by Swan yet */
        status: GraphQLTypes['SupportingDocumentStatus'];
        /** An unique URL and one-time URL to download the Document */
        downloadUrl: string;
        /** Original file name */
        filename: string;
    };
    ['SupportingDocumentUploadInfo']: {
        __typename: 'SupportingDocumentUploadInfo';
        url: string;
        fields: Array<GraphQLTypes['SupportingDocumentPostField']>;
    };
    /** Rejection returned if the supporting document collection cannot receive supporting documents anymore */
    ['SupportingDocumentUploadNotAllowedRejection']: {
        __typename: 'SupportingDocumentUploadNotAllowedRejection';
        supportingDocumentCollectionStatus: GraphQLTypes['SupportingDocumentCollectionStatus'];
        message: string;
    };
    /** Supporting document with Validated status */
    ['SupportingDocumentValidatedStatusInfo']: {
        __typename: 'SupportingDocumentValidatedStatusInfo';
        /** When the document has been uploaded and verified by Swan */
        status: GraphQLTypes['SupportingDocumentStatus'];
        /** An unique URL and one-time URL to download the Document */
        downloadUrl: string;
        /** Date on which the supporting document has been validated */
        validatedAt: GraphQLTypes['DateTime'];
        /** Original file name */
        filename: string;
        /** Reason why the supporting document has been validated */
        reason: string;
    };
    /** Supporting document with WaitingForUpload status */
    ['SupportingDocumentWaitingForUploadStatusInfo']: {
        __typename: 'SupportingDocumentWaitingForUploadStatusInfo';
        /** When the document is not uploaded yet */
        status: GraphQLTypes['SupportingDocumentStatus'];
        /** Info to upload the document : url and fields to add along file in form (POST) */
        upload: GraphQLTypes['SupportingDocumentUploadInfo'];
    };
    ['SuspendAccountMembershipInput']: {
        accountMembershipId: string;
    };
    ['SuspendAccountMembershipPayload']: {
        __typename: 'SuspendAccountMembershipSuccessPayload' | 'InternalErrorRejection' | 'LegalRepresentativeAccountMembershipCannotBeSuspendedRejection' | 'UserNotAllowedToManageAccountMembershipRejection' | 'UserNotAllowedToSuspendItsOwnAccountMembershipRejection' | 'ValidationRejection';
        ['...on SuspendAccountMembershipSuccessPayload']: '__union' & GraphQLTypes['SuspendAccountMembershipSuccessPayload'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on LegalRepresentativeAccountMembershipCannotBeSuspendedRejection']: '__union' & GraphQLTypes['LegalRepresentativeAccountMembershipCannotBeSuspendedRejection'];
        ['...on UserNotAllowedToManageAccountMembershipRejection']: '__union' & GraphQLTypes['UserNotAllowedToManageAccountMembershipRejection'];
        ['...on UserNotAllowedToSuspendItsOwnAccountMembershipRejection']: '__union' & GraphQLTypes['UserNotAllowedToSuspendItsOwnAccountMembershipRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['SuspendAccountMembershipSuccessPayload']: {
        __typename: 'SuspendAccountMembershipSuccessPayload';
        accountMembership: GraphQLTypes['AccountMembership'];
    };
    /** Define a reason with a message and a specific type for suspend account action */
    ['SuspendAccountReason']: {
        __typename: 'SuspendAccountReason';
        type: GraphQLTypes['SuspendAccountReasonType'];
        message?: string | undefined;
    };
    /** Input version */
    ['SuspendAccountReasonInput']: {
        type: GraphQLTypes['SuspendAccountReasonType'];
        message?: string | undefined;
    };
    /** Specific type for suspend account action */
    ['SuspendAccountReasonType']: SuspendAccountReasonType;
    /** SuspendAccountStatusReason */
    ['SuspendAccountStatusReason']: {
        __typename: 'SuspendAccountReason';
        ['...on SuspendAccountReason']: '__union' & GraphQLTypes['SuspendAccountReason'];
    };
    /** StatusInfo when funding limit settings has been suspended */
    ['SuspendedFundingLimitSettingsStatusInfo']: {
        __typename: 'SuspendedFundingLimitSettingsStatusInfo';
        status: GraphQLTypes['FundingLimitSettingsStatus'];
        reason: string;
    };
    /** Funding Source Suspended status information */
    ['SuspendedFundingSourceStatusInfo']: {
        __typename: 'SuspendedFundingSourceStatusInfo';
        /** Funding Source Suspended status */
        status: GraphQLTypes['FundingSourceStatus'];
        /** Date at which the funding source was suspended */
        suspendedAt: GraphQLTypes['Date'];
    };
    /** SuspendedMerchantPaymentMethodStatusInfo */
    ['SuspendedMerchantPaymentMethodStatusInfo']: {
        __typename: 'SuspendedMerchantPaymentMethodStatusInfo';
        status: GraphQLTypes['MerchantPaymentMethodStatus'];
        /** Merchant Payment Method suspended date */
        suspendedAt: GraphQLTypes['Date'];
    };
    /** SuspendedMerchantProfileStatusInfo */
    ['SuspendedMerchantProfileStatusInfo']: {
        __typename: 'SuspendedMerchantProfileStatusInfo';
        status: GraphQLTypes['MerchantProfileStatus'];
        suspendedAt: GraphQLTypes['Date'];
    };
    /** Inputs to suspend a physical card */
    ['SuspendPhysicalCardInput']: {
        /** Unique identifier of a card */
        cardId: string;
    };
    ['SuspendPhysicalCardPayload']: {
        __typename: 'SuspendPhysicalCardSuccessPayload' | 'AccountMembershipNotAllowedRejection' | 'CardNotFoundRejection' | 'ForbiddenRejection' | 'PhysicalCardNotFoundRejection' | 'ValidationRejection';
        ['...on SuspendPhysicalCardSuccessPayload']: '__union' & GraphQLTypes['SuspendPhysicalCardSuccessPayload'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on PhysicalCardNotFoundRejection']: '__union' & GraphQLTypes['PhysicalCardNotFoundRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['SuspendPhysicalCardSuccessPayload']: {
        __typename: 'SuspendPhysicalCardSuccessPayload';
        /** The physicalCard suspended */
        physicalCard: GraphQLTypes['PhysicalCard'];
    };
    /** Rejection returned if the SuspendReceivedDirectDebitMandatedRejection mutation is rejected */
    ['SuspendReceivedDirectDebitMandatedRejection']: {
        __typename: 'SuspendReceivedDirectDebitMandatedRejection';
        message: string;
        reason: GraphQLTypes['SuspendReceivedDirectDebitMandatedRejectionReason'];
    };
    /** Enum of reasons of rejection for suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandatedRejectionReason']: SuspendReceivedDirectDebitMandatedRejectionReason;
    /** Inputs to suspend a received direct debit mandate */
    ['SuspendReceivedDirectDebitMandateInput']: {
        receivedDirectDebitMandateId: string;
    };
    /** Union type returned by the suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandatePayload']: {
        __typename: 'SuspendReceivedDirectDebitMandateSuccessPayload' | 'SuspendReceivedDirectDebitMandatedRejection' | 'ReceivedDirectDebitMandateNotFoundRejection' | 'ReceivedDirectDebitMandateCanceledRejection' | 'ForbiddenRejection';
        ['...on SuspendReceivedDirectDebitMandateSuccessPayload']: '__union' & GraphQLTypes['SuspendReceivedDirectDebitMandateSuccessPayload'];
        ['...on SuspendReceivedDirectDebitMandatedRejection']: '__union' & GraphQLTypes['SuspendReceivedDirectDebitMandatedRejection'];
        ['...on ReceivedDirectDebitMandateNotFoundRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ['...on ReceivedDirectDebitMandateCanceledRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateCanceledRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
    };
    /** Return type in case of a successful response of the suspendReceivedDirectDebitMandate mutation */
    ['SuspendReceivedDirectDebitMandateSuccessPayload']: {
        __typename: 'SuspendReceivedDirectDebitMandateSuccessPayload';
        /** the received direct debit mandate is suspended */
        receivedDirectDebitMandate: GraphQLTypes['ReceivedDirectDebitMandate'];
    };
    /** Swan account beneficiary */
    ['SwanAccountBeneficiaryInput']: {
        /** account number to be credited */
        accountNumber: GraphQLTypes['AccountNumber'];
        /** full name of the beneficiary  (max 70 characters) */
        name: string;
        /** `true` if this new beneficiary will be saved to the beneficiary list of the debited account. */
        save: boolean;
    };
    /** Status values of an identification */
    ['SwanIdentificationStatus']: SwanIdentificationStatus;
    ['SwanTCUDocumentNotFoundRejection']: {
        __typename: 'SwanTCUDocumentNotFoundRejection';
        message: string;
    };
    ['SwanTCUDocumentStatusNotAllowedRejection']: {
        __typename: 'SwanTCUDocumentStatusNotAllowedRejection';
        message: string;
    };
    ['TextField']: {
        __typename: 'TextField';
        displayFormat?: string | undefined;
        example?: string | undefined;
        key: string;
        maxLength?: number | undefined;
        minLength?: number | undefined;
        name: string;
        refreshDynamicFieldsOnChange: boolean;
        required: boolean;
        validationRegex?: string | undefined;
    };
    /** Individual ultimate beneficial owner title (Mr/Ms) */
    ['TitleEnum']: TitleEnum;
    ['TokenRequestorId']: 'scalar' & {
        name: 'TokenRequestorId';
    };
    /** Rejection returned when trying to create a multi consent with too many child consents */
    ['TooManyChildConsentsRejection']: {
        __typename: 'TooManyChildConsentsRejection';
        message: string;
    };
    /** Rejection returned if too many items are given */
    ['TooManyItemsRejection']: {
        __typename: 'TooManyItemsRejection';
        message: string;
    };
    /** Transaction */
    ['Transaction']: {
        __typename: 'CardTransaction' | 'CheckTransaction' | 'FeeTransaction' | 'InternalCreditTransfer' | 'InternalDirectDebitTransaction' | 'InternationalCreditTransferTransaction' | 'SEPACreditTransferTransaction' | 'SEPADirectDebitTransaction';
        /** unique identifier of the transaction */
        id: string;
        /** external identifier of the transaction */
        reference: string;
        /** payment method identifier used for this transaction. e.g masked PAN or IBAN or accountNumber */
        paymentMethodIdentifier: string;
        /** side (Credit or Debit) */
        side: GraphQLTypes['TransactionSide'];
        /** type */
        type: GraphQLTypes['TransactionTypeEnum'];
        /** amount */
        amount: GraphQLTypes['Amount'];
        /** label */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TransactionStatusInfo'];
        /** ID of the payment associated to this transaction */
        paymentId?: string | undefined;
        /** payment associated to this transaction */
        payment?: GraphQLTypes['Payment'] | undefined;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** name of the counterparty. e.g Merchant name, Creditor name, Beneficiary Name ... */
        counterparty: string;
        /** booked balance after this transaction */
        bookedBalanceAfter?: GraphQLTypes['Amount'] | undefined;
        /** payment product used for this transaction */
        paymentProduct: GraphQLTypes['PaymentProduct'];
        /** matching account for this transaction */
        account?: GraphQLTypes['Account'] | undefined;
        /** an arbitrary identifier that was defined by you when you created this transaction.
    
    For example, you can define it in the CreditTransferInput mutation. */
        externalReference?: string | undefined;
        /** a date that reflects the execution date of a transaction from a user viewpoint. Can be used for sorting transactions. */
        executionDate: GraphQLTypes['DateTime'];
        /** a date that reflects the time at which the user asked the transaction to be executed */
        requestedExecutionAt?: GraphQLTypes['DateTime'] | undefined;
        /** ID of the origin transaction associated to this transaction */
        originTransactionId?: string | undefined;
        /** origin transaction associated to this transaction */
        originTransaction?: GraphQLTypes['Transaction'] | undefined;
        ['...on CardTransaction']: '__union' & GraphQLTypes['CardTransaction'];
        ['...on CheckTransaction']: '__union' & GraphQLTypes['CheckTransaction'];
        ['...on FeeTransaction']: '__union' & GraphQLTypes['FeeTransaction'];
        ['...on InternalCreditTransfer']: '__union' & GraphQLTypes['InternalCreditTransfer'];
        ['...on InternalDirectDebitTransaction']: '__union' & GraphQLTypes['InternalDirectDebitTransaction'];
        ['...on InternationalCreditTransferTransaction']: '__union' & GraphQLTypes['InternationalCreditTransferTransaction'];
        ['...on SEPACreditTransferTransaction']: '__union' & GraphQLTypes['SEPACreditTransferTransaction'];
        ['...on SEPADirectDebitTransaction']: '__union' & GraphQLTypes['SEPADirectDebitTransaction'];
    };
    /** Please see the Connection interface */
    ['TransactionConnection']: {
        __typename: 'TransactionConnection';
        pageInfo: GraphQLTypes['PageInfo'];
        totalCount: number;
        edges: Array<GraphQLTypes['TransactionEdge']>;
    };
    /** Please see the Edge interface */
    ['TransactionEdge']: {
        __typename: 'TransactionEdge';
        node: GraphQLTypes['Transaction'];
        cursor: string;
    };
    /** Rejection returned if the transaction was not found */
    ['TransactionNotFoundRejection']: {
        __typename: 'TransactionNotFoundRejection';
        transactionId: string;
        message: string;
    };
    /** The following reason codes for a r-transaction are defined: */
    ['TransactionReasonCode']: TransactionReasonCode;
    /** the criteria to filter transactions */
    ['TransactionsFiltersInput']: {
        /** To filter on some Transaction Status (all if empty) */
        status?: Array<GraphQLTypes['TransactionStatus']> | undefined;
        /** To filter on some Payment Products (all if empty) */
        paymentProduct?: Array<GraphQLTypes['PaymentProduct']> | undefined;
        /** To filter after an updatedAt value */
        isAfterUpdatedAt?: GraphQLTypes['DateTime'] | undefined;
        /** To filter before an updatedAt value */
        isBeforeUpdatedAt?: GraphQLTypes['DateTime'] | undefined;
        /** To filter on some text occurrences (words or ids) */
        search?: string | undefined;
        /** To filter on some transaction types */
        type?: Array<GraphQLTypes['TransactionTypeEnum']> | undefined;
        /** To filter so it includes rejected transactions that had a fallback (`true` by default) */
        includeRejectedWithFallback?: boolean | undefined;
    };
    /** Transaction side */
    ['TransactionSide']: TransactionSide;
    ['TransactionsOrderByField']: TransactionsOrderByField;
    /** the criteria to sort transactions */
    ['TransactionsOrderByInput']: {
        field?: GraphQLTypes['TransactionsOrderByField'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** Transaction status */
    ['TransactionStatus']: TransactionStatus;
    /** Transaction Status information */
    ['TransactionStatusInfo']: {
        __typename: 'BookedTransactionStatusInfo' | 'CanceledTransactionStatusInfo' | 'PendingTransactionStatusInfo' | 'RejectedTransactionStatusInfo' | 'ReleasedTransactionStatusInfo' | 'UpcomingTransactionStatusInfo';
        /** status of the transaction */
        status: GraphQLTypes['TransactionStatus'];
        ['...on BookedTransactionStatusInfo']: '__union' & GraphQLTypes['BookedTransactionStatusInfo'];
        ['...on CanceledTransactionStatusInfo']: '__union' & GraphQLTypes['CanceledTransactionStatusInfo'];
        ['...on PendingTransactionStatusInfo']: '__union' & GraphQLTypes['PendingTransactionStatusInfo'];
        ['...on RejectedTransactionStatusInfo']: '__union' & GraphQLTypes['RejectedTransactionStatusInfo'];
        ['...on ReleasedTransactionStatusInfo']: '__union' & GraphQLTypes['ReleasedTransactionStatusInfo'];
        ['...on UpcomingTransactionStatusInfo']: '__union' & GraphQLTypes['UpcomingTransactionStatusInfo'];
    };
    /** Transaction Type */
    ['TransactionTypeEnum']: TransactionTypeEnum;
    /** TrustedBeneficiary */
    ['TrustedBeneficiary']: {
        __typename: 'TrustedInternalBeneficiary' | 'TrustedInternationalBeneficiary' | 'TrustedSepaBeneficiary';
        /** unique identifier of a trusted beneficiary */
        id: string;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** full name of the beneficiary */
        name: string;
        /** label of the beneficiary */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type: GraphQLTypes['BeneficiaryType'];
        ['...on TrustedInternalBeneficiary']: '__union' & GraphQLTypes['TrustedInternalBeneficiary'];
        ['...on TrustedInternationalBeneficiary']: '__union' & GraphQLTypes['TrustedInternationalBeneficiary'];
        ['...on TrustedSepaBeneficiary']: '__union' & GraphQLTypes['TrustedSepaBeneficiary'];
    };
    /** Please see the Connection interface */
    ['TrustedBeneficiaryConnection']: {
        __typename: 'TrustedBeneficiaryConnection';
        pageInfo: GraphQLTypes['PageInfo'];
        edges: Array<GraphQLTypes['TrustedBeneficiaryEdge']>;
        totalCount: number;
    };
    /** TrustedBeneficiary status consent pending */
    ['TrustedBeneficiaryConsentPending']: {
        __typename: 'TrustedBeneficiaryConsentPending';
        /** status of the beneficiary  (set to `ConsentPending`) */
        status: GraphQLTypes['TrustedBeneficiaryStatus'];
        /** The consent required to initiate this beneficiary */
        consent: GraphQLTypes['Consent'];
    };
    /** Please see the Edge interface */
    ['TrustedBeneficiaryEdge']: {
        __typename: 'TrustedBeneficiaryEdge';
        node: GraphQLTypes['TrustedBeneficiary'];
        cursor: string;
    };
    /** Filters that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryFiltersInput']: {
        status?: Array<GraphQLTypes['TrustedBeneficiaryStatus']> | undefined;
        type?: Array<GraphQLTypes['BeneficiaryType']> | undefined;
    };
    /** Field we can use when ordering that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryOrderByFieldInput']: TrustedBeneficiaryOrderByFieldInput;
    /** Order that can be applied when listing trusted beneficiaries */
    ['TrustedBeneficiaryOrderByInput']: {
        field?: GraphQLTypes['TrustedBeneficiaryOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** TrustedBeneficiary status */
    ['TrustedBeneficiaryStatus']: TrustedBeneficiaryStatus;
    /** TrustedBeneficiary status information */
    ['TrustedBeneficiaryStatusInfo']: {
        __typename: 'TrustedBeneficiaryConsentPending' | 'TrustedBeneficiaryStatusInfoCanceled' | 'TrustedBeneficiaryStatusInfoEnabled';
        /** status of the beneficiary */
        status: GraphQLTypes['TrustedBeneficiaryStatus'];
        ['...on TrustedBeneficiaryConsentPending']: '__union' & GraphQLTypes['TrustedBeneficiaryConsentPending'];
        ['...on TrustedBeneficiaryStatusInfoCanceled']: '__union' & GraphQLTypes['TrustedBeneficiaryStatusInfoCanceled'];
        ['...on TrustedBeneficiaryStatusInfoEnabled']: '__union' & GraphQLTypes['TrustedBeneficiaryStatusInfoEnabled'];
    };
    /** TrustedBeneficiary status canceled */
    ['TrustedBeneficiaryStatusInfoCanceled']: {
        __typename: 'TrustedBeneficiaryStatusInfoCanceled';
        /** status of the beneficiary (set to `Canceled`) */
        status: GraphQLTypes['TrustedBeneficiaryStatus'];
        /** canceled Date */
        canceledAt: GraphQLTypes['DateTime'];
    };
    /** TrustedBeneficiary status enabled */
    ['TrustedBeneficiaryStatusInfoEnabled']: {
        __typename: 'TrustedBeneficiaryStatusInfoEnabled';
        /** status of the beneficiary (set to `Enabled`) */
        status: GraphQLTypes['TrustedBeneficiaryStatus'];
        /** enabled Date */
        enabledAt: GraphQLTypes['DateTime'];
    };
    /** Trusted Internal Beneficiary */
    ['TrustedInternalBeneficiary']: {
        __typename: 'TrustedInternalBeneficiary';
        /** unique identifier of a trusted beneficiary */
        id: string;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** full name of the beneficiary */
        name: string;
        /** label of the beneficiary */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type: GraphQLTypes['BeneficiaryType'];
        /** beneficiary account Id */
        accountId: string;
    };
    /** Trusted International Beneficiary */
    ['TrustedInternationalBeneficiary']: {
        __typename: 'TrustedInternationalBeneficiary';
        /** unique identifier of a trusted beneficiary */
        id: string;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** full name of the beneficiary */
        name: string;
        /** label of the beneficiary */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type: GraphQLTypes['BeneficiaryType'];
        /** Currency of the international beneficiary account */
        currency: GraphQLTypes['Currency'];
        /** Currency-specific details of the beneficiary */
        details: Array<GraphQLTypes['KeyValue']>;
        /** Route that Swan will use to transfer the funds */
        route: GraphQLTypes['InternationalCreditTransferRouteInput'];
    };
    /** Trusted SEPA Beneficiary type SEPA */
    ['TrustedSepaBeneficiary']: {
        __typename: 'TrustedSepaBeneficiary';
        /** unique identifier of a trusted beneficiary */
        id: string;
        /** created date */
        createdAt: GraphQLTypes['DateTime'];
        /** updated date */
        updatedAt: GraphQLTypes['DateTime'];
        /** full name of the beneficiary */
        name: string;
        /** label of the beneficiary */
        label: string;
        /** status information */
        statusInfo: GraphQLTypes['TrustedBeneficiaryStatusInfo'];
        /** type of the beneficiary */
        type: GraphQLTypes['BeneficiaryType'];
        /** IBAN if the beneficiary is a an account in an other financial institution */
        iban: GraphQLTypes['IBAN'];
        /** beneficiary address */
        address?: GraphQLTypes['Address'] | undefined;
    };
    /** Quality of the account holder doing the onboarding */
    ['TypeOfRepresentation']: TypeOfRepresentation;
    /** Ultimate beneficial Direct Owner company info. */
    ['UltimateBeneficialDirectOwnerCompanyInfo']: {
        __typename: 'UltimateBeneficialDirectOwnerCompanyInfo';
        /** Ultimate Beneficial Owner Unique Identifier . */
        id: string;
        /** Ultimate beneficial Direct Owner Company type. */
        type: GraphQLTypes['UltimateBeneficialOwnerType'];
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio: number;
        /** Name of the company. */
        name: string;
        /** Registration number. */
        registrationNumber: string;
    };
    /** Ultimate beneficial Direct Owner individual info. */
    ['UltimateBeneficialDirectOwnerIndividualInfo']: {
        __typename: 'UltimateBeneficialDirectOwnerIndividualInfo';
        /** Ultimate Beneficial Owner Unique Identifier . */
        id: string;
        /** Ultimate beneficial Direct owner Individual type . */
        type: GraphQLTypes['UltimateBeneficialOwnerType'];
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio: number;
        /** First name. */
        firstName: string;
        /** Last name. */
        lastName: string;
        /** Birth date. */
        birthDate: GraphQLTypes['Date'];
    };
    /** Ultimate beneficial owner company info. */
    ['UltimateBeneficialIndirectOwnerCompanyInfo']: {
        __typename: 'UltimateBeneficialIndirectOwnerCompanyInfo';
        /** Ultimate Beneficial Owner Unique Identifier . */
        id: string;
        /** Ultimate beneficial Indirect Owner Company type. */
        type: GraphQLTypes['UltimateBeneficialOwnerType'];
        /** Unique Reference of the Parent Company. */
        parentCompanyReference: string;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio: number;
        /** Name of the company. */
        name: string;
        /** Registration number. */
        registrationNumber: string;
    };
    /** Ultimate beneficial Indirect Owner individual info. */
    ['UltimateBeneficialIndirectOwnerIndividualInfo']: {
        __typename: 'UltimateBeneficialIndirectOwnerIndividualInfo';
        /** Ultimate Beneficial Owner Unique Identifier. */
        id: string;
        /** Ultimate beneficial Indirect Owner Individual type . */
        type: GraphQLTypes['UltimateBeneficialOwnerType'];
        /** Unique Reference of the Parent Company. */
        parentCompanyReference: string;
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio: number;
        /** First name. */
        firstName: string;
        /** Last name. */
        lastName: string;
        /** Birth date. */
        birthDate: GraphQLTypes['Date'];
    };
    /** The Ultimate Beneficial Owner could be for an Individual or a Company and these can Direct or Indirect */
    ['UltimateBeneficialOwnerInfo']: {
        __typename: 'UltimateBeneficialDirectOwnerCompanyInfo' | 'UltimateBeneficialDirectOwnerIndividualInfo' | 'UltimateBeneficialIndirectOwnerCompanyInfo' | 'UltimateBeneficialIndirectOwnerIndividualInfo';
        /** Ultimate Beneficial Owner Unique Identifier . */
        id: string;
        /** Ultimate beneficial owner type. */
        type: GraphQLTypes['UltimateBeneficialOwnerType'];
        /** Shares ratio of the parent company. Example: 50 if the share ratio is 50%. */
        parentCompanyShareRatio: number;
        ['...on UltimateBeneficialDirectOwnerCompanyInfo']: '__union' & GraphQLTypes['UltimateBeneficialDirectOwnerCompanyInfo'];
        ['...on UltimateBeneficialDirectOwnerIndividualInfo']: '__union' & GraphQLTypes['UltimateBeneficialDirectOwnerIndividualInfo'];
        ['...on UltimateBeneficialIndirectOwnerCompanyInfo']: '__union' & GraphQLTypes['UltimateBeneficialIndirectOwnerCompanyInfo'];
        ['...on UltimateBeneficialIndirectOwnerIndividualInfo']: '__union' & GraphQLTypes['UltimateBeneficialIndirectOwnerIndividualInfo'];
    };
    /** Ultimate Beneficial Owner type. */
    ['UltimateBeneficialOwnerType']: UltimateBeneficialOwnerType;
    /** Upcoming transaction status information */
    ['UpcomingTransactionStatusInfo']: {
        __typename: 'UpcomingTransactionStatusInfo';
        /** status of the transaction */
        status: GraphQLTypes['TransactionStatus'];
        /** The date when the transaction will be executed */
        executionDate: GraphQLTypes['DateTime'];
    };
    ['UpdateAccountHolderInput']: {
        accountHolderId: string;
        vatNumber?: string | undefined;
        taxIdentificationNumber?: string | undefined;
    };
    ['UpdateAccountHolderPayload']: {
        __typename: 'UpdateAccountHolderSuccessPayload' | 'AccountHolderNotFoundRejection' | 'ValidationRejection';
        ['...on UpdateAccountHolderSuccessPayload']: '__union' & GraphQLTypes['UpdateAccountHolderSuccessPayload'];
        ['...on AccountHolderNotFoundRejection']: '__union' & GraphQLTypes['AccountHolderNotFoundRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['UpdateAccountHolderSuccessPayload']: {
        __typename: 'UpdateAccountHolderSuccessPayload';
        accountHolder: GraphQLTypes['AccountHolder'];
    };
    /** Inputs to update an account */
    ['UpdateAccountInput']: {
        /** Unique identifier of an account */
        accountId: string;
        /** Name */
        name?: string | undefined;
        /** Language */
        language?: GraphQLTypes['AccountLanguage'] | undefined;
    };
    /** Inputs to update an account membership */
    ['UpdateAccountMembershipInput']: {
        /** Unique identifier of an account membership */
        accountMembershipId: string;
        /** Email address */
        email?: string | undefined;
        /** Restricted to a user if necessary */
        restrictedTo?: GraphQLTypes['UpdatedRestrictedToInput'] | undefined;
        /** `true` if this account membership can view account balances and transactions history */
        canViewAccount?: boolean | undefined;
        /** `true` if this account membership can add or canceled beneficiaries */
        canManageBeneficiaries?: boolean | undefined;
        /** `true` if this account membership can initiate payments */
        canInitiatePayments?: boolean | undefined;
        /** `true` if this account membership can invite, update, suspend or resume memberships */
        canManageAccountMembership?: boolean | undefined;
        /** `true` if this account membership can manage cards for himself or to the memberships he manages */
        canManageCards?: boolean | undefined;
        /** Periodic Spending limit */
        spendingLimit?: GraphQLTypes['SpendingLimitInput'] | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Residency address of the member to be added */
        residencyAddress?: GraphQLTypes['ResidencyAddressInput'] | undefined;
        /** Tax Identification Number of the user added */
        taxIdentificationNumber?: string | undefined;
    };
    ['UpdateAccountMembershipPayload']: {
        __typename: 'UpdateAccountMembershipSuccessPayload' | 'AccountMembershipCannotBeUpdatedRejection' | 'AccountMembershipNotFoundRejection' | 'ForbiddenRejection' | 'InvalidPhoneNumberRejection' | 'PermissionCannotBeGrantedRejection' | 'UserNotAllowedToManageAccountMembershipRejection' | 'ValidationRejection';
        ['...on UpdateAccountMembershipSuccessPayload']: '__union' & GraphQLTypes['UpdateAccountMembershipSuccessPayload'];
        ['...on AccountMembershipCannotBeUpdatedRejection']: '__union' & GraphQLTypes['AccountMembershipCannotBeUpdatedRejection'];
        ['...on AccountMembershipNotFoundRejection']: '__union' & GraphQLTypes['AccountMembershipNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InvalidPhoneNumberRejection']: '__union' & GraphQLTypes['InvalidPhoneNumberRejection'];
        ['...on PermissionCannotBeGrantedRejection']: '__union' & GraphQLTypes['PermissionCannotBeGrantedRejection'];
        ['...on UserNotAllowedToManageAccountMembershipRejection']: '__union' & GraphQLTypes['UserNotAllowedToManageAccountMembershipRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['UpdateAccountMembershipSuccessPayload']: {
        __typename: 'UpdateAccountMembershipSuccessPayload';
        consent: GraphQLTypes['Consent'];
    };
    ['UpdateAccountPayload']: {
        __typename: 'UpdateAccountSuccessPayload' | 'AccountNotFoundRejection' | 'BadAccountStatusRejection' | 'ForbiddenRejection' | 'InternalErrorRejection' | 'ValidationRejection';
        ['...on UpdateAccountSuccessPayload']: '__union' & GraphQLTypes['UpdateAccountSuccessPayload'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on BadAccountStatusRejection']: '__union' & GraphQLTypes['BadAccountStatusRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['UpdateAccountSuccessPayload']: {
        __typename: 'UpdateAccountSuccessPayload';
        account: GraphQLTypes['Account'];
    };
    /** Input to Update Card */
    ['UpdateCardInput']: {
        /** Unique identifier of the card to update */
        cardId: string;
        /** Card expiration date  if `null` it does not have an expiration date */
        cardContractExpiryDate?: GraphQLTypes['DateTime'] | undefined;
        /** `true` if this card allows cash withdrawals */
        withdrawal: boolean;
        /** `true` if this card allows payments outside of the country */
        international: boolean;
        /** `true` if this card allows transactions outside of the card's main currency */
        nonMainCurrencyTransactions: boolean;
        /** `true` if this card allows transactions at eCommerce sites */
        eCommerce: boolean;
        /** Periodic Spending limit */
        spendingLimit?: GraphQLTypes['SpendingLimitInput'] | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
        /** Card name */
        name?: string | undefined;
    };
    ['UpdateCardPayload']: {
        __typename: 'UpdateCardSuccessPayload' | 'AccountNotFoundRejection' | 'CardNotFoundRejection' | 'AccountMembershipNotAllowedRejection' | 'ValidationRejection';
        ['...on UpdateCardSuccessPayload']: '__union' & GraphQLTypes['UpdateCardSuccessPayload'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on AccountMembershipNotAllowedRejection']: '__union' & GraphQLTypes['AccountMembershipNotAllowedRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['UpdateCardSuccessPayload']: {
        __typename: 'UpdateCardSuccessPayload';
        consent: GraphQLTypes['Consent'];
    };
    ['UpdateCompanyOnboardingInput']: {
        /** Account name of the company account holder. Length must be from 0 to 100 characters */
        accountName?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: GraphQLTypes['AccountCountry'] | undefined;
        /** Name of the company. Length must be from 0 to 255 characters */
        name?: string | undefined;
        /** Registration number of the company (SIRET, ...). Length must be from 0 to 50 characters */
        registrationNumber?: string | undefined;
        /** Type of the company (Association ...) */
        companyType?: GraphQLTypes['CompanyType'] | undefined;
        /** Business activity */
        businessActivity?: GraphQLTypes['BusinessActivity'] | undefined;
        /** Business activity description. Length must be from 0 to 1024 characters */
        businessActivityDescription?: string | undefined;
        /** Estimated monthly payment volume (euro) */
        monthlyPaymentVolume?: GraphQLTypes['MonthlyPaymentVolume'] | undefined;
        /** The ultimate beneficial owner is defined as the natural person (s) who own or control, directly and/or indirectly, the reporting company.
    
    The ultimate beneficial owner is :
    - either the natural person (s) who hold, directly or indirectly, more than 25% of the capital or the rights of vote of the reporting company;
    - either the natural person (s) who exercise, by other means, a power of control of the company; */
        individualUltimateBeneficialOwners?: Array<GraphQLTypes['IndividualUltimateBeneficialOwnerInput']> | undefined;
        /** Residency address of the head office (Must be in a European country) */
        residencyAddress?: GraphQLTypes['ResidencyAddressInput'] | undefined;
        /** Email of the legal representative. Length must be from 0 to 255 characters */
        email?: string | undefined;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined;
        /** Is company registered at RCS in its country */
        isRegistered?: boolean | undefined;
        /** Id of onboarding to be updated. Must be a valid UUID v4. Required */
        onboardingId: string;
        /** VAT number */
        vatNumber?: string | undefined;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
        /** Legal representative personal address */
        legalRepresentativePersonalAddress?: GraphQLTypes['AddressInformationInput'] | undefined;
        /** Type of representation (legal representative or power of attorney) */
        typeOfRepresentation?: GraphQLTypes['TypeOfRepresentation'] | undefined;
    };
    /** Possible results for mutation `updateCompanyOnboarding` */
    ['UpdateCompanyOnboardingPayload']: {
        __typename: 'ForbiddenRejection' | 'InternalErrorRejection' | 'UpdateCompanyOnboardingSuccessPayload' | 'ValidationRejection';
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on UpdateCompanyOnboardingSuccessPayload']: '__union' & GraphQLTypes['UpdateCompanyOnboardingSuccessPayload'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Result when updateCompanyOnboarding is a success */
    ['UpdateCompanyOnboardingSuccessPayload']: {
        __typename: 'UpdateCompanyOnboardingSuccessPayload';
        onboarding: GraphQLTypes['OnboardingInfo'];
    };
    /** Input when the account membership is restricted to a verified user */
    ['UpdatedRestrictedToInput']: {
        /** Account member first name */
        firstName?: string | undefined;
        /** Account member last name */
        lastName?: string | undefined;
        /** Account member birth date */
        birthDate?: GraphQLTypes['Date'] | undefined;
        /** Account member phone number */
        phoneNumber?: string | undefined;
    };
    ['UpdateIndividualOnboardingInput']: {
        /** Account name of the individual account holder. Length must be from 0 to 255 characters */
        accountName?: string | undefined;
        /** Country of the account that will be created at the end of the onboarding process */
        accountCountry?: GraphQLTypes['AccountCountry'] | undefined;
        /** Employment status of the individual account holder */
        employmentStatus?: GraphQLTypes['EmploymentStatus'] | undefined;
        /** Monthly income of the individual account holder */
        monthlyIncome?: GraphQLTypes['MonthlyIncome'] | undefined;
        /** Residency address of the individual account holder (must be in a European country) */
        residencyAddress?: GraphQLTypes['ResidencyAddressInput'] | undefined;
        /** Email. Length must be from 0 to 255 characters */
        email?: string | undefined;
        /** Language of the onboarding process. Must be compliant with RFC 5646 */
        language?: string | undefined;
        /** Id of onboarding to be updated. Must be a valid UUID v4. Required */
        onboardingId: string;
        /** Tax Identification Number */
        taxIdentificationNumber?: string | undefined;
    };
    /** Possible result types for `updateIndividualOnboarding` */
    ['UpdateIndividualOnboardingPayload']: {
        __typename: 'ForbiddenRejection' | 'InternalErrorRejection' | 'UpdateIndividualOnboardingSuccessPayload' | 'ValidationRejection';
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on UpdateIndividualOnboardingSuccessPayload']: '__union' & GraphQLTypes['UpdateIndividualOnboardingSuccessPayload'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    /** Type of result when updateIndividualOnboarding is a success */
    ['UpdateIndividualOnboardingSuccessPayload']: {
        __typename: 'UpdateIndividualOnboardingSuccessPayload';
        onboarding: GraphQLTypes['OnboardingInfo'];
    };
    /** Inputs to update a received sepa direct debit mandate B2b. */
    ['UpdateReceivedSepaDirectDebitB2bMandateInput']: {
        /** The unique mandate id */
        receivedDirectDebitMandateId: string;
        /** The unique identifier of the received direct debit mandate */
        mandateReference?: string | undefined;
        /** The Sepa Creditor Identifier of the creditor */
        creditorIdentifier?: string | undefined;
        /** The name of the creditor */
        creditorName?: string | undefined;
        /** The Swan Iban of the debtor */
        iban?: string | undefined;
        /** Label that will be displayed along with this received direct debit mandate in the web banking */
        name?: string | undefined;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    /** Union type returned by the updateReceivedSepaDirectDebitB2bMandate mutation */
    ['UpdateReceivedSepaDirectDebitB2bMandatePayload']: {
        __typename: 'UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload' | 'ReceivedDirectDebitMandateNotFoundRejection' | 'ForbiddenRejection' | 'ReceivedDirectDebitMandateAlreadyExistRejection' | 'ReceivedDirectDebitMandateNotB2bRejection' | 'AccountNotFoundRejection';
        ['...on UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload']: '__union' & GraphQLTypes['UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload'];
        ['...on ReceivedDirectDebitMandateNotFoundRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateNotFoundRejection'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on ReceivedDirectDebitMandateAlreadyExistRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateAlreadyExistRejection'];
        ['...on ReceivedDirectDebitMandateNotB2bRejection']: '__union' & GraphQLTypes['ReceivedDirectDebitMandateNotB2bRejection'];
        ['...on AccountNotFoundRejection']: '__union' & GraphQLTypes['AccountNotFoundRejection'];
    };
    /** Return type in case of a successful response of the updateReceivedSepaDirectDebitB2bMandate mutation */
    ['UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload']: {
        __typename: 'UpdateReceivedSepaDirectDebitB2bMandateSuccessPayload';
        /** The received direct debit mandate updated */
        receivedDirectDebitMandate: GraphQLTypes['ReceivedDirectDebitMandate'];
    };
    ['UpdateSupportingDocumentInput']: {
        supportingDocumentId: string;
        supportingDocumentType?: GraphQLTypes['SupportingDocumentType'] | undefined;
        supportingDocumentPurpose?: GraphQLTypes['SupportingDocumentPurposeEnum'] | undefined;
    };
    ['UpdateSupportingDocumentPayload']: {
        __typename: 'UpdateSupportingDocumentSuccessPayload' | 'ForbiddenRejection' | 'InternalErrorRejection' | 'SupportingDocumentCollectionNotFoundRejection' | 'SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection' | 'SupportingDocumentNotFoundRejection' | 'SupportingDocumentStatusDoesNotAllowUpdateRejection' | 'ValidationRejection';
        ['...on UpdateSupportingDocumentSuccessPayload']: '__union' & GraphQLTypes['UpdateSupportingDocumentSuccessPayload'];
        ['...on ForbiddenRejection']: '__union' & GraphQLTypes['ForbiddenRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on SupportingDocumentCollectionNotFoundRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionNotFoundRejection'];
        ['...on SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection']: '__union' & GraphQLTypes['SupportingDocumentCollectionStatusDoesNotAllowUpdateRejection'];
        ['...on SupportingDocumentNotFoundRejection']: '__union' & GraphQLTypes['SupportingDocumentNotFoundRejection'];
        ['...on SupportingDocumentStatusDoesNotAllowUpdateRejection']: '__union' & GraphQLTypes['SupportingDocumentStatusDoesNotAllowUpdateRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['UpdateSupportingDocumentSuccessPayload']: {
        __typename: 'UpdateSupportingDocumentSuccessPayload';
        supportingDocument: GraphQLTypes['SupportingDocument'];
    };
    ['UpdateUserConsentSettingsInput']: {
        /** Swan user id */
        userId: string;
        /** Preferred consent notification channel, Sms or App */
        preferredNotificationChannel: GraphQLTypes['PreferredNotificationChannel'];
    };
    ['UpdateUserConsentSettingsPayload']: {
        __typename: 'UpdateUserConsentSettingsSuccessPayload' | 'UpdateUserConsentSettingsTokenRejection';
        ['...on UpdateUserConsentSettingsSuccessPayload']: '__union' & GraphQLTypes['UpdateUserConsentSettingsSuccessPayload'];
        ['...on UpdateUserConsentSettingsTokenRejection']: '__union' & GraphQLTypes['UpdateUserConsentSettingsTokenRejection'];
    };
    ['UpdateUserConsentSettingsSuccessPayload']: {
        __typename: 'UpdateUserConsentSettingsSuccessPayload';
        userConsentSettings: GraphQLTypes['UserConsentSettings'];
    };
    ['UpdateUserConsentSettingsTokenRejection']: {
        __typename: 'UpdateUserConsentSettingsTokenRejection';
        message: string;
    };
    ['Upload']: 'scalar' & {
        name: 'Upload';
    };
    /** URL that follows the WHATWG URL Standard.
  
  [Examples of parsed URLs](https://url.spec.whatwg.org/#example-url-parsing) may be found in the Standard itself. */
    ['URL']: 'scalar' & {
        name: 'URL';
    };
    /** The User is the unique user, natural person, of the Swan app. */
    ['User']: {
        __typename: 'User';
        /** unique identifier of the user */
        id: string;
        /** The list of account memberships
    
    Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
        accountMemberships: GraphQLTypes['AccountMembershipConnection'];
        /** mobile phone number with the international format (Example: +33689788967) */
        mobilePhoneNumber?: GraphQLTypes['PhoneNumber'] | undefined;
        /** first name */
        firstName?: string | undefined;
        /** last name */
        lastName?: string | undefined;
        /** list of first names */
        allFirstNames?: Array<string> | undefined;
        /** birth date */
        birthDate?: GraphQLTypes['Date'] | undefined;
        /** nationality */
        nationalityCCA3?: GraphQLTypes['CCA3'] | undefined;
        /** `true` if Swan has verified the user's identity */
        idVerified: boolean;
        /** the methods used to authenticate this user */
        authenticators?: Array<GraphQLTypes['Authenticator']> | undefined;
        /** Identification status
    
    Each attempt to go through our identity verification process will update this value.
    
    This field is only available for the current user. */
        identificationStatus?: GraphQLTypes['IdentificationStatus'] | undefined;
        /** List of identification levels available for the user.
    
    Whenever TRUE, it means the identification was successful for the associated level. */
        identificationLevels?: GraphQLTypes['IdentificationLevels'] | undefined;
        /** Preferred notification channel
    
    When it is "null" it means that the preferences have not been updated. Default SMS in use */
        preferredNotificationChannel?: GraphQLTypes['PreferredNotificationChannel'] | undefined;
        /** Creation date of the user */
        createdAt: GraphQLTypes['DateTime'];
        /** Last update date of the user */
        updatedAt: GraphQLTypes['DateTime'];
        /** Date on which the user joined the project. Joining the project is done after the first accepted OAuth login. */
        joinedAt: GraphQLTypes['DateTime'];
        identifications?: GraphQLTypes['IdentificationConnection'] | undefined;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['UserConnection']: {
        __typename: 'UserConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** UserEdge list */
        edges: Array<GraphQLTypes['UserEdge']>;
    };
    ['UserConsentSettings']: {
        __typename: 'UserConsentSettings';
        /** Preferred notification channel */
        preferredNotificationChannel: GraphQLTypes['PreferredNotificationChannel'];
        /** User identifier */
        userId: string;
        /** Project identifier */
        projectId: string;
    };
    /** Implements the Relay Edge interface */
    ['UserEdge']: {
        __typename: 'UserEdge';
        /** Opaque identifier pointing to this consent node in the pagination mechanism */
        cursor: string;
        /** The consent */
        node: GraphQLTypes['User'];
    };
    ['UserFilterInput']: {
        birthDate?: GraphQLTypes['Date'] | undefined;
        firstName?: string | undefined;
        identificationLevel?: GraphQLTypes['IdentificationLevelInput'] | undefined;
        lastName?: string | undefined;
        mobilePhoneNumber?: string | undefined;
        nationalityCCA3?: GraphQLTypes['CCA3'] | undefined;
        preferredNotificationChannel?: GraphQLTypes['PreferredNotificationChannel'] | undefined;
        /** Searches first name, last name, phone number and id
    Min length : 3 characters */
        search?: string | undefined;
    };
    ['UserNotAllowedToDisableItsOwnAccountMembershipRejection']: {
        __typename: 'UserNotAllowedToDisableItsOwnAccountMembershipRejection';
        accountMembershipId: string;
        message: string;
    };
    /** Rejection returned if a identity does not have enough permission to manage account membership */
    ['UserNotAllowedToManageAccountMembershipRejection']: {
        __typename: 'UserNotAllowedToManageAccountMembershipRejection';
        message: string;
    };
    ['UserNotAllowedToSuspendItsOwnAccountMembershipRejection']: {
        __typename: 'UserNotAllowedToSuspendItsOwnAccountMembershipRejection';
        accountMembershipId: string;
        message: string;
    };
    /** Rejection returned when the User is not the Card Holder */
    ['UserNotCardHolderRejection']: {
        __typename: 'UserNotCardHolderRejection';
        message: string;
    };
    /** Field we can use when ordering that can be applied when listing users */
    ['UserOrderByFieldInput']: UserOrderByFieldInput;
    /** Order that can be applied when listing users */
    ['UserOrderByInput']: {
        field?: GraphQLTypes['UserOrderByFieldInput'] | undefined;
        direction?: GraphQLTypes['OrderByDirection'] | undefined;
    };
    /** A detail of a validation error : what field is errored and why */
    ['ValidationError']: {
        __typename: 'ValidationError';
        /** Onboarding property that is not matching requirements to allow a finalization */
        field: string;
        /** Constraints that are not matched on the Onboarding property */
        errors?: Array<GraphQLTypes['FieldValidationError']> | undefined;
    };
    ['ValidationFieldError']: {
        __typename: 'ValidationFieldError';
        code: GraphQLTypes['ValidationFieldErrorCode'];
        message: string;
        path: Array<string>;
    };
    ['ValidationFieldErrorCode']: ValidationFieldErrorCode;
    /** Rejection returned if an input contains invalid data */
    ['ValidationRejection']: {
        __typename: 'ValidationRejection';
        fields: Array<GraphQLTypes['ValidationFieldError']>;
        message: string;
    };
    /** Information extracted from a valid IBAN */
    ['ValidIban']: {
        __typename: 'ValidIban';
        /** Iban from input */
        iban: GraphQLTypes['IBAN'];
        /** Account Number extracted from the IBAN */
        accountNumber: string;
        /** Checksum extracted from the IBAN */
        checksum: string;
        /** Bank that owns this IBAN */
        bank: GraphQLTypes['Bank'];
        /** Reachability of this IBAN over different payment methods */
        reachability: GraphQLTypes['Reachability'];
    };
    /** Describes a valid identification level for the process associated to this identification, and identification documents can be accessed */
    ['ValidIdentificationLevelStatusInfo']: {
        __typename: 'ValidIdentificationLevelStatusInfo';
        /** Always set to `Valid` */
        status: GraphQLTypes['SwanIdentificationStatus'];
    };
    /** Verification Flow. */
    ['VerificationFlow']: VerificationFlow;
    /** Verification status of an account holder */
    ['VerificationStatus']: VerificationStatus;
    /** Enabled Information */
    ['VerifiedStatusInfo']: {
        __typename: 'VerifiedStatusInfo';
        /** Date at which the verification was verified */
        verifiedAt: GraphQLTypes['DateTime'];
        /** Account verification status (Verified) */
        status: GraphQLTypes['AccountVerificationStatus'];
    };
    ['ViewCardNumbersInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ViewCardNumbersPayload']: {
        __typename: 'ViewCardNumbersSuccessPayload' | 'UserNotCardHolderRejection' | 'CardNotFoundRejection' | 'ValidationRejection';
        ['...on ViewCardNumbersSuccessPayload']: '__union' & GraphQLTypes['ViewCardNumbersSuccessPayload'];
        ['...on UserNotCardHolderRejection']: '__union' & GraphQLTypes['UserNotCardHolderRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['ViewCardNumbersSuccessPayload']: {
        __typename: 'ViewCardNumbersSuccessPayload';
        /** The consent required to view card numbers */
        consent: GraphQLTypes['Consent'];
    };
    ['ViewPhysicalCardNumbersInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ViewPhysicalCardNumbersPayload']: {
        __typename: 'ViewPhysicalCardNumbersSuccessPayload' | 'UserNotCardHolderRejection' | 'CardNotFoundRejection' | 'ValidationRejection';
        ['...on ViewPhysicalCardNumbersSuccessPayload']: '__union' & GraphQLTypes['ViewPhysicalCardNumbersSuccessPayload'];
        ['...on UserNotCardHolderRejection']: '__union' & GraphQLTypes['UserNotCardHolderRejection'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['ViewPhysicalCardNumbersSuccessPayload']: {
        __typename: 'ViewPhysicalCardNumbersSuccessPayload';
        /** The consent required to view card numbers */
        consent: GraphQLTypes['Consent'];
    };
    ['ViewPhysicalCardPinInput']: {
        /** Unique identifier of a card */
        cardId: string;
        /** URL the user is redirected to after consent has been given */
        consentRedirectUrl: string;
    };
    ['ViewPhysicalCardPinPayload']: {
        __typename: 'ViewPhysicalCardPinSuccessPayload' | 'CardNotFoundRejection' | 'PhysicalCardNotFoundRejection' | 'PINNotReadyRejection' | 'UserNotCardHolderRejection' | 'ValidationRejection';
        ['...on ViewPhysicalCardPinSuccessPayload']: '__union' & GraphQLTypes['ViewPhysicalCardPinSuccessPayload'];
        ['...on CardNotFoundRejection']: '__union' & GraphQLTypes['CardNotFoundRejection'];
        ['...on PhysicalCardNotFoundRejection']: '__union' & GraphQLTypes['PhysicalCardNotFoundRejection'];
        ['...on PINNotReadyRejection']: '__union' & GraphQLTypes['PINNotReadyRejection'];
        ['...on UserNotCardHolderRejection']: '__union' & GraphQLTypes['UserNotCardHolderRejection'];
        ['...on ValidationRejection']: '__union' & GraphQLTypes['ValidationRejection'];
    };
    ['ViewPhysicalCardPinSuccessPayload']: {
        __typename: 'ViewPhysicalCardPinSuccessPayload';
        /** The consent required to view card numbers */
        consent: GraphQLTypes['Consent'];
    };
    /** Virtual IBAN can be used by the account holder to receive SCT (Sepa Credit Transfer) or to be debited by SDD (Sepa Direct Debit). */
    ['VirtualIBANEntry']: {
        __typename: 'VirtualIBANEntry';
        /** Unique identifier of a Virtual IBAN entry */
        id: string;
        /** International Bank Account Number */
        IBAN: GraphQLTypes['IBAN'];
        /** Bank Identifier Code */
        BIC: GraphQLTypes['BIC'];
        /** Label (could be used to identify) */
        label?: string | undefined;
        /** Status of the Iban */
        status: GraphQLTypes['IBANStatus'];
        /** `true` if the Virtual IBAN refuses all Sepa Direct Debit received */
        blockSDD: boolean;
    };
    /** Implements the Relay Connection interface, used to paginate list of element ([Learn More](https://docs.swan.io/api/pagination)) */
    ['VirtualIBANEntryConnection']: {
        __typename: 'VirtualIBANEntryConnection';
        /** Total number of element in the list */
        totalCount: number;
        /** Information about the current, the previous and the next page */
        pageInfo: GraphQLTypes['PageInfo'];
        /** VirtualIBANEntryEdge list */
        edges: Array<GraphQLTypes['VirtualIBANEntryEdge']>;
    };
    /** Implements the Relay Edge interface */
    ['VirtualIBANEntryEdge']: {
        __typename: 'VirtualIBANEntryEdge';
        /** Opaque identifier pointing to this node in the pagination mechanism */
        cursor: string;
        /** The virtual iban entry */
        node: GraphQLTypes['VirtualIBANEntry'];
    };
    /** Wallet Provider (ApplePay, GooglePay ...) */
    ['WalletProvider']: {
        __typename: 'WalletProvider';
        /** name of the Wallet Provider (Apple / Google / Amazon or Unknown) */
        name: string;
        /** id of the Wallet Provider */
        id: string;
    };
    /** Wallet Provider */
    ['WalletProviderType']: WalletProviderType;
    ['WalletToken']: 'scalar' & {
        name: 'WalletToken';
    };
    ['WebBankingSettings']: {
        __typename: 'WebBankingSettings';
        canViewAccountDetails?: boolean | undefined;
        canViewAccountStatement?: boolean | undefined;
        canManageVirtualIbans?: boolean | undefined;
        canInitiatePaymentsToNewBeneficiaries?: boolean | undefined;
        canViewPaymentList?: boolean | undefined;
        canOrderVirtualCards?: boolean | undefined;
        canOrderPhysicalCards?: boolean | undefined;
        canViewMembers?: boolean | undefined;
        canAddNewMembers?: boolean | undefined;
    };
    /** A WebhookEvent Log for webhooks service.
  It describes the response and call context for webhook endpoints
  for a specific event. */
    ['WebhookEventLog']: {
        __typename: 'WebhookEventLog';
        /** Unique identifier of the EventLog */
        id: string;
        /** Date the EventLog has been created */
        createdAt: GraphQLTypes['DateTime'];
        /** Unique identifier of the event that triggered this eventLog */
        eventId: string;
        /** Date the Event has been generated */
        eventDate: GraphQLTypes['DateTime'];
        /** The type of the triggering event */
        eventType: string;
        /** Unique identifier linked of the resource carried by the Event */
        resourceId: string;
        /** Duration of the callback in MS */
        duration: number;
        /** Request payload send to callback in string format, jsonable. */
        requestPayload: string;
        /** Response payload get by the callback in string format, jsonable. */
        responsePayload?: string | undefined;
        /** The callback response status in number format. */
        statusCode?: number | undefined;
        /** The callback response status in text format. */
        statusText?: GraphQLTypes['StatusText'] | undefined;
        /** The webhook that triggered the event. */
        webhookSubscription?: GraphQLTypes['WebhookSubscription'] | undefined;
        /** Rank of this retry */
        retryCount?: number | undefined;
        /** Label of the associated subscription (inherited)
    This holds the label value of when the log was created, whereas
    webhookSubscription.label holds the current value of the label
    (it may have changed). */
        webhookSubscriptionLabel?: string | undefined;
        /** Endpoint of the associated subscription (inherited)
    This holds the endpoint value of when the log was created, whereas
    webhookSubscription.endpoint holds the current value of the endpoint
    (it may have changed). */
        webhookSubscriptionEndpoint?: string | undefined;
    };
    /** Filters that can be applied when listing eventLog */
    ['WebhookEventLogFiltersInput']: {
        statusCode?: number | undefined;
        statusText?: GraphQLTypes['StatusText'] | undefined;
        startDate?: GraphQLTypes['DateTime'] | undefined;
        endDate?: GraphQLTypes['DateTime'] | undefined;
        eventType?: string | undefined;
        eventId?: string | undefined;
        resourceId?: string | undefined;
        webhookSubscriptionId?: string | undefined;
    };
    /** Rejection returned when Webhook event log id is not found */
    ['WebhookEventLogNotFoundRejection']: {
        __typename: 'WebhookEventLogNotFoundRejection';
        message: string;
    };
    /** A Subscription to the webhooks service.
  It describes the registration of a callback url (the endpoint)
  and a list of event types the client wants to be notified of. */
    ['WebhookSubscription']: {
        __typename: 'WebhookSubscription';
        /** Unique identifier of the Subscription */
        id: string;
        /** A client provided short description of the Subscription */
        label: string;
        /** The callback URL to be used for POSTing events */
        endpoint: string;
        /** The optional secret to secure incoming webhook calls. We recommend a UUID-4 to be future proof.
    (max 36 characters) */
        secret?: string | undefined;
        /** The types of subscribed events
    A simple list of unique IDs */
        eventTypes: Array<string>;
        /** Date the Subscription has been created */
        createdAt: GraphQLTypes['DateTime'];
        /**   Last date the Subscription has been updated,
    except for state changes */
        updatedAt: GraphQLTypes['DateTime'];
        /** The current state of the Subscription */
        statusInfo: GraphQLTypes['WebhookSubscriptionStatusInfo'];
        /** KPI data about the subscription (7 last days) */
        kpi?: GraphQLTypes['WebhookSubscriptionKpi'] | undefined;
    };
    ['WebhookSubscriptionBrokenStatusInfo']: {
        __typename: 'WebhookSubscriptionBrokenStatusInfo';
        status: GraphQLTypes['WebhookSubscriptionStatus'];
        brokenAt: GraphQLTypes['DateTime'];
    };
    ['WebhookSubscriptionCreationStatus']: WebhookSubscriptionCreationStatus;
    ['WebhookSubscriptionDisabledStatusInfo']: {
        __typename: 'WebhookSubscriptionDisabledStatusInfo';
        status: GraphQLTypes['WebhookSubscriptionStatus'];
        disabledAt: GraphQLTypes['DateTime'];
    };
    ['WebhookSubscriptionEnabledStatusInfo']: {
        __typename: 'WebhookSubscriptionEnabledStatusInfo';
        status: GraphQLTypes['WebhookSubscriptionStatus'];
        enabledAt: GraphQLTypes['DateTime'];
    };
    ['WebhookSubscriptionKpi']: {
        __typename: 'WebhookSubscriptionKpi';
        /** Total number of eventLogs associated to this subscription */
        totalHits: number;
        /** Total number of eventLogs that failed associated to this subscription
    errorRate = (errorRate/totalHits) * 100, rounded */
        errorRate: number;
    };
    /** Rejection returned when Webhook Subscription is not found */
    ['WebhookSubscriptionNotFoundRejection']: {
        __typename: 'WebhookSubscriptionNotFoundRejection';
        message: string;
    };
    ['WebhookSubscriptionPayload']: {
        __typename: 'WebhookSubscriptionSuccessPayload' | 'WebhookSubscriptionNotFoundRejection' | 'InternalErrorRejection' | 'InvalidArgumentRejection';
        ['...on WebhookSubscriptionSuccessPayload']: '__union' & GraphQLTypes['WebhookSubscriptionSuccessPayload'];
        ['...on WebhookSubscriptionNotFoundRejection']: '__union' & GraphQLTypes['WebhookSubscriptionNotFoundRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on InvalidArgumentRejection']: '__union' & GraphQLTypes['InvalidArgumentRejection'];
    };
    /** State of a Webhook Subscription
  It is either Enabled or Disabled by the owner,
  ot set to Broken when delivery fails repeatedly. */
    ['WebhookSubscriptionStatus']: WebhookSubscriptionStatus;
    ['WebhookSubscriptionStatusInfo']: {
        __typename: 'WebhookSubscriptionBrokenStatusInfo' | 'WebhookSubscriptionDisabledStatusInfo' | 'WebhookSubscriptionEnabledStatusInfo';
        status: GraphQLTypes['WebhookSubscriptionStatus'];
        ['...on WebhookSubscriptionBrokenStatusInfo']: '__union' & GraphQLTypes['WebhookSubscriptionBrokenStatusInfo'];
        ['...on WebhookSubscriptionDisabledStatusInfo']: '__union' & GraphQLTypes['WebhookSubscriptionDisabledStatusInfo'];
        ['...on WebhookSubscriptionEnabledStatusInfo']: '__union' & GraphQLTypes['WebhookSubscriptionEnabledStatusInfo'];
    };
    ['WebhookSubscriptionSuccessPayload']: {
        __typename: 'WebhookSubscriptionSuccessPayload';
        webhookSubscription: GraphQLTypes['WebhookSubscription'];
    };
    ['WebhookUnsubscribePayload']: {
        __typename: 'WebhookUnsubscribeSuccessPayload' | 'WebhookSubscriptionNotFoundRejection' | 'InternalErrorRejection' | 'InvalidArgumentRejection';
        ['...on WebhookUnsubscribeSuccessPayload']: '__union' & GraphQLTypes['WebhookUnsubscribeSuccessPayload'];
        ['...on WebhookSubscriptionNotFoundRejection']: '__union' & GraphQLTypes['WebhookSubscriptionNotFoundRejection'];
        ['...on InternalErrorRejection']: '__union' & GraphQLTypes['InternalErrorRejection'];
        ['...on InvalidArgumentRejection']: '__union' & GraphQLTypes['InvalidArgumentRejection'];
    };
    ['WebhookUnsubscribeSuccessPayload']: {
        __typename: 'WebhookUnsubscribeSuccessPayload';
        unsubscribed: boolean;
    };
    /** Rejection returned when a parameter has a wrong value */
    ['WrongValueProvidedRejection']: {
        __typename: 'WrongValueProvidedRejection';
        message: string;
        valueProvided: string;
        parameterName: string;
    };
};
/** Refers to the country of the account. It will determine the country code of the local IBAN of the account.

Available Account Country: CCA3 */
export declare const enum AccountCountry {
    FRA = "FRA",
    DEU = "DEU",
    ESP = "ESP",
    NLD = "NLD"
}
export declare const enum AccountFundingLimitsReachedReason {
    InstantFundingLimitExceededRejection = "InstantFundingLimitExceededRejection",
    FundingLimitExceededRejection = "FundingLimitExceededRejection",
    ProjectInstantFundingLimitExceededRejection = "ProjectInstantFundingLimitExceededRejection",
    ProjectFundingLimitExceededRejection = "ProjectFundingLimitExceededRejection",
    GlobalInstantFundingLimitExceededRejection = "GlobalInstantFundingLimitExceededRejection",
    GlobalFundingLimitExceededRejection = "GlobalFundingLimitExceededRejection",
    InsufficientFundsRejection = "InsufficientFundsRejection"
}
/** Field we can use when ordering that can be applied when listing account holders */
export declare const enum AccountHolderOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Account holder status. */
export declare const enum AccountHolderStatus {
    Enabled = "Enabled",
    Suspended = "Suspended",
    Canceled = "Canceled"
}
/** Account holder type */
export declare const enum AccountHolderType {
    Individual = "Individual",
    Company = "Company"
}
/** Language: ISO 639-1 language code */
export declare const enum AccountLanguage {
    de = "de",
    en = "en",
    fr = "fr",
    it = "it",
    nl = "nl",
    es = "es",
    pt = "pt"
}
/** Field we can use when ordering that can be applied when listing account memberships */
export declare const enum AccountMembershipOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** List of account memberships permission */
export declare const enum AccountMembershipsPermission {
    canInitiatePayments = "canInitiatePayments",
    canManageAccountMembership = "canManageAccountMembership",
    canManageCards = "canManageCards",
    canManageBeneficiaries = "canManageBeneficiaries",
    canViewAccount = "canViewAccount"
}
/** AccountMembership enabled */
export declare const enum AccountMembershipStatus {
    ConsentPending = "ConsentPending",
    InvitationSent = "InvitationSent",
    BindingUserError = "BindingUserError",
    Enabled = "Enabled",
    Suspended = "Suspended",
    Disabled = "Disabled"
}
/** Fields that can be used when ordering accounts */
export declare const enum AccountOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Field we can use when ordering that can be applied when listing receives direct debit mandate results */
export declare const enum AccountReceivedDirectDebitOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Field we can use when ordering that can be applied when listing standing order results */
export declare const enum AccountStandingOrderOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
export declare const enum AccountStatus {
    Opened = "Opened",
    Suspended = "Suspended",
    Closing = "Closing",
    Closed = "Closed"
}
/** Account Verification Status */
export declare const enum AccountVerificationStatus {
    PendingVerification = "PendingVerification",
    PendingReview = "PendingReview",
    Verified = "Verified",
    Rejected = "Rejected"
}
export declare const enum AmlRiskLevel {
    Low = "Low",
    Medium = "Medium",
    High = "High",
    TooHigh = "TooHigh"
}
export declare const enum AuthenticatorType {
    SwanWeb = "SwanWeb",
    Swan = "Swan"
}
/** Type of the card authorization transaction */
export declare const enum AuthorizationType {
    Classic = "Classic",
    PreAuthorization = "PreAuthorization",
    DataRequest = "DataRequest"
}
/** BeneficiaryAccountHolderType */
export declare const enum BeneficiaryAccountHolderType {
    Individual = "Individual",
    Company = "Company",
    Unknown = "Unknown"
}
/** BeneficiaryAccountStatus */
export declare const enum BeneficiaryAccountStatus {
    Active = "Active",
    Inactive = "Inactive",
    Unknown = "Unknown"
}
/** Beneficiary type */
export declare const enum BeneficiaryType {
    Internal = "Internal",
    International = "International",
    Sepa = "Sepa"
}
/** Business activity. */
export declare const enum BusinessActivity {
    AdministrativeServices = "AdministrativeServices",
    Agriculture = "Agriculture",
    Arts = "Arts",
    BusinessAndRetail = "BusinessAndRetail",
    Construction = "Construction",
    Education = "Education",
    ElectricalDistributionAndWaterSupply = "ElectricalDistributionAndWaterSupply",
    FinancialAndInsuranceOperations = "FinancialAndInsuranceOperations",
    Health = "Health",
    Housekeeping = "Housekeeping",
    InformationAndCommunication = "InformationAndCommunication",
    LodgingAndFoodServices = "LodgingAndFoodServices",
    ManufacturingAndMining = "ManufacturingAndMining",
    Other = "Other",
    PublicAdministration = "PublicAdministration",
    RealEstate = "RealEstate",
    ScientificActivities = "ScientificActivities",
    Transportation = "Transportation"
}
/** Funding Source Canceled Reason */
export declare const enum CanceledFundingSourceReason {
    UserCanceled = "UserCanceled",
    MandateExpired = "MandateExpired",
    MandateCanceled = "MandateCanceled"
}
/** reason why the physical card is canceled */
export declare const enum CancelPhysicalCardReason {
    NonReceived = "NonReceived",
    Lost = "Lost",
    Stolen = "Stolen",
    Defected = "Defected",
    Blocked = "Blocked"
}
/** Field we can use when ordering that can be applied when listing capital deposit cases */
export declare const enum CapitalDepositCaseOrderByFieldInput {
    id = "id",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Status of a capital deposit case. */
export declare const enum CapitalDepositCaseStatus {
    Initiated = "Initiated",
    WaitingForRequirements = "WaitingForRequirements",
    WaitingForShareDepositCertificate = "WaitingForShareDepositCertificate",
    WaitingForRegisterExtract = "WaitingForRegisterExtract",
    WaitingForNotaryTransfer = "WaitingForNotaryTransfer",
    Completed = "Completed"
}
/** Status of the Capital Deposit Case */
export declare const enum CapitalDepositDocumentStatus {
    Pending = "Pending",
    Uploaded = "Uploaded",
    Validated = "Validated",
    Refused = "Refused"
}
/** Type of the document. */
export declare const enum CapitalDepositDocumentType {
    ArticlesOfIncorporation = "ArticlesOfIncorporation",
    RegisterExtract = "RegisterExtract",
    ProofOfIdentity = "ProofOfIdentity",
    CorporateIncomeTaxReturn = "CorporateIncomeTaxReturn",
    ProofOfIndividualAddress = "ProofOfIndividualAddress",
    CompanyLeaseAgreement = "CompanyLeaseAgreement",
    CapitalShareDepositCertificate = "CapitalShareDepositCertificate",
    PowerOfAttorney = "PowerOfAttorney"
}
export declare const enum CardAuthorizationOutcome {
    Accepted = "Accepted",
    AccountClosed = "AccountClosed",
    AccountSuspended = "AccountSuspended",
    AtmWithdrawalAmountLimitExceeded = "AtmWithdrawalAmountLimitExceeded",
    AtmWithdrawalNumberLimitExceeded = "AtmWithdrawalNumberLimitExceeded",
    AuthorizationConsumed = "AuthorizationConsumed",
    AuthorizationUpdated = "AuthorizationUpdated",
    AuthorizationValidityExceeded = "AuthorizationValidityExceeded",
    CardCanceled = "CardCanceled",
    CardExpired = "CardExpired",
    CardholderCancelation = "CardholderCancelation",
    CardLost = "CardLost",
    CardNotProvidedToCardholderOrClosed = "CardNotProvidedToCardholderOrClosed",
    CardNumberInvalid = "CardNumberInvalid",
    CardOpposedCardStolen = "CardOpposedCardStolen",
    CardOutOfOrder = "CardOutOfOrder",
    CardTemporarilyLocked = "CardTemporarilyLocked",
    CardUnknown = "CardUnknown",
    DoNotHonor = "DoNotHonor",
    eMoneyAccount = "eMoneyAccount",
    eMoneyAccountLimitExceeded = "eMoneyAccountLimitExceeded",
    IncorrectPinCodeAttemptsExceeded = "IncorrectPinCodeAttemptsExceeded",
    InsufficientFunds = "InsufficientFunds",
    MerchantInvalid = "MerchantInvalid",
    MerchantShouldResubmitAuthorization = "MerchantShouldResubmitAuthorization",
    MiscellaneousReason = "MiscellaneousReason",
    OriginalTransactionNotFound = "OriginalTransactionNotFound",
    PartialApproval = "PartialApproval",
    PartialCancelation = "PartialCancelation",
    PeriodAmountLimitExceeded = "PeriodAmountLimitExceeded",
    PeriodNumberTransactionLimitExceeded = "PeriodNumberTransactionLimitExceeded",
    PinCodeInvalid = "PinCodeInvalid",
    PinCodeValidationImpossible = "PinCodeValidationImpossible",
    SpendingLimitsReached = "SpendingLimitsReached",
    TechnicalError = "TechnicalError",
    TransactionAmountLimitExceeded = "TransactionAmountLimitExceeded",
    TransactionCurrencyIncorrect = "TransactionCurrencyIncorrect",
    TransactionInvalid = "TransactionInvalid",
    TransactionNotAuthorizedForCardholder = "TransactionNotAuthorizedForCardholder",
    TransactionNotAuthorizedForPointOfSale = "TransactionNotAuthorizedForPointOfSale"
}
export declare const enum CardAuthorizationType {
    Classic = "Classic",
    PreAuthorization = "PreAuthorization",
    DataRequest = "DataRequest"
}
/** Project Card Design Background Type */
export declare const enum CardDesignBackgroundType {
    Black = "Black",
    Silver = "Silver",
    Custom = "Custom"
}
/** Card designs Status */
export declare const enum CardDesignStatus {
    Draft = "Draft",
    Enabled = "Enabled",
    Disabled = "Disabled",
    ToReview = "ToReview"
}
/** Field we can use when ordering that can be applied when listing cards */
export declare const enum CardOrderByFieldInput {
    id = "id",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Card Product Status */
export declare const enum CardProductStatus {
    PendingReview = "PendingReview",
    Enabled = "Enabled",
    Suspended = "Suspended",
    Disabled = "Disabled"
}
/** Card Settings Background Type */
export declare const enum CardSettingsBackgroundType {
    Black = "Black",
    Silver = "Silver",
    Custom = "Custom"
}
/** Card Status */
export declare const enum CardStatus {
    ConsentPending = "ConsentPending",
    Processing = "Processing",
    Enabled = "Enabled",
    Canceled = "Canceled",
    Canceling = "Canceling"
}
export declare const enum CardTransactionCategory {
    InStore = "InStore",
    eCommerce = "eCommerce",
    eCommerceWith3DS = "eCommerceWith3DS",
    Withdrawal = "Withdrawal",
    Other = "Other"
}
/** Card Type */
export declare const enum CardType {
    Virtual = "Virtual",
    VirtualAndPhysical = "VirtualAndPhysical",
    SingleUseVirtual = "SingleUseVirtual"
}
/** Cash account type (Always Current) */
export declare const enum CashAccountType {
    Current = "Current",
    CashPayment = "CashPayment",
    Charges = "Charges",
    CashIncome = "CashIncome",
    Commission = "Commission",
    ClearingParticipantSettlementAccount = "ClearingParticipantSettlementAccount",
    LimitedLiquiditySavingsAccount = "LimitedLiquiditySavingsAccount",
    Loan = "Loan",
    MarginalLending = "MarginalLending",
    MoneyMarket = "MoneyMarket",
    NonResidentExternal = "NonResidentExternal",
    Overdraft = "Overdraft",
    OverNightDeposit = "OverNightDeposit",
    OtherAccount = "OtherAccount",
    Settlement = "Settlement",
    Salary = "Salary",
    Savings = "Savings",
    Tax = "Tax",
    TransactingAccount = "TransactingAccount",
    CashTrading = "CashTrading"
}
/** Payment flow available options */
export declare const enum Category {
    InStore = "InStore",
    eCommerce = "eCommerce",
    eCommerceWith3DS = "eCommerceWith3DS",
    Withdrawal = "Withdrawal",
    Other = "Other"
}
/** Specific type for closing account action */
export declare const enum CloseAccountReasonType {
    ComplianceReason = "ComplianceReason",
    PartnerReason = "PartnerReason",
    Inactivity = "Inactivity",
    CapitalDepositReason = "CapitalDepositReason"
}
/** Type of company. */
export declare const enum CompanyType {
    Association = "Association",
    Company = "Company",
    HomeOwnerAssociation = "HomeOwnerAssociation",
    Other = "Other",
    SelfEmployed = "SelfEmployed"
}
/** Complete Digital Card Status */
export declare const enum CompleteDigitalCardStatus {
    Enabled = "Enabled",
    Suspended = "Suspended",
    Canceled = "Canceled"
}
/** Purpose of a consent */
export declare const enum ConsentPurpose {
    AcceptPartnershipConditions = "AcceptPartnershipConditions",
    AddAccountMembership = "AddAccountMembership",
    AddAccountMemberships = "AddAccountMemberships",
    AddBeneficiary = "AddBeneficiary",
    AddCard = "AddCard",
    AddCards = "AddCards",
    AddDigitalCard = "AddDigitalCard",
    ActivatePhysicalCard = "ActivatePhysicalCard",
    CloseAccount = "CloseAccount",
    InitPayment = "InitPayment",
    PrintPhysicalCard = "PrintPhysicalCard",
    ResumeAccountMembership = "ResumeAccountMembership",
    ResumePhysicalCard = "ResumePhysicalCard",
    ScheduleStandingOrder = "ScheduleStandingOrder",
    UpdateAccountMembership = "UpdateAccountMembership",
    UpdateCard = "UpdateCard",
    UpdateServerConsentProjectSettings = "UpdateServerConsentProjectSettings",
    ViewCardNumbers = "ViewCardNumbers",
    ViewPhysicalCardPin = "ViewPhysicalCardPin",
    EnableMandate = "EnableMandate",
    AddDirectDebitPaymentMandate = "AddDirectDebitPaymentMandate",
    InitiateFundingRequest = "InitiateFundingRequest",
    InitiateInstantFundingRequest = "InitiateInstantFundingRequest",
    InitiateInternationalCreditTransfer = "InitiateInternationalCreditTransfer",
    ConsentToMultipleConsents = "ConsentToMultipleConsents"
}
/** Status of a consent */
export declare const enum ConsentStatus {
    Accepted = "Accepted",
    CustomerRefused = "CustomerRefused",
    OperationCommitting = "OperationCommitting",
    CredentialRefused = "CredentialRefused",
    Created = "Created",
    Started = "Started",
    Expired = "Expired",
    Failed = "Failed",
    Canceled = "Canceled"
}
export declare const enum CreditTransferMode {
    InstantWithoutFallback = "InstantWithoutFallback",
    InstantWithFallback = "InstantWithFallback",
    Regular = "Regular"
}
/** Field we can use when ordering that can be applied when listing digital cards */
export declare const enum DigitalCardOrderByFieldInput {
    id = "id",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Digitalization Type */
export declare const enum DigitalizationType {
    Manual = "Manual",
    CardOnFile = "CardOnFile",
    InApp = "InApp",
    Unknown = "Unknown"
}
export declare const enum DirectDebitSequence {
    OneOff = "OneOff",
    Recurring = "Recurring",
    Recurrent = "Recurrent"
}
/** From which side the document picture was taken */
export declare const enum DocumentFileSide {
    SideA = "SideA",
    SideB = "SideB",
    BothSides = "BothSides",
    Unknown = "Unknown"
}
/** Reason code of the document. */
export declare const enum DocumentReasonCode {
    CompanyNameMismatch = "CompanyNameMismatch",
    DeclaredAmountMismatch = "DeclaredAmountMismatch",
    ExpiredDocument = "ExpiredDocument",
    InvalidAddress = "InvalidAddress",
    InvalidDocument = "InvalidDocument",
    InvalidOrMissingData = "InvalidOrMissingData",
    MissingAccommodationProviderId = "MissingAccommodationProviderId",
    MissingAccommodationProviderIdLetter = "MissingAccommodationProviderIdLetter",
    MissingAccommodationProviderLetter = "MissingAccommodationProviderLetter",
    UnacceptableDocument = "UnacceptableDocument"
}
/** The type of the document */
export declare const enum DocumentType {
    IdCard = "IdCard",
    Passport = "Passport",
    ResidencePermit = "ResidencePermit",
    DriversLicense = "DriversLicense",
    Face = "Face",
    Report = "Report"
}
/** Employment status. */
export declare const enum EmploymentStatus {
    Craftsman = "Craftsman",
    Employee = "Employee",
    Entrepreneur = "Entrepreneur",
    Farmer = "Farmer",
    Manager = "Manager",
    Practitioner = "Practitioner",
    Retiree = "Retiree",
    ShopOwner = "ShopOwner",
    Student = "Student",
    Unemployed = "Unemployed"
}
export declare const enum EnvType {
    Live = "Live",
    Sandbox = "Sandbox"
}
export declare const enum ExternalAccountBalanceType {
    ClosingBooked = "ClosingBooked",
    PreviouslyClosedBooked = "PreviouslyClosedBooked",
    InterimAvailable = "InterimAvailable",
    Expected = "Expected",
    ValueDate = "ValueDate",
    Other = "Other"
}
export declare const enum ExternalAccountDataSourceType {
    Push = "Push"
}
export declare const enum ExternalAccountUsage {
    Private = "Private",
    Association = "Association",
    Organization = "Organization",
    Unknown = "Unknown"
}
/** Fees type */
export declare const enum FeesTypeEnum {
    BankingFee = "BankingFee",
    CardPaymentsOutsideSEPA = "CardPaymentsOutsideSEPA",
    CashWithdrawalsOutsideSEPA = "CashWithdrawalsOutsideSEPA",
    CashWithdrawalsWithinSEPA = "CashWithdrawalsWithinSEPA",
    CheckDeposit = "CheckDeposit",
    CheckIncident = "CheckIncident",
    CirculationLetterDraftingFee = "CirculationLetterDraftingFee",
    ConfirmationLetterDraftingFee = "ConfirmationLetterDraftingFee",
    DirectDebitRejection = "DirectDebitRejection",
    InternationalCreditTransferInGroup1 = "InternationalCreditTransferInGroup1",
    InternationalCreditTransferInGroup2 = "InternationalCreditTransferInGroup2",
    InternationalCreditTransferInGroup3 = "InternationalCreditTransferInGroup3",
    InternationalCreditTransferInGroup4 = "InternationalCreditTransferInGroup4",
    InternationalCreditTransferOutGroup1 = "InternationalCreditTransferOutGroup1",
    InternationalCreditTransferOutGroup2 = "InternationalCreditTransferOutGroup2",
    InternationalCreditTransferOutGroup3 = "InternationalCreditTransferOutGroup3",
    InternationalCreditTransferOutGroup4 = "InternationalCreditTransferOutGroup4",
    ImproperUseOfAccount = "ImproperUseOfAccount",
    PhysicalCardDeliveryExpress = "PhysicalCardDeliveryExpress",
    PhysicalCardDeliveryFrance = "PhysicalCardDeliveryFrance",
    PhysicalCardDeliveryIntl = "PhysicalCardDeliveryIntl",
    PhysicalCardPrinting = "PhysicalCardPrinting",
    ProcessingJudicialOrAdministrativeSeizure = "ProcessingJudicialOrAdministrativeSeizure",
    SepaDirectDebitInB2bLevel1 = "SepaDirectDebitInB2bLevel1",
    SepaDirectDebitInB2bLevel2 = "SepaDirectDebitInB2bLevel2",
    SepaDirectDebitInCoreLevel1 = "SepaDirectDebitInCoreLevel1",
    SepaDirectDebitInCoreLevel2 = "SepaDirectDebitInCoreLevel2",
    SepaDirectDebitInCoreReturn = "SepaDirectDebitInCoreReturn",
    UnauthorizedOverdraft = "UnauthorizedOverdraft",
    BusinessAccountSubscription = "BusinessAccountSubscription",
    IndividualAccountSubscription = "IndividualAccountSubscription",
    AccountMembershipSubscription = "AccountMembershipSubscription",
    VirtualCardSubscription = "VirtualCardSubscription",
    SepaCreditTransferIn = "SepaCreditTransferIn",
    SepaCreditTransferOut = "SepaCreditTransferOut",
    InstantSepaCreditTransferIn = "InstantSepaCreditTransferIn",
    InstantSepaCreditTransferOut = "InstantSepaCreditTransferOut",
    SepaDirectDebitIn = "SepaDirectDebitIn",
    SepaDirectDebitOut = "SepaDirectDebitOut",
    SingleUseVirtualCard = "SingleUseVirtualCard",
    CardTransaction = "CardTransaction"
}
export declare const enum FieldValidationError {
    Missing = "Missing"
}
/** Field we can use when ordering that can be applied when listing funding limit settings change requests */
export declare const enum FundingLimitSettingsChangeRequestOrderByFieldInput {
    id = "id",
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Funding Limit Settings Change Request Status */
export declare const enum FundingLimitSettingsChangeRequestStatus {
    WaitingForInformation = "WaitingForInformation",
    Pending = "Pending",
    Approved = "Approved",
    Refused = "Refused"
}
/** Possible values for funding limit settings status */
export declare const enum FundingLimitSettingsStatus {
    Enabled = "Enabled",
    Suspended = "Suspended",
    Disabled = "Disabled"
}
/** Field we can use when ordering that can be applied when listing funding source results */
export declare const enum FundingSourceOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Funding Source Statuses */
export declare const enum FundingSourceStatus {
    Pending = "Pending",
    Enabled = "Enabled",
    Canceled = "Canceled",
    Rejected = "Rejected",
    Suspended = "Suspended"
}
/** Virtual IBAN Status */
export declare const enum IBANStatus {
    Enabled = "Enabled",
    Canceled = "Canceled",
    Suspended = "Suspended"
}
/** The various reasons that can lead to an invalid identification level */
export declare const enum IdentificationInvalidReason {
    AbsentOrIncompleteFace = "AbsentOrIncompleteFace",
    AlteredDevice = "AlteredDevice",
    BadDocumentLighting = "BadDocumentLighting",
    DamagedDocument = "DamagedDocument",
    ExpiredDocument = "ExpiredDocument",
    FraudDetected = "FraudDetected",
    InadequateVideo = "InadequateVideo",
    InsufficientApplicantLighting = "InsufficientApplicantLighting",
    InsufficientApplicantLiveness = "InsufficientApplicantLiveness",
    InsufficientConnectionQuality = "InsufficientConnectionQuality",
    InsufficientDocumentLiveness = "InsufficientDocumentLiveness",
    InsufficientDocumentReadability = "InsufficientDocumentReadability",
    InsufficientFaceReadability = "InsufficientFaceReadability",
    InsufficientVideoReadability = "InsufficientVideoReadability",
    InternalError = "InternalError",
    InvalidAddress = "InvalidAddress",
    InvalidOrMissingData = "InvalidOrMissingData",
    InvoluntaryIdentification = "InvoluntaryIdentification",
    MissingGeolocationData = "MissingGeolocationData",
    NegativeNewsHit = "NegativeNewsHit",
    NonMatchingIdentity = "NonMatchingIdentity",
    NonOriginalDocument = "NonOriginalDocument",
    SanctionListHit = "SanctionListHit",
    SecondDocumentRequired = "SecondDocumentRequired",
    TechnicalSignatureError = "TechnicalSignatureError",
    TimeoutSignatureFlow = "TimeoutSignatureFlow",
    UnacceptableDocument = "UnacceptableDocument",
    UnderageApplicant = "UnderageApplicant"
}
/** Possible value for the field IdentificationLevel */
export declare const enum IdentificationLevel {
    Expert = "Expert",
    QES = "QES",
    PVID = "PVID"
}
/** User identification levels input payload. */
export declare const enum IdentificationLevelInput {
    Expert = "Expert",
    PVID = "PVID",
    QES = "QES"
}
/** Process of the identification */
export declare const enum IdentificationProcess {
    Expert = "Expert",
    QES = "QES",
    PVID = "PVID"
}
/** Fields we can use when ordering that can be applied when listing identifications */
export declare const enum IdentificationsOrderByField {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Identification status */
export declare const enum IdentificationStatus {
    Uninitiated = "Uninitiated",
    Processing = "Processing",
    ReadyToSign = "ReadyToSign",
    ValidIdentity = "ValidIdentity",
    InsufficientDocumentQuality = "InsufficientDocumentQuality",
    InvalidIdentity = "InvalidIdentity"
}
/** The type of the identity document */
export declare const enum IdentityDocumentType {
    IdCard = "IdCard",
    Passport = "Passport",
    ResidencePermit = "ResidencePermit",
    DriversLicense = "DriversLicense"
}
/** Individual Ultimate beneficial owner nature */
export declare const enum IndividualUltimateBeneficialOwnerTypeEnum {
    LegalRepresentative = "LegalRepresentative",
    HasCapital = "HasCapital",
    Other = "Other"
}
export declare const enum InternalDirectDebitSequence {
    OneOff = "OneOff",
    Recurring = "Recurring",
    Recurrent = "Recurrent"
}
export declare const enum InternalPaymentMandateScheme {
    InternalDirectDebitStandard = "InternalDirectDebitStandard",
    InternalDirectDebitB2b = "InternalDirectDebitB2b"
}
/** Internal Direct Debit Payment Mandate Sequence */
export declare const enum InternalPaymentMandateSequence {
    Recurring = "Recurring",
    Recurrent = "Recurrent",
    OneOff = "OneOff"
}
/** Received internal direct debit mandate scheme */
export declare const enum InternalReceivedDirectDebitMandateScheme {
    InternalDirectDebitB2b = "InternalDirectDebitB2b",
    InternalDirectDebitStandard = "InternalDirectDebitStandard"
}
/** Internal received direct debit mandate sequence */
export declare const enum InternalReceivedDirectDebitMandateSequence {
    OneOff = "OneOff",
    Recurrent = "Recurrent"
}
/** Language: ISO 639-1 language code */
export declare const enum InternationalCreditTransferDisplayLanguage {
    en = "en",
    nl = "nl",
    fr = "fr",
    de = "de",
    it = "it",
    pt = "pt",
    es = "es"
}
/** International Credit Transfer Route */
export declare const enum InternationalCreditTransferRoute {
    Unknown = "Unknown",
    Aba = "Aba",
    Argentina = "Argentina",
    Australian = "Australian",
    AustralianBpay = "AustralianBpay",
    Brazil = "Brazil",
    Canadian = "Canadian",
    Chile = "Chile",
    CostaRica = "CostaRica",
    Czech = "Czech",
    Emirates = "Emirates",
    FedwireLocal = "FedwireLocal",
    FijiMobile = "FijiMobile",
    HongKongFps = "HongKongFps",
    Hongkong = "Hongkong",
    Hungarian = "Hungarian",
    Iban = "Iban",
    Indian = "Indian",
    IndianUpi = "IndianUpi",
    Indonesian = "Indonesian",
    Interac = "Interac",
    IsraeliLocal = "IsraeliLocal",
    Japanese = "Japanese",
    KenyaLocal = "KenyaLocal",
    KenyaMobile = "KenyaMobile",
    Malaysian = "Malaysian",
    MalaysianDuitnow = "MalaysianDuitnow",
    Mexican = "Mexican",
    Morocco = "Morocco",
    Nepal = "Nepal",
    NewZealand = "NewZealand",
    Philippines = "Philippines",
    PhilippinesMobile = "PhilippinesMobile",
    Polish = "Polish",
    PrivatBank = "PrivatBank",
    Singapore = "Singapore",
    SingaporePaynow = "SingaporePaynow",
    SortCode = "SortCode",
    SouthAfrica = "SouthAfrica",
    SouthKoreanPaygate = "SouthKoreanPaygate",
    SouthKoreanPaygateBusiness = "SouthKoreanPaygateBusiness",
    SwiftCode = "SwiftCode",
    Thailand = "Thailand",
    TurkishEarthport = "TurkishEarthport",
    Uruguay = "Uruguay",
    VietnameEarthport = "VietnameEarthport"
}
/** International Credit Transfer Route */
export declare const enum InternationalCreditTransferRouteInput {
    Aba = "Aba",
    Argentina = "Argentina",
    Australian = "Australian",
    AustralianBpay = "AustralianBpay",
    Brazil = "Brazil",
    Canadian = "Canadian",
    Chile = "Chile",
    CostaRica = "CostaRica",
    Czech = "Czech",
    Emirates = "Emirates",
    FedwireLocal = "FedwireLocal",
    FijiMobile = "FijiMobile",
    HongKongFps = "HongKongFps",
    Hongkong = "Hongkong",
    Hungarian = "Hungarian",
    Iban = "Iban",
    Indian = "Indian",
    IndianUpi = "IndianUpi",
    Interac = "Interac",
    IsraeliLocal = "IsraeliLocal",
    Japanese = "Japanese",
    KenyaLocal = "KenyaLocal",
    KenyaMobile = "KenyaMobile",
    Malaysian = "Malaysian",
    MalaysianDuitnow = "MalaysianDuitnow",
    Mexican = "Mexican",
    Morocco = "Morocco",
    Nepal = "Nepal",
    NewZealand = "NewZealand",
    Philippines = "Philippines",
    PhilippinesMobile = "PhilippinesMobile",
    Polish = "Polish",
    PrivatBank = "PrivatBank",
    Singapore = "Singapore",
    SingaporePaynow = "SingaporePaynow",
    SortCode = "SortCode",
    SouthKoreanPaygate = "SouthKoreanPaygate",
    SouthKoreanPaygateBusiness = "SouthKoreanPaygateBusiness",
    SouthAfrica = "SouthAfrica",
    SwiftCode = "SwiftCode",
    Thailand = "Thailand",
    TurkishEarthport = "TurkishEarthport"
}
export declare const enum InvalidArgumentRejectionCode {
    INVALID_INPUT = "INVALID_INPUT"
}
/** InvalidIbanCode */
export declare const enum InvalidIbanCode {
    InvalidLength = "InvalidLength",
    InvalidStructure = "InvalidStructure",
    InvalidChecksum = "InvalidChecksum",
    InvalidBank = "InvalidBank"
}
/** The different statuses of invoice */
export declare const enum InvoiceStatus {
    Failed = "Failed",
    NotPaid = "NotPaid",
    Paid = "Paid",
    PaymentDue = "PaymentDue",
    Pending = "Pending",
    Voided = "Voided"
}
export declare const enum InvoiceType {
    Invoice = "Invoice",
    RefundNote = "RefundNote"
}
export declare const enum Language {
    de = "de",
    en = "en",
    fr = "fr",
    it = "it",
    nl = "nl",
    es = "es"
}
export declare const enum LegalDocumentStatus {
    Upcoming = "Upcoming",
    Active = "Active",
    Inactive = "Inactive"
}
export declare const enum LegalDocumentType {
    SwanTCU = "SwanTCU"
}
/** Language: ISO 639-1 language code */
export declare const enum MandateLanguage {
    de = "de",
    en = "en",
    fr = "fr",
    it = "it",
    nl = "nl",
    es = "es",
    pt = "pt",
    fi = "fi"
}
/** MerchantCategoryDescription */
export declare const enum MerchantCategoryDescription {
    AccessoryAndApparelStoresMiscellaneous = "AccessoryAndApparelStoresMiscellaneous",
    AccountingAuditingAndBookkeepingServices = "AccountingAuditingAndBookkeepingServices",
    AdvertisingServices = "AdvertisingServices",
    AgriculturalCooperatives = "AgriculturalCooperatives",
    AirCarriersAirlinesNotElsewhereClassified = "AirCarriersAirlinesNotElsewhereClassified",
    AirConditioningAndRefrigerationRepairShops = "AirConditioningAndRefrigerationRepairShops",
    AirConditioningHeatingAndPlumbingContractors = "AirConditioningHeatingAndPlumbingContractors",
    AirlinesAirCarriers = "AirlinesAirCarriers",
    AirportsAirportTerminalsFlyingFields = "AirportsAirportTerminalsFlyingFields",
    AlterationsMendingSeamstressesTailors = "AlterationsMendingSeamstressesTailors",
    AmbulanceServices = "AmbulanceServices",
    AmusementParksCarnivalsCircusesFortuneTellers = "AmusementParksCarnivalsCircusesFortuneTellers",
    AntiqueReproductionStores = "AntiqueReproductionStores",
    AntiqueShopsSalesRepairsAndRestorationServices = "AntiqueShopsSalesRepairsAndRestorationServices",
    ApplianceRepairShopsElectricalAndSmall = "ApplianceRepairShopsElectricalAndSmall",
    AquariumsDolphinariumsZoosAndSeaquariums = "AquariumsDolphinariumsZoosAndSeaquariums",
    ArchitecturalEngineeringAndSurveyingServices = "ArchitecturalEngineeringAndSurveyingServices",
    ArtDealersAndGalleries = "ArtDealersAndGalleries",
    ArtistSupplyStoresCraftShops = "ArtistSupplyStoresCraftShops",
    AssociationsCivicSocialAndFraternal = "AssociationsCivicSocialAndFraternal",
    AthleticFieldsCommercialSportsProfessionalSportsClubsSportsPromoters = "AthleticFieldsCommercialSportsProfessionalSportsClubsSportsPromoters",
    AttorneysLegalServices = "AttorneysLegalServices",
    AutomatedCashDisbursementsCustomerFinancialInstitution = "AutomatedCashDisbursementsCustomerFinancialInstitution",
    AutomobileAndTruckDealersSalesServiceRepairsPartsAndLeasing = "AutomobileAndTruckDealersSalesServiceRepairsPartsAndLeasing",
    AutomobileAndTruckDealersUsedOnlySales = "AutomobileAndTruckDealersUsedOnlySales",
    AutomobileAssociations = "AutomobileAssociations",
    AutomobileParkingLotsAndGarages = "AutomobileParkingLotsAndGarages",
    AutomobileRentalAgencyNotElsewhereClassified = "AutomobileRentalAgencyNotElsewhereClassified",
    AutomotiveBodyRepairShops = "AutomotiveBodyRepairShops",
    AutomotivePaintShops = "AutomotivePaintShops",
    AutomotivePartsAccessoriesStores = "AutomotivePartsAccessoriesStores",
    AutomotiveServiceShops = "AutomotiveServiceShops",
    AutomotiveTireStores = "AutomotiveTireStores",
    AutoStoreHomeSupplyStores = "AutoStoreHomeSupplyStores",
    BailAndBondPayments = "BailAndBondPayments",
    Bakeries = "Bakeries",
    BandsOrchestrasAndMiscellaneousEntertainersNotElsewhereClassified = "BandsOrchestrasAndMiscellaneousEntertainersNotElsewhereClassified",
    BarberAndBeautyShops = "BarberAndBeautyShops",
    BarsCocktailLoungesDiscothequesNightclubsAndTavernsDrinkingPlacesAlcoholicBeverages = "BarsCocktailLoungesDiscothequesNightclubsAndTavernsDrinkingPlacesAlcoholicBeverages",
    BicycleShopsSalesAndService = "BicycleShopsSalesAndService",
    BoatDealers = "BoatDealers",
    BoatLeasesAndBoatRentals = "BoatLeasesAndBoatRentals",
    BooksPeriodicalsAndNewspapers = "BooksPeriodicalsAndNewspapers",
    BookStores = "BookStores",
    BowlingAlleys = "BowlingAlleys",
    BridgeAndRoadFeesTolls = "BridgeAndRoadFeesTolls",
    BuildingMaterialsLumberStores = "BuildingMaterialsLumberStores",
    BusinessServicesNotElsewhereClassified = "BusinessServicesNotElsewhereClassified",
    BusLines = "BusLines",
    BuyingOrShoppingClubsServices = "BuyingOrShoppingClubsServices",
    CableSatelliteAndOtherPayTelevisionAndRadioServices = "CableSatelliteAndOtherPayTelevisionAndRadioServices",
    CameraAndPhotographicSupplyStores = "CameraAndPhotographicSupplyStores",
    CamperDealersRecreationalAndUtilityTrailers = "CamperDealersRecreationalAndUtilityTrailers",
    CampgroundsAndTrailerParks = "CampgroundsAndTrailerParks",
    CandyNutConfectioneryStores = "CandyNutConfectioneryStores",
    CardGiftNoveltyAndSouvenirShops = "CardGiftNoveltyAndSouvenirShops",
    CarpentryContractors = "CarpentryContractors",
    CarpetAndUpholsteryCleaning = "CarpetAndUpholsteryCleaning",
    CarRentalAgencies = "CarRentalAgencies",
    CarWashes = "CarWashes",
    Caterers = "Caterers",
    ChemicalsAndAlliedProductsNotElsewhereClassified = "ChemicalsAndAlliedProductsNotElsewhereClassified",
    ChildCareServices = "ChildCareServices",
    ChildrenAndInfantsWearStores = "ChildrenAndInfantsWearStores",
    ChiropodistsPodiatrists = "ChiropodistsPodiatrists",
    Chiropractors = "Chiropractors",
    CigarStoresAndStands = "CigarStoresAndStands",
    CleaningAndMaintenanceJanitorialServices = "CleaningAndMaintenanceJanitorialServices",
    CleaningGarmentAndLaundryServices = "CleaningGarmentAndLaundryServices",
    ClockJewelryAndWatchRepairShops = "ClockJewelryAndWatchRepairShops",
    ClockJewelryWatchAndSilverwareStore = "ClockJewelryWatchAndSilverwareStore",
    ClothingRentalCostumesUniformsAndFormalWear = "ClothingRentalCostumesUniformsAndFormalWear",
    ClubsCountryClubsMembershipAthleticRecreationSportsPrivateGolfCourses = "ClubsCountryClubsMembershipAthleticRecreationSportsPrivateGolfCourses",
    CollegesUniversitiesProfessionalSchoolsAndJuniorColleges = "CollegesUniversitiesProfessionalSchoolsAndJuniorColleges",
    CommercialArtGraphicsPhotography = "CommercialArtGraphicsPhotography",
    CommercialEquipmentNotElsewhereClassified = "CommercialEquipmentNotElsewhereClassified",
    CommercialFootwear = "CommercialFootwear",
    ComputerMaintenanceRepairAndServicesNotElsewhereClassified = "ComputerMaintenanceRepairAndServicesNotElsewhereClassified",
    ComputerNetworkOrInformationServices = "ComputerNetworkOrInformationServices",
    ComputerProgrammingDataProcessingAndIntegratedSystemsDesignServices = "ComputerProgrammingDataProcessingAndIntegratedSystemsDesignServices",
    ComputersComputerPeripheralEquipmentSoftware = "ComputersComputerPeripheralEquipmentSoftware",
    ComputerSoftwareStores = "ComputerSoftwareStores",
    ConcreteWorkContractors = "ConcreteWorkContractors",
    ConstructionMaterialsNotElsewhereClassified = "ConstructionMaterialsNotElsewhereClassified",
    ConsultingManagementAndPublicRelationsServices = "ConsultingManagementAndPublicRelationsServices",
    ConsumerCreditReportingAgencies = "ConsumerCreditReportingAgencies",
    ContractorsSpecialTradeNotElsewhereClassified = "ContractorsSpecialTradeNotElsewhereClassified",
    CosmeticStores = "CosmeticStores",
    CourierServiceAirAndGroundFreightForwarders = "CourierServiceAirAndGroundFreightForwarders",
    CourtCostsIncludingAlimonyAndChildSupport = "CourtCostsIncludingAlimonyAndChildSupport",
    CruiseLines = "CruiseLines",
    CrystalAndGlasswareStores = "CrystalAndGlasswareStores",
    DairyProductsStores = "DairyProductsStores",
    DanceHallsSchoolsAndStudios = "DanceHallsSchoolsAndStudios",
    DatingServices = "DatingServices",
    DebtMarriagePersonalCounselingService = "DebtMarriagePersonalCounselingService",
    DentalAndMedicalLaboratories = "DentalAndMedicalLaboratories",
    DentalLaboratoryMedicalOphthalmicHospitalEquipmentAndSupplies = "DentalLaboratoryMedicalOphthalmicHospitalEquipmentAndSupplies",
    DentistsOrthodontists = "DentistsOrthodontists",
    DepartmentStores = "DepartmentStores",
    DetectiveAgenciesProtectiveAgenciesSecurityServicesIncludingArmoredCarsGuardDogs = "DetectiveAgenciesProtectiveAgenciesSecurityServicesIncludingArmoredCarsGuardDogs",
    DigitalGoodsAudiovisualMediaIncludingBooksMoviesAndMusic = "DigitalGoodsAudiovisualMediaIncludingBooksMoviesAndMusic",
    DigitalGoodsGames = "DigitalGoodsGames",
    DigitalGoodsMultiCategory = "DigitalGoodsMultiCategory",
    DigitalGoodsSoftwareApplicationsExcludingGames = "DigitalGoodsSoftwareApplicationsExcludingGames",
    DirectMarketingCatalogMerchants = "DirectMarketingCatalogMerchants",
    DirectMarketingCombinationCatalogAndRetailMerchants = "DirectMarketingCombinationCatalogAndRetailMerchants",
    DirectMarketingContinuitySubscriptionMerchants = "DirectMarketingContinuitySubscriptionMerchants",
    DirectMarketingInboundTelemarketingMerchants = "DirectMarketingInboundTelemarketingMerchants",
    DirectMarketingInsuranceServices = "DirectMarketingInsuranceServices",
    DirectMarketingOtherDirectMarketersNotElsewhereClassified = "DirectMarketingOtherDirectMarketersNotElsewhereClassified",
    DirectMarketingOutboundTelemarketingMerchants = "DirectMarketingOutboundTelemarketingMerchants",
    DirectMarketingTravelRelatedArrangementServices = "DirectMarketingTravelRelatedArrangementServices",
    DiscountStores = "DiscountStores",
    DoctorsNotElsewhereClassified = "DoctorsNotElsewhereClassified",
    DoorToDoorSales = "DoorToDoorSales",
    DraperyUpholsteryAndWindowCoveringsStores = "DraperyUpholsteryAndWindowCoveringsStores",
    DrugsDrugProprietorsAndDruggistsSundries = "DrugsDrugProprietorsAndDruggistsSundries",
    DrugStoresPharmacies = "DrugStoresPharmacies",
    DryCleaners = "DryCleaners",
    DurableGoodsNotElsewhereClassified = "DurableGoodsNotElsewhereClassified",
    DutyFreeStores = "DutyFreeStores",
    EatingPlacesRestaurants = "EatingPlacesRestaurants",
    ElectricalContractors = "ElectricalContractors",
    ElectricalPartsAndEquipment = "ElectricalPartsAndEquipment",
    ElectricRazorStoresSalesAndService = "ElectricRazorStoresSalesAndService",
    ElectricVehicleCharging = "ElectricVehicleCharging",
    ElectronicRepairShops = "ElectronicRepairShops",
    ElectronicSales = "ElectronicSales",
    EmploymentAgenciesTemporaryHelpServices = "EmploymentAgenciesTemporaryHelpServices",
    EquipmentFurnitureAndHomeFurnishingsStoresExceptAppliances = "EquipmentFurnitureAndHomeFurnishingsStoresExceptAppliances",
    EquipmentRentalAndLeasingServicesFurnitureRentalToolRental = "EquipmentRentalAndLeasingServicesFurnitureRentalToolRental",
    ExterminatingAndDisinfectingServices = "ExterminatingAndDisinfectingServices",
    FabricNeedleworkPieceGoodsAndSewingStores = "FabricNeedleworkPieceGoodsAndSewingStores",
    FamilyClothingStores = "FamilyClothingStores",
    FastFoodRestaurants = "FastFoodRestaurants",
    Fines = "Fines",
    FireplaceFireplaceScreensAndAccessoriesStores = "FireplaceFireplaceScreensAndAccessoriesStores",
    FloorCoveringStores = "FloorCoveringStores",
    Florists = "Florists",
    FloristsSuppliesNurseryStockAndFlowers = "FloristsSuppliesNurseryStockAndFlowers",
    FreezerLockerMeatProvisioners = "FreezerLockerMeatProvisioners",
    FuelDealersCoalFuelOilLiquefiedPetroleumWood = "FuelDealersCoalFuelOilLiquefiedPetroleumWood",
    FuelDispenserAutomated = "FuelDispenserAutomated",
    FuneralServiceAndCrematories = "FuneralServiceAndCrematories",
    FurnitureReupholsteryAndRepairRefinishing = "FurnitureReupholsteryAndRepairRefinishing",
    FurriersAndFurShops = "FurriersAndFurShops",
    GamblingTransactions = "GamblingTransactions",
    GameToyAndHobbyShops = "GameToyAndHobbyShops",
    GeneralContractorsResidentialAndCommercial = "GeneralContractorsResidentialAndCommercial",
    GlassPaintWallpaperStores = "GlassPaintWallpaperStores",
    GolfCoursesPublic = "GolfCoursesPublic",
    GovernmentLicensedHorseOrDogRacingUSRegionOnly = "GovernmentLicensedHorseOrDogRacingUSRegionOnly",
    GovernmentOwnedLotterySpecificCountries = "GovernmentOwnedLotterySpecificCountries",
    GovernmentOwnedLotteryUSRegionOnly = "GovernmentOwnedLotteryUSRegionOnly",
    GovernmentServicesNotElsewhereClassified = "GovernmentServicesNotElsewhereClassified",
    GroceryStoresSupermarkets = "GroceryStoresSupermarkets",
    HardwareEquipmentAndSupplies = "HardwareEquipmentAndSupplies",
    HardwareStores = "HardwareStores",
    HatCleaningShopsShoeRepairShopsShoeShineParlors = "HatCleaningShopsShoeRepairShopsShoeShineParlors",
    HealthAndBeautySpas = "HealthAndBeautySpas",
    HealthPractitionersMedicalServicesNotElsewhereClassified = "HealthPractitionersMedicalServicesNotElsewhereClassified",
    HearingAidsSalesServiceSupplyStores = "HearingAidsSalesServiceSupplyStores",
    HomeSupplyWarehouseStores = "HomeSupplyWarehouseStores",
    HorticulturalAndLandscapingServices = "HorticulturalAndLandscapingServices",
    Hospitals = "Hospitals",
    HouseholdApplianceStores = "HouseholdApplianceStores",
    IndustrialSuppliesNotElsewhereClassified = "IndustrialSuppliesNotElsewhereClassified",
    InformationRetrievalServices = "InformationRetrievalServices",
    InsulationMasonryPlasteringStoneworkAndTileSettingContractors = "InsulationMasonryPlasteringStoneworkAndTileSettingContractors",
    InsuranceSalesUnderwritingAndPremiums = "InsuranceSalesUnderwritingAndPremiums",
    InternetGamblingUSRegionOnly = "InternetGamblingUSRegionOnly",
    IntraGovernmentPurchasesGovernmentOnly = "IntraGovernmentPurchasesGovernmentOnly",
    KeyEntryTelecomMerchantProvidingSingleLocalAndLongDistancePhoneCallsUsingACentralAccessNumberInANonFaceToFaceEnvironmentUsingKeyEntry = "KeyEntryTelecomMerchantProvidingSingleLocalAndLongDistancePhoneCallsUsingACentralAccessNumberInANonFaceToFaceEnvironmentUsingKeyEntry",
    LaundryServicesFamilyAndCommercial = "LaundryServicesFamilyAndCommercial",
    LawnAndGardenSupplyStores = "LawnAndGardenSupplyStores",
    LeatherGoodsAndLuggageStores = "LeatherGoodsAndLuggageStores",
    LimousinesAndTaxicabs = "LimousinesAndTaxicabs",
    LodgingHotelsMotelsResorts = "LodgingHotelsMotelsResorts",
    LodgingHotelsMotelsResortsNotElsewhereClassified = "LodgingHotelsMotelsResortsNotElsewhereClassified",
    ManualCashDisbursementsCustomerFinancialInstitution = "ManualCashDisbursementsCustomerFinancialInstitution",
    MarinasMarineServiceSupplies = "MarinasMarineServiceSupplies",
    MassageParlors = "MassageParlors",
    MenAndBoysClothingAndAccessoriesStores = "MenAndBoysClothingAndAccessoriesStores",
    MenAndWomenClothingStores = "MenAndWomenClothingStores",
    MenWomenAndChildrenUniformsAndCommercialClothing = "MenWomenAndChildrenUniformsAndCommercialClothing",
    MerchandiseAndServicesCustomerFinancialInstitution = "MerchandiseAndServicesCustomerFinancialInstitution",
    MetalServiceCentersAndOffices = "MetalServiceCentersAndOffices",
    MiscellaneousAndSpecialtyRetailStores = "MiscellaneousAndSpecialtyRetailStores",
    MiscellaneousAutomotiveAircraftAndFarmEquipmentDealersNotElsewhereClassified = "MiscellaneousAutomotiveAircraftAndFarmEquipmentDealersNotElsewhereClassified",
    MiscellaneousFoodStoresConvenienceStoresMarketsSpecialtyStores = "MiscellaneousFoodStoresConvenienceStoresMarketsSpecialtyStores",
    MiscellaneousGeneralMerchandiseStores = "MiscellaneousGeneralMerchandiseStores",
    MiscellaneousHouseFurnishingSpecialtyShops = "MiscellaneousHouseFurnishingSpecialtyShops",
    MiscellaneousPublishingAndPrinting = "MiscellaneousPublishingAndPrinting",
    MiscellaneousRepairShopsAndRelatedServices = "MiscellaneousRepairShopsAndRelatedServices",
    MobileHomeDealers = "MobileHomeDealers",
    MoneySendFunding = "MoneySendFunding",
    MoneySendInterCountry = "MoneySendInterCountry",
    MoneySendIntraCountry = "MoneySendIntraCountry",
    MoneyTransfer = "MoneyTransfer",
    MotionPictureAndVideoTapeProductionAndDistribution = "MotionPictureAndVideoTapeProductionAndDistribution",
    MotionPictureTheaters = "MotionPictureTheaters",
    MotorcycleShopsAndDealers = "MotorcycleShopsAndDealers",
    MotorFreightCarriersTruckingLocalLongDistanceMovingAndStorageCompaniesLocalDelivery = "MotorFreightCarriersTruckingLocalLongDistanceMovingAndStorageCompaniesLocalDelivery",
    MotorHomeAndRecreationalVehicleRental = "MotorHomeAndRecreationalVehicleRental",
    MotorHomeDealers = "MotorHomeDealers",
    MotorVehicleSuppliesAndNewParts = "MotorVehicleSuppliesAndNewParts",
    MusicStoresMusicalInstrumentsPianosSheetMusic = "MusicStoresMusicalInstrumentsPianosSheetMusic",
    NewsDealersAndNewsstands = "NewsDealersAndNewsstands",
    NondurableGoodsNotElsewhereClassified = "NondurableGoodsNotElsewhereClassified",
    NursingAndPersonalCareFacilities = "NursingAndPersonalCareFacilities",
    OfficeAndCommercialFurniture = "OfficeAndCommercialFurniture",
    OfficePhotographicPhotocopyAndMicrofilmEquipment = "OfficePhotographicPhotocopyAndMicrofilmEquipment",
    OfficeSchoolSupplyAndStationeryStores = "OfficeSchoolSupplyAndStationeryStores",
    OpticiansOpticalGoodsAndEyeglasses = "OpticiansOpticalGoodsAndEyeglasses",
    OptometristsOphthalmologists = "OptometristsOphthalmologists",
    OrganizationsCharitableAndSocialService = "OrganizationsCharitableAndSocialService",
    OrganizationsMembershipNotElsewhereClassified = "OrganizationsMembershipNotElsewhereClassified",
    OrganizationsPolitical = "OrganizationsPolitical",
    OrganizationsReligious = "OrganizationsReligious",
    OrthopedicGoodsArtificialLimbStores = "OrthopedicGoodsArtificialLimbStores",
    OsteopathicPhysicians = "OsteopathicPhysicians",
    OtherServicesNotElsewhereClassified = "OtherServicesNotElsewhereClassified",
    PackageStoresBeerWineAndLiquor = "PackageStoresBeerWineAndLiquor",
    PaintsVarnishesAndSupplies = "PaintsVarnishesAndSupplies",
    PassengerRailways = "PassengerRailways",
    PawnShops = "PawnShops",
    PaymentTransactionCustomerFinancialInstitution = "PaymentTransactionCustomerFinancialInstitution",
    PaymentTransactionMerchant = "PaymentTransactionMerchant",
    PetroleumAndPetroleumProducts = "PetroleumAndPetroleumProducts",
    PetShopsPetFoodAndSupplies = "PetShopsPetFoodAndSupplies",
    PhotoDevelopingPhotofinishingLaboratories = "PhotoDevelopingPhotofinishingLaboratories",
    PhotographicStudios = "PhotographicStudios",
    PieceGoodsNotionsAndOtherDryGoods = "PieceGoodsNotionsAndOtherDryGoods",
    PlumbingAndHeatingEquipment = "PlumbingAndHeatingEquipment",
    PoiFundingTransactions = "PoiFundingTransactions",
    PoolAndBilliardEstablishments = "PoolAndBilliardEstablishments",
    PostalServicesGovernmentOnly = "PostalServicesGovernmentOnly",
    PreciousStonesAndMetalsWatchesAndJewelry = "PreciousStonesAndMetalsWatchesAndJewelry",
    ProfessionalServicesNotElsewhereClassified = "ProfessionalServicesNotElsewhereClassified",
    PublicWarehousingFarmProductsRefrigeratedGoodsHouseholdGoodsStorage = "PublicWarehousingFarmProductsRefrigeratedGoodsHouseholdGoodsStorage",
    QuasiCashCustomerFinancialInstitution = "QuasiCashCustomerFinancialInstitution",
    QuasiCashMerchant = "QuasiCashMerchant",
    QuickCopyReproductionAndBlueprintingServices = "QuickCopyReproductionAndBlueprintingServices",
    RailroadsFreight = "RailroadsFreight",
    RealEstateAgentsAndManagersRentals = "RealEstateAgentsAndManagersRentals",
    RecordShops = "RecordShops",
    RecreationalAndSportingCamps = "RecreationalAndSportingCamps",
    RecreationServicesNotElsewhereClassified = "RecreationServicesNotElsewhereClassified",
    ReligiousGoodsStores = "ReligiousGoodsStores",
    RoofingAndSidingSheetMetalWorkContractors = "RoofingAndSidingSheetMetalWorkContractors",
    SalvageAndWreckingYards = "SalvageAndWreckingYards",
    SanitationPolishingAndSpecialtyCleaningPreparations = "SanitationPolishingAndSpecialtyCleaningPreparations",
    SchoolsAndEducationalServicesNotElsewhereClassified = "SchoolsAndEducationalServicesNotElsewhereClassified",
    SchoolsBusinessAndSecretarial = "SchoolsBusinessAndSecretarial",
    SchoolsCorrespondence = "SchoolsCorrespondence",
    SchoolsElementaryAndSecondary = "SchoolsElementaryAndSecondary",
    SchoolsTradeAndVocational = "SchoolsTradeAndVocational",
    SecondHandStoresUsedMerchandiseStores = "SecondHandStoresUsedMerchandiseStores",
    SecuritiesBrokersDealers = "SecuritiesBrokersDealers",
    ServiceStationsWithOrWithoutAncillaryServices = "ServiceStationsWithOrWithoutAncillaryServices",
    ShoeStores = "ShoeStores",
    SnowmobileDealers = "SnowmobileDealers",
    SportingGoodsStores = "SportingGoodsStores",
    SportsApparelRidingApparelStores = "SportsApparelRidingApparelStores",
    StampAndCoinStoresPhilatelicAndNumismaticSupplies = "StampAndCoinStoresPhilatelicAndNumismaticSupplies",
    StationeryOfficeSuppliesPrintingAndWritingPaper = "StationeryOfficeSuppliesPrintingAndWritingPaper",
    StenographicAndSecretarialSupportServices = "StenographicAndSecretarialSupportServices",
    SwimmingPoolsSalesAndSupplies = "SwimmingPoolsSalesAndSupplies",
    TaxPayments = "TaxPayments",
    TaxPreparationService = "TaxPreparationService",
    TelecommunicationEquipmentIncludingTelephoneSales = "TelecommunicationEquipmentIncludingTelephoneSales",
    TelecommunicationServicesIncludingButNotLimitedToPrepaidPhoneServicesAndRecurringPhoneServices = "TelecommunicationServicesIncludingButNotLimitedToPrepaidPhoneServicesAndRecurringPhoneServices",
    TelegraphServices = "TelegraphServices",
    TentAndAwningShops = "TentAndAwningShops",
    TestingLaboratoriesNonMedical = "TestingLaboratoriesNonMedical",
    TheatricalProducersExceptMotionPicturesAndTicketAgencies = "TheatricalProducersExceptMotionPicturesAndTicketAgencies",
    Timeshares = "Timeshares",
    TireRetreadingAndRepairShops = "TireRetreadingAndRepairShops",
    TouristAttractionsAndExhibits = "TouristAttractionsAndExhibits",
    TowingServices = "TowingServices",
    TransportationServicesNotElsewhereClassified = "TransportationServicesNotElsewhereClassified",
    TransportationSuburbanAndLocalCommuterPassengerIncludingFerries = "TransportationSuburbanAndLocalCommuterPassengerIncludingFerries",
    TravelAgenciesAndTourOperators = "TravelAgenciesAndTourOperators",
    TruckRental = "TruckRental",
    TypesettingPlateMakingAndRelatedServices = "TypesettingPlateMakingAndRelatedServices",
    TypewriterStoresRentalsSalesService = "TypewriterStoresRentalsSalesService",
    Unknown = "Unknown",
    UtilitiesElectricGasHeatingOilSanitaryWater = "UtilitiesElectricGasHeatingOilSanitaryWater",
    VarietyStores = "VarietyStores",
    VeterinaryServices = "VeterinaryServices",
    VideoAmusementGameSupplies = "VideoAmusementGameSupplies",
    VideoEntertainmentRentalStores = "VideoEntertainmentRentalStores",
    VideoGameArcadesOrEstablishments = "VideoGameArcadesOrEstablishments",
    WeldingRepair = "WeldingRepair",
    WholesaleClubs = "WholesaleClubs",
    WigAndToupeeShops = "WigAndToupeeShops",
    WomenAccessoryAndSpecialtyStores = "WomenAccessoryAndSpecialtyStores",
    WomenReadyToWearStores = "WomenReadyToWearStores"
}
export declare const enum MerchantPaymentLinkStatus {
    Active = "Active",
    Expired = "Expired",
    Completed = "Completed",
    Canceled = "Canceled"
}
/** The different statuses a MerchantPaymentMethod can have */
export declare const enum MerchantPaymentMethodStatus {
    PendingReview = "PendingReview",
    Enabled = "Enabled",
    Rejected = "Rejected",
    Disabled = "Disabled",
    Canceled = "Canceled",
    Suspended = "Suspended"
}
/** The different statuses a MerchantPaymentMethod can have */
export declare const enum MerchantPaymentMethodType {
    InternalDirectDebitStandard = "InternalDirectDebitStandard",
    InternalDirectDebitB2b = "InternalDirectDebitB2b",
    SepaDirectDebitCore = "SepaDirectDebitCore",
    SepaDirectDebitB2b = "SepaDirectDebitB2b",
    Check = "Check",
    Card = "Card"
}
export declare const enum MerchantProfileOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Merchant Profile Statuses */
export declare const enum MerchantProfileStatus {
    PendingReview = "PendingReview",
    Enabled = "Enabled",
    Rejected = "Rejected",
    Canceled = "Canceled",
    Suspended = "Suspended"
}
/** Monthly income. */
export declare const enum MonthlyIncome {
    LessThan500 = "LessThan500",
    Between500And1500 = "Between500And1500",
    Between1500And3000 = "Between1500And3000",
    Between3000And4500 = "Between3000And4500",
    MoreThan4500 = "MoreThan4500"
}
/** Monthly payment volume. */
export declare const enum MonthlyPaymentVolume {
    Between10000And50000 = "Between10000And50000",
    Between50000And100000 = "Between50000And100000",
    LessThan10000 = "LessThan10000",
    MoreThan100000 = "MoreThan100000"
}
/** Field we can use when ordering that can be applied when listing onboardings */
export declare const enum OnboardingOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt",
    finalizedAt = "finalizedAt"
}
/** Onboarding process state */
export declare const enum OnboardingState {
    Ongoing = "Ongoing",
    Completed = "Completed"
}
/** Possible values for onboarding status */
export declare const enum OnboardingStatus {
    Finalized = "Finalized",
    Invalid = "Invalid",
    Valid = "Valid"
}
export declare const enum OrderByDirection {
    Asc = "Asc",
    Desc = "Desc"
}
/** Specific type for closing account action */
export declare const enum PartnerCloseAccountReasonType {
    ClosingRequested = "ClosingRequested"
}
export declare const enum PartnershipStatus {
    Accepted = "Accepted",
    Canceling = "Canceling",
    Canceled = "Canceled"
}
export declare const enum PaymentAccountType {
    EMoney = "EMoney",
    PaymentService = "PaymentService"
}
/** Payment Level of the account */
export declare const enum PaymentLevel {
    Limited = "Limited",
    Unlimited = "Unlimited"
}
export declare const enum PaymentLinkSequenceType {
    OneOff = "OneOff",
    Recurrent = "Recurrent"
}
export declare const enum PaymentMandateCanceledReason {
    RequestedByUser = "RequestedByUser",
    MandateExpired = "MandateExpired"
}
/** Field we can use when ordering that can be applied when listing payment mandate results */
export declare const enum PaymentMandateOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
export declare const enum PaymentMandateScheme {
    SepaDirectDebitCore = "SepaDirectDebitCore",
    SepaDirectDebitB2b = "SepaDirectDebitB2b",
    InternalDirectDebitStandard = "InternalDirectDebitStandard",
    InternalDirectDebitB2b = "InternalDirectDebitB2b"
}
/** Payment Mandate Sequence */
export declare const enum PaymentMandateSequence {
    Recurrent = "Recurrent",
    OneOff = "OneOff"
}
/** Payment Mandate status */
export declare const enum PaymentMandateStatus {
    ConsentPending = "ConsentPending",
    Enabled = "Enabled",
    Rejected = "Rejected",
    Canceled = "Canceled"
}
/** Field we can use when ordering that can be applied when listing payment */
export declare const enum PaymentOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
/** Payment product */
export declare const enum PaymentProduct {
    InternalCreditTransfer = "InternalCreditTransfer",
    SEPACreditTransfer = "SEPACreditTransfer",
    SEPADirectDebit = "SEPADirectDebit",
    Card = "Card",
    Fees = "Fees",
    InternalDirectDebit = "InternalDirectDebit",
    Check = "Check",
    InternationalCreditTransfer = "InternationalCreditTransfer"
}
/** Payment status */
export declare const enum PaymentStatus {
    ConsentPending = "ConsentPending",
    Initiated = "Initiated",
    Rejected = "Rejected"
}
/** Pending Digital Card Status */
export declare const enum PendingDigitalCardStatus {
    ConsentPending = "ConsentPending",
    Pending = "Pending",
    Declined = "Declined"
}
/** Physical Card Status */
export declare const enum PhysicalCardStatus {
    ConsentPending = "ConsentPending",
    Processing = "Processing",
    Activated = "Activated",
    Suspended = "Suspended",
    Canceled = "Canceled",
    Canceling = "Canceling",
    ToActivate = "ToActivate",
    ToRenew = "ToRenew",
    Renewed = "Renewed"
}
export declare const enum PreferredNotificationChannel {
    Sms = "Sms",
    App = "App"
}
/** Type of product sold. Gifts and donations can be club subscription or collection of donations (for associations), tips collection, contributions for local authorities */
export declare const enum ProductType {
    Goods = "Goods",
    Services = "Services",
    VirtualGoods = "VirtualGoods",
    GiftsAndDonations = "GiftsAndDonations"
}
/** Project Card Settings Background Type */
export declare const enum ProjectCardSettingsBackgroundType {
    Black = "Black",
    Silver = "Silver",
    Custom = "Custom"
}
/** Card Status */
export declare const enum ProjectCardStatus {
    Initiated = "Initiated",
    Enabled = "Enabled",
    Disabled = "Disabled",
    ToReview = "ToReview",
    Suspended = "Suspended",
    Rejected = "Rejected"
}
export declare const enum ProjectStatus {
    Initiated = "Initiated",
    MeetingScheduled = "MeetingScheduled",
    ToReview = "ToReview",
    PendingCompliance = "PendingCompliance",
    LimitedLiveAccess = "LimitedLiveAccess",
    BetaLiveAccess = "BetaLiveAccess",
    Enabled = "Enabled",
    FullLiveAccess = "FullLiveAccess",
    Disabled = "Disabled",
    Suspended = "Suspended",
    Rejected = "Rejected",
    PendingLiveReview = "PendingLiveReview"
}
export declare const enum ProjectType {
    INDIVIDUAL = "INDIVIDUAL",
    COMPANY = "COMPANY",
    COMPANY_AND_CUSTOMERS = "COMPANY_AND_CUSTOMERS",
    Individual = "Individual",
    Company = "Company",
    CompanyAndCustomers = "CompanyAndCustomers"
}
/** Received Direct Debit Mandate Scheme */
export declare const enum ReceivedDirectDebitMandateScheme {
    SepaDirectDebitB2b = "SepaDirectDebitB2b",
    SepaDirectDebitCore = "SepaDirectDebitCore"
}
/** Received Direct Debit Mandate Statuses */
export declare const enum ReceivedDirectDebitMandateStatus {
    Enabled = "Enabled",
    Suspended = "Suspended",
    Canceled = "Canceled",
    ConsentInitiationPending = "ConsentInitiationPending",
    ConsentPending = "ConsentPending"
}
/** Reason code that explains why we can't refund the transactions */
export declare const enum RefundRejectionCode {
    TransactionNotFound = "TransactionNotFound",
    TransactionNonRefundable = "TransactionNonRefundable",
    ServerError = "ServerError"
}
/** Funding Source Rejected Reason */
export declare const enum RejectedFundingSourceReason {
    AccountVerificationRejected = "AccountVerificationRejected"
}
/** The following reason code for a rejected transaction are defined: */
export declare const enum RejectedReasonCode {
    AccountClosed = "AccountClosed",
    AccountHolderDeceased = "AccountHolderDeceased",
    AccountMembershipRefused = "AccountMembershipRefused",
    AccountSuspended = "AccountSuspended",
    AccountUnknown = "AccountUnknown",
    AmountMismatch = "AmountMismatch",
    BankRefused = "BankRefused",
    BeneficiaryBankNotReachable = "BeneficiaryBankNotReachable",
    BeneficiaryMissingOrIncorrect = "BeneficiaryMissingOrIncorrect",
    CardExpired = "CardExpired",
    CardPermanentlyBlocked = "CardPermanentlyBlocked",
    CardSuspended = "CardSuspended",
    CheckReceivedLate = "CheckReceivedLate",
    CreditorBankOffline = "CreditorBankOffline",
    CreditorBankTechnicalErrorOccurred = "CreditorBankTechnicalErrorOccurred",
    CreditorBankTimeout = "CreditorBankTimeout",
    DateMissing = "DateMissing",
    DateInvalid = "DateInvalid",
    DebtorAccountClosed = "DebtorAccountClosed",
    DebtorAccountConsumer = "DebtorAccountConsumer",
    DebtorAccountUnknown = "DebtorAccountUnknown",
    DebtorBankOffline = "DebtorBankOffline",
    DebtorBankTechnicalErrorOccurred = "DebtorBankTechnicalErrorOccurred",
    DebtorBankTimeout = "DebtorBankTimeout",
    DebtorDeceased = "DebtorDeceased",
    DebtorNameMissing = "DebtorNameMissing",
    EndorsementMissing = "EndorsementMissing",
    FraudSuspected = "FraudSuspected",
    IbanInvalid = "IbanInvalid",
    IbanSuspended = "IbanSuspended",
    InsufficientFunds = "InsufficientFunds",
    InvalidTransferDate = "InvalidTransferDate",
    InvalidOrMissingAmount = "InvalidOrMissingAmount",
    MandateInvalid = "MandateInvalid",
    NoMandate = "NoMandate",
    PartnerRefused = "PartnerRefused",
    PartnerTechnicalErrorOccurred = "PartnerTechnicalErrorOccurred",
    PeriodAmountLimitExceeded = "PeriodAmountLimitExceeded",
    PeriodNbTransactionLimitExceeded = "PeriodNbTransactionLimitExceeded",
    ReasonNotSpecifiedByBank = "ReasonNotSpecifiedByBank",
    ReasonNotSpecifiedByDebtor = "ReasonNotSpecifiedByDebtor",
    RegulatoryReason = "RegulatoryReason",
    SignatureMissing = "SignatureMissing",
    SuspiciousCheck = "SuspiciousCheck",
    SwanOffline = "SwanOffline",
    SwanRefused = "SwanRefused",
    SwanTechnicalErrorOccurred = "SwanTechnicalErrorOccurred",
    SwanTimeout = "SwanTimeout",
    TermsAndConditionsLimitExceeded = "TermsAndConditionsLimitExceeded",
    TransactionAmountLimitExceeded = "TransactionAmountLimitExceeded",
    TransactionDuplicated = "TransactionDuplicated",
    TransactionOnAccountTypeNotAllowed = "TransactionOnAccountTypeNotAllowed",
    TransactionTypeNotAllowed = "TransactionTypeNotAllowed",
    CardNotActivated = "CardNotActivated",
    InvalidPin = "InvalidPin",
    InvalidPinAttemptsExceeded = "InvalidPinAttemptsExceeded",
    MerchantShouldResubmitAuthorization = "MerchantShouldResubmitAuthorization",
    InvalidExpirationDate = "InvalidExpirationDate",
    InvalidSecurityNumber = "InvalidSecurityNumber",
    PinRequiredForFurtherTransaction = "PinRequiredForFurtherTransaction",
    RetryWithChipAndPin = "RetryWithChipAndPin"
}
/** Rejected Verification Reason */
export declare const enum RejectedVerificationReason {
    HolderDidNotMatch = "HolderDidNotMatch"
}
export declare const enum ReleasedReason {
    Captured = "Captured",
    Expired = "Expired",
    AdviceReceived = "AdviceReceived",
    MerchantReleased = "MerchantReleased",
    ManuallyReleased = "ManuallyReleased",
    Other = "Other"
}
/** Request Merchant Profile Update Statuses */
export declare const enum RequestMerchantProfileUpdateStatus {
    PendingReview = "PendingReview",
    Enabled = "Enabled",
    Rejected = "Rejected"
}
/** Scheme that will be used to create the underlying payment mandate for this funding source */
export declare const enum SEPADirectDebitScheme {
    SepaDirectDebitCore = "SepaDirectDebitCore",
    SepaDirectDebitB2b = "SepaDirectDebitB2b"
}
export declare const enum SEPAPaymentMandateScheme {
    SepaDirectDebitCore = "SepaDirectDebitCore",
    SepaDirectDebitB2b = "SepaDirectDebitB2b"
}
/** SEPA Direct Debit Payment Mandate Sequence */
export declare const enum SEPAPaymentMandateSequence {
    Recurrent = "Recurrent",
    OneOff = "OneOff"
}
/** Received SEPA direct debit mandate scheme */
export declare const enum SEPAReceivedDirectDebitMandateScheme {
    SepaDirectDebitB2b = "SepaDirectDebitB2b",
    SepaDirectDebitCore = "SepaDirectDebitCore"
}
/** SEPA received direct debit mandate sequence */
export declare const enum SEPAReceivedDirectDebitMandateSequence {
    OneOff = "OneOff",
    Recurrent = "Recurrent"
}
/** Status of the shareholder during the process with Swan. */
export declare const enum ShareholderStatus {
    PendingOnboarding = "PendingOnboarding",
    WaitingForVerification = "WaitingForVerification",
    WaitingForTransfer = "WaitingForTransfer",
    CapitalTransferred = "CapitalTransferred",
    CapitalFundsWiredToNotary = "CapitalFundsWiredToNotary"
}
/** Shareholder type to identify individuals and companies. */
export declare const enum ShareholderType {
    Individual = "Individual",
    Company = "Company"
}
export declare const enum SimulationCardType {
    Physical = "Physical",
    Virtual = "Virtual"
}
/** Available period to compute spending limits */
export declare const enum SpendingLimitPeriod {
    Monthly = "Monthly",
    Weekly = "Weekly",
    Daily = "Daily",
    Always = "Always"
}
/** Available period to compute spending limits */
export declare const enum SpendingLimitPeriodInput {
    Monthly = "Monthly",
    Weekly = "Weekly",
    Daily = "Daily",
    Always = "Always"
}
/** Available type of spending limits */
export declare const enum SpendingLimitType {
    AccountHolder = "AccountHolder",
    Partner = "Partner"
}
export declare const enum StandingOrderPeriod {
    Daily = "Daily",
    Weekly = "Weekly",
    Monthly = "Monthly"
}
export declare const enum StandingOrderStatus {
    ConsentPending = "ConsentPending",
    Enabled = "Enabled",
    Canceled = "Canceled"
}
/** The different periods of statement */
export declare const enum StatementPeriod {
    Monthly = "Monthly",
    Custom = "Custom"
}
/** The different statuses of statement */
export declare const enum StatementStatus {
    Available = "Available",
    Failed = "Failed",
    Pending = "Pending"
}
/** The different type of statement actually available
- PDF will be a PDF file with the statement information */
export declare const enum StatementType {
    PDF = "PDF",
    CSV = "CSV"
}
export declare const enum StatusText {
    Success = "Success",
    Failure = "Failure"
}
/** Verification status of a supporting document collection */
export declare const enum SupportingDocumentCollectionStatus {
    WaitingForDocument = "WaitingForDocument",
    PendingReview = "PendingReview",
    Approved = "Approved",
    Canceled = "Canceled",
    Rejected = "Rejected"
}
export declare const enum SupportingDocumentCollectMode {
    API = "API",
    EndCustomer = "EndCustomer",
    Partner = "Partner"
}
export declare const enum SupportingDocumentCommunicationLanguageSettings {
    en = "en",
    fr = "fr"
}
/** Supporting document purpose */
export declare const enum SupportingDocumentPurposeEnum {
    AssociationRegistration = "AssociationRegistration",
    Banking = "Banking",
    CompanyRegistration = "CompanyRegistration",
    GeneralAssemblyMinutes = "GeneralAssemblyMinutes",
    Other = "Other",
    PowerOfAttorney = "PowerOfAttorney",
    ProofOfCompanyAddress = "ProofOfCompanyAddress",
    ProofOfCompanyIncome = "ProofOfCompanyIncome",
    ProofOfIdentity = "ProofOfIdentity",
    ProofOfIndividualAddress = "ProofOfIndividualAddress",
    ProofOfIndividualIncome = "ProofOfIndividualIncome",
    ProofOfOriginOfFunds = "ProofOfOriginOfFunds",
    SignedStatus = "SignedStatus",
    UBODeclaration = "UBODeclaration",
    SwornStatement = "SwornStatement",
    LegalRepresentativeProofOfIdentity = "LegalRepresentativeProofOfIdentity",
    UltimateBeneficialOwnerProofOfIdentity = "UltimateBeneficialOwnerProofOfIdentity",
    NIFAccreditationCard = "NIFAccreditationCard",
    PresidentDecisionOfAppointment = "PresidentDecisionOfAppointment",
    AdministratorDecisionOfAppointment = "AdministratorDecisionOfAppointment",
    FinancialStatements = "FinancialStatements",
    UltimateBeneficialOwnerProofOfAddress = "UltimateBeneficialOwnerProofOfAddress"
}
/** Verification status of a document */
export declare const enum SupportingDocumentStatus {
    WaitingForUpload = "WaitingForUpload",
    Uploaded = "Uploaded",
    Validated = "Validated",
    Refused = "Refused",
    NotUploaded = "NotUploaded"
}
/** Specific type for document */
export declare const enum SupportingDocumentType {
    Selfie = "Selfie",
    Passport = "Passport",
    NationalIdCard = "NationalIdCard",
    ResidentPermit = "ResidentPermit",
    DrivingLicense = "DrivingLicense",
    UtilityBill = "UtilityBill",
    PhoneBill = "PhoneBill",
    RentReceipt = "RentReceipt",
    HomeInsurance = "HomeInsurance",
    IncomeTaxReturn = "IncomeTaxReturn",
    PaySlip = "PaySlip",
    RegisterExtract = "RegisterExtract",
    ArticlesOfIncorporation = "ArticlesOfIncorporation",
    CapitalShareDepositCertificate = "CapitalShareDepositCertificate",
    UBODeclaration = "UBODeclaration",
    JOAFFEExtract = "JOAFFEExtract",
    CompanyLeaseAgreement = "CompanyLeaseAgreement",
    BankStatement = "BankStatement",
    BankAccountDetails = "BankAccountDetails",
    PowerOfAttorney = "PowerOfAttorney",
    CorporateIncomeTaxReturn = "CorporateIncomeTaxReturn",
    Other = "Other",
    ByLaws = "ByLaws",
    AccountStatement = "AccountStatement",
    DeedOfDonation = "DeedOfDonation",
    DeedOfSale = "DeedOfSale",
    DeedOfSuccession = "DeedOfSuccession",
    LoanContract = "LoanContract",
    NotarialDeed = "NotarialDeed",
    SwornStatement = "SwornStatement",
    MeetingMinutes = "MeetingMinutes",
    NIFAccreditationCard = "NIFAccreditationCard",
    DecisionOfAppointment = "DecisionOfAppointment",
    FinancialStatements = "FinancialStatements"
}
/** Specific type for suspend account action */
export declare const enum SuspendAccountReasonType {
    SuspendRequested = "SuspendRequested"
}
/** Enum of reasons of rejection for suspendReceivedDirectDebitMandate mutation */
export declare const enum SuspendReceivedDirectDebitMandatedRejectionReason {
    ReceivedDirectDebitMandateCanceled = "ReceivedDirectDebitMandateCanceled"
}
/** Status values of an identification */
export declare const enum SwanIdentificationStatus {
    Pending = "Pending",
    Valid = "Valid",
    Invalid = "Invalid",
    Canceled = "Canceled",
    Expired = "Expired",
    NotSupported = "NotSupported",
    NotStarted = "NotStarted",
    Started = "Started"
}
/** Individual ultimate beneficial owner title (Mr/Ms) */
export declare const enum TitleEnum {
    Mr = "Mr",
    Ms = "Ms"
}
/** The following reason codes for a r-transaction are defined: */
export declare const enum TransactionReasonCode {
    AccountClosed = "AccountClosed",
    AccountHolderDeceased = "AccountHolderDeceased",
    AccountLimited = "AccountLimited",
    AccountSuspended = "AccountSuspended",
    AccountUnknown = "AccountUnknown",
    BankRefused = "BankRefused",
    BeneficiaryAccountBlocked = "BeneficiaryAccountBlocked",
    BeneficiaryAccountClosed = "BeneficiaryAccountClosed",
    BeneficiaryAccountIncorrect = "BeneficiaryAccountIncorrect",
    BeneficiaryAccountUnknown = "BeneficiaryAccountUnknown",
    BeneficiaryBankBicInvalid = "BeneficiaryBankBicInvalid",
    BeneficiaryBranchCodeInvalid = "BeneficiaryBranchCodeInvalid",
    BeneficiaryPhoneNumberInvalid = "BeneficiaryPhoneNumberInvalid",
    BeneficiaryIdNumberInvalid = "BeneficiaryIdNumberInvalid",
    BeneficiaryRutNumberInvalid = "BeneficiaryRutNumberInvalid",
    BeneficiaryTaxIdInvalid = "BeneficiaryTaxIdInvalid",
    BeneficiaryTaxIdSuspended = "BeneficiaryTaxIdSuspended",
    BeneficiaryCurrencyInvalid = "BeneficiaryCurrencyInvalid",
    BeneficiaryBankNotReachable = "BeneficiaryBankNotReachable",
    BeneficiaryDeceased = "BeneficiaryDeceased",
    CardExpired = "CardExpired",
    CardNotActivated = "CardNotActivated",
    CardPermanentlyBlocked = "CardPermanentlyBlocked",
    CardSuspended = "CardSuspended",
    CheckInvalid = "CheckInvalid",
    CheckNumberInvalid = "CheckNumberInvalid",
    CreditorBankOffline = "CreditorBankOffline",
    CreditorBankTechnicalErrorOccurred = "CreditorBankTechnicalErrorOccurred",
    CreditorBankTimeout = "CreditorBankTimeout",
    DebtorAccountBlocked = "DebtorAccountBlocked",
    DebtorAccountClosed = "DebtorAccountClosed",
    DebtorAccountConsumer = "DebtorAccountConsumer",
    DebtorAccountUnknown = "DebtorAccountUnknown",
    DebtorBankOffline = "DebtorBankOffline",
    DebtorBankTechnicalErrorOccurred = "DebtorBankTechnicalErrorOccurred",
    DebtorBankTimeout = "DebtorBankTimeout",
    DebtorDeceased = "DebtorDeceased",
    FundsAlreadyTransferredBack = "FundsAlreadyTransferredBack",
    InsufficientFunds = "InsufficientFunds",
    InvalidCreditorName = "InvalidCreditorName",
    InvalidExpirationDate = "InvalidExpirationDate",
    InvalidPin = "InvalidPin",
    InvalidPinAttemptsExceeded = "InvalidPinAttemptsExceeded",
    InvalidSecurityNumber = "InvalidSecurityNumber",
    LegalOrBankDecision = "LegalOrBankDecision",
    MandateInvalid = "MandateInvalid",
    MerchantShouldResubmitAuthorization = "MerchantShouldResubmitAuthorization",
    NoAnswerFromBeneficiary = "NoAnswerFromBeneficiary",
    NoOriginalTransactionReceived = "NoOriginalTransactionReceived",
    PartnerRefused = "PartnerRefused",
    PartnerTechnicalErrorOccurred = "PartnerTechnicalErrorOccurred",
    PeriodAmountLimitExceeded = "PeriodAmountLimitExceeded",
    PeriodNbTransactionLimitExceeded = "PeriodNbTransactionLimitExceeded",
    PinRequiredForFurtherTransaction = "PinRequiredForFurtherTransaction",
    ReasonNotSpecifiedByBank = "ReasonNotSpecifiedByBank",
    ReasonNotSpecifiedByBeneficiary = "ReasonNotSpecifiedByBeneficiary",
    ReasonNotSpecifiedByDebtor = "ReasonNotSpecifiedByDebtor",
    ReasonNotSpecifiedByOriginator = "ReasonNotSpecifiedByOriginator",
    RecallAccepted = "RecallAccepted",
    RefundRequestedByDebtor = "RefundRequestedByDebtor",
    RefundRequestedByCreditor = "RefundRequestedByCreditor",
    RegulatoryReason = "RegulatoryReason",
    RlmcKeyInvalid = "RlmcKeyInvalid",
    SwanOffline = "SwanOffline",
    SwanRefused = "SwanRefused",
    SwanTechnicalErrorOccurred = "SwanTechnicalErrorOccurred",
    SwanTimeout = "SwanTimeout",
    TechnicalIssue = "TechnicalIssue",
    TermsAndConditionsLimitExceeded = "TermsAndConditionsLimitExceeded",
    TransactionAmountIncorrect = "TransactionAmountIncorrect",
    TransactionAmountLimitExceeded = "TransactionAmountLimitExceeded",
    TargetCurrencyNotAvailable = "TargetCurrencyNotAvailable",
    TransactionDuplicated = "TransactionDuplicated",
    TransactionOnAccountTypeNotAllowed = "TransactionOnAccountTypeNotAllowed",
    TransactionOnCardTypeNotAllowed = "TransactionOnCardTypeNotAllowed",
    TransactionPurposeInvalid = "TransactionPurposeInvalid",
    TransactionReferenceInvalid = "TransactionReferenceInvalid",
    TransactionTypeNotAllowed = "TransactionTypeNotAllowed"
}
/** Transaction side */
export declare const enum TransactionSide {
    Debit = "Debit",
    Credit = "Credit"
}
export declare const enum TransactionsOrderByField {
    id = "id",
    createdAt = "createdAt",
    updatedAt = "updatedAt",
    executionDate = "executionDate"
}
/** Transaction status */
export declare const enum TransactionStatus {
    Booked = "Booked",
    Rejected = "Rejected",
    Pending = "Pending",
    Canceled = "Canceled",
    Upcoming = "Upcoming",
    Released = "Released"
}
/** Transaction Type */
export declare const enum TransactionTypeEnum {
    InternalCreditTransferOut = "InternalCreditTransferOut",
    InternalCreditTransferOutReturn = "InternalCreditTransferOutReturn",
    InternalCreditTransferOutRecall = "InternalCreditTransferOutRecall",
    InternalCreditTransferIn = "InternalCreditTransferIn",
    InternalCreditTransferInReturn = "InternalCreditTransferInReturn",
    InternalCreditTransferInRecall = "InternalCreditTransferInRecall",
    SepaCreditTransferOut = "SepaCreditTransferOut",
    SepaInstantCreditTransferOut = "SepaInstantCreditTransferOut",
    SepaInstantCreditTransferIn = "SepaInstantCreditTransferIn",
    SepaCreditTransferOutReturn = "SepaCreditTransferOutReturn",
    SepaInstantCreditTransferOutRecall = "SepaInstantCreditTransferOutRecall",
    SepaInstantCreditTransferInRecall = "SepaInstantCreditTransferInRecall",
    SepaCreditTransferOutRecall = "SepaCreditTransferOutRecall",
    SepaCreditTransferIn = "SepaCreditTransferIn",
    SepaCreditTransferInReturn = "SepaCreditTransferInReturn",
    SepaCreditTransferInRecall = "SepaCreditTransferInRecall",
    FeesOut = "FeesOut",
    FeesIn = "FeesIn",
    SepaDirectDebitIn = "SepaDirectDebitIn",
    SepaDirectDebitInReturn = "SepaDirectDebitInReturn",
    SepaDirectDebitInReversal = "SepaDirectDebitInReversal",
    SepaDirectDebitOut = "SepaDirectDebitOut",
    SepaDirectDebitOutReturn = "SepaDirectDebitOutReturn",
    SepaDirectDebitOutReversal = "SepaDirectDebitOutReversal",
    CardOutAuthorization = "CardOutAuthorization",
    CardOutDebit = "CardOutDebit",
    CardOutDebitReversal = "CardOutDebitReversal",
    CardOutCredit = "CardOutCredit",
    CardOutCreditReversal = "CardOutCreditReversal",
    InternalDirectDebitIn = "InternalDirectDebitIn",
    InternalDirectDebitInReturn = "InternalDirectDebitInReturn",
    InternalDirectDebitOut = "InternalDirectDebitOut",
    InternalDirectDebitOutReturn = "InternalDirectDebitOutReturn",
    CheckIn = "CheckIn",
    CheckInReturn = "CheckInReturn",
    InternationalCreditTransferIn = "InternationalCreditTransferIn",
    InternationalCreditTransferOut = "InternationalCreditTransferOut",
    InternationalCreditTransferInReturn = "InternationalCreditTransferInReturn",
    InternationalCreditTransferOutReturn = "InternationalCreditTransferOutReturn"
}
/** Field we can use when ordering that can be applied when listing trusted beneficiaries */
export declare const enum TrustedBeneficiaryOrderByFieldInput {
    createdAt = "createdAt",
    label = "label",
    updatedAt = "updatedAt"
}
/** TrustedBeneficiary status */
export declare const enum TrustedBeneficiaryStatus {
    Canceled = "Canceled",
    ConsentPending = "ConsentPending",
    Enabled = "Enabled"
}
/** Quality of the account holder doing the onboarding */
export declare const enum TypeOfRepresentation {
    LegalRepresentative = "LegalRepresentative",
    PowerOfAttorney = "PowerOfAttorney"
}
/** Ultimate Beneficial Owner type. */
export declare const enum UltimateBeneficialOwnerType {
    DirectIndividual = "DirectIndividual",
    DirectCompany = "DirectCompany",
    IndirectIndividual = "IndirectIndividual",
    IndirectCompany = "IndirectCompany"
}
/** Field we can use when ordering that can be applied when listing users */
export declare const enum UserOrderByFieldInput {
    createdAt = "createdAt",
    updatedAt = "updatedAt"
}
export declare const enum ValidationFieldErrorCode {
    InvalidString = "InvalidString",
    InvalidType = "InvalidType",
    TooLong = "TooLong",
    TooShort = "TooShort",
    UnrecognizedKeys = "UnrecognizedKeys"
}
/** Verification Flow. */
export declare const enum VerificationFlow {
    Upfront = "Upfront",
    Progressive = "Progressive"
}
/** Verification status of an account holder */
export declare const enum VerificationStatus {
    NotStarted = "NotStarted",
    WaitingForInformation = "WaitingForInformation",
    Pending = "Pending",
    Verified = "Verified",
    Refused = "Refused"
}
/** Wallet Provider */
export declare const enum WalletProviderType {
    ApplePay = "ApplePay",
    GooglePay = "GooglePay"
}
export declare const enum WebhookSubscriptionCreationStatus {
    Enabled = "Enabled",
    Disabled = "Disabled"
}
/** State of a Webhook Subscription
It is either Enabled or Disabled by the owner,
ot set to Broken when delivery fails repeatedly. */
export declare const enum WebhookSubscriptionStatus {
    Enabled = "Enabled",
    Disabled = "Disabled",
    Broken = "Broken"
}
type ZEUS_VARIABLES = {
    ['AccountCountry']: ValueTypes['AccountCountry'];
    ['AccountFilterInput']: ValueTypes['AccountFilterInput'];
    ['AccountFundingLimitsReachedReason']: ValueTypes['AccountFundingLimitsReachedReason'];
    ['AccountHolderFilterInput']: ValueTypes['AccountHolderFilterInput'];
    ['AccountHolderOrderByFieldInput']: ValueTypes['AccountHolderOrderByFieldInput'];
    ['AccountHolderOrderByInput']: ValueTypes['AccountHolderOrderByInput'];
    ['AccountHolderStatus']: ValueTypes['AccountHolderStatus'];
    ['AccountHolderType']: ValueTypes['AccountHolderType'];
    ['AccountLanguage']: ValueTypes['AccountLanguage'];
    ['AccountMembershipOrderByFieldInput']: ValueTypes['AccountMembershipOrderByFieldInput'];
    ['AccountMembershipOrderByInput']: ValueTypes['AccountMembershipOrderByInput'];
    ['AccountMembershipsFilterInput']: ValueTypes['AccountMembershipsFilterInput'];
    ['AccountMembershipsPermission']: ValueTypes['AccountMembershipsPermission'];
    ['AccountMembershipStatus']: ValueTypes['AccountMembershipStatus'];
    ['AccountNumber']: ValueTypes['AccountNumber'];
    ['AccountOrderByFieldInput']: ValueTypes['AccountOrderByFieldInput'];
    ['AccountOrderByInput']: ValueTypes['AccountOrderByInput'];
    ['AccountReceivedDirectDebitMandateFiltersInput']: ValueTypes['AccountReceivedDirectDebitMandateFiltersInput'];
    ['AccountReceivedDirectDebitOrderByFieldInput']: ValueTypes['AccountReceivedDirectDebitOrderByFieldInput'];
    ['AccountReceivedDirectDebitOrderByInput']: ValueTypes['AccountReceivedDirectDebitOrderByInput'];
    ['AccountStandingOrderFiltersInput']: ValueTypes['AccountStandingOrderFiltersInput'];
    ['AccountStandingOrderOrderByFieldInput']: ValueTypes['AccountStandingOrderOrderByFieldInput'];
    ['AccountStandingOrderOrderByInput']: ValueTypes['AccountStandingOrderOrderByInput'];
    ['AccountStatus']: ValueTypes['AccountStatus'];
    ['AccountVerificationStatus']: ValueTypes['AccountVerificationStatus'];
    ['ActivatePhysicalCardInput']: ValueTypes['ActivatePhysicalCardInput'];
    ['AddAccountMembershipInput']: ValueTypes['AddAccountMembershipInput'];
    ['AddAccountMembershipsInput']: ValueTypes['AddAccountMembershipsInput'];
    ['AddCardInput']: ValueTypes['AddCardInput'];
    ['AddCardsInput']: ValueTypes['AddCardsInput'];
    ['AddCardsWithGroupDeliveryInput']: ValueTypes['AddCardsWithGroupDeliveryInput'];
    ['AddDigitalCardInput']: ValueTypes['AddDigitalCardInput'];
    ['AddDirectDebitFundingSourceInput']: ValueTypes['AddDirectDebitFundingSourceInput'];
    ['AddExternalAccountBalanceInput']: ValueTypes['AddExternalAccountBalanceInput'];
    ['AddExternalAccountInput']: ValueTypes['AddExternalAccountInput'];
    ['AddFundingLimitSettingsChangeRequestInput']: ValueTypes['AddFundingLimitSettingsChangeRequestInput'];
    ['AddInternalDirectDebitPaymentMandateInput']: ValueTypes['AddInternalDirectDebitPaymentMandateInput'];
    ['AddMerchantProfileInput']: ValueTypes['AddMerchantProfileInput'];
    ['AddOrUpdateExternalAccountBalanceInput']: ValueTypes['AddOrUpdateExternalAccountBalanceInput'];
    ['AddReceivedInternalDirectDebitB2bMandateInput']: ValueTypes['AddReceivedInternalDirectDebitB2bMandateInput'];
    ['AddReceivedSepaDirectDebitB2bMandateInput']: ValueTypes['AddReceivedSepaDirectDebitB2bMandateInput'];
    ['AddressInformationInput']: ValueTypes['AddressInformationInput'];
    ['AddressInput']: ValueTypes['AddressInput'];
    ['AddSepaDirectDebitPaymentMandateInput']: ValueTypes['AddSepaDirectDebitPaymentMandateInput'];
    ['AddSingleUseVirtualCardInput']: ValueTypes['AddSingleUseVirtualCardInput'];
    ['AddSingleUseVirtualCardsInput']: ValueTypes['AddSingleUseVirtualCardsInput'];
    ['AddVirtualIbanInput']: ValueTypes['AddVirtualIbanInput'];
    ['AddWebhookSubscriptionInput']: ValueTypes['AddWebhookSubscriptionInput'];
    ['AllowSddInput']: ValueTypes['AllowSddInput'];
    ['AllowSddVirtualIbanEntryInput']: ValueTypes['AllowSddVirtualIbanEntryInput'];
    ['AmlRiskLevel']: ValueTypes['AmlRiskLevel'];
    ['AmountInput']: ValueTypes['AmountInput'];
    ['AmountValue']: ValueTypes['AmountValue'];
    ['AuditId']: ValueTypes['AuditId'];
    ['AuthenticatorType']: ValueTypes['AuthenticatorType'];
    ['AuthorizationId']: ValueTypes['AuthorizationId'];
    ['AuthorizationType']: ValueTypes['AuthorizationType'];
    ['BeneficiaryAccountHolderType']: ValueTypes['BeneficiaryAccountHolderType'];
    ['BeneficiaryAccountStatus']: ValueTypes['BeneficiaryAccountStatus'];
    ['BeneficiaryType']: ValueTypes['BeneficiaryType'];
    ['BeneficiaryVerificationInput']: ValueTypes['BeneficiaryVerificationInput'];
    ['BIC']: ValueTypes['BIC'];
    ['BindAccountMembershipInput']: ValueTypes['BindAccountMembershipInput'];
    ['BusinessActivity']: ValueTypes['BusinessActivity'];
    ['CancelCardInput']: ValueTypes['CancelCardInput'];
    ['CancelConsentInput']: ValueTypes['CancelConsentInput'];
    ['CancelDigitalCardInput']: ValueTypes['CancelDigitalCardInput'];
    ['CanceledFundingSourceReason']: ValueTypes['CanceledFundingSourceReason'];
    ['CancelFundingSourceInput']: ValueTypes['CancelFundingSourceInput'];
    ['CancelPhysicalCardInput']: ValueTypes['CancelPhysicalCardInput'];
    ['CancelPhysicalCardReason']: ValueTypes['CancelPhysicalCardReason'];
    ['CancelStandingOrderInput']: ValueTypes['CancelStandingOrderInput'];
    ['CancelTransactionInput']: ValueTypes['CancelTransactionInput'];
    ['CancelVirtualIbanEntryInput']: ValueTypes['CancelVirtualIbanEntryInput'];
    ['CapitalDepositCaseFiltersInput']: ValueTypes['CapitalDepositCaseFiltersInput'];
    ['CapitalDepositCaseOrderByFieldInput']: ValueTypes['CapitalDepositCaseOrderByFieldInput'];
    ['CapitalDepositCaseOrderByInput']: ValueTypes['CapitalDepositCaseOrderByInput'];
    ['CapitalDepositCaseStatus']: ValueTypes['CapitalDepositCaseStatus'];
    ['CapitalDepositDocumentStatus']: ValueTypes['CapitalDepositDocumentStatus'];
    ['CapitalDepositDocumentType']: ValueTypes['CapitalDepositDocumentType'];
    ['CardAuthorizationOutcome']: ValueTypes['CardAuthorizationOutcome'];
    ['CardAuthorizationType']: ValueTypes['CardAuthorizationType'];
    ['CardConfigInput']: ValueTypes['CardConfigInput'];
    ['CardConfigWithGroupDeliveryInput']: ValueTypes['CardConfigWithGroupDeliveryInput'];
    ['CardDesignBackgroundType']: ValueTypes['CardDesignBackgroundType'];
    ['CardDesignStatus']: ValueTypes['CardDesignStatus'];
    ['CardFiltersInput']: ValueTypes['CardFiltersInput'];
    ['CardOrderByFieldInput']: ValueTypes['CardOrderByFieldInput'];
    ['CardOrderByInput']: ValueTypes['CardOrderByInput'];
    ['CardPaymentMethodInput']: ValueTypes['CardPaymentMethodInput'];
    ['CardProductStatus']: ValueTypes['CardProductStatus'];
    ['CardSettingsBackgroundType']: ValueTypes['CardSettingsBackgroundType'];
    ['CardStatus']: ValueTypes['CardStatus'];
    ['CardToken']: ValueTypes['CardToken'];
    ['CardTransactionCategory']: ValueTypes['CardTransactionCategory'];
    ['CardType']: ValueTypes['CardType'];
    ['CashAccountType']: ValueTypes['CashAccountType'];
    ['Category']: ValueTypes['Category'];
    ['CCA2']: ValueTypes['CCA2'];
    ['CCA3']: ValueTypes['CCA3'];
    ['Certificate']: ValueTypes['Certificate'];
    ['CheckPaymentMethodInput']: ValueTypes['CheckPaymentMethodInput'];
    ['CloseAccountInput']: ValueTypes['CloseAccountInput'];
    ['CloseAccountReasonType']: ValueTypes['CloseAccountReasonType'];
    ['CompanyType']: ValueTypes['CompanyType'];
    ['CompleteAddressInput']: ValueTypes['CompleteAddressInput'];
    ['CompleteAddressWithContactInput']: ValueTypes['CompleteAddressWithContactInput'];
    ['CompleteDigitalCardStatus']: ValueTypes['CompleteDigitalCardStatus'];
    ['ConfirmPhysicalCardRenewalInput']: ValueTypes['ConfirmPhysicalCardRenewalInput'];
    ['ConsentIdWithOrder']: ValueTypes['ConsentIdWithOrder'];
    ['ConsentPurpose']: ValueTypes['ConsentPurpose'];
    ['ConsentsFiltersInput']: ValueTypes['ConsentsFiltersInput'];
    ['ConsentStatus']: ValueTypes['ConsentStatus'];
    ['CreateCapitalDepositCaseInput']: ValueTypes['CreateCapitalDepositCaseInput'];
    ['CreateMerchantPaymentLinkInput']: ValueTypes['CreateMerchantPaymentLinkInput'];
    ['CreateMultiConsentInput']: ValueTypes['CreateMultiConsentInput'];
    ['CreditTransferInput']: ValueTypes['CreditTransferInput'];
    ['CreditTransferMode']: ValueTypes['CreditTransferMode'];
    ['Currency']: ValueTypes['Currency'];
    ['CustomerInput']: ValueTypes['CustomerInput'];
    ['Date']: ValueTypes['Date'];
    ['DateTime']: ValueTypes['DateTime'];
    ['DeleteSupportingDocumentInput']: ValueTypes['DeleteSupportingDocumentInput'];
    ['DenySddInput']: ValueTypes['DenySddInput'];
    ['DenySddVirtualIbanEntryInput']: ValueTypes['DenySddVirtualIbanEntryInput'];
    ['DigitalCardFiltersInput']: ValueTypes['DigitalCardFiltersInput'];
    ['DigitalCardOrderByFieldInput']: ValueTypes['DigitalCardOrderByFieldInput'];
    ['DigitalCardOrderByInput']: ValueTypes['DigitalCardOrderByInput'];
    ['DigitalizationType']: ValueTypes['DigitalizationType'];
    ['DirectDebitSequence']: ValueTypes['DirectDebitSequence'];
    ['DisableAccountMembershipInput']: ValueTypes['DisableAccountMembershipInput'];
    ['DocumentFileSide']: ValueTypes['DocumentFileSide'];
    ['DocumentReasonCode']: ValueTypes['DocumentReasonCode'];
    ['DocumentType']: ValueTypes['DocumentType'];
    ['EmailAddress']: ValueTypes['EmailAddress'];
    ['EmploymentStatus']: ValueTypes['EmploymentStatus'];
    ['EnableReceivedDirectDebitMandateInput']: ValueTypes['EnableReceivedDirectDebitMandateInput'];
    ['EnvType']: ValueTypes['EnvType'];
    ['ExternalAccountBalanceInput']: ValueTypes['ExternalAccountBalanceInput'];
    ['ExternalAccountBalanceType']: ValueTypes['ExternalAccountBalanceType'];
    ['ExternalAccountDataSourceType']: ValueTypes['ExternalAccountDataSourceType'];
    ['ExternalAccountUsage']: ValueTypes['ExternalAccountUsage'];
    ['FeesTypeEnum']: ValueTypes['FeesTypeEnum'];
    ['FieldValidationError']: ValueTypes['FieldValidationError'];
    ['FinalizeOnboardingInput']: ValueTypes['FinalizeOnboardingInput'];
    ['FundingLimitAmountInput']: ValueTypes['FundingLimitAmountInput'];
    ['FundingLimitSettingsChangeRequestFiltersInput']: ValueTypes['FundingLimitSettingsChangeRequestFiltersInput'];
    ['FundingLimitSettingsChangeRequestOrderByFieldInput']: ValueTypes['FundingLimitSettingsChangeRequestOrderByFieldInput'];
    ['FundingLimitSettingsChangeRequestOrderByInput']: ValueTypes['FundingLimitSettingsChangeRequestOrderByInput'];
    ['FundingLimitSettingsChangeRequestStatus']: ValueTypes['FundingLimitSettingsChangeRequestStatus'];
    ['FundingLimitSettingsStatus']: ValueTypes['FundingLimitSettingsStatus'];
    ['FundingSourceFiltersInput']: ValueTypes['FundingSourceFiltersInput'];
    ['FundingSourceOrderByFieldInput']: ValueTypes['FundingSourceOrderByFieldInput'];
    ['FundingSourceOrderByInput']: ValueTypes['FundingSourceOrderByInput'];
    ['FundingSourceStatus']: ValueTypes['FundingSourceStatus'];
    ['GenerateAccountStatementInput']: ValueTypes['GenerateAccountStatementInput'];
    ['GenerateCapitalDepositDocumentUploadUrlInput']: ValueTypes['GenerateCapitalDepositDocumentUploadUrlInput'];
    ['GenerateSupportingDocumentUploadUrlInput']: ValueTypes['GenerateSupportingDocumentUploadUrlInput'];
    ['GrantConsentWithServerSignatureInput']: ValueTypes['GrantConsentWithServerSignatureInput'];
    ['HexColorCode']: ValueTypes['HexColorCode'];
    ['IBAN']: ValueTypes['IBAN'];
    ['IBANStatus']: ValueTypes['IBANStatus'];
    ['IbanValidationInput']: ValueTypes['IbanValidationInput'];
    ['IdentificationFiltersInput']: ValueTypes['IdentificationFiltersInput'];
    ['IdentificationInvalidReason']: ValueTypes['IdentificationInvalidReason'];
    ['IdentificationLevel']: ValueTypes['IdentificationLevel'];
    ['IdentificationLevelInput']: ValueTypes['IdentificationLevelInput'];
    ['IdentificationProcess']: ValueTypes['IdentificationProcess'];
    ['IdentificationsOrderByField']: ValueTypes['IdentificationsOrderByField'];
    ['IdentificationsOrderByInput']: ValueTypes['IdentificationsOrderByInput'];
    ['IdentificationStatus']: ValueTypes['IdentificationStatus'];
    ['IdentityDocumentType']: ValueTypes['IdentityDocumentType'];
    ['IndividualUltimateBeneficialOwnerInput']: ValueTypes['IndividualUltimateBeneficialOwnerInput'];
    ['IndividualUltimateBeneficialOwnerTypeEnum']: ValueTypes['IndividualUltimateBeneficialOwnerTypeEnum'];
    ['InitiateCheckMerchantPaymentInput']: ValueTypes['InitiateCheckMerchantPaymentInput'];
    ['InitiateCreditTransfersInput']: ValueTypes['InitiateCreditTransfersInput'];
    ['InitiateFundingRequestInput']: ValueTypes['InitiateFundingRequestInput'];
    ['InitiateInternationalCreditTransferInput']: ValueTypes['InitiateInternationalCreditTransferInput'];
    ['InitiateMerchantPaymentCollectionInput']: ValueTypes['InitiateMerchantPaymentCollectionInput'];
    ['InternalDirectDebitB2BPaymentMethodInput']: ValueTypes['InternalDirectDebitB2BPaymentMethodInput'];
    ['InternalDirectDebitPaymentCollectionInput']: ValueTypes['InternalDirectDebitPaymentCollectionInput'];
    ['InternalDirectDebitSequence']: ValueTypes['InternalDirectDebitSequence'];
    ['InternalDirectDebitStandardPaymentMethodInput']: ValueTypes['InternalDirectDebitStandardPaymentMethodInput'];
    ['InternalPaymentMandateScheme']: ValueTypes['InternalPaymentMandateScheme'];
    ['InternalPaymentMandateSequence']: ValueTypes['InternalPaymentMandateSequence'];
    ['InternalReceivedDirectDebitMandateScheme']: ValueTypes['InternalReceivedDirectDebitMandateScheme'];
    ['InternalReceivedDirectDebitMandateSequence']: ValueTypes['InternalReceivedDirectDebitMandateSequence'];
    ['InternationalAddressInput']: ValueTypes['InternationalAddressInput'];
    ['InternationalBeneficiaryDetailsInput']: ValueTypes['InternationalBeneficiaryDetailsInput'];
    ['InternationalBeneficiaryInput']: ValueTypes['InternationalBeneficiaryInput'];
    ['InternationalCreditTransferDetailsInput']: ValueTypes['InternationalCreditTransferDetailsInput'];
    ['InternationalCreditTransferDisplayLanguage']: ValueTypes['InternationalCreditTransferDisplayLanguage'];
    ['InternationalCreditTransferRoute']: ValueTypes['InternationalCreditTransferRoute'];
    ['InternationalCreditTransferRouteInput']: ValueTypes['InternationalCreditTransferRouteInput'];
    ['InvalidArgumentRejectionCode']: ValueTypes['InvalidArgumentRejectionCode'];
    ['InvalidIbanCode']: ValueTypes['InvalidIbanCode'];
    ['InvoiceStatus']: ValueTypes['InvoiceStatus'];
    ['InvoiceType']: ValueTypes['InvoiceType'];
    ['Language']: ValueTypes['Language'];
    ['LegalDocumentsFilterInput']: ValueTypes['LegalDocumentsFilterInput'];
    ['LegalDocumentStatus']: ValueTypes['LegalDocumentStatus'];
    ['LegalDocumentType']: ValueTypes['LegalDocumentType'];
    ['MandateLanguage']: ValueTypes['MandateLanguage'];
    ['MembershipInfoInput']: ValueTypes['MembershipInfoInput'];
    ['MembershipsFilterInput']: ValueTypes['MembershipsFilterInput'];
    ['MerchantCategoryDescription']: ValueTypes['MerchantCategoryDescription'];
    ['MerchantPaymentLinkStatus']: ValueTypes['MerchantPaymentLinkStatus'];
    ['MerchantPaymentMethodStatus']: ValueTypes['MerchantPaymentMethodStatus'];
    ['MerchantPaymentMethodType']: ValueTypes['MerchantPaymentMethodType'];
    ['MerchantProfileFiltersInput']: ValueTypes['MerchantProfileFiltersInput'];
    ['MerchantProfileOrderByFieldInput']: ValueTypes['MerchantProfileOrderByFieldInput'];
    ['MerchantProfileOrderByInput']: ValueTypes['MerchantProfileOrderByInput'];
    ['MerchantProfileStatus']: ValueTypes['MerchantProfileStatus'];
    ['MonthlyIncome']: ValueTypes['MonthlyIncome'];
    ['MonthlyPaymentVolume']: ValueTypes['MonthlyPaymentVolume'];
    ['OAuthRedirectParametersInput']: ValueTypes['OAuthRedirectParametersInput'];
    ['OnboardCompanyAccountHolderInput']: ValueTypes['OnboardCompanyAccountHolderInput'];
    ['OnboardCompanyShareholderInput']: ValueTypes['OnboardCompanyShareholderInput'];
    ['OnboardIndividualAccountHolderInput']: ValueTypes['OnboardIndividualAccountHolderInput'];
    ['OnboardIndividualShareholderInput']: ValueTypes['OnboardIndividualShareholderInput'];
    ['OnboardingFiltersInput']: ValueTypes['OnboardingFiltersInput'];
    ['OnboardingOrderByFieldInput']: ValueTypes['OnboardingOrderByFieldInput'];
    ['OnboardingOrderByInput']: ValueTypes['OnboardingOrderByInput'];
    ['OnboardingState']: ValueTypes['OnboardingState'];
    ['OnboardingStatus']: ValueTypes['OnboardingStatus'];
    ['OrderByDirection']: ValueTypes['OrderByDirection'];
    ['PartnerCloseAccountReasonInput']: ValueTypes['PartnerCloseAccountReasonInput'];
    ['PartnerCloseAccountReasonType']: ValueTypes['PartnerCloseAccountReasonType'];
    ['PartnershipStatus']: ValueTypes['PartnershipStatus'];
    ['PaymentAccountType']: ValueTypes['PaymentAccountType'];
    ['PaymentFiltersInput']: ValueTypes['PaymentFiltersInput'];
    ['PaymentLevel']: ValueTypes['PaymentLevel'];
    ['PaymentLinkSequenceType']: ValueTypes['PaymentLinkSequenceType'];
    ['PaymentMandateCanceledReason']: ValueTypes['PaymentMandateCanceledReason'];
    ['PaymentMandateFiltersInput']: ValueTypes['PaymentMandateFiltersInput'];
    ['PaymentMandateOrderByFieldInput']: ValueTypes['PaymentMandateOrderByFieldInput'];
    ['PaymentMandateOrderByInput']: ValueTypes['PaymentMandateOrderByInput'];
    ['PaymentMandateScheme']: ValueTypes['PaymentMandateScheme'];
    ['PaymentMandateSequence']: ValueTypes['PaymentMandateSequence'];
    ['PaymentMandateStatus']: ValueTypes['PaymentMandateStatus'];
    ['PaymentOrderByFieldInput']: ValueTypes['PaymentOrderByFieldInput'];
    ['PaymentOrderByInput']: ValueTypes['PaymentOrderByInput'];
    ['PaymentProduct']: ValueTypes['PaymentProduct'];
    ['PaymentStatus']: ValueTypes['PaymentStatus'];
    ['PendingDigitalCardStatus']: ValueTypes['PendingDigitalCardStatus'];
    ['PhoneNumber']: ValueTypes['PhoneNumber'];
    ['PhysicalCardConfigInput']: ValueTypes['PhysicalCardConfigInput'];
    ['PhysicalCardCustomOptionsForGroupDeliveryInput']: ValueTypes['PhysicalCardCustomOptionsForGroupDeliveryInput'];
    ['PhysicalCardCustomOptionsForPrintInput']: ValueTypes['PhysicalCardCustomOptionsForPrintInput'];
    ['PhysicalCardCustomOptionsInput']: ValueTypes['PhysicalCardCustomOptionsInput'];
    ['PhysicalCardStatus']: ValueTypes['PhysicalCardStatus'];
    ['PIN']: ValueTypes['PIN'];
    ['PreferredNotificationChannel']: ValueTypes['PreferredNotificationChannel'];
    ['PrintPhysicalCardInput']: ValueTypes['PrintPhysicalCardInput'];
    ['ProductType']: ValueTypes['ProductType'];
    ['ProjectCardSettingsBackgroundType']: ValueTypes['ProjectCardSettingsBackgroundType'];
    ['ProjectCardStatus']: ValueTypes['ProjectCardStatus'];
    ['ProjectStatus']: ValueTypes['ProjectStatus'];
    ['ProjectType']: ValueTypes['ProjectType'];
    ['ReasonInput']: ValueTypes['ReasonInput'];
    ['ReceivedDirectDebitMandateScheme']: ValueTypes['ReceivedDirectDebitMandateScheme'];
    ['ReceivedDirectDebitMandateStatus']: ValueTypes['ReceivedDirectDebitMandateStatus'];
    ['RefundInput']: ValueTypes['RefundInput'];
    ['RefundRejectionCode']: ValueTypes['RefundRejectionCode'];
    ['RefundTransaction']: ValueTypes['RefundTransaction'];
    ['RejectedFundingSourceReason']: ValueTypes['RejectedFundingSourceReason'];
    ['RejectedReasonCode']: ValueTypes['RejectedReasonCode'];
    ['RejectedVerificationReason']: ValueTypes['RejectedVerificationReason'];
    ['ReleasedReason']: ValueTypes['ReleasedReason'];
    ['ReplayWebhookEventInput']: ValueTypes['ReplayWebhookEventInput'];
    ['RequestMerchantPaymentMethodsInput']: ValueTypes['RequestMerchantPaymentMethodsInput'];
    ['RequestMerchantProfileUpdateInput']: ValueTypes['RequestMerchantProfileUpdateInput'];
    ['RequestMerchantProfileUpdateStatus']: ValueTypes['RequestMerchantProfileUpdateStatus'];
    ['RequestSupportingDocumentCollectionReviewInput']: ValueTypes['RequestSupportingDocumentCollectionReviewInput'];
    ['ResidencyAddressInput']: ValueTypes['ResidencyAddressInput'];
    ['RestrictedToInput']: ValueTypes['RestrictedToInput'];
    ['ResumeAccountMembershipInput']: ValueTypes['ResumeAccountMembershipInput'];
    ['ResumePhysicalCardInput']: ValueTypes['ResumePhysicalCardInput'];
    ['ScheduleStandingOrderInput']: ValueTypes['ScheduleStandingOrderInput'];
    ['SepaBeneficiaryInput']: ValueTypes['SepaBeneficiaryInput'];
    ['SepaCreditorIdentifier']: ValueTypes['SepaCreditorIdentifier'];
    ['SepaDirectDebitB2BPaymentMethodInput']: ValueTypes['SepaDirectDebitB2BPaymentMethodInput'];
    ['SepaDirectDebitCorePaymentMethodInput']: ValueTypes['SepaDirectDebitCorePaymentMethodInput'];
    ['SepaDirectDebitPaymentCollectionInput']: ValueTypes['SepaDirectDebitPaymentCollectionInput'];
    ['SEPADirectDebitScheme']: ValueTypes['SEPADirectDebitScheme'];
    ['SepaPaymentMandateDebtorInput']: ValueTypes['SepaPaymentMandateDebtorInput'];
    ['SEPAPaymentMandateScheme']: ValueTypes['SEPAPaymentMandateScheme'];
    ['SEPAPaymentMandateSequence']: ValueTypes['SEPAPaymentMandateSequence'];
    ['SEPAReceivedDirectDebitMandateScheme']: ValueTypes['SEPAReceivedDirectDebitMandateScheme'];
    ['SEPAReceivedDirectDebitMandateSequence']: ValueTypes['SEPAReceivedDirectDebitMandateSequence'];
    ['SepaReference']: ValueTypes['SepaReference'];
    ['ShareholderStatus']: ValueTypes['ShareholderStatus'];
    ['ShareholderType']: ValueTypes['ShareholderType'];
    ['SignatureData']: ValueTypes['SignatureData'];
    ['SimulationCardType']: ValueTypes['SimulationCardType'];
    ['SingleUseVirtualCardConfigInput']: ValueTypes['SingleUseVirtualCardConfigInput'];
    ['SpendingLimitInput']: ValueTypes['SpendingLimitInput'];
    ['SpendingLimitPeriod']: ValueTypes['SpendingLimitPeriod'];
    ['SpendingLimitPeriodInput']: ValueTypes['SpendingLimitPeriodInput'];
    ['SpendingLimitType']: ValueTypes['SpendingLimitType'];
    ['StandingOrderPeriod']: ValueTypes['StandingOrderPeriod'];
    ['StandingOrderStatus']: ValueTypes['StandingOrderStatus'];
    ['StatementFiltersInput']: ValueTypes['StatementFiltersInput'];
    ['StatementPeriod']: ValueTypes['StatementPeriod'];
    ['StatementStatus']: ValueTypes['StatementStatus'];
    ['StatementType']: ValueTypes['StatementType'];
    ['StatusText']: ValueTypes['StatusText'];
    ['SupportingDocumentCollectionStatus']: ValueTypes['SupportingDocumentCollectionStatus'];
    ['SupportingDocumentCollectMode']: ValueTypes['SupportingDocumentCollectMode'];
    ['SupportingDocumentCommunicationLanguageSettings']: ValueTypes['SupportingDocumentCommunicationLanguageSettings'];
    ['SupportingDocumentPurposeEnum']: ValueTypes['SupportingDocumentPurposeEnum'];
    ['SupportingDocumentStatus']: ValueTypes['SupportingDocumentStatus'];
    ['SupportingDocumentType']: ValueTypes['SupportingDocumentType'];
    ['SuspendAccountMembershipInput']: ValueTypes['SuspendAccountMembershipInput'];
    ['SuspendAccountReasonInput']: ValueTypes['SuspendAccountReasonInput'];
    ['SuspendAccountReasonType']: ValueTypes['SuspendAccountReasonType'];
    ['SuspendPhysicalCardInput']: ValueTypes['SuspendPhysicalCardInput'];
    ['SuspendReceivedDirectDebitMandatedRejectionReason']: ValueTypes['SuspendReceivedDirectDebitMandatedRejectionReason'];
    ['SuspendReceivedDirectDebitMandateInput']: ValueTypes['SuspendReceivedDirectDebitMandateInput'];
    ['SwanAccountBeneficiaryInput']: ValueTypes['SwanAccountBeneficiaryInput'];
    ['SwanIdentificationStatus']: ValueTypes['SwanIdentificationStatus'];
    ['TitleEnum']: ValueTypes['TitleEnum'];
    ['TokenRequestorId']: ValueTypes['TokenRequestorId'];
    ['TransactionReasonCode']: ValueTypes['TransactionReasonCode'];
    ['TransactionsFiltersInput']: ValueTypes['TransactionsFiltersInput'];
    ['TransactionSide']: ValueTypes['TransactionSide'];
    ['TransactionsOrderByField']: ValueTypes['TransactionsOrderByField'];
    ['TransactionsOrderByInput']: ValueTypes['TransactionsOrderByInput'];
    ['TransactionStatus']: ValueTypes['TransactionStatus'];
    ['TransactionTypeEnum']: ValueTypes['TransactionTypeEnum'];
    ['TrustedBeneficiaryFiltersInput']: ValueTypes['TrustedBeneficiaryFiltersInput'];
    ['TrustedBeneficiaryOrderByFieldInput']: ValueTypes['TrustedBeneficiaryOrderByFieldInput'];
    ['TrustedBeneficiaryOrderByInput']: ValueTypes['TrustedBeneficiaryOrderByInput'];
    ['TrustedBeneficiaryStatus']: ValueTypes['TrustedBeneficiaryStatus'];
    ['TypeOfRepresentation']: ValueTypes['TypeOfRepresentation'];
    ['UltimateBeneficialOwnerType']: ValueTypes['UltimateBeneficialOwnerType'];
    ['UpdateAccountHolderInput']: ValueTypes['UpdateAccountHolderInput'];
    ['UpdateAccountInput']: ValueTypes['UpdateAccountInput'];
    ['UpdateAccountMembershipInput']: ValueTypes['UpdateAccountMembershipInput'];
    ['UpdateCardInput']: ValueTypes['UpdateCardInput'];
    ['UpdateCompanyOnboardingInput']: ValueTypes['UpdateCompanyOnboardingInput'];
    ['UpdatedRestrictedToInput']: ValueTypes['UpdatedRestrictedToInput'];
    ['UpdateIndividualOnboardingInput']: ValueTypes['UpdateIndividualOnboardingInput'];
    ['UpdateReceivedSepaDirectDebitB2bMandateInput']: ValueTypes['UpdateReceivedSepaDirectDebitB2bMandateInput'];
    ['UpdateSupportingDocumentInput']: ValueTypes['UpdateSupportingDocumentInput'];
    ['UpdateUserConsentSettingsInput']: ValueTypes['UpdateUserConsentSettingsInput'];
    ['Upload']: ValueTypes['Upload'];
    ['URL']: ValueTypes['URL'];
    ['UserFilterInput']: ValueTypes['UserFilterInput'];
    ['UserOrderByFieldInput']: ValueTypes['UserOrderByFieldInput'];
    ['UserOrderByInput']: ValueTypes['UserOrderByInput'];
    ['ValidationFieldErrorCode']: ValueTypes['ValidationFieldErrorCode'];
    ['VerificationFlow']: ValueTypes['VerificationFlow'];
    ['VerificationStatus']: ValueTypes['VerificationStatus'];
    ['ViewCardNumbersInput']: ValueTypes['ViewCardNumbersInput'];
    ['ViewPhysicalCardNumbersInput']: ValueTypes['ViewPhysicalCardNumbersInput'];
    ['ViewPhysicalCardPinInput']: ValueTypes['ViewPhysicalCardPinInput'];
    ['WalletProviderType']: ValueTypes['WalletProviderType'];
    ['WalletToken']: ValueTypes['WalletToken'];
    ['WebhookEventLogFiltersInput']: ValueTypes['WebhookEventLogFiltersInput'];
    ['WebhookSubscriptionCreationStatus']: ValueTypes['WebhookSubscriptionCreationStatus'];
    ['WebhookSubscriptionStatus']: ValueTypes['WebhookSubscriptionStatus'];
};
export {};
